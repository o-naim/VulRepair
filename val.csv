cwe_id,source,target,project_and_commit_id,cve_id,original_address,time
CWE-264,"CWE-264 static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kfree ( buf ) ; return ret ; }
","<S2SV_ModStart> ret = 0 ; if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) return - ENOKEY
",torvalds@linux/096fe9eaea40a17e125569f9e657e34cdb6d73bd,CVE-2015-8539,https://github.com/torvalds/linux/commit/096fe9eaea40a17e125569f9e657e34cdb6d73bd,2016-02-08T03:59Z
CWE-119,"CWE-119 static void header_seek ( SF_PRIVATE * psf , sf_count_t position , int whence ) { switch ( whence ) { case SEEK_SET : <S2SV_StartBug> if ( position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( position > psf -> headend ) <S2SV_EndBug> <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - psf -> headend , psf ) ; <S2SV_EndBug> psf -> headindex = position ; break ; case SEEK_CUR : <S2SV_StartBug> if ( psf -> headindex + position < 0 ) <S2SV_EndBug> break ; <S2SV_StartBug> if ( psf -> headindex >= SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { psf_fseek ( psf , position , whence ) ; return ; } ; <S2SV_StartBug> if ( psf -> headindex + position <= psf -> headend ) <S2SV_EndBug> { psf -> headindex += position ; break ; } ; <S2SV_StartBug> if ( psf -> headindex + position > SIGNED_SIZEOF ( psf -> header ) ) <S2SV_EndBug> { <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> psf_fseek ( psf , position , SEEK_CUR ) ; break ; } ; <S2SV_StartBug> psf -> headend += psf_fread ( psf -> header + psf -> headend , 1 , position - ( psf -> headend - psf -> headindex ) , psf ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> headindex = psf -> headend ; <S2SV_EndBug> break ; case SEEK_END : default : psf_log_printf ( psf , ""Bad<S2SV_blank>whence<S2SV_blank>param<S2SV_blank>in<S2SV_blank>header_seek().\\n"" ) ; break ; } ; return ; }
","<S2SV_ModStart> : if ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( position > psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> > psf -> header . end ) psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> - psf -> header . end , psf ) ; psf -> header . indx <S2SV_ModEnd> = position ; <S2SV_ModStart> ( psf -> header . indx + position >= psf -> header . len ) psf_bump_header_allocation ( psf , position ) ; if ( psf -> header . indx <S2SV_ModEnd> + position < <S2SV_ModStart> ( psf -> header . indx >= psf -> header . len <S2SV_ModEnd> ) { psf_fseek <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position <= <S2SV_ModStart> <= psf -> header . end ) { psf -> header . indx <S2SV_ModEnd> += position ; <S2SV_ModStart> ( psf -> header . indx <S2SV_ModEnd> + position > <S2SV_ModStart> + position > psf -> header . len ) { psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; psf_fseek ( <S2SV_ModStart> ; psf -> header . end <S2SV_ModEnd> += psf_fread ( <S2SV_ModStart> psf -> header . ptr + psf -> header . end <S2SV_ModEnd> , 1 , <S2SV_ModStart> ( psf -> header . end <S2SV_ModEnd> - psf -> <S2SV_ModStart> - psf -> header . indx ) , psf ) ; psf -> header . indx <S2SV_ModEnd> = psf -> <S2SV_ModStart> = psf -> header . end <S2SV_ModEnd> ; break ;
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-20,"CWE-20 static Image * ReadCUTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowCUTReaderException ( severity , tag ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( severity , tag ) ; } <S2SV_EndBug> Image * image , * palette ; ImageInfo * clone_info ; MagickBooleanType status ; MagickOffsetType offset ; size_t EncodedByte ; unsigned char RunCount , RunValue , RunCountMasked ; CUTHeader Header ; CUTPalHeader PalHeader ; ssize_t depth ; ssize_t i , j ; ssize_t ldblk ; unsigned char * BImgBuff = NULL , * ptrB ; register Quantum * q ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } palette = NULL ; clone_info = NULL ; Header . Width = ReadBlobLSBShort ( image ) ; Header . Height = ReadBlobLSBShort ( image ) ; Header . Reserved = ReadBlobLSBShort ( image ) ; if ( Header . Width == 0 || Header . Height == 0 || Header . Reserved != 0 ) CUT_KO : ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; EncodedByte = ReadBlobLSBShort ( image ) ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; ldblk = 0 ; while ( ( int ) RunCountMasked != 0 ) { i = 1 ; if ( ( int ) RunCount < 0x80 ) i = ( ssize_t ) RunCountMasked ; offset = SeekBlob ( image , TellBlob ( image ) + i , SEEK_SET ) ; if ( offset < 0 ) ThrowCUTReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; EncodedByte -= i + 1 ; ldblk += ( ssize_t ) RunCountMasked ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) goto CUT_KO ; RunCountMasked = RunCount & 0x7F ; } if ( EncodedByte != 1 ) goto CUT_KO ; i = 0 ; if ( ldblk == ( int ) Header . Width ) i = 8 ; if ( 2 * ldblk == ( int ) Header . Width ) i = 4 ; if ( 8 * ldblk == ( int ) Header . Width ) i = 1 ; if ( i == 0 ) goto CUT_KO ; depth = i ; image -> columns = Header . Width ; image -> rows = Header . Height ; image -> depth = 8 ; image -> colors = ( size_t ) ( GetQuantumRange ( 1UL * i ) + 1 ) ; if ( image_info -> ping != MagickFalse ) goto Finish ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( clone_info = CloneImageInfo ( image_info ) ) == NULL ) goto NoPalette ; i = ( ssize_t ) strlen ( clone_info -> filename ) ; j = i ; while ( -- i > 0 ) { if ( clone_info -> filename [ i ] == '.' ) { break ; } if ( clone_info -> filename [ i ] == '/' || clone_info -> filename [ i ] == '\\\\' || clone_info -> filename [ i ] == ':' ) { i = j ; break ; } } ( void ) CopyMagickString ( clone_info -> filename + i , "".PAL"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { ( void ) CopyMagickString ( clone_info -> filename + i , "".pal"" , ( size_t ) ( MagickPathExtent - i ) ) ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info -> filename [ i ] = '\\0' ; if ( ( clone_info -> file = fopen_utf8 ( clone_info -> filename , ""rb"" ) ) == NULL ) { clone_info = DestroyImageInfo ( clone_info ) ; clone_info = NULL ; goto NoPalette ; } } } if ( ( palette = AcquireImage ( clone_info , exception ) ) == NULL ) goto NoPalette ; status = OpenBlob ( clone_info , palette , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ErasePalette : palette = DestroyImage ( palette ) ; palette = NULL ; goto NoPalette ; } if ( palette != NULL ) { ( void ) ReadBlob ( palette , 2 , ( unsigned char * ) PalHeader . FileId ) ; if ( strncmp ( PalHeader . FileId , ""AH"" , 2 ) != 0 ) goto ErasePalette ; PalHeader . Version = ReadBlobLSBShort ( palette ) ; PalHeader . Size = ReadBlobLSBShort ( palette ) ; PalHeader . FileType = ( char ) ReadBlobByte ( palette ) ; PalHeader . SubType = ( char ) ReadBlobByte ( palette ) ; PalHeader . BoardID = ReadBlobLSBShort ( palette ) ; PalHeader . GraphicsMode = ReadBlobLSBShort ( palette ) ; PalHeader . MaxIndex = ReadBlobLSBShort ( palette ) ; PalHeader . MaxRed = ReadBlobLSBShort ( palette ) ; PalHeader . MaxGreen = ReadBlobLSBShort ( palette ) ; PalHeader . MaxBlue = ReadBlobLSBShort ( palette ) ; ( void ) ReadBlob ( palette , 20 , ( unsigned char * ) PalHeader . PaletteId ) ; if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; if ( PalHeader . MaxIndex < 1 ) goto ErasePalette ; image -> colors = PalHeader . MaxIndex + 1 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) goto NoMemory ; if ( PalHeader . MaxRed == 0 ) PalHeader . MaxRed = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxGreen == 0 ) PalHeader . MaxGreen = ( unsigned int ) QuantumRange ; if ( PalHeader . MaxBlue == 0 ) PalHeader . MaxBlue = ( unsigned int ) QuantumRange ; for ( i = 0 ; i <= ( int ) PalHeader . MaxIndex ; i ++ ) { j = ( ssize_t ) TellBlob ( palette ) ; if ( ( j % 512 ) > 512 - 6 ) { j = ( ( j / 512 ) + 1 ) * 512 ; offset = SeekBlob ( palette , j , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } image -> colormap [ i ] . red = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxRed ) { image -> colormap [ i ] . red = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . red * QuantumRange + ( PalHeader . MaxRed >> 1 ) ) / PalHeader . MaxRed ) ; } image -> colormap [ i ] . green = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxGreen ) { image -> colormap [ i ] . green = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . green * QuantumRange + ( PalHeader . MaxGreen >> 1 ) ) / PalHeader . MaxGreen ) ; } image -> colormap [ i ] . blue = ( Quantum ) ReadBlobLSBShort ( palette ) ; if ( QuantumRange != ( Quantum ) PalHeader . MaxBlue ) { image -> colormap [ i ] . blue = ClampToQuantum ( ( ( double ) image -> colormap [ i ] . blue * QuantumRange + ( PalHeader . MaxBlue >> 1 ) ) / PalHeader . MaxBlue ) ; } } if ( EOFBlob ( image ) ) ThrowCUTReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; } NoPalette : if ( palette == NULL ) { image -> colors = 256 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { NoMemory : ThrowCUTReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) i ) ; } } BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ldblk , sizeof ( * BImgBuff ) ) ; if ( BImgBuff == NULL ) goto NoMemory ; <S2SV_StartBug> offset = SeekBlob ( image , 6 , SEEK_SET ) ; <S2SV_EndBug> if ( offset < 0 ) { if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < ( int ) Header . Height ; i ++ ) { EncodedByte = ReadBlobLSBShort ( image ) ; ptrB = BImgBuff ; j = ldblk ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; while ( ( int ) RunCountMasked != 0 ) { if ( ( ssize_t ) RunCountMasked > j ) { RunCountMasked = ( unsigned char ) j ; if ( j == 0 ) { break ; } } if ( ( int ) RunCount > 0x80 ) { RunValue = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) memset ( ptrB , ( int ) RunValue , ( size_t ) RunCountMasked ) ; } else { ( void ) ReadBlob ( image , ( size_t ) RunCountMasked , ptrB ) ; } ptrB += ( int ) RunCountMasked ; j -= ( int ) RunCountMasked ; if ( EOFBlob ( image ) != MagickFalse ) goto Finish ; RunCount = ( unsigned char ) ReadBlobByte ( image ) ; RunCountMasked = RunCount & 0x7F ; } InsertRow ( image , depth , BImgBuff , i , exception ) ; } ( void ) SyncImage ( image , exception ) ; if ( palette == NULL ) { if ( ( image -> storage_class == PseudoClass ) && ( SetImageGray ( image , exception ) != MagickFalse ) ) { if ( GetCutColors ( image , exception ) == 2 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { register Quantum sample ; sample = ScaleCharToQuantum ( ( unsigned char ) i ) ; if ( image -> colormap [ i ] . red != sample ) goto Finish ; if ( image -> colormap [ i ] . green != sample ) goto Finish ; if ( image -> colormap [ i ] . blue != sample ) goto Finish ; } image -> colormap [ 1 ] . red = image -> colormap [ 1 ] . green = image -> colormap [ 1 ] . blue = QuantumRange ; for ( i = 0 ; i < ( ssize_t ) image -> rows ; i ++ ) { q = QueueAuthenticPixels ( image , 0 , i , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) { if ( GetPixelRed ( image , q ) == ScaleCharToQuantum ( 1 ) ) { SetPixelRed ( image , QuantumRange , q ) ; SetPixelGreen ( image , QuantumRange , q ) ; SetPixelBlue ( image , QuantumRange , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) goto Finish ; } } } } Finish : if ( BImgBuff != NULL ) BImgBuff = ( unsigned char * ) RelinquishMagickMemory ( BImgBuff ) ; if ( palette != NULL ) palette = DestroyImage ( palette ) ; if ( clone_info != NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , tag ) \\\n{ <S2SV_ModEnd> if ( palette <S2SV_ModStart> tag ) ; \\\n} <S2SV_ModEnd> Image * image <S2SV_ModStart> goto NoMemory ; ( void ) memset ( BImgBuff , 0 , ( size_t ) ldblk * sizeof ( * BImgBuff ) ) ;
",ImageMagick@ImageMagick/cdb383749ef7b68a38891440af8cc23e0115306d,CVE-2019-13135,https://github.com/ImageMagick/ImageMagick/commit/cdb383749ef7b68a38891440af8cc23e0115306d,2019-07-01T20:15Z
CWE-000,"CWE-000 rfbBool SetFormatAndEncodings ( rfbClient * client ) { rfbSetPixelFormatMsg spf ; <S2SV_StartBug> char buf [ sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> rfbSetEncodingsMsg * se = ( rfbSetEncodingsMsg * ) buf ; <S2SV_EndBug> <S2SV_StartBug> uint32_t * encs = ( uint32_t * ) ( & buf [ sz_rfbSetEncodingsMsg ] ) ; <S2SV_EndBug> int len = 0 ; rfbBool requestCompressLevel = FALSE ; rfbBool requestQualityLevel = FALSE ; rfbBool requestLastRectEncoding = FALSE ; rfbClientProtocolExtension * e ; if ( ! SupportsClient2Server ( client , rfbSetPixelFormat ) ) return TRUE ; spf . type = rfbSetPixelFormat ; spf . pad1 = 0 ; spf . pad2 = 0 ; spf . format = client -> format ; spf . format . redMax = rfbClientSwap16IfLE ( spf . format . redMax ) ; spf . format . greenMax = rfbClientSwap16IfLE ( spf . format . greenMax ) ; spf . format . blueMax = rfbClientSwap16IfLE ( spf . format . blueMax ) ; if ( ! WriteToRFBServer ( client , ( char * ) & spf , sz_rfbSetPixelFormatMsg ) ) return FALSE ; if ( ! SupportsClient2Server ( client , rfbSetEncodings ) ) return TRUE ; se -> type = rfbSetEncodings ; se -> pad = 0 ; se -> nEncodings = 0 ; if ( client -> appData . encodingsString ) { const char * encStr = client -> appData . encodingsString ; int encStrLen ; do { const char * nextEncStr = strchr ( encStr , '<S2SV_blank>' ) ; if ( nextEncStr ) { encStrLen = nextEncStr - encStr ; nextEncStr ++ ; } else { encStrLen = strlen ( encStr ) ; } if ( strncasecmp ( encStr , ""raw"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } else if ( strncasecmp ( encStr , ""copyrect"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG } else if ( strncasecmp ( encStr , ""tight"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; if ( client -> appData . enableJPEG ) requestQualityLevel = TRUE ; # endif # endif } else if ( strncasecmp ( encStr , ""hextile"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ } else if ( strncasecmp ( encStr , ""zlib"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""zlibhex"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlibHex ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) requestCompressLevel = TRUE ; } else if ( strncasecmp ( encStr , ""trle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTRLE ) ; } else if ( strncasecmp ( encStr , ""zrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; } else if ( strncasecmp ( encStr , ""zywrle"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; requestQualityLevel = TRUE ; # endif } else if ( ( strncasecmp ( encStr , ""ultra"" , encStrLen ) == 0 ) || ( strncasecmp ( encStr , ""ultrazip"" , encStrLen ) == 0 ) ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; } else if ( strncasecmp ( encStr , ""corre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; } else if ( strncasecmp ( encStr , ""rre"" , encStrLen ) == 0 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; } else { rfbClientLog ( ""Unknown<S2SV_blank>encoding<S2SV_blank>\'%.*s\'\\n"" , encStrLen , encStr ) ; } encStr = nextEncStr ; } while ( encStr && se -> nEncodings < MAX_ENCODINGS ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestCompressLevel ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } if ( se -> nEncodings < MAX_ENCODINGS && requestQualityLevel ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } else { if ( SameMachine ( client -> sock ) ) { rfbClientLog ( ""Same<S2SV_blank>machine:<S2SV_blank>preferring<S2SV_blank>raw<S2SV_blank>encoding\\n"" ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRaw ) ; } encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCopyRect ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ # ifdef LIBVNCSERVER_HAVE_LIBJPEG encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingTight ) ; requestLastRectEncoding = TRUE ; # endif # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingHextile ) ; # ifdef LIBVNCSERVER_HAVE_LIBZ encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZlib ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZRLE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingZYWRLE ) ; # endif encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltra ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingUltraZip ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCoRRE ) ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRRE ) ; if ( client -> appData . compressLevel >= 0 && client -> appData . compressLevel <= 9 ) { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . compressLevel + rfbEncodingCompressLevel0 ) ; } else { encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingCompressLevel1 ) ; } if ( client -> appData . enableJPEG ) { if ( client -> appData . qualityLevel < 0 || client -> appData . qualityLevel > 9 ) client -> appData . qualityLevel = 5 ; encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( client -> appData . qualityLevel + rfbEncodingQualityLevel0 ) ; } } if ( client -> appData . useRemoteCursor ) { if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingRichCursor ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingPointerPos ) ; } if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingKeyboardLedState ) ; if ( se -> nEncodings < MAX_ENCODINGS && client -> canHandleNewFBSize ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingNewFBSize ) ; if ( se -> nEncodings < MAX_ENCODINGS && requestLastRectEncoding ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingLastRect ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedMessages ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingSupportedEncodings ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingServerIdentity ) ; if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( rfbEncodingXvp ) ; for ( e = rfbClientExtensions ; e ; e = e -> next ) if ( e -> encodings ) { int * enc ; for ( enc = e -> encodings ; * enc ; enc ++ ) if ( se -> nEncodings < MAX_ENCODINGS ) encs [ se -> nEncodings ++ ] = rfbClientSwap32IfLE ( * enc ) ; } len = sz_rfbSetEncodingsMsg + se -> nEncodings * 4 ; se -> nEncodings = rfbClientSwap16IfLE ( se -> nEncodings ) ; <S2SV_StartBug> if ( ! WriteToRFBServer ( client , buf , len ) ) return FALSE ; <S2SV_EndBug> return TRUE ; }
","<S2SV_ModStart> rfbSetPixelFormatMsg spf ; union { char bytes <S2SV_ModEnd> [ sz_rfbSetEncodingsMsg + <S2SV_ModStart> ] ; rfbSetEncodingsMsg msg ; } buf ; rfbSetEncodingsMsg * se = & buf . msg <S2SV_ModEnd> ; uint32_t * <S2SV_ModStart> ( & buf . bytes <S2SV_ModStart> client , buf . bytes
",LibVNC@libvncserver/23e5cbe6b090d7f22982aee909a6a618174d3c2d,CVE-2020-14399,https://github.com/LibVNC/libvncserver/commit/23e5cbe6b090d7f22982aee909a6a618174d3c2d,2020-06-17T16:15Z
CWE-476,"CWE-476 void rfbReleaseClientIterator ( rfbClientIteratorPtr iterator ) { <S2SV_StartBug> if ( iterator -> next ) rfbDecrClientRef ( iterator -> next ) ; <S2SV_EndBug> free ( iterator ) ; }
","<S2SV_ModStart> { if ( iterator &&
",LibVNC@libvncserver/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,CVE-2020-14397,https://github.com/LibVNC/libvncserver/commit/38e98ee61d74f5f5ab4aa4c77146faad1962d6d0,2020-06-17T16:15Z
CWE-119,"CWE-119 hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""created<S2SV_blank>handle<S2SV_blank>%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; <S2SV_StartBug> h -> size = statbuf . st_size ; <S2SV_EndBug> if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mapped<S2SV_blank>file<S2SV_blank>at<S2SV_blank>%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1 ; } if ( h -> hdr -> magic [ 0 ] != 'r' || h -> hdr -> magic [ 1 ] != 'e' || h -> hdr -> magic [ 2 ] != 'g' || h -> hdr -> magic [ 3 ] != 'f' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; } uint32_t major_ver = le32toh ( h -> hdr -> major_ver ) ; if ( major_ver != 1 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>hive<S2SV_blank>file<S2SV_blank>major<S2SV_blank>version<S2SV_blank>%"" PRIu32 ""<S2SV_blank>(expected<S2SV_blank>1)"" , filename , major_ver ) ; goto error ; } h -> bitmap = calloc ( 1 + h -> size / 32 , 1 ) ; if ( h -> bitmap == NULL ) goto error ; uint32_t sum = header_checksum ( h ) ; if ( sum != le32toh ( h -> hdr -> csum ) ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>bad<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>hive<S2SV_blank>header"" , filename ) ; goto error ; } h -> last_modified = le64toh ( ( int64_t ) h -> hdr -> last_modified ) ; if ( h -> msglvl >= 2 ) { char * name = _hivex_windows_utf16_to_utf8 ( h -> hdr -> name , 64 ) ; fprintf ( stderr , ""hivex_open:<S2SV_blank>header<S2SV_blank>fields:\\n"" ""<S2SV_blank><S2SV_blank>file<S2SV_blank>version<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 "".%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank>sequence<S2SV_blank>nos<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu32 ""<S2SV_blank>%"" PRIu32 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(sequences<S2SV_blank>nos<S2SV_blank>should<S2SV_blank>match<S2SV_blank>if<S2SV_blank>hive<S2SV_blank>was<S2SV_blank>synched<S2SV_blank>at<S2SV_blank>shutdown)\\n"" ""<S2SV_blank><S2SV_blank>last<S2SV_blank>modified<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%"" PRIu64 ""\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Windows<S2SV_blank>filetime,<S2SV_blank>x<S2SV_blank>100<S2SV_blank>ns<S2SV_blank>since<S2SV_blank>1601-01-01)\\n"" ""<S2SV_blank><S2SV_blank>original<S2SV_blank>file<S2SV_blank>name<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\n"" ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(only<S2SV_blank>32<S2SV_blank>chars<S2SV_blank>are<S2SV_blank>stored,<S2SV_blank>name<S2SV_blank>is<S2SV_blank>probably<S2SV_blank>truncated)\\n"" ""<S2SV_blank><S2SV_blank>root<S2SV_blank>offset<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000\\n"" ""<S2SV_blank><S2SV_blank>end<S2SV_blank>of<S2SV_blank>last<S2SV_blank>page<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>+<S2SV_blank>0x1000<S2SV_blank>(total<S2SV_blank>file<S2SV_blank>size<S2SV_blank>0x%zx)\\n"" ""<S2SV_blank><S2SV_blank>checksum<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x<S2SV_blank>(calculated<S2SV_blank>0x%x)\\n"" , major_ver , le32toh ( h -> hdr -> minor_ver ) , le32toh ( h -> hdr -> sequence1 ) , le32toh ( h -> hdr -> sequence2 ) , h -> last_modified , name ? name : ""(conversion<S2SV_blank>failed)"" , le32toh ( h -> hdr -> offset ) , le32toh ( h -> hdr -> blocks ) , h -> size , le32toh ( h -> hdr -> csum ) , sum ) ; free ( name ) ; } h -> rootoffs = le32toh ( h -> hdr -> offset ) + 0x1000 ; h -> endpages = le32toh ( h -> hdr -> blocks ) + 0x1000 ; DEBUG ( 2 , ""root<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>0x%zx"" , h -> rootoffs ) ; int seen_root_block = 0 , bad_root_block = 0 ; size_t pages = 0 ; size_t smallest_page = SIZE_MAX , largest_page = 0 ; size_t blocks = 0 ; size_t smallest_block = SIZE_MAX , largest_block = 0 , blocks_bytes = 0 ; size_t used_blocks = 0 ; size_t used_size = 0 ; size_t off ; struct ntreg_hbin_page * page ; for ( off = 0x1000 ; off < h -> size ; off += le32toh ( page -> page_size ) ) { if ( off >= h -> endpages ) break ; page = ( struct ntreg_hbin_page * ) ( ( char * ) h -> addr + off ) ; if ( page -> magic [ 0 ] != 'h' || page -> magic [ 1 ] != 'b' || page -> magic [ 2 ] != 'i' || page -> magic [ 3 ] != 'n' ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>trailing<S2SV_blank>garbage<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>file<S2SV_blank>"" ""(at<S2SV_blank>0x%zx,<S2SV_blank>after<S2SV_blank>%zu<S2SV_blank>pages)"" , filename , off , pages ) ; goto error ; } size_t page_size = le32toh ( page -> page_size ) ; DEBUG ( 2 , ""page<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>size<S2SV_blank>%zu"" , off , page_size ) ; pages ++ ; if ( page_size < smallest_page ) smallest_page = page_size ; if ( page_size > largest_page ) largest_page = page_size ; if ( page_size <= sizeof ( struct ntreg_hbin_page ) || ( page_size & 0x0fff ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>page<S2SV_blank>size<S2SV_blank>%zu<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , page_size , off ) ; goto error ; } size_t blkoff ; struct ntreg_hbin_block * block ; size_t seg_len ; for ( blkoff = off + 0x20 ; blkoff < off + page_size ; blkoff += seg_len ) { blocks ++ ; int is_root = blkoff == h -> rootoffs ; if ( is_root ) seen_root_block = 1 ; block = ( struct ntreg_hbin_block * ) ( ( char * ) h -> addr + blkoff ) ; int used ; seg_len = block_len ( h , blkoff , & used ) ; if ( seg_len <= 4 || ( seg_len & 3 ) != 0 ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%"" PRIu32 ""<S2SV_blank>at<S2SV_blank>0x%zx,<S2SV_blank>bad<S2SV_blank>registry"" , filename , le32toh ( block -> seg_len ) , blkoff ) ; goto error ; } if ( h -> msglvl >= 2 ) { unsigned char * id = ( unsigned char * ) block -> id ; int id0 = id [ 0 ] , id1 = id [ 1 ] ; fprintf ( stderr , ""%s:<S2SV_blank>%s:<S2SV_blank>"" ""%s<S2SV_blank>block<S2SV_blank>id<S2SV_blank>%d,%d<S2SV_blank>(%c%c)<S2SV_blank>at<S2SV_blank>0x%zx<S2SV_blank>size<S2SV_blank>%zu%s\\n"" , ""hivex"" , __func__ , used ? ""used"" : ""free"" , id0 , id1 , c_isprint ( id0 ) ? id0 : '.' , c_isprint ( id1 ) ? id1 : '.' , blkoff , seg_len , is_root ? ""<S2SV_blank>(root)"" : """" ) ; } blocks_bytes += seg_len ; if ( seg_len < smallest_block ) smallest_block = seg_len ; if ( seg_len > largest_block ) largest_block = seg_len ; if ( is_root && ! used ) bad_root_block = 1 ; if ( used ) { used_blocks ++ ; used_size += seg_len ; if ( is_root && ( block -> id [ 0 ] != 'n' || block -> id [ 1 ] != 'k' ) ) bad_root_block = 1 ; BITMAP_SET ( h -> bitmap , blkoff ) ; } } } if ( ! seen_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>no<S2SV_blank>root<S2SV_blank>block<S2SV_blank>found"" , filename ) ; goto error ; } if ( bad_root_block ) { SET_ERRNO ( ENOTSUP , ""%s:<S2SV_blank>bad<S2SV_blank>root<S2SV_blank>block<S2SV_blank>(free<S2SV_blank>or<S2SV_blank>not<S2SV_blank>nk)"" , filename ) ; goto error ; } DEBUG ( 1 , ""successfully<S2SV_blank>read<S2SV_blank>Windows<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file:\\n"" ""<S2SV_blank><S2SV_blank>pages:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu<S2SV_blank>[sml:<S2SV_blank>%zu,<S2SV_blank>avg:<S2SV_blank>%zu,<S2SV_blank>lge:<S2SV_blank>%zu]\\n"" ""<S2SV_blank><S2SV_blank>blocks<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu\\n"" ""<S2SV_blank><S2SV_blank>bytes<S2SV_blank>used:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%zu"" , pages , smallest_page , largest_page , blocks , smallest_block , blocks_bytes / blocks , largest_block , used_blocks , used_size ) ; return h ; error : ; int err = errno ; if ( h ) { free ( h -> bitmap ) ; if ( h -> addr && h -> size && h -> addr != MAP_FAILED ) { if ( ! h -> writable ) munmap ( h -> addr , h -> size ) ; else free ( h -> addr ) ; } if ( h -> fd >= 0 ) close ( h -> fd ) ; free ( h -> filename ) ; free ( h ) ; } errno = err ; return NULL ; }
","<S2SV_ModStart> . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>a<S2SV_blank>Windows<S2SV_blank>NT<S2SV_blank>Registry<S2SV_blank>hive<S2SV_blank>file"" , filename ) ; goto error ; }
",libguestfs@hivex/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,CVE-2014-9273,https://github.com/libguestfs/hivex/commit/357f26fa64fd1d9ccac2331fe174a8ee9c607adb,2014-12-08T16:59Z
CWE-399,"CWE-399 static Image * ReadCAPTIONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * caption , geometry [ MaxTextExtent ] , * property , * text ; const char * gravity , * option ; DrawInfo * draw_info ; Image * image ; MagickBooleanType split , status ; register ssize_t i ; size_t height , width ; TypeMetric metrics ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; option = GetImageOption ( image_info , ""filename"" ) ; if ( option == ( const char * ) NULL ) property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; else if ( LocaleNCompare ( option , ""caption:"" , 8 ) == 0 ) property = InterpretImageProperties ( image_info , image , option + 8 ) ; else property = InterpretImageProperties ( image_info , image , option ) ; ( void ) SetImageProperty ( image , ""caption"" , property ) ; property = DestroyString ( property ) ; caption = ConstantString ( GetImageProperty ( image , ""caption"" ) ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; gravity = GetImageOption ( image_info , ""gravity"" ) ; if ( gravity != ( char * ) NULL ) draw_info -> gravity = ( GravityType ) ParseCommandOption ( MagickGravityOptions , MagickFalse , gravity ) ; split = MagickFalse ; status = MagickTrue ; if ( image -> columns == 0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; image -> columns = width ; } if ( image -> rows == 0 ) { split = MagickTrue ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; image -> rows = ( size_t ) ( ( i + 1 ) * ( metrics . ascent - metrics . descent + draw_info -> interline_spacing + draw_info -> stroke_width ) + 0.5 ) ; } if ( status != MagickFalse ) status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ( fabs ( image_info -> pointsize ) < MagickEpsilon ) && ( strlen ( caption ) > 0 ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; ( void ) status ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; text = AcquireString ( caption ) ; i = FormatMagickCaption ( image , draw_info , split , & metrics , & text ) ; ( void ) CloneString ( & draw_info -> text , text ) ; text = DestroyString ( text ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = floor ( ( low + high ) / 2.0 - 0.5 ) ; } i = FormatMagickCaption ( image , draw_info , split , & metrics , & caption ) ; ( void ) CloneString ( & draw_info -> text , caption ) ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , MagickMax ( draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : - metrics . bounds . x1 , 0.0 ) , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; <S2SV_StartBug> draw_info -> geometry = AcquireString ( geometry ) ; <S2SV_EndBug> status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""caption:pointsize"" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; caption = DestroyString ( caption ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> 0.0 ) ; ( void ) CloneString ( & <S2SV_ModStart> draw_info -> geometry , <S2SV_ModEnd> geometry ) ;
",ImageMagick@ImageMagick/aeff00de228bc5a158c2a975ab47845d8a1db456,CVE-2016-10146,https://github.com/ImageMagick/ImageMagick/commit/aeff00de228bc5a158c2a975ab47845d8a1db456,2017-03-24T15:59Z
CWE-400,"CWE-400 struct sctp_chunk * sctp_assoc_lookup_asconf_ack ( const struct sctp_association * asoc , __be32 serial ) { struct sctp_chunk * ack ; list_for_each_entry ( ack , & asoc -> asconf_ack_list , transmitted_list ) { <S2SV_StartBug> if ( ack -> subh . addip_hdr -> serial == serial ) { <S2SV_EndBug> sctp_chunk_hold ( ack ) ; return ack ; } } return NULL ; }
","<S2SV_ModStart> { if ( sctp_chunk_pending ( ack ) ) continue ; if (
",torvalds@linux/b69040d8e39f20d5215a03502a8e8b4c6ab78395,CVE-2014-3687,https://github.com/torvalds/linux/commit/b69040d8e39f20d5215a03502a8e8b4c6ab78395,2014-11-10T11:55Z
CWE-190,"CWE-190 int pnm_validate ( jas_stream_t * in ) { <S2SV_StartBug> uchar buf [ 2 ] ; <S2SV_EndBug> int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ; if ( ( n = jas_stream_read ( in , buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == 'P' && isdigit ( buf [ 1 ] ) ) { return 0 ; } return - 1 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> buf [ 2
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void Huff_transmit ( huff_t * huff , int ch , byte * fout ) { <S2SV_EndBug> int i ; if ( huff -> loc [ ch ] == NULL ) { <S2SV_StartBug> Huff_transmit ( huff , NYT , fout ) ; <S2SV_EndBug> for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else { <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> byte * fout , int maxoffset <S2SV_ModStart> NYT , fout , maxoffset <S2SV_ModStart> NULL , fout , maxoffset
",ioquake@ioq3/d2b1d124d4055c2fcbe5126863487c52fd58cca1,CVE-2017-11721,https://github.com/ioquake/ioq3/commit/d2b1d124d4055c2fcbe5126863487c52fd58cca1,2017-08-03T08:29Z
CWE-119,"CWE-119 static int xlate_to_uni ( const unsigned char * name , int len , unsigned char * outname , int * longlen , int * outlen , int escape , int utf8 , struct nls_table * nls ) { const unsigned char * ip ; unsigned char nc ; unsigned char * op ; unsigned int ec ; int i , k , fill ; int charlen ; if ( utf8 ) { <S2SV_StartBug> * outlen = utf8s_to_utf16s ( name , len , ( wchar_t * ) outname ) ; <S2SV_EndBug> if ( * outlen < 0 ) return * outlen ; else if ( * outlen > FAT_LFN_LEN ) return - ENAMETOOLONG ; op = & outname [ * outlen * sizeof ( wchar_t ) ] ; } else { if ( nls ) { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; * outlen += 1 ) { if ( escape && ( * ip == ':' ) ) { if ( i > len - 5 ) return - EINVAL ; ec = 0 ; for ( k = 1 ; k < 5 ; k ++ ) { nc = ip [ k ] ; ec <<= 4 ; if ( nc >= '0' && nc <= '9' ) { ec |= nc - '0' ; continue ; } if ( nc >= 'a' && nc <= 'f' ) { ec |= nc - ( 'a' - 10 ) ; continue ; } if ( nc >= 'A' && nc <= 'F' ) { ec |= nc - ( 'A' - 10 ) ; continue ; } return - EINVAL ; } * op ++ = ec & 0xFF ; * op ++ = ec >> 8 ; ip += 5 ; i += 5 ; } else { if ( ( charlen = nls -> char2uni ( ip , len - i , ( wchar_t * ) op ) ) < 0 ) return - EINVAL ; ip += charlen ; i += charlen ; op += 2 ; } } if ( i < len ) return - ENAMETOOLONG ; } else { for ( i = 0 , ip = name , op = outname , * outlen = 0 ; i < len && * outlen <= FAT_LFN_LEN ; i ++ , * outlen += 1 ) { * op ++ = * ip ++ ; * op ++ = 0 ; } if ( i < len ) return - ENAMETOOLONG ; } } * longlen = * outlen ; if ( * outlen % 13 ) { * op ++ = 0 ; * op ++ = 0 ; * outlen += 1 ; if ( * outlen % 13 ) { fill = 13 - ( * outlen % 13 ) ; for ( i = 0 ; i < fill ; i ++ ) { * op ++ = 0xff ; * op ++ = 0xff ; } * outlen += fill ; } } return 0 ; }
","<S2SV_ModStart> , len , UTF16_HOST_ENDIAN , <S2SV_ModStart> * ) outname , FAT_LFN_LEN + 2
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
CWE-190,"CWE-190 static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) { png_structp png_ptr = NULL ; png_infop info_ptr = NULL ; png_size_t rowbytes ; int color_type , bit_depth ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; if ( ! png_ptr ) { return PNG_OUT_OF_MEMORY_ERROR ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return LIBPNG_FATAL_ERROR ; } # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; # endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\0iTXt\\0tEXt\\0zTXt"" , 4 ) ; # endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; struct rwpng_read_data read_data = { infile , 0 } ; png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ; <S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) { # ifdef PNG_READ_FILLER_SUPPORTED png_set_expand ( png_ptr ) ; png_set_filler ( png_ptr , 65535L , PNG_FILLER_AFTER ) ; # else fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>image<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>RGBA<S2SV_blank>nor<S2SV_blank>GA\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> retval = WRONG_INPUT_COLOR_TYPE ; return mainprog_ptr -> retval ; # endif } if ( bit_depth == 16 ) { png_set_strip_16 ( png_ptr ) ; } if ( ! ( color_type & PNG_COLOR_MASK_COLOR ) ) { png_set_gray_to_rgb ( png_ptr ) ; } double gamma = 0.45455 ; if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) ) { mainprog_ptr -> input_color = RWPNG_SRGB ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { png_get_gAMA ( png_ptr , info_ptr , & gamma ) ; if ( gamma > 0 && gamma <= 1.0 ) { mainprog_ptr -> input_color = RWPNG_GAMA_ONLY ; mainprog_ptr -> output_color = RWPNG_GAMA_ONLY ; } else { fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>ignored<S2SV_blank>out-of-range<S2SV_blank>gamma<S2SV_blank>%f\\n"" , gamma ) ; mainprog_ptr -> input_color = RWPNG_NONE ; mainprog_ptr -> output_color = RWPNG_NONE ; gamma = 0.45455 ; } } mainprog_ptr -> gamma = gamma ; png_set_interlace_handling ( png_ptr ) ; png_read_update_info ( png_ptr , info_ptr ) ; rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug> fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } png_bytepp row_pointers = rwpng_create_row_pointers ( info_ptr , png_ptr , mainprog_ptr -> rgba_data , mainprog_ptr -> height , 0 ) ; png_read_image ( png_ptr , row_pointers ) ; png_read_end ( png_ptr , NULL ) ; # if USE_LCMS # if PNG_LIBPNG_VER < 10500 png_charp ProfileData ; # else png_bytep ProfileData ; # endif png_uint_32 ProfileLen ; cmsHPROFILE hInProfile = NULL ; int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR ; if ( png_get_iCCP ( png_ptr , info_ptr , & ( png_charp ) { 0 } , & ( int ) { 0 } , & ProfileData , & ProfileLen ) ) { hInProfile = cmsOpenProfileFromMem ( ProfileData , ProfileLen ) ; cmsColorSpaceSignature colorspace = cmsGetColorSpace ( hInProfile ) ; if ( colorspace == cmsSigRgbData && COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { if ( colorspace == cmsSigGrayData && ! COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP_WARN_GRAY ; mainprog_ptr -> output_color = RWPNG_SRGB ; } cmsCloseProfile ( hInProfile ) ; hInProfile = NULL ; } } if ( hInProfile == NULL && COLOR_PNG && ! png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_gAMA ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_cHRM ) ) { cmsCIExyY WhitePoint ; cmsCIExyYTRIPLE Primaries ; png_get_cHRM ( png_ptr , info_ptr , & WhitePoint . x , & WhitePoint . y , & Primaries . Red . x , & Primaries . Red . y , & Primaries . Green . x , & Primaries . Green . y , & Primaries . Blue . x , & Primaries . Blue . y ) ; WhitePoint . Y = Primaries . Red . Y = Primaries . Green . Y = Primaries . Blue . Y = 1.0 ; cmsToneCurve * GammaTable [ 3 ] ; GammaTable [ 0 ] = GammaTable [ 1 ] = GammaTable [ 2 ] = cmsBuildGamma ( NULL , 1 / gamma ) ; hInProfile = cmsCreateRGBProfile ( & WhitePoint , & Primaries , GammaTable ) ; cmsFreeToneCurve ( GammaTable [ 0 ] ) ; mainprog_ptr -> input_color = RWPNG_GAMA_CHRM ; mainprog_ptr -> output_color = RWPNG_SRGB ; } if ( hInProfile != NULL ) { cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile ( ) ; cmsHTRANSFORM hTransform = cmsCreateTransform ( hInProfile , TYPE_RGBA_8 , hOutProfile , TYPE_RGBA_8 , INTENT_PERCEPTUAL , omp_get_max_threads ( ) > 1 ? cmsFLAGS_NOCACHE : 0 ) ; # pragma omp parallel for if ( mainprog_ptr -> height * mainprog_ptr -> width > 8000 ) schedule ( static ) for ( unsigned int i = 0 ; i < mainprog_ptr -> height ; i ++ ) { cmsDoTransform ( hTransform , row_pointers [ i ] , row_pointers [ i ] , mainprog_ptr -> width ) ; } cmsDeleteTransform ( hTransform ) ; cmsCloseProfile ( hOutProfile ) ; cmsCloseProfile ( hInProfile ) ; mainprog_ptr -> gamma = 0.45455 ; } # endif png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> file_size = read_data . bytes_read ; mainprog_ptr -> row_pointers = ( unsigned char * * ) row_pointers ; return SUCCESS ; }
","<S2SV_ModStart> NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if (
",pornel@pngquant/b7c217680cda02dddced245d237ebe8c383be285,CVE-2016-5735,https://github.com/pornel/pngquant/commit/b7c217680cda02dddced245d237ebe8c383be285,2017-05-23T04:29Z
CWE-20,"CWE-20 static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }
","<S2SV_ModStart> graveyard_link ) ; short state = key -> state ; <S2SV_ModStart> ; if ( state == KEY_IS_POSITIVE && <S2SV_ModEnd> key -> type <S2SV_ModStart> ; if ( state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) atomic_dec (
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-119,"CWE-119 void vp8_first_pass ( VP8_COMP * cpi ) { int mb_row , mb_col ; MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; int recon_yoffset , recon_uvoffset ; YV12_BUFFER_CONFIG * lst_yv12 = & cm -> yv12_fb [ cm -> lst_fb_idx ] ; YV12_BUFFER_CONFIG * new_yv12 = & cm -> yv12_fb [ cm -> new_fb_idx ] ; YV12_BUFFER_CONFIG * gld_yv12 = & cm -> yv12_fb [ cm -> gld_fb_idx ] ; int recon_y_stride = lst_yv12 -> y_stride ; int recon_uv_stride = lst_yv12 -> uv_stride ; int64_t intra_error = 0 ; int64_t coded_error = 0 ; int sum_mvr = 0 , sum_mvc = 0 ; int sum_mvr_abs = 0 , sum_mvc_abs = 0 ; int sum_mvrs = 0 , sum_mvcs = 0 ; int mvcount = 0 ; int intercount = 0 ; int second_ref_count = 0 ; int intrapenalty = 256 ; int neutral_count = 0 ; int new_mv_count = 0 ; int sum_in_vectors = 0 ; uint32_t lastmv_as_int = 0 ; int_mv zero_ref_mv ; zero_ref_mv . as_int = 0 ; vp8_clear_system_state ( ) ; x -> src = * cpi -> Source ; xd -> pre = * lst_yv12 ; xd -> dst = * new_yv12 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; if ( ! cm -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_bilinear_predict8x4 ; xd -> subpixel_predict8x8 = vp8_bilinear_predict8x8 ; xd -> subpixel_predict16x16 = vp8_bilinear_predict16x16 ; } vp8_build_block_offsets ( x ) ; vp8_setup_intra_recon ( new_yv12 ) ; vp8cx_frame_init_quantizer ( cpi ) ; { int flag [ 2 ] = { 1 , 1 } ; vp8_initialize_rd_consts ( cpi , x , vp8_dc_quant ( cm -> base_qindex , cm -> y1dc_delta_q ) ) ; <S2SV_StartBug> vpx_memcpy ( cm -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cm -> fc . mvc , flag ) ; } for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { int_mv best_ref_mv ; best_ref_mv . as_int = 0 ; xd -> up_available = ( mb_row != 0 ) ; recon_yoffset = ( mb_row * recon_y_stride * 16 ) ; recon_uvoffset = ( mb_row * recon_uv_stride * 8 ) ; x -> mv_row_min = - ( ( mb_row * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_row_max = ( ( cm -> mb_rows - 1 - mb_row ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { int this_error ; int gf_motion_error = INT_MAX ; int use_dc_pred = ( mb_col || mb_row ) && ( ! mb_col || ! mb_row ) ; xd -> dst . y_buffer = new_yv12 -> y_buffer + recon_yoffset ; xd -> dst . u_buffer = new_yv12 -> u_buffer + recon_uvoffset ; xd -> dst . v_buffer = new_yv12 -> v_buffer + recon_uvoffset ; xd -> left_available = ( mb_col != 0 ) ; vp8_copy_mem16x16 ( x -> src . y_buffer , x -> src . y_stride , x -> thismb , 16 ) ; this_error = vp8_encode_intra ( cpi , x , use_dc_pred ) ; this_error += intrapenalty ; intra_error += ( int64_t ) this_error ; x -> mv_col_min = - ( ( mb_col * 16 ) + ( VP8BORDERINPIXELS - 16 ) ) ; x -> mv_col_max = ( ( cm -> mb_cols - 1 - mb_col ) * 16 ) + ( VP8BORDERINPIXELS - 16 ) ; if ( cm -> current_video_frame > 0 ) { BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MV tmp_mv = { 0 , 0 } ; int tmp_err ; int motion_error = INT_MAX ; int raw_motion_error = INT_MAX ; zz_motion_search ( cpi , x , cpi -> last_frame_unscaled_source , & raw_motion_error , lst_yv12 , & motion_error , recon_yoffset ) ; d -> bmi . mv . as_mv . row = 0 ; d -> bmi . mv . as_mv . col = 0 ; if ( raw_motion_error < cpi -> oxcf . encode_breakout ) goto skip_motion_search ; first_pass_motion_search ( cpi , x , & best_ref_mv , & d -> bmi . mv . as_mv , lst_yv12 , & motion_error , recon_yoffset ) ; if ( best_ref_mv . as_int ) { tmp_err = INT_MAX ; first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , lst_yv12 , & tmp_err , recon_yoffset ) ; if ( tmp_err < motion_error ) { motion_error = tmp_err ; d -> bmi . mv . as_mv . row = tmp_mv . row ; d -> bmi . mv . as_mv . col = tmp_mv . col ; } } if ( cm -> current_video_frame > 1 ) { first_pass_motion_search ( cpi , x , & zero_ref_mv , & tmp_mv , gld_yv12 , & gf_motion_error , recon_yoffset ) ; if ( ( gf_motion_error < motion_error ) && ( gf_motion_error < this_error ) ) { second_ref_count ++ ; } xd -> pre . y_buffer = lst_yv12 -> y_buffer + recon_yoffset ; xd -> pre . u_buffer = lst_yv12 -> u_buffer + recon_uvoffset ; xd -> pre . v_buffer = lst_yv12 -> v_buffer + recon_uvoffset ; } skip_motion_search : best_ref_mv . as_int = 0 ; if ( motion_error <= this_error ) { if ( ( ( ( this_error - intrapenalty ) * 9 ) <= ( motion_error * 10 ) ) && ( this_error < ( 2 * intrapenalty ) ) ) { neutral_count ++ ; } d -> bmi . mv . as_mv . row *= 8 ; d -> bmi . mv . as_mv . col *= 8 ; this_error = motion_error ; vp8_set_mbmode_and_mvs ( x , NEWMV , & d -> bmi . mv ) ; vp8_encode_inter16x16y ( x ) ; sum_mvr += d -> bmi . mv . as_mv . row ; sum_mvr_abs += abs ( d -> bmi . mv . as_mv . row ) ; sum_mvc += d -> bmi . mv . as_mv . col ; sum_mvc_abs += abs ( d -> bmi . mv . as_mv . col ) ; sum_mvrs += d -> bmi . mv . as_mv . row * d -> bmi . mv . as_mv . row ; sum_mvcs += d -> bmi . mv . as_mv . col * d -> bmi . mv . as_mv . col ; intercount ++ ; best_ref_mv . as_int = d -> bmi . mv . as_int ; if ( d -> bmi . mv . as_int ) { mvcount ++ ; if ( d -> bmi . mv . as_int != lastmv_as_int ) new_mv_count ++ ; lastmv_as_int = d -> bmi . mv . as_int ; if ( mb_row < cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors ++ ; } else if ( mb_row > cm -> mb_rows / 2 ) { if ( d -> bmi . mv . as_mv . row > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . row < 0 ) sum_in_vectors -- ; } if ( mb_col < cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors -- ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors ++ ; } else if ( mb_col > cm -> mb_cols / 2 ) { if ( d -> bmi . mv . as_mv . col > 0 ) sum_in_vectors ++ ; else if ( d -> bmi . mv . as_mv . col < 0 ) sum_in_vectors -- ; } } } } coded_error += ( int64_t ) this_error ; x -> src . y_buffer += 16 ; x -> src . u_buffer += 8 ; x -> src . v_buffer += 8 ; recon_yoffset += 16 ; recon_uvoffset += 8 ; } x -> src . y_buffer += 16 * x -> src . y_stride - 16 * cm -> mb_cols ; x -> src . u_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; x -> src . v_buffer += 8 * x -> src . uv_stride - 8 * cm -> mb_cols ; vp8_extend_mb_row ( new_yv12 , xd -> dst . y_buffer + 16 , xd -> dst . u_buffer + 8 , xd -> dst . v_buffer + 8 ) ; vp8_clear_system_state ( ) ; } vp8_clear_system_state ( ) ; { double weight = 0.0 ; FIRSTPASS_STATS fps ; fps . frame = cm -> current_video_frame ; fps . intra_error = ( double ) ( intra_error >> 8 ) ; fps . coded_error = ( double ) ( coded_error >> 8 ) ; weight = simple_weight ( cpi -> Source ) ; if ( weight < 0.1 ) weight = 0.1 ; fps . ssim_weighted_pred_err = fps . coded_error * weight ; fps . pcnt_inter = 0.0 ; fps . pcnt_motion = 0.0 ; fps . MVr = 0.0 ; fps . mvr_abs = 0.0 ; fps . MVc = 0.0 ; fps . mvc_abs = 0.0 ; fps . MVrv = 0.0 ; fps . MVcv = 0.0 ; fps . mv_in_out_count = 0.0 ; fps . new_mv_count = 0.0 ; fps . count = 1.0 ; fps . pcnt_inter = 1.0 * ( double ) intercount / cm -> MBs ; fps . pcnt_second_ref = 1.0 * ( double ) second_ref_count / cm -> MBs ; fps . pcnt_neutral = 1.0 * ( double ) neutral_count / cm -> MBs ; if ( mvcount > 0 ) { fps . MVr = ( double ) sum_mvr / ( double ) mvcount ; fps . mvr_abs = ( double ) sum_mvr_abs / ( double ) mvcount ; fps . MVc = ( double ) sum_mvc / ( double ) mvcount ; fps . mvc_abs = ( double ) sum_mvc_abs / ( double ) mvcount ; fps . MVrv = ( ( double ) sum_mvrs - ( fps . MVr * fps . MVr / ( double ) mvcount ) ) / ( double ) mvcount ; fps . MVcv = ( ( double ) sum_mvcs - ( fps . MVc * fps . MVc / ( double ) mvcount ) ) / ( double ) mvcount ; fps . mv_in_out_count = ( double ) sum_in_vectors / ( double ) ( mvcount * 2 ) ; fps . new_mv_count = new_mv_count ; fps . pcnt_motion = 1.0 * ( double ) mvcount / cpi -> common . MBs ; } fps . duration = ( double ) ( cpi -> source -> ts_end - cpi -> source -> ts_start ) ; memcpy ( & cpi -> twopass . this_frame_stats , & fps , sizeof ( FIRSTPASS_STATS ) ) ; output_stats ( cpi , cpi -> output_pkt_list , & cpi -> twopass . this_frame_stats ) ; accumulate_stats ( & cpi -> twopass . total_stats , & fps ) ; } if ( ( cm -> current_video_frame > 0 ) && ( cpi -> twopass . this_frame_stats . pcnt_inter > 0.20 ) && ( ( cpi -> twopass . this_frame_stats . intra_error / DOUBLE_DIVIDE_CHECK ( cpi -> twopass . this_frame_stats . coded_error ) ) > 2.0 ) ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } vp8_swap_yv12_buffer ( lst_yv12 , new_yv12 ) ; vp8_yv12_extend_frame_borders ( lst_yv12 ) ; if ( cm -> current_video_frame == 0 ) { vp8_yv12_copy_frame ( lst_yv12 , gld_yv12 ) ; } if ( 0 ) { char filename [ 512 ] ; FILE * recon_file ; sprintf ( filename , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; if ( cm -> current_video_frame == 0 ) recon_file = fopen ( filename , ""wb"" ) ; else recon_file = fopen ( filename , ""ab"" ) ; ( void ) fwrite ( lst_yv12 -> buffer_alloc , lst_yv12 -> frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } cm -> current_video_frame ++ ; }
","<S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( cm ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-436,"CWE-436 static gssize find_auth_end ( FlatpakProxyClient * client , Buffer * buffer ) { <S2SV_StartBug> guchar * match ; <S2SV_EndBug> int i ; if ( client -> auth_end_offset > 0 ) { gsize left = strlen ( AUTH_END_STRING ) - client -> auth_end_offset ; <S2SV_StartBug> gsize to_match = MIN ( left , buffer -> pos ) ; <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( buffer -> data , & AUTH_END_STRING [ client -> auth_end_offset ] , to_match ) == 0 ) <S2SV_EndBug> { client -> auth_end_offset += to_match ; if ( client -> auth_end_offset == strlen ( AUTH_END_STRING ) ) return to_match ; return - 1 ; } client -> auth_end_offset = - 1 ; } match = memmem ( buffer , buffer -> pos , AUTH_END_STRING , strlen ( AUTH_END_STRING ) ) ; if ( match != NULL ) <S2SV_StartBug> return match - buffer -> data + strlen ( AUTH_END_STRING ) ; <S2SV_EndBug> for ( i = MIN ( strlen ( AUTH_END_STRING ) - 1 , buffer -> pos ) ; i > 0 ; i -- ) { if ( memcmp ( buffer -> data + buffer -> pos - i , AUTH_END_STRING , i ) == 0 ) { client -> auth_end_offset = i ; break ; } } return - 1 ; }
","<S2SV_ModStart> buffer ) { goffset offset = 0 ; gsize original_size = client -> auth_buffer -> len ; g_byte_array_append ( client -> auth_buffer <S2SV_ModEnd> , buffer -> <S2SV_ModStart> , buffer -> data , buffer -> <S2SV_ModStart> pos ) ; while ( TRUE ) { guint8 * line_start = client -> auth_buffer <S2SV_ModEnd> -> data + <S2SV_ModStart> -> data + offset ; gsize remaining_data = client -> auth_buffer -> len - offset ; guint8 * line_end ; line_end = memmem ( line_start , remaining_data , AUTH_LINE_SENTINEL , strlen ( AUTH_LINE_SENTINEL ) ) ; if ( line_end ) { offset = ( line_end + strlen ( AUTH_LINE_SENTINEL ) - line_start ) ; if ( ! auth_line_is_valid ( line_start , line_end ) ) return FIND_AUTH_END_ABORT ; * line_end = 0 ; if ( auth_line_is_begin ( line_start ) ) return offset - original_size ; } else { g_byte_array_remove_range ( client -> auth_buffer , 0 , offset ) ; if ( client -> auth_buffer -> len >= 16 * 1024 ) return FIND_AUTH_END_ABORT ; return FIND_AUTH_END_CONTINUE ; } } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",flatpak@flatpak/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,CVE-2018-6560,https://github.com/flatpak/flatpak/commit/52346bf187b5a7f1c0fe9075b328b7ad6abe78f6,2018-02-02T14:29Z
CWE-787,"CWE-787 size_t OpenMP4Source ( char * filename , uint32_t traktype , uint32_t traksubtype ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; <S2SV_StartBug> memset ( mp4 , 0 , sizeof ( mp4object ) ) ; <S2SV_EndBug> # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { uint32_t qttag , qtsize32 , skip , type = 0 , subtype = 0 , num ; size_t len ; int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( len == 8 ) <S2SV_EndBug> { if ( ! VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { <S2SV_StartBug> fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; <S2SV_EndBug> qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; # if PRINT_MP4_STRUCTURE for ( int i = 1 ; i < nest ; i ++ ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; printf ( ""%c%c%c%c<S2SV_blank>(%lld)\\n"" , ( qttag & 0xff ) , ( ( qttag >> 8 ) & 0xff ) , ( ( qttag >> 16 ) & 0xff ) , ( ( qttag >> 24 ) & 0xff ) , qtsize ) ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) || <S2SV_StartBug> qttag == MAKEID ( 'u' , 'd' , 't' , 'a' ) ) <S2SV_EndBug> { <S2SV_StartBug> LONGSEEK ( mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } # else if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'm' , 'v' , 'h' , 'd' ) && qttag != MAKEID ( 't' , 'r' , 'a' , 'k' ) && qttag != MAKEID ( 'm' , 'd' , 'i' , 'a' ) && qttag != MAKEID ( 'm' , 'd' , 'h' , 'd' ) && qttag != MAKEID ( 'm' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'g' , 'm' , 'i' , 'n' ) && qttag != MAKEID ( 'd' , 'i' , 'n' , 'f' ) && qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && qttag != MAKEID ( 's' , 't' , 's' , 'd' ) && <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 'a' , 'l' , 'i' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'b' , 'l' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 't' , 's' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'c' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 's' , 'z' ) && <S2SV_EndBug> <S2SV_StartBug> qttag != MAKEID ( 's' , 't' , 'c' , 'o' ) && <S2SV_EndBug> qttag != MAKEID ( 'c' , 'o' , '6' , '4' ) && qttag != MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else # endif if ( qttag == MAKEID ( 'm' , 'v' , 'h' , 'd' ) ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & mp4 -> clockdemon , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockdemon = BYTESWAP32 ( mp4 -> clockdemon ) ; len += fread ( & mp4 -> clockcount , 1 , 4 , mp4 -> mediafp ) ; mp4 -> clockcount = BYTESWAP32 ( mp4 -> clockcount ) ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'm' , 'd' , 'h' , 'd' ) ) { media_header md ; len = fread ( & md , 1 , sizeof ( md ) , mp4 -> mediafp ) ; if ( len == sizeof ( md ) ) { md . creation_time = BYTESWAP32 ( md . creation_time ) ; md . modification_time = BYTESWAP32 ( md . modification_time ) ; md . time_scale = BYTESWAP32 ( md . time_scale ) ; md . duration = BYTESWAP32 ( md . duration ) ; mp4 -> trak_clockdemon = md . time_scale ; mp4 -> trak_clockcount = md . duration ; if ( mp4 -> videolength == 0.0 ) { mp4 -> videolength = ( float ) ( ( double ) mp4 -> trak_clockcount / ( double ) mp4 -> trak_clockdemon ) ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'h' , 'd' , 'l' , 'r' ) ) { uint32_t temp ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & temp , 1 , 4 , mp4 -> mediafp ) ; <S2SV_StartBug> if ( temp != MAKEID ( 'a' , 'l' , 'i' , 's' ) ) <S2SV_EndBug> type = temp ; <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'd' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & subtype , 1 , 4 , mp4 -> mediafp ) ; if ( len == 16 ) { if ( subtype != traksubtype ) { type = 0 ; } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'c' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 12 <= qtsize - 8 - len ) { mp4 -> metastsc_count = num ; if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; <S2SV_StartBug> mp4 -> metastsc = ( SampleToChunk * ) malloc ( num * 12 ) ; <S2SV_EndBug> if ( mp4 -> metastsc ) { <S2SV_StartBug> uint32_t total_stsc = num ; <S2SV_EndBug> len += fread ( mp4 -> metastsc , 1 , num * sizeof ( SampleToChunk ) , mp4 -> mediafp ) ; do { num -- ; mp4 -> metastsc [ num ] . chunk_num = BYTESWAP32 ( mp4 -> metastsc [ num ] . chunk_num ) ; mp4 -> metastsc [ num ] . samples = BYTESWAP32 ( mp4 -> metastsc [ num ] . samples ) ; mp4 -> metastsc [ num ] . id = BYTESWAP32 ( mp4 -> metastsc [ num ] . id ) ; } while ( num > 0 ) ; } <S2SV_StartBug> if ( mp4 -> metastsc_count == 1 && mp4 -> metastsc [ 0 ] . samples == 1 ) <S2SV_EndBug> { if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; <S2SV_StartBug> mp4 -> metastsc_count = 0 ; <S2SV_EndBug> } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 's' , 'z' ) ) { if ( type == traktype ) { uint32_t equalsamplesize ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & equalsamplesize , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { mp4 -> metasize_count = num ; if ( mp4 -> metasizes ) free ( mp4 -> metasizes ) ; <S2SV_StartBug> mp4 -> metasizes = ( uint32_t * ) malloc ( num * 4 ) ; <S2SV_EndBug> if ( mp4 -> metasizes ) { if ( equalsamplesize == 0 ) { len += fread ( mp4 -> metasizes , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metasizes [ num ] = BYTESWAP32 ( mp4 -> metasizes [ num ] ) ; } while ( num > 0 ) ; } else { equalsamplesize = BYTESWAP32 ( equalsamplesize ) ; do { num -- ; mp4 -> metasizes [ num ] = equalsamplesize ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 'c' , 'o' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 4 <= qtsize - 8 - len ) { <S2SV_StartBug> if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) <S2SV_EndBug> { <S2SV_StartBug> mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> <S2SV_StartBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; int repeat = 1 ; len += fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; do { num -- ; metaoffsets32 [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; mp4 -> metaoffsets [ 0 ] = fileoffset = metaoffsets32 [ stco_pos ] ; num = 1 ; <S2SV_StartBug> while ( num < mp4 -> metasize_count ) <S2SV_EndBug> { if ( stsc_pos + 1 < ( int ) mp4 -> metastsc_count && num == stsc_pos ) { stco_pos ++ ; stsc_pos ++ ; fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; repeat = 1 ; } else if ( repeat == mp4 -> metastsc [ stsc_pos ] . samples ) { <S2SV_StartBug> stco_pos ++ ; <S2SV_EndBug> fileoffset = ( uint64_t ) metaoffsets32 [ stco_pos ] ; <S2SV_StartBug> repeat = 1 ; <S2SV_EndBug> } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_StartBug> repeat ++ ; <S2SV_EndBug> } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets32 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { uint32_t * metaoffsets32 = NULL ; metaoffsets32 = ( uint32_t * ) malloc ( num * 4 ) ; if ( metaoffsets32 ) { size_t readlen = fread ( metaoffsets32 , 1 , num * 4 , mp4 -> mediafp ) ; len += readlen ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP32 ( metaoffsets32 [ num ] ) ; } while ( num > 0 ) ; free ( metaoffsets32 ) ; } } } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 'c' , 'o' , '6' , '4' ) ) { if ( type == traktype ) { len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; <S2SV_StartBug> if ( num * 8 <= qtsize - 8 - len ) <S2SV_EndBug> { if ( mp4 -> metastsc_count > 0 && num != mp4 -> metasize_count ) { mp4 -> indexcount = mp4 -> metasize_count ; <S2SV_StartBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; <S2SV_EndBug> mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> metasize_count * 8 ) ; if ( mp4 -> metaoffsets ) { uint64_t * metaoffsets64 = NULL ; metaoffsets64 = ( uint64_t * ) malloc ( num * 8 ) ; if ( metaoffsets64 ) { uint64_t fileoffset = 0 ; int stsc_pos = 0 ; int stco_pos = 0 ; len += fread ( metaoffsets64 , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; metaoffsets64 [ num ] = BYTESWAP64 ( metaoffsets64 [ num ] ) ; } while ( num > 0 ) ; fileoffset = metaoffsets64 [ 0 ] ; mp4 -> metaoffsets [ 0 ] = fileoffset ; num = 1 ; while ( num < mp4 -> metasize_count ) { if ( num != mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 && 0 == ( num - ( mp4 -> metastsc [ stsc_pos ] . chunk_num - 1 ) ) % mp4 -> metastsc [ stsc_pos ] . samples ) { stco_pos ++ ; fileoffset = ( uint64_t ) metaoffsets64 [ stco_pos ] ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; } mp4 -> metaoffsets [ num ] = fileoffset ; num ++ ; } if ( mp4 -> metastsc ) free ( mp4 -> metastsc ) ; mp4 -> metastsc = NULL ; mp4 -> metastsc_count = 0 ; free ( metaoffsets64 ) ; } } } else { <S2SV_StartBug> mp4 -> indexcount = num ; <S2SV_EndBug> if ( mp4 -> metaoffsets ) free ( mp4 -> metaoffsets ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( num * 8 ) ; if ( mp4 -> metaoffsets ) { len += fread ( mp4 -> metaoffsets , 1 , num * 8 , mp4 -> mediafp ) ; do { num -- ; mp4 -> metaoffsets [ num ] = BYTESWAP64 ( mp4 -> metaoffsets [ num ] ) ; } while ( num > 0 ) ; } } } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else if ( qttag == MAKEID ( 's' , 't' , 't' , 's' ) ) { if ( type == traktype ) { uint32_t totaldur = 0 , samples = 0 ; int32_t entries = 0 ; len = fread ( & skip , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & num , 1 , 4 , mp4 -> mediafp ) ; num = BYTESWAP32 ( num ) ; if ( num * 8 <= qtsize - 8 - len ) { entries = num ; mp4 -> meta_clockdemon = mp4 -> trak_clockdemon ; mp4 -> meta_clockcount = mp4 -> trak_clockcount ; while ( entries > 0 ) { int32_t samplecount ; int32_t duration ; len += fread ( & samplecount , 1 , 4 , mp4 -> mediafp ) ; samplecount = BYTESWAP32 ( samplecount ) ; len += fread ( & duration , 1 , 4 , mp4 -> mediafp ) ; duration = BYTESWAP32 ( duration ) ; samples += samplecount ; entries -- ; totaldur += duration ; mp4 -> metadatalength += ( double ) ( ( double ) samplecount * ( double ) duration / ( double ) mp4 -> meta_clockdemon ) ; } mp4 -> basemetadataduration = mp4 -> metadatalength * ( double ) mp4 -> meta_clockdemon / ( double ) samples ; } <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 - len , SEEK_CUR ) ; <S2SV_EndBug> } else <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; } else { NESTSIZE ( 8 ) ; } } else { break ; } } while ( len > 0 ) ; <S2SV_StartBug> } <S2SV_EndBug> else { free ( mp4 ) ; mp4 = NULL ; } return ( size_t ) mp4 ; }
","<S2SV_ModStart> mp4object ) ) ; struct stat64 mp4stat ; stat64 ( filename , & mp4stat ) ; mp4 -> filesize = mp4stat . st_size ; if ( mp4 -> filesize < 64 ) return 0 <S2SV_ModStart> mediafp ) ; mp4 -> filepos += len ; <S2SV_ModStart> len == 8 && mp4 -> filepos < mp4 -> filesize <S2SV_ModStart> ) ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break <S2SV_ModEnd> ; } qtsize32 <S2SV_ModStart> 1 ) { len = <S2SV_ModStart> -> mediafp ) ; mp4 -> filepos += len <S2SV_ModStart> , 'a' ) || qttag == MAKEID ( 'f' , 'r' , 'e' , 'e' ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> != MAKEID ( 's' , 't' , 'b' , 'l' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 's' , 't' , 't' <S2SV_ModEnd> , 's' ) <S2SV_ModStart> , 't' , 's' , 'c' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 's' , 'z' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> , 't' , 'c' , 'o' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( 'c' , 'o' , '6' , '4' <S2SV_ModEnd> ) && qttag <S2SV_ModStart> != MAKEID ( <S2SV_ModEnd> 'h' , 'd' <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> clockcount ) ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> , 's' ) && temp != MAKEID ( 'u' , 'r' , 'l' , '<S2SV_blank>' ) <S2SV_ModStart> = temp ; mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metastsc ) ; if ( num > 0 ) { <S2SV_ModStart> ( num * sizeof ( SampleToChunk ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> metastsc ) { <S2SV_ModEnd> len += fread <S2SV_ModStart> ) ; } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> metasizes ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> len ) { uint32_t metastco_count = num ; <S2SV_ModStart> -> indexcount = num <S2SV_ModEnd> ; if ( <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> ) malloc ( num <S2SV_ModEnd> * 8 ) <S2SV_ModStart> < mp4 -> indexcount ) { if ( ( uint32_t ) <S2SV_ModEnd> repeat == mp4 <S2SV_ModStart> samples ) { if ( ( uint32_t ) stco_pos + 1 < metastco_count ) { <S2SV_ModStart> stco_pos ] ; <S2SV_ModEnd> } else { <S2SV_ModStart> 1 ] ; } if ( ( uint32_t ) stsc_pos + 1 < mp4 -> metastsc_count ) if ( mp4 -> metastsc [ stsc_pos + 1 ] . chunk_num == ( uint32_t ) stco_pos + 1 ) stsc_pos ++ ; repeat = 1 ; } else { fileoffset += ( uint64_t ) mp4 -> metasizes [ num - 1 ] ; <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> metaoffsets ) ; if ( num > 0 ) { <S2SV_ModStart> } } } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> if ( num == 0 ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } if ( num <S2SV_ModStart> metaoffsets ) ; if ( mp4 -> metasize_count ) { <S2SV_ModStart> } else { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; break ; } } else { <S2SV_ModStart> } } } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> samples ; } mp4 -> filepos += len ; LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> 8 - len <S2SV_ModEnd> ) ; } <S2SV_ModStart> ; } else LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> 0 ) ; if ( mp4 ) { if ( mp4 -> metasizes == NULL || mp4 -> metaoffsets == NULL ) { CloseSource ( ( size_t ) mp4 ) ; mp4 = NULL ; } }
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z
CWE-787,"CWE-787 static int grub_ext2_iterate_dir ( grub_fshelp_node_t dir , int ( * hook ) ( const char * filename , enum grub_fshelp_filetype filetype , grub_fshelp_node_t node , void * closure ) , void * closure ) { unsigned int fpos = 0 ; struct grub_fshelp_node * diro = ( struct grub_fshelp_node * ) dir ; if ( ! diro -> inode_read ) { grub_ext2_read_inode ( diro -> data , diro -> ino , & diro -> inode ) ; if ( grub_errno ) return 0 ; } if ( hook ) while ( fpos < grub_le_to_cpu32 ( diro -> inode . size ) ) { struct ext2_dirent dirent ; grub_ext2_read_file ( diro , NULL , NULL , 0 , fpos , sizeof ( dirent ) , ( char * ) & dirent ) ; if ( grub_errno ) return 0 ; if ( dirent . direntlen == 0 ) return 0 ; if ( dirent . namelen != 0 ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char filename [ dirent . namelen + 1 ] ; <S2SV_EndBug> # else char * filename = grub_malloc ( dirent . namelen + 1 ) ; # endif struct grub_fshelp_node * fdiro ; <S2SV_StartBug> enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN ; <S2SV_EndBug> grub_ext2_read_file ( diro , 0 , 0 , 0 , fpos + sizeof ( struct ext2_dirent ) , dirent . namelen , filename ) ; if ( grub_errno ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> fdiro = grub_malloc ( sizeof ( struct grub_fshelp_node ) ) ; if ( ! fdiro ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> fdiro -> data = diro -> data ; fdiro -> ino = grub_le_to_cpu32 ( dirent . inode ) ; filename [ dirent . namelen ] = '\\0' ; if ( dirent . filetype != FILETYPE_UNKNOWN ) { fdiro -> inode_read = 0 ; if ( dirent . filetype == FILETYPE_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( dirent . filetype == FILETYPE_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( dirent . filetype == FILETYPE_REG ) type = GRUB_FSHELP_REG ; } else { grub_ext2_read_inode ( diro -> data , grub_le_to_cpu32 ( dirent . inode ) , & fdiro -> inode ) ; if ( grub_errno ) <S2SV_StartBug> { <S2SV_EndBug> grub_free ( fdiro ) ; return 0 ; } fdiro -> inode_read = 1 ; if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_DIRECTORY ) type = GRUB_FSHELP_DIR ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_SYMLINK ) type = GRUB_FSHELP_SYMLINK ; else if ( ( grub_le_to_cpu16 ( fdiro -> inode . mode ) & FILETYPE_INO_MASK ) == FILETYPE_INO_REG ) type = GRUB_FSHELP_REG ; } <S2SV_StartBug> if ( hook ( filename , type , fdiro , closure ) ) <S2SV_EndBug> return 1 ; } fpos += grub_le_to_cpu16 ( dirent . direntlen ) ; } return 0 ; }
","<S2SV_ModStart> 0 ) { char * filename = grub_malloc ( <S2SV_ModEnd> dirent . namelen <S2SV_ModStart> namelen + 1 ) ; <S2SV_ModEnd> struct grub_fshelp_node * <S2SV_ModStart> = GRUB_FSHELP_UNKNOWN ; if ( ! filename ) { break ; } <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro = grub_malloc <S2SV_ModStart> ! fdiro ) { free ( filename ) ; return 0 ; } <S2SV_ModEnd> fdiro -> data <S2SV_ModStart> ( grub_errno ) { free ( filename ) ; <S2SV_ModEnd> grub_free ( fdiro <S2SV_ModStart> closure ) ) { free ( filename ) ; return 1 ; } free ( filename ) <S2SV_ModEnd> ; } fpos
",radare@radare2/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,CVE-2017-9949,https://github.com/radare/radare2/commit/796dd28aaa6b9fa76d99c42c4d5ff8b257cc2191,2017-06-26T20:29Z
CWE-119,"CWE-119 void vp9_update_layer_context_change_config ( VP9_COMP * const cpi , const int target_bandwidth ) { SVC * const svc = & cpi -> svc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> int layer ; <S2SV_EndBug> int layer_end ; float bitrate_alloc = 1.0 ; <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> layer_end = svc -> number_temporal_layers ; } else { layer_end = svc -> number_spatial_layers ; } for ( layer = 0 ; layer < layer_end ; ++ layer ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ layer ] ; <S2SV_StartBug> RATE_CONTROL * const lrc = & lc -> rc ; <S2SV_EndBug> <S2SV_StartBug> if ( svc -> number_temporal_layers > 1 ) { <S2SV_EndBug> lc -> target_bandwidth = oxcf -> ts_target_bitrate [ layer ] * 1000 ; } else { lc -> target_bandwidth = oxcf -> ss_target_bitrate [ layer ] * 1000 ; } bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lc -> starting_buffer_level = ( int64_t ) ( oxcf -> starting_buffer_level * bitrate_alloc ) ; lc -> optimal_buffer_level = ( int64_t ) ( oxcf -> optimal_buffer_level * bitrate_alloc ) ; lc -> maximum_buffer_size = ( int64_t ) ( oxcf -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lc -> maximum_buffer_size ) ; if ( svc -> number_temporal_layers > 1 ) { <S2SV_StartBug> lc -> framerate = oxcf -> framerate / oxcf -> ts_rate_decimator [ layer ] ; <S2SV_EndBug> } else { <S2SV_StartBug> lc -> framerate = oxcf -> framerate ; <S2SV_EndBug> } <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> svc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> rc ; int sl , tl , layer = 0 , spatial_layer_target ; float bitrate_alloc = 1.0 ; if ( svc -> temporal_layering_mode != VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING ) { for ( sl = 0 ; sl < oxcf -> ss_number_layers ; ++ sl ) { spatial_layer_target = 0 ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { layer = LAYER_IDS_TO_IDX ( sl , tl , oxcf -> ts_number_layers ) ; svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; } layer = LAYER_IDS_TO_IDX ( sl , ( ( oxcf -> ts_number_layers - 1 ) < 0 ? 0 : ( oxcf -> ts_number_layers - 1 ) ) , oxcf -> ts_number_layers ) ; spatial_layer_target = svc -> layer_context [ layer ] . target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; for ( tl = 0 ; tl < oxcf -> ts_number_layers ; ++ tl ) { LAYER_CONTEXT * const lc = & svc -> layer_context [ sl * oxcf -> ts_number_layers + tl ] ; RATE_CONTROL * const lrc = & lc -> rc ; lc -> spatial_layer_target_bandwidth = spatial_layer_target ; bitrate_alloc = ( float ) lc -> target_bandwidth / spatial_layer_target ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) ; lc -> framerate = cpi -> framerate / oxcf -> ts_rate_decimator [ tl ] ; lrc -> avg_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; lrc -> max_frame_bandwidth = rc -> max_frame_bandwidth ; lrc -> worst_quality = rc -> worst_quality ; lrc -> best_quality = rc -> best_quality ; } } } else { int layer_end <S2SV_ModEnd> ; if ( <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModStart> lc -> rc ; lc -> target_bandwidth = oxcf -> layer_target_bitrate [ layer ] ; bitrate_alloc = ( float ) lc -> target_bandwidth / target_bandwidth ; lrc -> starting_buffer_level = ( int64_t ) ( rc -> starting_buffer_level * bitrate_alloc ) ; lrc -> optimal_buffer_level = ( int64_t ) ( rc -> optimal_buffer_level * bitrate_alloc ) ; lrc -> maximum_buffer_size = ( int64_t ) ( rc -> maximum_buffer_size * bitrate_alloc ) ; lrc -> bits_off_target = MIN ( lrc -> bits_off_target , lrc -> maximum_buffer_size ) ; lrc -> buffer_level = MIN ( lrc -> buffer_level , lrc -> maximum_buffer_size ) <S2SV_ModStart> number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR <S2SV_ModEnd> ) { lc <S2SV_ModStart> -> framerate = cpi <S2SV_ModEnd> -> framerate / <S2SV_ModStart> -> framerate = cpi <S2SV_ModEnd> -> framerate ; <S2SV_ModStart> } lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( int <S2SV_ModStart> ; } } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 tsize_t t2p_readwrite_pdf_image_tile ( T2P * t2p , TIFF * input , TIFF * output , ttile_t tile ) { uint16 edge = 0 ; tsize_t written = 0 ; unsigned char * buffer = NULL ; tsize_t bufferoffset = 0 ; unsigned char * samplebuffer = NULL ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; uint16 i = 0 ; ttile_t tilecount = 0 ; ttile_t septilecount = 0 ; tsize_t septilesize = 0 ; # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint32 xuint32 = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; edge |= t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; edge |= t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ; if ( ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) && ( ( edge == 0 ) # if defined ( JPEG_SUPPORT ) || defined ( OJPEG_SUPPORT ) || ( t2p -> pdf_compression == T2P_COMPRESS_JPEG ) # endif ) ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef ZIP_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_ZIP ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawTile ( input , tile , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer , t2p -> tiff_datasize ) ; } t2pWriteFile ( output , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; _TIFFfree ( buffer ) ; return ( t2p -> tiff_datasize ) ; } # endif # ifdef OJPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_OJPEG ) { if ( ! t2p -> pdf_ojpegdata ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>OJPEG<S2SV_blank>image<S2SV_blank>%s<S2SV_blank>with<S2SV_blank>"" ""bad<S2SV_blank>tables"" , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } _TIFFmemcpy ( buffer , t2p -> pdf_ojpegdata , t2p -> pdf_ojpegdatalength ) ; if ( edge != 0 ) { if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { buffer [ 7 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength >> 8 ) & 0xff ; buffer [ 8 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) & 0xff ; } if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) ) { buffer [ 9 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth >> 8 ) & 0xff ; buffer [ 10 ] = ( t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) & 0xff ; } } bufferoffset = t2p -> pdf_ojpegdatalength ; bufferoffset += TIFFReadRawTile ( input , tile , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xff ; ( ( unsigned char * ) buffer ) [ bufferoffset ++ ] = 0xd9 ; t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif # ifdef JPEG_SUPPORT if ( t2p -> tiff_compression == COMPRESSION_JPEG ) { unsigned char table_end [ 2 ] ; uint32 count = 0 ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>"" TIFF_SIZE_FORMAT ""<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( TIFF_SIZE_T ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } if ( TIFFGetField ( input , TIFFTAG_JPEGTABLES , & count , & jpt ) != 0 ) { <S2SV_StartBug> if ( count >= 4 ) { <S2SV_EndBug> int retTIFFReadRawTile ; _TIFFmemcpy ( buffer , jpt , count - 2 ) ; bufferoffset += count - 2 ; table_end [ 0 ] = buffer [ bufferoffset - 2 ] ; table_end [ 1 ] = buffer [ bufferoffset - 1 ] ; xuint32 = bufferoffset ; bufferoffset -= 2 ; retTIFFReadRawTile = TIFFReadRawTile ( input , tile , ( tdata_t ) & ( ( ( unsigned char * ) buffer ) [ bufferoffset ] ) , - 1 ) ; if ( retTIFFReadRawTile < 0 ) { _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } bufferoffset += retTIFFReadRawTile ; buffer [ xuint32 - 2 ] = table_end [ 0 ] ; buffer [ xuint32 - 1 ] = table_end [ 1 ] ; } } t2pWriteFile ( output , ( tdata_t ) buffer , bufferoffset ) ; _TIFFfree ( buffer ) ; return ( bufferoffset ) ; } # endif ( void ) 0 ; } if ( t2p -> pdf_sample == T2P_SAMPLE_NOTHING ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>"" ""t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } read = TIFFReadEncodedTile ( input , tile , ( tdata_t ) & buffer [ bufferoffset ] , t2p -> tiff_datasize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } else { if ( t2p -> pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG ) { septilesize = TIFFTileSize ( input ) ; septilecount = TIFFNumberOfTiles ( input ) ; tilecount = septilecount / t2p -> tiff_samplesperpixel ; buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebuffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( samplebuffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset = 0 ; for ( i = 0 ; i < t2p -> tiff_samplesperpixel ; i ++ ) { read = TIFFReadEncodedTile ( input , tile + i * tilecount , ( tdata_t ) & ( samplebuffer [ samplebufferoffset ] ) , septilesize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile + i * tilecount , TIFFFileName ( input ) ) ; _TIFFfree ( samplebuffer ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } samplebufferoffset += read ; } t2p_sample_planar_separate_to_contig ( t2p , & ( buffer [ bufferoffset ] ) , samplebuffer , samplebufferoffset ) ; bufferoffset += samplebufferoffset ; _TIFFfree ( samplebuffer ) ; } if ( buffer == NULL ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'t<S2SV_blank>allocate<S2SV_blank>%lu<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>t2p_readwrite_pdf_image_tile,<S2SV_blank>%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } read = TIFFReadEncodedTile ( input , tile , ( tdata_t ) & buffer [ bufferoffset ] , t2p -> tiff_datasize ) ; if ( read == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>on<S2SV_blank>decoding<S2SV_blank>tile<S2SV_blank>%u<S2SV_blank>of<S2SV_blank>%s"" , tile , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgba_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB ) { t2p -> tiff_datasize = t2p_sample_rgbaa_to_rgb ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB ) { TIFFError ( TIFF2PDF_MODULE , ""No<S2SV_blank>support<S2SV_blank>for<S2SV_blank>YCbCr<S2SV_blank>to<S2SV_blank>RGB<S2SV_blank>in<S2SV_blank>tile<S2SV_blank>for<S2SV_blank>%s"" , TIFFFileName ( input ) ) ; _TIFFfree ( buffer ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } if ( t2p -> pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED ) { t2p -> tiff_datasize = t2p_sample_lab_signed_to_unsigned ( ( tdata_t ) buffer , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth * t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } } if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) != 0 ) { t2p_tile_collapse_left ( buffer , TIFFTileRowSize ( input ) , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } t2p_disable ( output ) ; TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , t2p -> tiff_photometric ) ; TIFFSetField ( output , TIFFTAG_BITSPERSAMPLE , t2p -> tiff_bitspersample ) ; TIFFSetField ( output , TIFFTAG_SAMPLESPERPIXEL , t2p -> tiff_samplesperpixel ) ; if ( t2p_tile_is_right_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilewidth ) ; } else { TIFFSetField ( output , TIFFTAG_IMAGEWIDTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilewidth ) ; } if ( t2p_tile_is_bottom_edge ( t2p -> tiff_tiles [ t2p -> pdf_page ] , tile ) == 0 ) { TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_tilelength ) ; } else { TIFFSetField ( output , TIFFTAG_IMAGELENGTH , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; TIFFSetField ( output , TIFFTAG_ROWSPERSTRIP , t2p -> tiff_tiles [ t2p -> pdf_page ] . tiles_edgetilelength ) ; } TIFFSetField ( output , TIFFTAG_PLANARCONFIG , PLANARCONFIG_CONTIG ) ; TIFFSetField ( output , TIFFTAG_FILLORDER , FILLORDER_MSB2LSB ) ; switch ( t2p -> pdf_compression ) { case T2P_COMPRESS_NONE : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_NONE ) ; break ; # ifdef CCITT_SUPPORT case T2P_COMPRESS_G4 : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_CCITTFAX4 ) ; break ; # endif # ifdef JPEG_SUPPORT case T2P_COMPRESS_JPEG : if ( t2p -> tiff_photometric == PHOTOMETRIC_YCBCR ) { uint16 hor = 0 , ver = 0 ; if ( TIFFGetField ( input , TIFFTAG_YCBCRSUBSAMPLING , & hor , & ver ) != 0 ) { if ( hor != 0 && ver != 0 ) { TIFFSetField ( output , TIFFTAG_YCBCRSUBSAMPLING , hor , ver ) ; } } if ( TIFFGetField ( input , TIFFTAG_REFERENCEBLACKWHITE , & xfloatp ) != 0 ) { TIFFSetField ( output , TIFFTAG_REFERENCEBLACKWHITE , xfloatp ) ; } } TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_JPEG ) ; TIFFSetField ( output , TIFFTAG_JPEGTABLESMODE , 0 ) ; if ( t2p -> pdf_colorspace & ( T2P_CS_RGB | T2P_CS_LAB ) ) { TIFFSetField ( output , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; if ( t2p -> tiff_photometric != PHOTOMETRIC_YCBCR ) { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { TIFFSetField ( output , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RAW ) ; } } if ( t2p -> pdf_colorspace & T2P_CS_GRAY ) { ( void ) 0 ; } if ( t2p -> pdf_colorspace & T2P_CS_CMYK ) { ( void ) 0 ; } if ( t2p -> pdf_defaultcompressionquality != 0 ) { TIFFSetField ( output , TIFFTAG_JPEGQUALITY , t2p -> pdf_defaultcompressionquality ) ; } break ; # endif # ifdef ZIP_SUPPORT case T2P_COMPRESS_ZIP : TIFFSetField ( output , TIFFTAG_COMPRESSION , COMPRESSION_DEFLATE ) ; if ( t2p -> pdf_defaultcompressionquality % 100 != 0 ) { TIFFSetField ( output , TIFFTAG_PREDICTOR , t2p -> pdf_defaultcompressionquality % 100 ) ; } if ( t2p -> pdf_defaultcompressionquality / 100 != 0 ) { TIFFSetField ( output , TIFFTAG_ZIPQUALITY , ( t2p -> pdf_defaultcompressionquality / 100 ) ) ; } break ; # endif default : break ; } t2p_enable ( output ) ; t2p -> outputwritten = 0 ; bufferoffset = TIFFWriteEncodedStrip ( output , ( tstrip_t ) 0 , buffer , TIFFStripSize ( output ) ) ; if ( buffer != NULL ) { _TIFFfree ( buffer ) ; buffer = NULL ; } if ( bufferoffset == - 1 ) { TIFFError ( TIFF2PDF_MODULE , ""Error<S2SV_blank>writing<S2SV_blank>encoded<S2SV_blank>tile<S2SV_blank>to<S2SV_blank>output<S2SV_blank>PDF<S2SV_blank>%s"" , TIFFFileName ( output ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } written = t2p -> outputwritten ; return ( written ) ; }
","<S2SV_ModStart> if ( count > <S2SV_ModEnd> 4 ) {
",vadz@libtiff/c7153361a4041260719b340f73f2f76b0969235c,CVE-2016-10094,https://github.com/vadz/libtiff/commit/c7153361a4041260719b340f73f2f76,2017-03-01T15:59Z
CWE-416,"CWE-416 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> generic_pipe_buf_get ( struct <S2SV_ModStart> buf ) { return try_get_page <S2SV_ModEnd> ( buf ->
",torvalds@linux/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,CVE-2019-11487,https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb,2019-04-23T22:29Z
CWE-125,"CWE-125 <S2SV_StartBug> INST_HANDLER ( lds ) { <S2SV_EndBug> int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; int k = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; op -> ptr = k ; __generic_ld_st ( op , ""ram"" , 0 , 1 , 0 , k , 0 ) ; ESIL_A ( ""r%d,=,"" , d ) ; }
","<S2SV_ModStart> lds ) { if ( len < 4 ) { return ; }
",radare@radare2/041e53cab7ca33481ae45ecd65ad596976d78e68,CVE-2018-11375,https://github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68,2018-05-22T19:29Z
CWE-119,"CWE-119 static int xpm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { XPMDecContext * x = avctx -> priv_data ; AVFrame * p = data ; <S2SV_StartBug> const uint8_t * end , * ptr = avpkt -> data ; <S2SV_EndBug> int ncolors , cpp , ret , i , j ; int64_t size ; uint32_t * dst ; avctx -> pix_fmt = AV_PIX_FMT_BGRA ; <S2SV_StartBug> end = avpkt -> data + avpkt -> size ; <S2SV_EndBug> <S2SV_StartBug> while ( memcmp ( ptr , ""/*<S2SV_blank>XPM<S2SV_blank>*/"" , 9 ) && ptr < end - 9 ) <S2SV_EndBug> ptr ++ ; if ( ptr >= end ) { av_log ( avctx , AV_LOG_ERROR , ""missing<S2SV_blank>signature\\n"" ) ; return AVERROR_INVALIDDATA ; } ptr += mod_strcspn ( ptr , ""\\"""" ) ; if ( sscanf ( ptr , ""\\""%u<S2SV_blank>%u<S2SV_blank>%u<S2SV_blank>%u\\"","" , & avctx -> width , & avctx -> height , & ncolors , & cpp ) != 4 ) { av_log ( avctx , AV_LOG_ERROR , ""missing<S2SV_blank>image<S2SV_blank>parameters\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , avctx -> width , avctx -> height ) ) < 0 ) return ret ; if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; if ( cpp <= 0 || cpp >= 5 ) { av_log ( avctx , AV_LOG_ERROR , ""unsupported/invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>chars<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%d\\n"" , cpp ) ; return AVERROR_INVALIDDATA ; } size = 1 ; for ( i = 0 ; i < cpp ; i ++ ) <S2SV_StartBug> size *= 94 ; <S2SV_EndBug> if ( ncolors <= 0 || ncolors > size ) { av_log ( avctx , AV_LOG_ERROR , ""invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%d\\n"" , ncolors ) ; return AVERROR_INVALIDDATA ; } size *= 4 ; av_fast_padded_malloc ( & x -> pixels , & x -> pixels_size , size ) ; if ( ! x -> pixels ) return AVERROR ( ENOMEM ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ; <S2SV_StartBug> for ( i = 0 ; i < ncolors ; i ++ ) { <S2SV_EndBug> const uint8_t * index ; int len ; ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; index = ptr ; ptr += cpp ; ptr = strstr ( ptr , ""c<S2SV_blank>"" ) ; if ( ptr ) { ptr += 2 ; } else { return AVERROR_INVALIDDATA ; } len = strcspn ( ptr , ""\\""<S2SV_blank>"" ) ; if ( ( ret = ascii2index ( index , cpp ) ) < 0 ) return ret ; x -> pixels [ ret ] = color_string_to_rgba ( ptr , len ) ; ptr += mod_strcspn ( ptr , "","" ) + 1 ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < avctx -> height ; i ++ ) { dst = ( uint32_t * ) ( p -> data [ 0 ] + i * p -> linesize [ 0 ] ) ; <S2SV_StartBug> ptr += mod_strcspn ( ptr , ""\\"""" ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> for ( j = 0 ; j < avctx -> width ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> if ( ptr + cpp > end ) <S2SV_EndBug> return AVERROR_INVALIDDATA ; if ( ( ret = ascii2index ( ptr , cpp ) ) < 0 ) return ret ; * dst ++ = x -> pixels [ ret ] ; ptr += cpp ; } ptr += mod_strcspn ( ptr , "","" ) + 1 ; } p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
","<S2SV_ModStart> , * ptr <S2SV_ModEnd> ; int ncolors <S2SV_ModStart> = AV_PIX_FMT_BGRA ; av_fast_padded_malloc ( & x -> buf , & x -> buf_size , avpkt -> size ) ; if ( ! x -> buf ) return AVERROR ( ENOMEM ) ; memcpy ( x -> buf , avpkt -> data , avpkt -> size ) ; x -> buf [ avpkt -> size ] = 0 ; ptr = x -> buf ; end = x -> buf <S2SV_ModEnd> + avpkt -> <S2SV_ModStart> ; while ( end - ptr > 9 && <S2SV_ModStart> , 9 ) ) ptr ++ ; if ( end - ptr <= 9 <S2SV_ModEnd> ) { av_log <S2SV_ModStart> ) size *= 95 <S2SV_ModEnd> ; if ( <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ; if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> ] ) ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> + 1 ; if ( end - ptr < 1 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> { if ( end - ptr < cpp <S2SV_ModEnd> ) return AVERROR_INVALIDDATA
",FFmpeg@FFmpeg/cb243972b121b1ae6b60a78ff55a0506c69f3879,CVE-2017-9990,https://github.com/FFmpeg/FFmpeg/commit/cb243972b121b1ae6b60a78ff55a0506c69f3879,2017-06-28T06:29Z
CWE-190,"CWE-190 static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-119,"CWE-119 <S2SV_StartBug> VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { <S2SV_EndBug> <S2SV_StartBug> VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ; <S2SV_EndBug> <S2SV_StartBug> VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; <S2SV_EndBug> if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ; <S2SV_StartBug> vp9_initialize_dec ( ) ; <S2SV_EndBug> vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; <S2SV_StartBug> cm -> current_video_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> pbi -> oxcf = * oxcf ; <S2SV_EndBug> pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> pbi -> decoded_key_frame = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_dequantizer ( cm ) ; <S2SV_EndBug> vp9_loop_filter_init ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }
","<S2SV_ModStart> * vp9_decoder_create ( BufferPool * const pool <S2SV_ModEnd> ) { VP9Decoder <S2SV_ModStart> { VP9Decoder * volatile <S2SV_ModStart> ; VP9_COMMON * volatile <S2SV_ModStart> = 1 ; CHECK_MEM_ERROR ( cm , cm -> fc , ( FRAME_CONTEXT * ) vpx_calloc ( 1 , sizeof ( * cm -> fc ) ) ) ; CHECK_MEM_ERROR ( cm , cm -> frame_contexts , ( FRAME_CONTEXT * ) vpx_calloc ( FRAME_CONTEXTS , sizeof ( * cm -> frame_contexts ) ) ) ; pbi -> need_resync = 1 ; once ( initialize_dec ) ; memset <S2SV_ModEnd> ( & cm <S2SV_ModStart> ) ) ; memset ( & cm -> next_ref_frame_map , - 1 , sizeof ( cm -> next_ref_frame_map ) ) ; <S2SV_ModStart> ; pbi -> <S2SV_ModEnd> ready_for_new_data = 1 <S2SV_ModStart> ; pbi -> common . buffer_pool = pool ; cm -> bit_depth = VPX_BITS_8 ; cm -> dequant_bit_depth = VPX_BITS_8 ; cm -> alloc_mi = vp9_dec_alloc_mi ; cm -> free_mi = vp9_dec_free_mi ; cm -> setup_mi = vp9_dec_setup_mi ; vp9_loop_filter_init ( cm ) ; cm -> error . setjmp <S2SV_ModEnd> = 0 ; <S2SV_ModStart> = 0 ; vpx_get_worker_interface ( ) -> init <S2SV_ModEnd> ( & pbi
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 static int llc_ui_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddrlen , int peer ) { struct sockaddr_llc sllc ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> memset ( & sllc , 0 , sizeof ( sllc ) ) ; lock_sock ( sk ) ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> memset ( uaddr , 0 , * uaddrlen ) ; if ( peer ) { rc = - ENOTCONN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( llc -> dev ) sllc . sllc_arphrd = llc -> dev -> type ; sllc . sllc_sap = llc -> daddr . lsap ; memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ) ; } else { rc = - EINVAL ; if ( ! llc -> sap ) goto out ; sllc . sllc_sap = llc -> sap -> laddr . lsap ; if ( llc -> dev ) { sllc . sllc_arphrd = llc -> dev -> type ; memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ) ; } } rc = 0 ; sllc . sllc_family = AF_LLC ; memcpy ( uaddr , & sllc , sizeof ( sllc ) ) ; out : release_sock ( sk ) ; return rc ; }
","<S2SV_ModStart> int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> sizeof ( sllc <S2SV_ModEnd> ) ; if
",torvalds@linux/3592aaeb80290bda0f2cf0b5456c97bfc638b192,CVE-2012-6542,https://github.com/torvalds/linux/commit/3592aaeb80290bda0f2cf0b5456c97bfc638b192,2013-03-15T20:55Z
CWE-119,"CWE-119 void vp9_cyclic_refresh_update_segment ( VP9_COMP * const cpi , MB_MODE_INFO * const mbmi , int mi_row , int mi_col , <S2SV_StartBug> BLOCK_SIZE bsize , int use_rd ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; CYCLIC_REFRESH * const cr = cpi -> cyclic_refresh ; const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; const int block_index = mi_row * cm -> mi_cols + mi_col ; <S2SV_StartBug> const int refresh_this_block = candidate_refresh_aq ( cr , mbmi , bsize , use_rd ) ; <S2SV_EndBug> int new_map_value = cr -> map [ block_index ] ; int x = 0 ; int y = 0 ; <S2SV_StartBug> if ( mbmi -> segment_id > 0 && ! refresh_this_block ) <S2SV_EndBug> mbmi -> segment_id = 0 ; <S2SV_StartBug> if ( mbmi -> segment_id == 1 ) { <S2SV_EndBug> new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] == 1 ) new_map_value = 0 ; } else { new_map_value = 1 ; } for ( y = 0 ; y < ymis ; y ++ ) for ( x = 0 ; x < xmis ; x ++ ) { <S2SV_StartBug> cr -> map [ block_index + y * cm -> mi_cols + x ] = new_map_value ; <S2SV_EndBug> <S2SV_StartBug> cpi -> segmentation_map [ block_index + y * cm -> mi_cols + x ] = <S2SV_EndBug> mbmi -> segment_id ; } if ( mbmi -> segment_id ) cr -> num_seg_blocks += xmis * ymis ; }
","<S2SV_ModStart> BLOCK_SIZE bsize , int64_t rate , int64_t dist , int skip <S2SV_ModEnd> ) { const <S2SV_ModStart> , mbmi , rate , dist , bsize <S2SV_ModEnd> ) ; int <S2SV_ModStart> ; if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { mbmi -> segment_id = refresh_this_block ; if ( skip ) mbmi -> segment_id = CR_SEGMENT_ID_BASE ; } if ( cyclic_refresh_segment_id_boosted ( mbmi -> segment_id ) ) { new_map_value = - cr -> time_for_refresh ; } else if ( refresh_this_block ) { if ( cr -> map [ block_index ] <S2SV_ModEnd> == 1 ) <S2SV_ModStart> == 1 ) <S2SV_ModEnd> new_map_value = 0 <S2SV_ModStart> ++ ) { int map_offset = <S2SV_ModEnd> block_index + y <S2SV_ModStart> mi_cols + x ; cr -> map [ map_offset <S2SV_ModStart> -> segmentation_map [ map_offset ] = mbmi -> segment_id ; if ( ! is_inter_block ( mbmi ) || ! skip ) cr -> last_coded_q_map [ map_offset ] = clamp ( cm -> base_qindex + cr -> qindex_delta [ mbmi -> segment_id ] , 0 , MAXQ ) ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; <S2SV_StartBug> size_t sz = sizeof ( * info ) + size ; <S2SV_EndBug> if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
","<S2SV_ModStart> ) + size ; if ( sz < sizeof ( * info ) ) return NULL
",torvalds@linux/d157bd761585605b7882935ffb86286919f62ea1,CVE-2016-3135,https://github.com/torvalds/linux/commit/d157bd761585605b7882935ffb86286919f62ea1,2016-04-27T17:59Z
CWE-190,"CWE-190 int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
","<S2SV_ModStart> int m ; if ( n < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_gobble"" ) ; }
",mdadams@jasper/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,CVE-2016-9262,https://github.com/mdadams/jasper/commit/634ce8e8a5accc0fa05dd2c20d42b4749d4b2735,2017-03-23T18:59Z
CWE-125,"CWE-125 struct r_bin_dyldcache_lib_t * r_bin_dyldcache_extract ( struct r_bin_dyldcache_obj_t * bin , int idx , int * nlib ) { ut64 liboff , linkedit_offset ; ut64 dyld_vmbase ; ut32 addend = 0 ; struct r_bin_dyldcache_lib_t * ret = NULL ; struct dyld_cache_image_info * image_infos = NULL ; struct mach_header * mh ; ut8 * data , * cmdptr ; int cmd , libsz = 0 ; RBuffer * dbuf ; char * libname ; if ( ! bin ) { return NULL ; } if ( bin -> size < 1 ) { eprintf ( ""Empty<S2SV_blank>file?<S2SV_blank>(%s)\\n"" , bin -> file ? bin -> file : ""(null)"" ) ; return NULL ; } if ( bin -> nlibs < 0 || idx < 0 || idx >= bin -> nlibs ) { return NULL ; } * nlib = bin -> nlibs ; ret = R_NEW0 ( struct r_bin_dyldcache_lib_t ) ; if ( ! ret ) { <S2SV_StartBug> perror ( ""malloc<S2SV_blank>(ret)"" ) ; <S2SV_EndBug> return NULL ; } if ( bin -> hdr . startaddr > bin -> size ) { eprintf ( ""corrupted<S2SV_blank>dyldcache"" ) ; free ( ret ) ; return NULL ; } if ( bin -> hdr . startaddr > bin -> size || bin -> hdr . baseaddroff > bin -> size ) { eprintf ( ""corrupted<S2SV_blank>dyldcache"" ) ; free ( ret ) ; return NULL ; } <S2SV_StartBug> image_infos = ( struct dyld_cache_image_info * ) ( bin -> b -> buf + bin -> hdr . startaddr ) ; <S2SV_EndBug> <S2SV_StartBug> dyld_vmbase = * ( ut64 * ) ( bin -> b -> buf + bin -> hdr . baseaddroff ) ; <S2SV_EndBug> liboff = image_infos [ idx ] . address - dyld_vmbase ; if ( liboff > bin -> size ) { eprintf ( ""Corrupted<S2SV_blank>file\\n"" ) ; free ( ret ) ; return NULL ; } ret -> offset = liboff ; <S2SV_StartBug> if ( image_infos [ idx ] . pathFileOffset > bin -> size ) { <S2SV_EndBug> <S2SV_StartBug> eprintf ( ""corrupted<S2SV_blank>file\\n"" ) ; <S2SV_EndBug> free ( ret ) ; return NULL ; } <S2SV_StartBug> libname = ( char * ) ( bin -> b -> buf + image_infos [ idx ] . pathFileOffset ) ; <S2SV_EndBug> data = bin -> b -> buf + liboff ; mh = ( struct mach_header * ) data ; if ( mh -> magic != MH_MAGIC && mh -> magic != MH_MAGIC_64 ) { if ( mh -> magic == 0xbebafeca ) { eprintf ( ""FAT<S2SV_blank>Binary\\n"" ) ; } eprintf ( ""Not<S2SV_blank>mach-o\\n"" ) ; free ( ret ) ; return NULL ; } if ( ! ( dbuf = r_buf_new ( ) ) ) { eprintf ( ""new<S2SV_blank>(dbuf)\\n"" ) ; free ( ret ) ; return NULL ; } addend = mh -> magic == MH_MAGIC ? sizeof ( struct mach_header ) : sizeof ( struct mach_header_64 ) ; r_buf_set_bytes ( dbuf , data , addend ) ; cmdptr = data + addend ; for ( cmd = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; r_buf_append_bytes ( dbuf , ( ut8 * ) lc , lc -> cmdsize ) ; cmdptr += lc -> cmdsize ; } cmdptr = data + addend ; for ( cmd = linkedit_offset = 0 ; cmd < mh -> ncmds ; cmd ++ ) { struct load_command * lc = ( struct load_command * ) cmdptr ; cmdptr += lc -> cmdsize ; switch ( lc -> cmd ) { case LC_SEGMENT : { struct segment_command * seg = ( struct segment_command * ) lc ; int t = seg -> filesize ; if ( seg -> fileoff + seg -> filesize > bin -> size || seg -> fileoff > bin -> size ) { eprintf ( ""malformed<S2SV_blank>dyldcache\\n"" ) ; free ( ret ) ; r_buf_free ( dbuf ) ; return NULL ; } r_buf_append_bytes ( dbuf , bin -> b -> buf + seg -> fileoff , t ) ; r_bin_dyldcache_apply_patch ( dbuf , dbuf -> length , ( ut64 ) ( ( size_t ) & seg -> fileoff - ( size_t ) data ) ) ; int sect_offset = seg -> fileoff - libsz ; libsz = dbuf -> length ; if ( ! strcmp ( seg -> segname , ""__LINKEDIT"" ) ) { linkedit_offset = sect_offset ; } if ( seg -> nsects > 0 ) { struct section * sects = ( struct section * ) ( ( ut8 * ) seg + sizeof ( struct segment_command ) ) ; int nsect ; for ( nsect = 0 ; nsect < seg -> nsects ; nsect ++ ) { if ( sects [ nsect ] . offset > libsz ) { r_bin_dyldcache_apply_patch ( dbuf , sects [ nsect ] . offset - sect_offset , ( ut64 ) ( ( size_t ) & sects [ nsect ] . offset - ( size_t ) data ) ) ; } } } } break ; case LC_SYMTAB : { struct symtab_command * st = ( struct symtab_command * ) lc ; NZ_OFFSET ( st -> symoff ) ; NZ_OFFSET ( st -> stroff ) ; } break ; case LC_DYSYMTAB : { struct dysymtab_command * st = ( struct dysymtab_command * ) lc ; NZ_OFFSET ( st -> tocoff ) ; NZ_OFFSET ( st -> modtaboff ) ; NZ_OFFSET ( st -> extrefsymoff ) ; NZ_OFFSET ( st -> indirectsymoff ) ; NZ_OFFSET ( st -> extreloff ) ; NZ_OFFSET ( st -> locreloff ) ; } break ; case LC_DYLD_INFO : case LC_DYLD_INFO_ONLY : { struct dyld_info_command * st = ( struct dyld_info_command * ) lc ; NZ_OFFSET ( st -> rebase_off ) ; NZ_OFFSET ( st -> bind_off ) ; NZ_OFFSET ( st -> weak_bind_off ) ; NZ_OFFSET ( st -> lazy_bind_off ) ; NZ_OFFSET ( st -> export_off ) ; } break ; } } ret -> b = dbuf ; strncpy ( ret -> path , libname , sizeof ( ret -> path ) - 1 ) ; ret -> size = libsz ; return ret ; }
","<S2SV_ModStart> ret ) { <S2SV_ModEnd> return NULL ; <S2SV_ModStart> NULL ; } int sz = bin -> nlibs * sizeof ( struct dyld_cache_image_info ) ; image_infos = malloc ( sz ) ; if ( ! image_infos ) { free ( ret ) ; return NULL ; } r_buf_read_at <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> hdr . startaddr , ( ut8 * ) image_infos , sz <S2SV_ModStart> ; dyld_vmbase = r_buf_read64le <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , <S2SV_ModEnd> bin -> hdr <S2SV_ModStart> = liboff ; int pfo = <S2SV_ModEnd> image_infos [ idx <S2SV_ModStart> ] . pathFileOffset ; if ( pfo < 0 || pfo <S2SV_ModStart> { eprintf ( ""corrupted<S2SV_blank>file:<S2SV_blank>pathFileOffset<S2SV_blank>><S2SV_blank>bin->size<S2SV_blank>(%d)\\n"" , pfo <S2SV_ModEnd> ) ; free <S2SV_ModStart> } libname = r_buf_read_string <S2SV_ModEnd> ( bin -> <S2SV_ModStart> bin -> b , pfo , 64 <S2SV_ModEnd> ) ; data
",radareorg@radare2/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19,CVE-2018-20458,https://github.com/radareorg/radare2/commit/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19,2018-12-25T19:29Z
CWE-20,"CWE-20 void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; <S2SV_StartBug> * dptr ++ = 0xAA ; <S2SV_EndBug> memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * dptr ++ = 0 ; break ; case ROSE_CLEAR_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = rose -> cause ; * dptr ++ = rose -> diagnostic ; break ; case ROSE_RESET_REQUEST : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = ROSE_DTE_ORIGINATED ; * dptr ++ = 0 ; break ; case ROSE_RR : case ROSE_RNR : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr = frametype ; * dptr ++ |= ( rose -> vr << 5 ) & 0xE0 ; break ; case ROSE_CLEAR_CONFIRMATION : case ROSE_RESET_CONFIRMATION : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; break ; default : printk ( KERN_ERR ""ROSE:<S2SV_blank>rose_write_internal<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>frametype<S2SV_blank>%02X\\n"" , frametype ) ; kfree_skb ( skb ) ; return ; } rose_transmit_link ( skb , rose -> neighbour ) ; }
","<S2SV_ModStart> dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL <S2SV_ModEnd> ; memcpy (
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z
CWE-190,"CWE-190 static int bson_validate_string ( bson * b , const unsigned char * string , <S2SV_StartBug> const int length , const char check_utf8 , const char check_dot , <S2SV_EndBug> const char check_dollar ) { <S2SV_StartBug> int position = 0 ; <S2SV_EndBug> int sequence_length = 1 ; if ( check_dollar && string [ 0 ] == '$' ) { if ( ! bson_string_is_db_ref ( string , length ) ) b -> err |= BSON_FIELD_INIT_DOLLAR ; } while ( position < length ) { if ( check_dot && * ( string + position ) == '.' ) { b -> err |= BSON_FIELD_HAS_DOT ; } if ( check_utf8 ) { sequence_length = trailingBytesForUTF8 [ * ( string + position ) ] + 1 ; if ( ( position + sequence_length ) > length ) { b -> err |= BSON_NOT_UTF8 ; return BSON_ERROR ; } if ( ! isLegalUTF8 ( string + position , sequence_length ) ) { b -> err |= BSON_NOT_UTF8 ; return BSON_ERROR ; } } position += sequence_length ; } return BSON_OK ; }
","<S2SV_ModStart> string , const size_t <S2SV_ModEnd> length , const <S2SV_ModStart> check_dollar ) { size_t <S2SV_ModEnd> position = 0
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-119,"CWE-119 void vp9_loop_filter_init ( VP9_COMMON * cm ) { loop_filter_info_n * lfi = & cm -> lf_info ; struct loopfilter * lf = & cm -> lf ; int lvl ; update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . hev_thr , ( lvl >> 4 ) , SIMD_WIDTH ) ; <S2SV_EndBug> }
","<S2SV_ModStart> lvl ++ ) memset <S2SV_ModEnd> ( lfi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-74,"CWE-74 int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK"" , CASE_IGNORE ) ) { if ( ! mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY"" , CASE_IGNORE ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { <S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_str_startswith ( adata -> buf , ""*<S2SV_blank>PREAUTH"" , CASE_IGNORE ) ) { # ifdef USE_SSL if ( adata -> conn -> ssf == 0 ) { bool proceed = true ; if ( C_SslForceTls ) { proceed = false ; } else if ( C_SslStarttls != MUTT_NO ) { proceed = mutt_yesorno ( _ ( ""Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?"" ) , C_SslStarttls ) != MUTT_NO ; } if ( ! proceed ) { mutt_error ( _ ( ""Encrypted<S2SV_blank>connection<S2SV_blank>unavailable"" ) ) ; goto err_close_conn ; } } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( ""imap_open_connection()"" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
","<S2SV_ModStart> , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn <S2SV_ModEnd> ) ; if
",neomutt@neomutt/fb013ec666759cb8a9e294347c7b4c1f597639cc,CVE-2020-14954,https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc,2020-06-21T17:15Z
CWE-287,"CWE-287 static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""auth<S2SV_blank>request<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(mechanism=%s)"" , mech ) ; <S2SV_StartBug> if ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) { <S2SV_EndBug> _sx_debug ( ZONE , ""client<S2SV_blank>requested<S2SV_blank>mechanism<S2SV_blank>(%s)<S2SV_blank>that<S2SV_blank>we<S2SV_blank>didn\'t<S2SV_blank>offer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_start<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( sd ) ; if ( sctx != NULL ) free ( sctx ) ; sctx = ( _sx_sasl_sess_t ) calloc ( 1 , sizeof ( struct _sx_sasl_sess_st ) ) ; sctx -> s = s ; sctx -> ctx = ctx ; gsasl_session_hook_set ( sd , ( void * ) sctx ) ; gsasl_property_set ( sd , GSASL_SERVICE , ctx -> appname ) ; gsasl_property_set ( sd , GSASL_REALM , realm ) ; hostname [ 0 ] = '\\0' ; gethostname ( hostname , 256 ) ; hostname [ 255 ] = '\\0' ; gsasl_property_set ( sd , GSASL_HOSTNAME , hostname ) ; ext_id = NULL ; # ifdef HAVE_SSL for ( i = 0 ; i < s -> env -> nplugins ; i ++ ) if ( s -> env -> plugins [ i ] -> magic == SX_SSL_MAGIC && s -> plugin_data [ s -> env -> plugins [ i ] -> index ] != NULL ) ext_id = ( ( _sx_ssl_conn_t ) s -> plugin_data [ s -> env -> plugins [ i ] -> index ] ) -> external_id ; if ( ext_id != NULL ) { for ( i = 0 ; i < SX_CONN_EXTERNAL_ID_MAX_COUNT ; i ++ ) if ( ext_id [ i ] != NULL ) { ctx -> ext_id [ i ] = strdup ( ext_id [ i ] ) ; } else { ctx -> ext_id [ i ] = NULL ; break ; } } # endif _sx_debug ( ZONE , ""sasl<S2SV_blank>context<S2SV_blank>initialised<S2SV_blank>for<S2SV_blank>%d"" , s -> tag ) ; s -> plugin_data [ p -> index ] = ( void * ) sd ; if ( strcmp ( mech , ""ANONYMOUS"" ) == 0 ) { ( ctx -> cb ) ( sx_sasl_cb_GEN_AUTHZID , NULL , ( void * * ) & out , s , ctx -> cbarg ) ; buf = strdup ( out ) ; buflen = strlen ( buf ) ; } else if ( strstr ( in , ""<"" ) != NULL && strncmp ( in , ""="" , strstr ( in , ""<"" ) - in ) == 0 ) { _sx_debug ( ZONE , ""gsasl<S2SV_blank>auth<S2SV_blank>string<S2SV_blank>is<S2SV_blank>empty"" ) ; buf = strdup ( """" ) ; buflen = strlen ( buf ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } } ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } else { ret = gsasl_base64_from ( in , inlen , & buf , & buflen ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_base64_from<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; return ; } if ( ! sd ) { _sx_debug ( ZONE , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_MECH_TOO_WEAK , ""response<S2SV_blank>send<S2SV_blank>before<S2SV_blank>auth<S2SV_blank>request<S2SV_blank>enabling<S2SV_blank>mechanism"" ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; return ; } _sx_debug ( ZONE , ""response<S2SV_blank>from<S2SV_blank>client<S2SV_blank>(decoded:<S2SV_blank>%.*s)"" , buflen , buf ) ; ret = gsasl_step ( sd , buf , buflen , & out , & outlen ) ; } if ( buf != NULL ) free ( buf ) ; if ( ret == GSASL_OK ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>completed"" ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_success ( s , buf , buflen ) , 0 ) ; free ( buf ) ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify = _sx_sasl_notify_success ; ( ( sx_buf_t ) s -> wbufq -> front -> data ) -> notify_arg = ( void * ) p ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( ret == GSASL_NEEDS_MORE ) { _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>in<S2SV_blank>progress<S2SV_blank>(challenge:<S2SV_blank>%.*s)"" , outlen , out ) ; ret = gsasl_base64_to ( out , outlen , & buf , & buflen ) ; if ( ret == GSASL_OK ) { _sx_nad_write ( s , _sx_sasl_challenge ( s , buf , buflen ) , 0 ) ; free ( buf ) ; } else { _sx_debug ( ZONE , ""gsasl_base64_to<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>sasl<S2SV_blank>for<S2SV_blank>this<S2SV_blank>conn;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INCORRECT_ENCODING , gsasl_strerror ( ret ) ) , 0 ) ; if ( buf != NULL ) free ( buf ) ; } if ( out != NULL ) free ( out ) ; return ; } if ( out != NULL ) free ( out ) ; _sx_debug ( ZONE , ""sasl<S2SV_blank>handshake<S2SV_blank>failed;<S2SV_blank>(%d):<S2SV_blank>%s"" , ret , gsasl_strerror ( ret ) ) ; switch ( ret ) { case GSASL_AUTHENTICATION_ERROR : case GSASL_NO_ANONYMOUS_TOKEN : case GSASL_NO_AUTHID : case GSASL_NO_AUTHZID : case GSASL_NO_PASSWORD : case GSASL_NO_PASSCODE : case GSASL_NO_PIN : case GSASL_NO_SERVICE : case GSASL_NO_HOSTNAME : out = _sasl_err_NOT_AUTHORIZED ; break ; case GSASL_UNKNOWN_MECHANISM : case GSASL_MECHANISM_PARSE_ERROR : out = _sasl_err_INVALID_MECHANISM ; break ; case GSASL_BASE64_ERROR : out = _sasl_err_INCORRECT_ENCODING ; break ; default : out = _sasl_err_MALFORMED_REQUEST ; } _sx_nad_write ( s , _sx_sasl_failure ( s , out , gsasl_strerror ( ret ) ) , 0 ) ; }
","<S2SV_ModStart> , mech ) || ( ctx -> cb ) ( sx_sasl_cb_CHECK_MECH , ( void * ) mech , NULL , s , ctx -> cbarg ) != sx_sasl_ret_OK
",jabberd2@jabberd2/8416ae54ecefa670534f27a31db71d048b9c7f16,CVE-2017-10807,https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16,2017-07-04T15:29Z
CWE-252,"CWE-252 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
",ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z
CWE-119,"CWE-119 static vpx_codec_err_t image2yuvconfig ( const vpx_image_t * img , YV12_BUFFER_CONFIG * yv12 ) { <S2SV_StartBug> vpx_codec_err_t res = VPX_CODEC_OK ; <S2SV_EndBug> yv12 -> y_buffer = img -> planes [ VPX_PLANE_Y ] ; yv12 -> u_buffer = img -> planes [ VPX_PLANE_U ] ; yv12 -> v_buffer = img -> planes [ VPX_PLANE_V ] ; <S2SV_StartBug> yv12 -> y_crop_width = img -> d_w ; <S2SV_EndBug> yv12 -> y_crop_height = img -> d_h ; yv12 -> y_width = img -> d_w ; yv12 -> y_height = img -> d_h ; yv12 -> uv_width = yv12 -> y_width / 2 ; <S2SV_StartBug> yv12 -> uv_height = yv12 -> y_height / 2 ; <S2SV_EndBug> yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - img -> d_w ) / 2 ; return res ; }
","<S2SV_ModStart> yv12 ) { const int y_w = img -> d_w ; const int y_h = img -> d_h ; const int uv_w = ( img -> d_w + 1 ) / 2 ; const int uv_h = ( img -> d_h + 1 ) / 2 ; <S2SV_ModStart> -> y_crop_width = y_w ; yv12 -> y_crop_height = y_h ; yv12 -> y_width = y_w ; yv12 -> y_height = y_h ; yv12 -> uv_crop_width = uv_w ; yv12 -> uv_crop_height = uv_h ; yv12 -> uv_width = uv_w ; yv12 -> uv_height = uv_h ; yv12 -> y_stride = img -> stride [ VPX_PLANE_Y ] ; yv12 -> uv_stride = img -> stride [ VPX_PLANE_U ] ; yv12 -> border = ( img -> stride [ VPX_PLANE_Y ] - <S2SV_ModStart> img -> d_w ) <S2SV_ModEnd> / 2 ; <S2SV_ModStart> / 2 ; <S2SV_ModEnd> return res ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-269,"CWE-269 static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; <S2SV_StartBug> } <S2SV_EndBug> } free ( fname ) ; } else { if ( asprintf ( & fname , ""%s/.bashrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.bashrc"" , & s ) == 0 ) { <S2SV_StartBug> if ( copy_file ( ""/etc/skel/.bashrc"" , fname , u , g , 0644 ) == 0 ) { <S2SV_EndBug> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( fname ) ; } }
","<S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.zshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.zshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.cshrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.cshrc"" <S2SV_ModStart> ) ; } else { touch_file_as_user ( fname , u , g , 0644 <S2SV_ModEnd> ) ; fs_logger2 <S2SV_ModStart> fname ) ; <S2SV_ModEnd> } free ( <S2SV_ModStart> 0 ) { <S2SV_ModEnd> copy_file ( ""/etc/skel/.bashrc"" <S2SV_ModStart> , 0644 ) ; <S2SV_ModEnd> fs_logger ( ""clone<S2SV_blank>/etc/skel/.bashrc"" <S2SV_ModStart> ) ; } <S2SV_ModEnd> free ( fname
",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z
CWE-369,"CWE-369 static int mov_write_audio_tag ( AVFormatContext * s , AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track ) { int64_t pos = avio_tell ( pb ) ; int version = 0 ; uint32_t tag = track -> tag ; if ( track -> mode == MODE_MOV ) { <S2SV_StartBug> if ( track -> timescale > UINT16_MAX ) { <S2SV_EndBug> if ( mov_get_lpcm_flags ( track -> par -> codec_id ) ) tag = AV_RL32 ( ""lpcm"" ) ; version = 2 ; } else if ( track -> audio_vbr || mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 ) { version = 1 ; } } avio_wb32 ( pb , 0 ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ffio_wfourcc ( pb , ""enca"" ) ; } else { avio_wl32 ( pb , tag ) ; } avio_wb32 ( pb , 0 ) ; avio_wb16 ( pb , 0 ) ; avio_wb16 ( pb , 1 ) ; avio_wb16 ( pb , version ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( version == 2 ) { avio_wb16 ( pb , 3 ) ; avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , 0xfffe ) ; avio_wb16 ( pb , 0 ) ; avio_wb32 ( pb , 0x00010000 ) ; avio_wb32 ( pb , 72 ) ; avio_wb64 ( pb , av_double2int ( track -> par -> sample_rate ) ) ; avio_wb32 ( pb , track -> par -> channels ) ; avio_wb32 ( pb , 0x7F000000 ) ; avio_wb32 ( pb , av_get_bits_per_sample ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , mov_get_lpcm_flags ( track -> par -> codec_id ) ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , get_samples_per_packet ( track ) ) ; } else { if ( track -> mode == MODE_MOV ) { avio_wb16 ( pb , track -> par -> channels ) ; if ( track -> par -> codec_id == AV_CODEC_ID_PCM_U8 || track -> par -> codec_id == AV_CODEC_ID_PCM_S8 ) avio_wb16 ( pb , 8 ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ADPCM_G726 ) avio_wb16 ( pb , track -> par -> bits_per_coded_sample ) ; else avio_wb16 ( pb , 16 ) ; avio_wb16 ( pb , track -> audio_vbr ? - 2 : 0 ) ; } else { if ( track -> par -> codec_id == AV_CODEC_ID_FLAC || track -> par -> codec_id == AV_CODEC_ID_OPUS ) { avio_wb16 ( pb , track -> par -> channels ) ; } else { avio_wb16 ( pb , 2 ) ; } if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) { avio_wb16 ( pb , track -> par -> bits_per_raw_sample ) ; } else { avio_wb16 ( pb , 16 ) ; } avio_wb16 ( pb , 0 ) ; } avio_wb16 ( pb , 0 ) ; if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) avio_wb16 ( pb , 48000 ) ; else avio_wb16 ( pb , track -> par -> sample_rate <= UINT16_MAX ? track -> par -> sample_rate : 0 ) ; avio_wb16 ( pb , 0 ) ; } if ( version == 1 ) { if ( mov_pcm_le_gt16 ( track -> par -> codec_id ) || mov_pcm_be_gt16 ( track -> par -> codec_id ) ) avio_wb32 ( pb , 1 ) ; else avio_wb32 ( pb , track -> par -> frame_size ) ; avio_wb32 ( pb , track -> sample_size / track -> par -> channels ) ; avio_wb32 ( pb , track -> sample_size ) ; avio_wb32 ( pb , 2 ) ; } if ( track -> mode == MODE_MOV && ( track -> par -> codec_id == AV_CODEC_ID_AAC || track -> par -> codec_id == AV_CODEC_ID_AC3 || track -> par -> codec_id == AV_CODEC_ID_EAC3 || track -> par -> codec_id == AV_CODEC_ID_AMR_NB || track -> par -> codec_id == AV_CODEC_ID_ALAC || track -> par -> codec_id == AV_CODEC_ID_ADPCM_MS || track -> par -> codec_id == AV_CODEC_ID_ADPCM_IMA_WAV || track -> par -> codec_id == AV_CODEC_ID_QDM2 || ( mov_pcm_le_gt16 ( track -> par -> codec_id ) && version == 1 ) || ( mov_pcm_be_gt16 ( track -> par -> codec_id ) && version == 1 ) ) ) mov_write_wave_tag ( s , pb , track ) ; else if ( track -> tag == MKTAG ( 'm' , 'p' , '4' , 'a' ) ) mov_write_esds_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AMR_NB ) mov_write_amr_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_AC3 ) mov_write_ac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_EAC3 ) mov_write_eac3_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_ALAC ) mov_write_extradata_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_WMAPRO ) mov_write_wfex_tag ( s , pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_FLAC ) mov_write_dfla_tag ( pb , track ) ; else if ( track -> par -> codec_id == AV_CODEC_ID_OPUS ) mov_write_dops_tag ( pb , track ) ; else if ( track -> vos_len > 0 ) mov_write_glbl_tag ( pb , track ) ; if ( track -> mode == MODE_MOV && track -> par -> codec_type == AVMEDIA_TYPE_AUDIO ) mov_write_chan_tag ( s , pb , track ) ; if ( mov -> encryption_scheme != MOV_ENC_NONE ) { ff_mov_cenc_write_sinf_tag ( track , pb , mov -> encryption_kid ) ; } return update_size ( pb , pos ) ; }
","<S2SV_ModStart> timescale > UINT16_MAX || ! track -> par -> channels
",FFmpeg@FFmpeg/fa19fbcf712a6a6cc5a5cfdc3254a97b9bce6582,CVE-2018-14395,https://github.com/FFmpeg/FFmpeg/commit/fa19fbcf712a6a6cc5a5cfdc3254a97b9bce6582,2018-07-19T05:29Z
CWE-264,"CWE-264 <S2SV_StartBug> int lsm_set_label_at ( int procfd , int on_exec , char * lsm_label ) { <S2SV_EndBug> <S2SV_StartBug> int labelfd = - 1 ; <S2SV_EndBug> int ret = 0 ; const char * name ; char * command = NULL ; name = lsm_name ( ) ; if ( strcmp ( name , ""nop"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""none"" ) == 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ; <S2SV_StartBug> if ( on_exec ) { <S2SV_EndBug> labelfd = openat ( procfd , ""self/attr/exec"" , O_RDWR ) ; } else { labelfd = openat ( procfd , ""self/attr/current"" , O_RDWR ) ; } if ( labelfd < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } if ( strcmp ( name , ""AppArmor"" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( ""changeprofile<S2SV_blank>"" ) + 1 ) ; if ( ! command ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } size = sprintf ( command , ""changeprofile<S2SV_blank>%s"" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( write ( labelfd , command , size + 1 ) < 0 ) { <S2SV_EndBug> <S2SV_StartBug> SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; <S2SV_EndBug> <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; ret = - 1 ; goto out ; } } else { ERROR ( ""Unable<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>label<S2SV_blank>for<S2SV_blank>unknown<S2SV_blank>LSM:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> ret = - 1 ; <S2SV_EndBug> goto out ; } out : free ( command ) ; <S2SV_StartBug> if ( labelfd != - 1 ) <S2SV_EndBug> <S2SV_StartBug> close ( labelfd ) ; <S2SV_EndBug> <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> lsm_set_label_at ( int lsm_labelfd <S2SV_ModEnd> , int on_exec <S2SV_ModStart> * lsm_label ) { int fret <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 <S2SV_ModEnd> ; const char <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> == 0 ) return 0 <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( strcmp <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>apparmor<S2SV_blank>profile"" ) ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> ( write ( lsm_labelfd <S2SV_ModEnd> , command , <S2SV_ModStart> { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label:<S2SV_blank>%s."" , command ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , command ) ; } else if ( strcmp ( name , ""SELinux"" ) == 0 ) { if ( write ( lsm_labelfd , lsm_label , strlen ( lsm_label ) + 1 ) < 0 ) { SYSERROR ( <S2SV_ModStart> ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>LSM<S2SV_blank>label"" ) ; goto out ; } INFO ( ""Set<S2SV_blank>LSM<S2SV_blank>label<S2SV_blank>to:<S2SV_blank>%s."" , lsm_label ) ; } else <S2SV_ModEnd> { ERROR ( <S2SV_ModStart> name ) ; goto out ; } fret = 0 ; <S2SV_ModEnd> out : free <S2SV_ModStart> ; if ( lsm_labelfd <S2SV_ModEnd> != - 1 <S2SV_ModStart> ) close ( lsm_labelfd <S2SV_ModEnd> ) ; return <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
",lxc@lxc/81f466d05f2a89cb4f122ef7f593ff3f279b165c,CVE-2016-8649,https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c,2017-05-01T06:59Z
CWE-416,"CWE-416 static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }
","<S2SV_ModStart> } else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
",torvalds@linux/8fde12ca79aff9b5ba951fce1a2641901b8d8e64,CVE-2019-11487,https://github.com/torvalds/linux/commit/8fde12ca79aff9b5ba951fce1a2641901b8d8e64,2019-04-23T22:29Z
CWE-284,"CWE-284 static int accept_server_socket ( int sfd ) { struct sockaddr_un remote ; struct pollfd pfd ; int fd ; socklen_t len = sizeof ( struct sockaddr_un ) ; BTIF_TRACE_EVENT ( ""accept<S2SV_blank>fd<S2SV_blank>%d"" , sfd ) ; pfd . fd = sfd ; pfd . events = POLLIN ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 0 ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( ""accept<S2SV_blank>poll<S2SV_blank>timeout"" ) ; return - 1 ; } <S2SV_StartBug> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>accept<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; return - 1 ; } return fd ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 0 ) <S2SV_ModStart> ( fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & len )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-125,"CWE-125 void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; <S2SV_StartBug> * ptr = ( char ) ( ( existing & ~ ( mask << bitIdx ) ) | ( ( col & mask ) << bitIdx ) ) ; <S2SV_EndBug> if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
","<S2SV_ModStart> : idx ; assert ( ptr >= gfx -> backendData && ptr < ( ( char * ) gfx -> backendData + graphicsGetMemoryRequired ( gfx ) ) ) ;
",espruino@Espruino/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,CVE-2018-11592,https://github.com/espruino/Espruino/commit/8a44b04b584b3d3ab1cb68fed410f7ecb165e50e,2018-05-31T16:29Z
CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_replace_fw __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_replace_fw karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int newFwSize ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_replace_fw ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_replace_fw<S2SV_blank>called.\\n"" , ioc -> name ) ) ; if ( ioc -> cached_fw == NULL ) return 0 ; mpt_free_fw_memory ( ioc ) ; newFwSize = ALIGN ( karg . newImageSize , 4 ) ; mpt_alloc_fw_memory ( ioc , newFwSize ) ; if ( ioc -> cached_fw == NULL ) return - ENOMEM ; if ( copy_from_user ( ioc -> cached_fw , uarg -> newImage , newFwSize ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>image<S2SV_blank>"" ""@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; mpt_free_fw_memory ( ioc ) ; return - EFAULT ; } ioc -> facts . FWImageSize = newFwSize ; return 0 ; }
","<S2SV_ModStart> int mptctl_replace_fw ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_replace_fw karg ; <S2SV_ModEnd> int newFwSize ; <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-119,"CWE-119 static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""<S2SV_blank>pts:%s<S2SV_blank>pts_time:%s<S2SV_blank>pos:%"" PRId64 ""<S2SV_blank>"" ""fmt:%s<S2SV_blank>sar:%d/%d<S2SV_blank>s:%dx%d<S2SV_blank>i:%c<S2SV_blank>iskey:%d<S2SV_blank>type:%c<S2SV_blank>"" ""checksum:%08X<S2SV_blank>plane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type_char ( frame -> pict_type ) , checksum , plane_checksum [ 0 ] ) ; <S2SV_StartBug> for ( plane = 1 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) <S2SV_EndBug> av_log ( ctx , AV_LOG_INFO , ""<S2SV_blank>%08X"" , plane_checksum [ plane ] ) ; av_log ( ctx , AV_LOG_INFO , ""]\\n"" ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , frame ) ; }
","<S2SV_ModStart> frame -> data [ plane ] && frame -> linesize <S2SV_ModStart> [ plane ] && frame -> linesize [ plane ]
",FFmpeg@FFmpeg/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,CVE-2013-4263,https://github.com/FFmpeg/FFmpeg/commit/e43a0a232dbf6d3c161823c2e07c52e76227a1bc,2013-11-23T17:55Z
CWE-20,"CWE-20 EXPORTED const char * dlist_reserve_path ( const char * part , int isarchive , const struct message_guid * guid ) { static char buf [ MAX_MAILBOX_PATH ] ; <S2SV_StartBug> const char * base ; <S2SV_EndBug> if ( strchr ( part , '/' ) ) { base = part ; } else { base = isarchive ? config_archivepartitiondir ( part ) : config_partitiondir ( part ) ; <S2SV_StartBug> } <S2SV_EndBug> assert ( base != NULL ) ; snprintf ( buf , MAX_MAILBOX_PATH , ""%s/sync./%lu/%s"" , base , ( unsigned long ) getpid ( ) , message_guid_encode ( guid ) ) ; if ( cyrus_mkdir ( buf , 0755 ) ) { syslog ( LOG_ERR , ""IOERROR:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%s/sync./%lu/<S2SV_blank>for<S2SV_blank>reserve:<S2SV_blank>%m"" , base , ( unsigned long ) getpid ( ) ) ; } return buf ; }
","<S2SV_ModStart> char * base <S2SV_ModEnd> = isarchive ? <S2SV_ModStart> part ) ; <S2SV_ModEnd> assert ( base
",cyrusimap@cyrus-imapd/5edadcfb83bf27107578830801817f9e6d0ad941,CVE-2017-12843,https://github.com/cyrusimap/cyrus-imapd/commit/5edadcfb83bf27107578830801817f9e6d0ad941,2017-08-22T14:29Z
CWE-125,"CWE-125 static int print_prefix ( netdissect_options * ndo , const u_char * prefix , u_int max_length ) { int plenbytes ; char buf [ sizeof ( ""xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128"" ) ] ; if ( prefix [ 0 ] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address ( & prefix [ 1 ] ) ) { struct in_addr addr ; u_int plen ; plen = prefix [ 0 ] - 96 ; if ( 32 < plen ) return - 1 ; max_length -= 1 ; memset ( & addr , 0 , sizeof ( addr ) ) ; plenbytes = ( plen + 7 ) / 8 ; if ( max_length < ( u_int ) plenbytes + IPV4_MAPPED_HEADING_LEN ) return - 3 ; memcpy ( & addr , & prefix [ 1 + IPV4_MAPPED_HEADING_LEN ] , plenbytes ) ; if ( plen % 8 ) { ( ( u_char * ) & addr ) [ plenbytes - 1 ] &= ( ( 0xff00 >> ( plen % 8 ) ) & 0xff ) ; } snprintf ( buf , sizeof ( buf ) , ""%s/%d"" , ipaddr_string ( ndo , & addr ) , plen ) ; plenbytes += 1 + IPV4_MAPPED_HEADING_LEN ; } else { plenbytes = decode_prefix6 ( ndo , prefix , max_length , buf , sizeof ( buf ) ) ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , buf ) ) ; return plenbytes ; }
","<S2SV_ModStart> ) ) ; if ( plenbytes < 0 ) return plenbytes ;
",the-tcpdump-group@tcpdump/83a412a5275cac973c5841eca3511c766bed778d,CVE-2018-16228,https://github.com/the-tcpdump-group/tcpdump/commit/83a412a5275cac973c5841eca3511c766bed778d,2019-10-03T16:15Z
CWE-119,"CWE-119 static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char buf [ EXT2_BLOCK_SIZE ( data ) ] ; <S2SV_EndBug> # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { <S2SV_StartBug> grub_error ( GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; <S2SV_EndBug> return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; <S2SV_StartBug> if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> else <S2SV_EndBug> { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; <S2SV_StartBug> return fileblock + start ; <S2SV_EndBug> } } else { grub_error ( GRUB_ERR_BAD_FS , ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> } if ( fileblock < INDIRECT_BLOCKS ) { blknr = grub_le_to_cpu32 ( inode -> blocks . dir_blocks [ fileblock ] ) ; } else if ( fileblock < INDIRECT_BLOCKS + blksz / 4 ) { grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ fileblock - INDIRECT_BLOCKS ] ) ; grub_free ( indir ) ; } else if ( fileblock < ( grub_disk_addr_t ) ( INDIRECT_BLOCKS + blksz / 4 ) * ( grub_disk_addr_t ) ( blksz / 4 + 1 ) ) { unsigned int perblock = blksz / 4 ; unsigned int rblock = fileblock - ( INDIRECT_BLOCKS + blksz / 4 ) ; grub_uint32_t * indir ; indir = grub_malloc ( blksz ) ; <S2SV_StartBug> if ( ! indir ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( inode -> blocks . double_indir_block ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> if ( grub_disk_read ( data -> disk , ( ( grub_disk_addr_t ) grub_le_to_cpu32 ( indir [ rblock / perblock ] ) ) << log2_blksz , <S2SV_StartBug> 0 , blksz , indir ) ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> blknr = grub_le_to_cpu32 ( indir [ rblock % perblock ] ) ; grub_free ( indir ) ; } else { grub_error ( GRUB_ERR_NOT_IMPLEMENTED_YET , ""ext2fs<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>triple<S2SV_blank>indirect<S2SV_blank>blocks"" ) ; } return blknr ; }
","<S2SV_ModStart> EXT4_EXTENTS_FLAG ) { char * buf = grub_malloc ( <S2SV_ModEnd> EXT2_BLOCK_SIZE ( data <S2SV_ModStart> ( data ) ) ; if ( ! buf ) { return - 1 ; } <S2SV_ModEnd> struct grub_ext4_extent_header * <S2SV_ModStart> GRUB_ERR_BAD_FS , ""invalid<S2SV_blank>extent"" ) ; free ( buf <S2SV_ModStart> len ) ) { free ( buf ) ; <S2SV_ModStart> return 0 ; } <S2SV_ModStart> start ) ; free ( buf ) ; <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>with<S2SV_blank>extent"" ) ; free ( buf ) ; <S2SV_ModStart> 1 ; } free ( buf ) ; <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> ! indir ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; } <S2SV_ModStart> indir ) ) { <S2SV_ModStart> return grub_errno ; }
",radare@radare2/65000a7fd9eea62359e6d6714f17b94a99a82edd,CVE-2017-9763,https://github.com/radare/radare2/commit/65000a7fd9eea62359e6d6714f17b94a99a82edd,2017-06-19T16:29Z
CWE-416,"CWE-416 int SMB2_read ( const unsigned int xid , struct cifs_io_parms * io_parms , unsigned int * nbytes , char * * buf , int * buf_type ) { struct smb_rqst rqst ; int resp_buftype , rc = - EACCES ; struct smb2_read_plain_req * req = NULL ; struct smb2_read_rsp * rsp = NULL ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; unsigned int total_len ; int flags = CIFS_LOG_ERROR ; struct cifs_ses * ses = io_parms -> tcon -> ses ; * nbytes = 0 ; rc = smb2_new_read_req ( ( void * * ) & req , & total_len , io_parms , NULL , 0 , 0 ) ; if ( rc ) return rc ; if ( smb3_encryption_required ( io_parms -> tcon ) ) flags |= CIFS_TRANSFORM_REQ ; iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; <S2SV_StartBug> cifs_small_buf_release ( req ) ; <S2SV_EndBug> rsp = ( struct smb2_read_rsp * ) rsp_iov . iov_base ; if ( rc ) { if ( rc != - ENODATA ) { cifs_stats_fail_inc ( io_parms -> tcon , SMB2_READ_HE ) ; cifs_dbg ( VFS , ""Send<S2SV_blank>error<S2SV_blank>in<S2SV_blank>read<S2SV_blank>=<S2SV_blank>%d\\n"" , rc ) ; trace_smb3_read_err ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length , rc ) ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , 0 ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; return rc == - ENODATA ? 0 : rc ; } else trace_smb3_read_done ( xid , req -> PersistentFileId , io_parms -> tcon -> tid , ses -> Suid , io_parms -> offset , io_parms -> length ) ; <S2SV_StartBug> * nbytes = le32_to_cpu ( rsp -> DataLength ) ; <S2SV_EndBug> if ( ( * nbytes > CIFS_MAX_MSGSIZE ) || ( * nbytes > io_parms -> length ) ) { cifs_dbg ( FYI , ""bad<S2SV_blank>length<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>count<S2SV_blank>%d\\n"" , * nbytes , io_parms -> length ) ; rc = - EIO ; * nbytes = 0 ; } if ( * buf ) { memcpy ( * buf , ( char * ) rsp + rsp -> DataOffset , * nbytes ) ; free_rsp_buf ( resp_buftype , rsp_iov . iov_base ) ; } else if ( resp_buftype != CIFS_NO_BUFFER ) { * buf = rsp_iov . iov_base ; if ( resp_buftype == CIFS_SMALL_BUFFER ) * buf_type = CIFS_SMALL_BUFFER ; else if ( resp_buftype == CIFS_LARGE_BUFFER ) * buf_type = CIFS_LARGE_BUFFER ; } return rc ; }
","<S2SV_ModStart> rsp_iov ) ; <S2SV_ModEnd> rsp = ( <S2SV_ModStart> length ) ; cifs_small_buf_release ( req ) ;
",torvalds@linux/088aaf17aa79300cab14dbee2569c58cfafd7d6e,CVE-2019-15920,https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e,2019-09-04T19:15Z
CWE-20,"CWE-20 static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
","<S2SV_ModStart> f2fs_wait_discard_bios ( sbi , true
",torvalds@linux/638164a2718f337ea224b747cf5977ef143166a4,CVE-2017-18200,https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4,2018-02-26T03:29Z
CWE-284,"CWE-284 int btsock_thread_exit ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created"" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ; free_thread_slot ( h ) ; pthread_mutex_unlock ( & thread_slot_lock ) ; return TRUE ; } return FALSE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-000,"CWE-000 static int powermate_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( intf ) ; struct usb_host_interface * interface ; struct usb_endpoint_descriptor * endpoint ; struct powermate_device * pm ; struct input_dev * input_dev ; int pipe , maxp ; int error = - ENOMEM ; <S2SV_StartBug> interface = intf -> cur_altsetting ; <S2SV_EndBug> endpoint = & interface -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_int_in ( endpoint ) ) return - EIO ; usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , 0x0a , USB_TYPE_CLASS | USB_RECIP_INTERFACE , 0 , interface -> desc . bInterfaceNumber , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; pm = kzalloc ( sizeof ( struct powermate_device ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! pm || ! input_dev ) goto fail1 ; if ( powermate_alloc_buffers ( udev , pm ) ) goto fail2 ; pm -> irq = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> irq ) goto fail2 ; pm -> config = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! pm -> config ) goto fail3 ; pm -> udev = udev ; pm -> intf = intf ; pm -> input = input_dev ; usb_make_path ( udev , pm -> phys , sizeof ( pm -> phys ) ) ; strlcat ( pm -> phys , ""/input0"" , sizeof ( pm -> phys ) ) ; spin_lock_init ( & pm -> lock ) ; switch ( le16_to_cpu ( udev -> descriptor . idProduct ) ) { case POWERMATE_PRODUCT_NEW : input_dev -> name = pm_name_powermate ; break ; case POWERMATE_PRODUCT_OLD : input_dev -> name = pm_name_soundknob ; break ; default : input_dev -> name = pm_name_soundknob ; printk ( KERN_WARNING ""powermate:<S2SV_blank>unknown<S2SV_blank>product<S2SV_blank>id<S2SV_blank>%04x\\n"" , le16_to_cpu ( udev -> descriptor . idProduct ) ) ; } input_dev -> phys = pm -> phys ; usb_to_input_id ( udev , & input_dev -> id ) ; input_dev -> dev . parent = & intf -> dev ; input_set_drvdata ( input_dev , pm ) ; input_dev -> event = powermate_input_event ; input_dev -> evbit [ 0 ] = BIT_MASK ( EV_KEY ) | BIT_MASK ( EV_REL ) | BIT_MASK ( EV_MSC ) ; input_dev -> keybit [ BIT_WORD ( BTN_0 ) ] = BIT_MASK ( BTN_0 ) ; input_dev -> relbit [ BIT_WORD ( REL_DIAL ) ] = BIT_MASK ( REL_DIAL ) ; input_dev -> mscbit [ BIT_WORD ( MSC_PULSELED ) ] = BIT_MASK ( MSC_PULSELED ) ; pipe = usb_rcvintpipe ( udev , endpoint -> bEndpointAddress ) ; maxp = usb_maxpacket ( udev , pipe , usb_pipeout ( pipe ) ) ; if ( maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX ) { printk ( KERN_WARNING ""powermate:<S2SV_blank>Expected<S2SV_blank>payload<S2SV_blank>of<S2SV_blank>%d--%d<S2SV_blank>bytes,<S2SV_blank>found<S2SV_blank>%d<S2SV_blank>bytes!\\n"" , POWERMATE_PAYLOAD_SIZE_MIN , POWERMATE_PAYLOAD_SIZE_MAX , maxp ) ; maxp = POWERMATE_PAYLOAD_SIZE_MAX ; } usb_fill_int_urb ( pm -> irq , udev , pipe , pm -> data , maxp , powermate_irq , pm , endpoint -> bInterval ) ; pm -> irq -> transfer_dma = pm -> data_dma ; pm -> irq -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; if ( usb_submit_urb ( pm -> irq , GFP_KERNEL ) ) { error = - EIO ; goto fail4 ; } error = input_register_device ( pm -> input ) ; if ( error ) goto fail5 ; pm -> requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS ; powermate_pulse_led ( pm , 0x80 , 255 , 0 , 1 , 0 ) ; usb_set_intfdata ( intf , pm ) ; return 0 ; fail5 : usb_kill_urb ( pm -> irq ) ; fail4 : usb_free_urb ( pm -> config ) ; fail3 : usb_free_urb ( pm -> irq ) ; fail2 : powermate_free_buffers ( udev , pm ) ; fail1 : input_free_device ( input_dev ) ; kfree ( pm ) ; return error ; }
","<S2SV_ModStart> intf -> cur_altsetting ; if ( interface -> desc . bNumEndpoints < 1 ) return - EINVAL
",torvalds@linux/9c6ba456711687b794dcf285856fc14e2c76074f,CVE-2016-2186,https://github.com/torvalds/linux/commit/9c6ba456711687b794dcf285856fc14e2c76074f,2016-05-02T10:59Z
CWE-400,"CWE-400 static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; <S2SV_StartBug> __be16 type ; <S2SV_EndBug> off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo ) ; } for ( p = * head ; p ; p = p -> next ) { const struct gre_base_hdr * greh2 ; if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; greh2 = ( struct gre_base_hdr * ) ( p -> data + off ) ; if ( greh2 -> flags != greh -> flags || greh2 -> protocol != greh -> protocol ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } if ( greh -> flags & GRE_KEY ) { if ( * ( __be32 * ) ( greh2 + 1 ) != * ( __be32 * ) ( greh + 1 ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } } skb_gro_pull ( skb , grehlen ) ; skb_gro_postpull_rcsum ( skb , greh , grehlen ) ; pp = ptype -> callbacks . gro_receive ( head , skb ) ; flush = 0 ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }
","<S2SV_ModStart> ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1
",torvalds@linux/fac8e0f579695a3ecbc4d3cac369139d7f819971,CVE-2016-8666,https://github.com/torvalds/linux/commit/fac8e0f579695a3ecbc4d3cac369139d7f819971,2016-10-16T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> int read_frame ( struct VpxInputContext * input_ctx , vpx_image_t * img ) { <S2SV_EndBug> FILE * f = input_ctx -> file ; y4m_input * y4m = & input_ctx -> y4m ; int shortread = 0 ; if ( input_ctx -> file_type == FILE_TYPE_Y4M ) { if ( y4m_input_fetch_frame ( y4m , f , img ) < 1 ) return 0 ; } else { shortread = read_yuv_frame ( input_ctx , img ) ; } return ! shortread ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_scaling_mode_t * data = va_arg ( args , vpx_scaling_mode_t * ) ; if ( data ) { int res ; vpx_scaling_mode_t scalemode = * ( vpx_scaling_mode_t * ) data ; res = vp8_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) scalemode . h_scaling_mode , ( VPX_SCALING ) scalemode . v_scaling_mode ) ; if ( ! res ) { ctx -> next_frame_flag |= FRAMEFLAGS_KEY ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) { unsigned char * op ; const unsigned char * ip ; size_t t , next ; size_t state = 0 ; const unsigned char * m_pos ; const unsigned char * const ip_end = in + in_len ; unsigned char * const op_end = out + * out_len ; op = out ; ip = in ; if ( unlikely ( in_len < 3 ) ) goto input_overrun ; if ( * ip > 17 ) { t = * ip ++ - 17 ; if ( t < 4 ) { next = t ; goto match_next ; } goto copy_literal_run ; } for ( ; ; ) { t = * ip ++ ; if ( t < 16 ) { if ( likely ( state == 0 ) ) { if ( unlikely ( t == 0 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 15 + * ip ++ ; } t += 3 ; copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( t + 15 ) && HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> const unsigned char * ie = ip + t ; unsigned char * oe = op + t ; do { COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; } while ( ip < ie ) ; ip = ie ; op = oe ; } else # endif { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> do { * op ++ = * ip ++ ; } while ( -- t > 0 ) ; } state = 4 ; continue ; } else if ( state != 4 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; <S2SV_StartBug> NEED_OP ( 2 ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; goto match_next ; } else { next = t & 3 ; m_pos = op - ( 1 + M2_MAX_OFFSET ) ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; t = 3 ; } } else if ( t >= 64 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= ( t >> 2 ) & 7 ; m_pos -= * ip ++ << 3 ; t = ( t >> 5 ) - 1 + ( 3 - 1 ) ; } else if ( t >= 32 ) { t = ( t & 31 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 31 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } m_pos = op - 1 ; next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; } else { m_pos = op ; m_pos -= ( t & 8 ) << 11 ; t = ( t & 7 ) + ( 3 - 1 ) ; if ( unlikely ( t == 2 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; <S2SV_StartBug> NEED_IP ( 1 ) ; <S2SV_EndBug> } t += 7 + * ip ++ ; <S2SV_StartBug> NEED_IP ( 2 ) ; <S2SV_EndBug> } next = get_unaligned_le16 ( ip ) ; ip += 2 ; m_pos -= next >> 2 ; next &= 3 ; if ( m_pos == op ) goto eof_found ; m_pos -= 0x4000 ; } TEST_LB ( m_pos ) ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( op - m_pos >= 8 ) { unsigned char * oe = op + t ; <S2SV_StartBug> if ( likely ( HAVE_OP ( t + 15 ) ) ) { <S2SV_EndBug> do { COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; COPY8 ( op , m_pos ) ; op += 8 ; m_pos += 8 ; } while ( op < oe ) ; op = oe ; <S2SV_StartBug> if ( HAVE_IP ( 6 ) ) { <S2SV_EndBug> state = next ; COPY4 ( op , ip ) ; op += next ; ip += next ; continue ; } } else { <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } } else # endif { unsigned char * oe = op + t ; <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ; m_pos += 2 ; do { * op ++ = * m_pos ++ ; } while ( op < oe ) ; } match_next : state = next ; t = next ; # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) <S2SV_StartBug> if ( likely ( HAVE_IP ( 6 ) && HAVE_OP ( 4 ) ) ) { <S2SV_EndBug> COPY4 ( op , ip ) ; op += t ; ip += t ; } else # endif { <S2SV_StartBug> NEED_IP ( t + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> NEED_OP ( t ) ; <S2SV_EndBug> while ( t > 0 ) { * op ++ = * ip ++ ; t -- ; } } } eof_found : * out_len = op - out ; return ( t != 3 ? LZO_E_ERROR : ip == ip_end ? LZO_E_OK : ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN ) ; input_overrun : * out_len = op - out ; return LZO_E_INPUT_OVERRUN ; output_overrun : * out_len = op - out ; return LZO_E_OUTPUT_OVERRUN ; lookbehind_overrun : * out_len = op - out ; return LZO_E_LOOKBEHIND_OVERRUN ; }
","<S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> HAVE_IP ( t , <S2SV_ModEnd> 15 ) && <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> NEED_IP ( 1 , 0 <S2SV_ModStart> NEED_IP ( 2 , 0 <S2SV_ModStart> HAVE_OP ( t , <S2SV_ModEnd> 15 ) ) <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> NEED_OP ( t , 0 <S2SV_ModStart> HAVE_IP ( 6 , 0 <S2SV_ModStart> HAVE_OP ( 4 , 0 <S2SV_ModStart> NEED_IP ( t , <S2SV_ModEnd> 3 ) ; <S2SV_ModStart> NEED_OP ( t , 0
",torvalds@linux/206a81c18401c0cde6e579164f752c4b147324ce,CVE-2014-4608,https://github.com/torvalds/linux/commit/206a81c18401c0cde6e579164f752c4b147324ce,2014-07-03T04:22Z
CWE-20,"CWE-20 int dsOpen ( void ) { struct stat sb ; int retval ; <S2SV_StartBug> char * path = server . diskstore_path ; <S2SV_EndBug> if ( ( retval = stat ( path , & sb ) == - 1 ) && errno != ENOENT ) { redisLog ( REDIS_WARNING , ""Error<S2SV_blank>opening<S2SV_blank>disk<S2SV_blank>store<S2SV_blank>at<S2SV_blank>%s:<S2SV_blank>%s"" , path , strerror ( errno ) ) ; return REDIS_ERR ; } if ( retval == 0 && S_ISDIR ( sb . st_mode ) ) return REDIS_OK ; if ( retval == 0 && ! S_ISDIR ( sb . st_mode ) ) { redisLog ( REDIS_WARNING , ""Disk<S2SV_blank>store<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>directory"" , path ) ; return REDIS_ERR ; } if ( mkdir ( path ) == - 1 ) { redisLog ( REDIS_WARNING , ""Disk<S2SV_blank>store<S2SV_blank>init<S2SV_blank>failed<S2SV_blank>creating<S2SV_blank>dir<S2SV_blank>%s:<S2SV_blank>%s"" , path , strerror ( errno ) ) ; return REDIS_ERR ; } return REDIS_OK ; }
","<S2SV_ModStart> = server . ds_path <S2SV_ModEnd> ; if (
",antirez@redis/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,CVE-2013-0178,https://github.com/antirez/redis/commit/697af434fbeb2e3ba2ba9687cd283ed1a2734fa5,2019-11-01T19:15Z
CWE-134,"CWE-134 static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>zsocket_new<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIVL ) ; if ( pData -> multicastHops > - 1 ) zsocket_set_multicast_hops ( pData -> socket , pData -> multicastHops ) ; if ( pData -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( pData -> socket , pData -> reconnectIVL ) ; if ( pData -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( pData -> socket , pData -> reconnectIVLMax ) ; if ( pData -> ipv4Only > - 1 ) zsocket_set_ipv4only ( pData -> socket , pData -> ipv4Only ) ; if ( pData -> affinity != 1 ) zsocket_set_affinity ( pData -> socket , pData -> affinity ) ; if ( pData -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( pData -> socket , pData -> rcvHWM ) ; if ( pData -> sndHWM > - 1 ) zsocket_set_sndhwm ( pData -> socket , pData -> sndHWM ) ; if ( pData -> action == ACTION_BIND ) { <S2SV_StartBug> if ( - 1 == zsocket_bind ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>bind<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>bind<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful\\n"" , pData -> description ) ; } else { <S2SV_StartBug> if ( - 1 == zsocket_connect ( pData -> socket , ( char * ) pData -> description ) ) { <S2SV_EndBug> errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:<S2SV_blank>connect<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } DBGPRINTF ( ""omzmq3:<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>successful"" , pData -> description ) ; } finalize_it : RETiRet ; }
","<S2SV_ModStart> -> socket , ""%s"" , <S2SV_ModStart> -> socket , ""%s"" ,
",rsyslog@rsyslog/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,CVE-2017-12588,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,2017-08-06T14:29Z
CWE-476,"CWE-476 static int dissect_u3v ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) { gint offset = 0 ; proto_tree * u3v_tree = NULL , * ccd_tree_flag , * u3v_telegram_tree = NULL , * ccd_tree = NULL ; gint data_length = 0 ; gint req_id = 0 ; gint command_id = - 1 ; gint status = 0 ; guint prefix = 0 ; proto_item * ti = NULL ; proto_item * item = NULL ; const char * command_string ; usb_conv_info_t * usb_conv_info ; gint stream_detected = FALSE ; gint control_detected = FALSE ; u3v_conv_info_t * u3v_conv_info = NULL ; gencp_transaction_t * gencp_trans = NULL ; usb_conv_info = ( usb_conv_info_t * ) data ; u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; if ( ! u3v_conv_info ) { u3v_conv_info = wmem_new0 ( wmem_file_scope ( ) , u3v_conv_info_t ) ; <S2SV_StartBug> usb_conv_info -> class_data = u3v_conv_info ; <S2SV_EndBug> } prefix = tvb_get_letohl ( tvb , 0 ) ; if ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_CONTROL_PREFIX == prefix ) || ( U3V_EVENT_PREFIX == prefix ) ) ) { control_detected = TRUE ; } if ( ( ( tvb_reported_length ( tvb ) >= 4 ) && ( ( U3V_STREAM_LEADER_PREFIX == prefix ) || ( U3V_STREAM_TRAILER_PREFIX == prefix ) ) ) || ( usb_conv_info -> endpoint == u3v_conv_info -> ep_stream ) ) { stream_detected = TRUE ; } if ( control_detected || stream_detected ) { if ( usb_conv_info -> interfaceClass == IF_CLASS_UNKNOWN && usb_conv_info -> interfaceSubclass == IF_SUBCLASS_UNKNOWN ) { usb_conv_info -> interfaceClass = IF_CLASS_MISCELLANEOUS ; usb_conv_info -> interfaceSubclass = IF_SUBCLASS_MISC_U3V ; } } if ( control_detected ) { col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""U3V"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ; u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ; prefix = tvb_get_letohl ( tvb , offset ) ; command_id = tvb_get_letohs ( tvb , offset + 6 ) ; if ( ( prefix == U3V_CONTROL_PREFIX || prefix == U3V_EVENT_PREFIX ) && ( ( command_id % 2 ) == 0 ) ) { command_string = val_to_str ( command_id , command_names , ""Unknown<S2SV_blank>Command<S2SV_blank>(0x%x)"" ) ; item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_cmd , tvb , offset , 8 , ENC_NA ) ; proto_item_append_text ( item , "":<S2SV_blank>%s"" , command_string ) ; ccd_tree = proto_item_add_subtree ( item , ett_u3v_cmd ) ; proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; item = proto_tree_add_item ( ccd_tree , hf_u3v_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; ccd_tree_flag = proto_item_add_subtree ( item , ett_u3v_flags ) ; proto_tree_add_item ( ccd_tree_flag , hf_u3v_acknowledge_required_flag , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; col_append_fstr ( pinfo -> cinfo , COL_INFO , ""><S2SV_blank>%s<S2SV_blank>"" , command_string ) ; } else if ( prefix == U3V_CONTROL_PREFIX && ( ( command_id % 2 ) == 1 ) ) { command_string = val_to_str ( command_id , command_names , ""Unknown<S2SV_blank>Acknowledge<S2SV_blank>(0x%x)"" ) ; item = proto_tree_add_item ( u3v_tree , hf_u3v_ccd_ack , tvb , offset , 8 , ENC_NA ) ; proto_item_append_text ( item , "":<S2SV_blank>%s"" , command_string ) ; ccd_tree = proto_item_add_subtree ( item , ett_u3v_ack ) ; proto_tree_add_item ( ccd_tree , hf_u3v_gencp_prefix , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ; offset += 4 ; proto_tree_add_item ( ccd_tree , hf_u3v_status , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; status = tvb_get_letohs ( tvb , offset ) ; offset += 2 ; col_append_fstr ( pinfo -> cinfo , COL_INFO , ""<<S2SV_blank>%s<S2SV_blank>%s"" , command_string , val_to_str ( status , status_names_short , ""Unknown<S2SV_blank>status<S2SV_blank>(0x%04X)"" ) ) ; } else { return 0 ; } proto_tree_add_item ( ccd_tree , hf_u3v_command_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; offset += 2 ; proto_tree_add_item ( ccd_tree , hf_u3v_length , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; data_length = tvb_get_letohs ( tvb , offset ) ; offset += 2 ; proto_tree_add_item ( ccd_tree , hf_u3v_request_id , tvb , offset , 2 , ENC_LITTLE_ENDIAN ) ; req_id = tvb_get_letohs ( tvb , offset ) ; offset += 2 ; u3v_telegram_tree = proto_item_add_subtree ( u3v_tree , ett_u3v ) ; if ( ! PINFO_FD_VISITED ( pinfo ) ) { if ( ( command_id % 2 ) == 0 ) { gencp_trans = wmem_new ( wmem_file_scope ( ) , gencp_transaction_t ) ; gencp_trans -> cmd_frame = pinfo -> fd -> num ; gencp_trans -> ack_frame = 0 ; gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ; u3v_conv_info -> trans_info = gencp_trans ; } else { gencp_trans = u3v_conv_info -> trans_info ; if ( gencp_trans ) { gencp_trans -> ack_frame = pinfo -> fd -> num ; p_add_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id , gencp_trans ) ; } } } else { gencp_trans = ( gencp_transaction_t * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_u3v , req_id ) ; } if ( ! gencp_trans ) { gencp_trans = wmem_new ( wmem_packet_scope ( ) , gencp_transaction_t ) ; gencp_trans -> cmd_frame = 0 ; gencp_trans -> ack_frame = 0 ; gencp_trans -> cmd_time = pinfo -> fd -> abs_ts ; } switch ( command_id ) { case U3V_READMEM_CMD : dissect_u3v_read_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; break ; case U3V_WRITEMEM_CMD : dissect_u3v_write_mem_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; break ; case U3V_EVENT_CMD : dissect_u3v_event_cmd ( u3v_telegram_tree , tvb , pinfo , offset , data_length ) ; break ; case U3V_READMEM_ACK : if ( U3V_STATUS_GENCP_SUCCESS == status ) { dissect_u3v_read_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; } break ; case U3V_WRITEMEM_ACK : dissect_u3v_write_mem_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; break ; case U3V_PENDING_ACK : dissect_u3v_pending_ack ( u3v_telegram_tree , tvb , pinfo , offset , data_length , u3v_conv_info , gencp_trans ) ; break ; default : proto_tree_add_item ( u3v_telegram_tree , hf_u3v_payloaddata , tvb , offset , data_length , ENC_NA ) ; break ; } return data_length + 12 ; } else if ( stream_detected ) { u3v_conv_info = ( u3v_conv_info_t * ) usb_conv_info -> class_data ; u3v_conv_info -> ep_stream = usb_conv_info -> endpoint ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""U3V"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; ti = proto_tree_add_item ( tree , proto_u3v , tvb , offset , - 1 , ENC_NA ) ; u3v_tree = proto_item_add_subtree ( ti , ett_u3v ) ; if ( tvb_captured_length ( tvb ) >= 4 ) { prefix = tvb_get_letohl ( tvb , offset ) ; switch ( prefix ) { case U3V_STREAM_LEADER_PREFIX : dissect_u3v_stream_leader ( u3v_tree , tvb , pinfo , usb_conv_info ) ; break ; case U3V_STREAM_TRAILER_PREFIX : dissect_u3v_stream_trailer ( u3v_tree , tvb , pinfo , usb_conv_info ) ; break ; default : dissect_u3v_stream_payload ( u3v_tree , tvb , pinfo , usb_conv_info ) ; break ; } } return tvb_captured_length ( tvb ) ; } return 0 ; }
","<S2SV_ModStart> class_data = u3v_conv_info ; usb_conv_info -> class_data_type = USB_CONV_U3V ; } else if ( usb_conv_info -> class_data_type != USB_CONV_U3V ) { return 0
",wireshark@wireshark/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,CVE-2016-5354,https://github.com/wireshark/wireshark/commit/2cb5985bf47bdc8bea78d28483ed224abdd33dc6,2016-08-07T16:59Z
CWE-269,"CWE-269 qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
","<S2SV_ModStart> CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }
",iortcw@iortcw/b248763e4878ef12d5835ece6600be8334f67da1,CVE-2017-6903,https://github.com/iortcw/iortcw/commit/b248763e4878ef12d5835ece6600be8334f67da1,2017-03-14T22:59Z
CWE-125,"CWE-125 static UINT drive_process_irp_write ( DRIVE_DEVICE * drive , IRP * irp ) { DRIVE_FILE * file ; UINT32 Length ; UINT64 Offset ; <S2SV_StartBug> if ( ! drive || ! irp || ! irp -> input || ! irp -> output || ! irp -> Complete ) <S2SV_EndBug> return ERROR_INVALID_PARAMETER ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; Stream_Read_UINT32 ( irp -> input , Length ) ; Stream_Read_UINT64 ( irp -> input , Offset ) ; Stream_Seek ( irp -> input , 20 ) ; <S2SV_StartBug> file = drive_get_file_by_id ( drive , irp -> FileId ) ; <S2SV_EndBug> if ( ! file ) { irp -> IoStatus = STATUS_UNSUCCESSFUL ; Length = 0 ; } else if ( ! drive_file_seek ( file , Offset ) ) { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } <S2SV_StartBug> else if ( ! drive_file_write ( file , Stream_Pointer ( irp -> input ) , Length ) ) <S2SV_EndBug> { irp -> IoStatus = drive_map_windows_err ( GetLastError ( ) ) ; Length = 0 ; } Stream_Write_UINT32 ( irp -> output , Length ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return irp -> Complete ( irp ) ; }
","<S2SV_ModStart> UINT64 Offset ; void * ptr ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( file , ptr <S2SV_ModEnd> , Length )
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-190,"CWE-190 <S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> int c0 , int r1 , int c1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & JAS_MATRIX_REF ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= JAS_MATRIX_REF ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }
","<S2SV_ModStart> * mat1 , jas_matind_t r0 , jas_matind_t c0 , jas_matind_t r1 , jas_matind_t <S2SV_ModEnd> c1 ) { <S2SV_ModStart> c1 ) { jas_matind_t <S2SV_ModEnd> i ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-787,"CWE-787 <S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
","<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j
",ImageMagick@ImageMagick/a906fe9298bf89e01d5272023db687935068849a,CVE-2019-13300,https://github.com/ImageMagick/ImageMagick/commit/a906fe9298bf89e01d5272023db687935068849a,2019-07-05T01:15Z
CWE-362,"CWE-362 static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
","<S2SV_ModStart> dev ) ; kvm_get_kvm ( kvm ) ; <S2SV_ModStart> 0 ) { kvm_put_kvm ( kvm ) ; <S2SV_ModStart> ret ; } <S2SV_ModEnd> cd -> fd
",torvalds@linux/cfa39381173d5f969daf43582c95ad679189cbc9,CVE-2019-6974,https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9,2019-02-15T15:29Z
CWE-399,"CWE-399 static void record_and_restart ( struct perf_event * event , unsigned long val , <S2SV_StartBug> struct pt_regs * regs , int nmi ) <S2SV_EndBug> { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; <S2SV_StartBug> if ( perf_event_overflow ( event , nmi , & data , regs ) ) <S2SV_EndBug> power_pmu_stop ( event , 0 ) ; } }
","<S2SV_ModStart> pt_regs * regs <S2SV_ModEnd> ) { u64 <S2SV_ModStart> ( event , <S2SV_ModEnd> & data ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static int decode_coefs ( VP9_COMMON * cm , const MACROBLOCKD * xd , PLANE_TYPE type , <S2SV_EndBug> <S2SV_StartBug> int16_t * dqcoeff , TX_SIZE tx_size , const int16_t * dq , <S2SV_EndBug> int ctx , const int16_t * scan , const int16_t * nb , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> const int max_eob = 16 << ( tx_size << 1 ) ; <S2SV_StartBug> const FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> FRAME_COUNTS * const counts = & cm -> counts ; const int ref = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ; int band , c = 0 ; <S2SV_StartBug> const vp9_prob ( * coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = <S2SV_EndBug> fc -> coef_probs [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> const vp9_prob * prob ; <S2SV_EndBug> <S2SV_StartBug> unsigned int ( * coef_counts ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES + 1 ] = <S2SV_EndBug> counts -> coef [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] = <S2SV_EndBug> counts -> eob_branch [ tx_size ] [ type ] [ ref ] ; <S2SV_StartBug> uint8_t token_cache [ 32 * 32 ] ; <S2SV_EndBug> const uint8_t * cat6 ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v ; int16_t dqv = dq [ 0 ] ; while ( c < max_eob ) { <S2SV_StartBug> int val ; <S2SV_EndBug> band = * band_translate ++ ; prob = coef_probs [ band ] [ ctx ] ; <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ eob_branch_count [ band ] [ ctx ] ; <S2SV_StartBug> if ( ! vp9_read ( r , prob [ EOB_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( EOB_MODEL_TOKEN ) ; break ; } <S2SV_StartBug> while ( ! vp9_read ( r , prob [ ZERO_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( ZERO_TOKEN ) ; dqv = dq [ 1 ] ; token_cache [ scan [ c ] ] = 0 ; ++ c ; if ( c >= max_eob ) return c ; ctx = get_coef_context ( nb , token_cache , c ) ; band = * band_translate ++ ; prob = coef_probs [ band ] [ ctx ] ; } <S2SV_StartBug> if ( ! vp9_read ( r , prob [ ONE_CONTEXT_NODE ] ) ) { <S2SV_EndBug> INCREMENT_COUNT ( ONE_TOKEN ) ; <S2SV_StartBug> WRITE_COEF_CONTINUE ( 1 , ONE_TOKEN ) ; <S2SV_EndBug> } INCREMENT_COUNT ( TWO_TOKEN ) ; <S2SV_StartBug> prob = vp9_pareto8_full [ prob [ PIVOT_NODE ] - 1 ] ; <S2SV_EndBug> if ( ! vp9_read ( r , prob [ LOW_VAL_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ TWO_CONTEXT_NODE ] ) ) { WRITE_COEF_CONTINUE ( 2 , TWO_TOKEN ) ; } if ( ! vp9_read ( r , prob [ THREE_CONTEXT_NODE ] ) ) { WRITE_COEF_CONTINUE ( 3 , THREE_TOKEN ) ; } WRITE_COEF_CONTINUE ( 4 , FOUR_TOKEN ) ; } if ( ! vp9_read ( r , prob [ HIGH_LOW_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ CAT_ONE_CONTEXT_NODE ] ) ) { val = CAT1_MIN_VAL ; ADJUST_COEF ( CAT1_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY1_TOKEN ) ; } val = CAT2_MIN_VAL ; ADJUST_COEF ( CAT2_PROB1 , 1 ) ; ADJUST_COEF ( CAT2_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY2_TOKEN ) ; } if ( ! vp9_read ( r , prob [ CAT_THREEFOUR_CONTEXT_NODE ] ) ) { if ( ! vp9_read ( r , prob [ CAT_THREE_CONTEXT_NODE ] ) ) { val = CAT3_MIN_VAL ; ADJUST_COEF ( CAT3_PROB2 , 2 ) ; ADJUST_COEF ( CAT3_PROB1 , 1 ) ; ADJUST_COEF ( CAT3_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY3_TOKEN ) ; } val = CAT4_MIN_VAL ; ADJUST_COEF ( CAT4_PROB3 , 3 ) ; ADJUST_COEF ( CAT4_PROB2 , 2 ) ; ADJUST_COEF ( CAT4_PROB1 , 1 ) ; ADJUST_COEF ( CAT4_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY4_TOKEN ) ; } if ( ! vp9_read ( r , prob [ CAT_FIVE_CONTEXT_NODE ] ) ) { val = CAT5_MIN_VAL ; ADJUST_COEF ( CAT5_PROB4 , 4 ) ; ADJUST_COEF ( CAT5_PROB3 , 3 ) ; ADJUST_COEF ( CAT5_PROB2 , 2 ) ; ADJUST_COEF ( CAT5_PROB1 , 1 ) ; ADJUST_COEF ( CAT5_PROB0 , 0 ) ; WRITE_COEF_CONTINUE ( val , CATEGORY5_TOKEN ) ; } val = 0 ; cat6 = cat6_prob ; while ( * cat6 ) val = ( val << 1 ) | vp9_read ( r , * cat6 ++ ) ; val += CAT6_MIN_VAL ; WRITE_COEF_CONTINUE ( val , CATEGORY6_TOKEN ) ; } return c ; }
","<S2SV_ModStart> int decode_coefs ( <S2SV_ModEnd> const MACROBLOCKD * <S2SV_ModStart> PLANE_TYPE type , tran_low_t <S2SV_ModEnd> * dqcoeff , <S2SV_ModStart> * nb , vpx_reader * r ) { FRAME_COUNTS * counts = xd -> counts ; <S2SV_ModEnd> const int max_eob <S2SV_ModStart> const fc = xd -> fc <S2SV_ModEnd> ; const int <S2SV_ModStart> 0 ; const vpx_prob <S2SV_ModEnd> ( * coef_probs <S2SV_ModStart> ] ; const vpx_prob <S2SV_ModEnd> * prob ; <S2SV_ModStart> + 1 ] ; unsigned int ( * eob_branch_count ) [ COEFF_CONTEXTS ] ; uint8_t token_cache [ 32 * 32 ] ; const uint8_t * band_translate = get_band_translate ( tx_size ) ; const int dq_shift = ( tx_size == TX_32X32 ) ; int v , token ; int16_t dqv = dq [ 0 ] ; const uint8_t * cat1_prob ; const uint8_t * cat2_prob ; const uint8_t * cat3_prob ; const uint8_t * cat4_prob ; const uint8_t * cat5_prob ; const uint8_t * cat6_prob ; if ( counts ) { coef_counts = <S2SV_ModEnd> counts -> coef <S2SV_ModStart> ref ] ; eob_branch_count = <S2SV_ModEnd> counts -> eob_branch <S2SV_ModStart> ref ] ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> bd > VPX_BITS_8 ) { if ( xd -> bd == VPX_BITS_10 ) { cat1_prob = vp9_cat1_prob_high10 ; cat2_prob = vp9_cat2_prob_high10 ; cat3_prob = vp9_cat3_prob_high10 ; cat4_prob = vp9_cat4_prob_high10 ; cat5_prob = vp9_cat5_prob_high10 ; cat6_prob = vp9_cat6_prob_high10 ; } else { cat1_prob = vp9_cat1_prob_high12 ; cat2_prob = vp9_cat2_prob_high12 ; cat3_prob = vp9_cat3_prob_high12 ; cat4_prob = vp9_cat4_prob_high12 ; cat5_prob = vp9_cat5_prob_high12 ; cat6_prob = vp9_cat6_prob_high12 ; } } else { cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; } # else cat1_prob = vp9_cat1_prob ; cat2_prob = vp9_cat2_prob ; cat3_prob = vp9_cat3_prob ; cat4_prob = vp9_cat4_prob ; cat5_prob = vp9_cat5_prob ; cat6_prob = vp9_cat6_prob ; # endif <S2SV_ModEnd> while ( c <S2SV_ModStart> { int val = - 1 <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ eob_branch_count <S2SV_ModStart> if ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> while ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> if ( ! vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ONE_TOKEN ) ; token = ONE_TOKEN ; val = 1 ; } else { <S2SV_ModEnd> INCREMENT_COUNT ( TWO_TOKEN <S2SV_ModStart> TWO_TOKEN ) ; token = vpx_read_tree ( r , vp9_coef_con_tree , <S2SV_ModEnd> vp9_pareto8_full [ prob <S2SV_ModStart> - 1 ] ) ; switch ( token ) { case TWO_TOKEN : case THREE_TOKEN : case FOUR_TOKEN : val = token ; break ; case CATEGORY1_TOKEN : val = CAT1_MIN_VAL + read_coeff ( cat1_prob , 1 , r ) ; break ; case CATEGORY2_TOKEN : val = CAT2_MIN_VAL + read_coeff ( cat2_prob , 2 , r ) ; break ; case CATEGORY3_TOKEN : val = CAT3_MIN_VAL + read_coeff ( cat3_prob , 3 , r ) ; break ; case CATEGORY4_TOKEN : val = CAT4_MIN_VAL + read_coeff ( cat4_prob , 4 , r ) ; break ; case CATEGORY5_TOKEN : val = CAT5_MIN_VAL + read_coeff ( cat5_prob , 5 , r ) ; break ; case CATEGORY6_TOKEN : # if CONFIG_VP9_HIGHBITDEPTH switch ( xd -> bd ) { case VPX_BITS_8 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; break ; case VPX_BITS_10 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 16 , r ) ; break ; case VPX_BITS_12 : val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 18 , r ) ; break ; default : assert ( 0 ) ; return - 1 ; } # else val = CAT6_MIN_VAL + read_coeff ( cat6_prob , 14 , r ) ; # endif break ; } } v = ( val * dqv ) >> dq_shift ; # if CONFIG_COEFFICIENT_RANGE_CHECKING # if CONFIG_VP9_HIGHBITDEPTH dqcoeff [ scan [ c ] ] = highbd_check_range ( ( vpx_read_bit ( r ) ? - v : v ) , xd -> bd ) ; # else dqcoeff [ scan [ c ] ] = check_range ( vpx_read_bit ( r ) ? - v : v ) ; # endif # else dqcoeff [ scan [ c ] ] = vpx_read_bit ( r ) ? - v : v ; # endif token_cache [ scan [ c ] ] = vp9_pt_energy_class [ token ] ; ++ c ; ctx = get_coef_context ( nb , token_cache , c ) ; dqv = dq [ 1 ] <S2SV_ModEnd> ; } return
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 char * gf_text_get_utf8_line ( char * szLine , u32 lineSize , FILE * txt_in , s32 unicode_type ) { u32 i , j , len ; char * sOK ; char szLineConv [ 1024 ] ; unsigned short * sptr ; memset ( szLine , 0 , sizeof ( char ) * lineSize ) ; sOK = fgets ( szLine , lineSize , txt_in ) ; if ( ! sOK ) return NULL ; if ( unicode_type <= 1 ) { j = 0 ; len = ( u32 ) strlen ( szLine ) ; <S2SV_StartBug> for ( i = 0 ; i < len ; i ++ ) { <S2SV_EndBug> if ( ! unicode_type && ( szLine [ i ] & 0x80 ) ) { if ( ( szLine [ i + 1 ] & 0xc0 ) != 0x80 ) { <S2SV_StartBug> szLineConv [ j ] = 0xc0 | ( ( szLine [ i ] >> 6 ) & 0x3 ) ; <S2SV_EndBug> j ++ ; szLine [ i ] &= 0xbf ; } <S2SV_StartBug> else if ( ( szLine [ i ] & 0xe0 ) == 0xc0 ) { <S2SV_EndBug> <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf0 ) == 0xe0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else if ( ( szLine [ i ] & 0xf8 ) == 0xf0 ) { <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { i += 1 ; continue ; } } <S2SV_StartBug> szLineConv [ j ] = szLine [ i ] ; <S2SV_EndBug> j ++ ; } szLineConv [ j ] = 0 ; strcpy ( szLine , szLineConv ) ; return sOK ; } # ifdef GPAC_BIG_ENDIAN if ( unicode_type == 3 ) { # else if ( unicode_type == 2 ) { # endif i = 0 ; while ( 1 ) { char c ; if ( ! szLine [ i ] && ! szLine [ i + 1 ] ) break ; c = szLine [ i + 1 ] ; szLine [ i + 1 ] = szLine [ i ] ; szLine [ i ] = c ; i += 2 ; } } sptr = ( u16 * ) szLine ; i = ( u32 ) gf_utf8_wcstombs ( szLineConv , 1024 , ( const unsigned short * * ) & sptr ) ; if ( i >= ( u32 ) ARRAY_LENGTH ( szLineConv ) ) return NULL ; szLineConv [ i ] = 0 ; strcpy ( szLine , szLineConv ) ; if ( unicode_type == 3 ) fgetc ( txt_in ) ; return sOK ; }
","<S2SV_ModStart> i < len && j < sizeof ( szLineConv ) - 1 ; i ++ , j <S2SV_ModEnd> ++ ) { <S2SV_ModStart> 0x80 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 ) { <S2SV_ModStart> ; } else break ; } else <S2SV_ModStart> 0xc0 ) { if ( j + 1 < sizeof ( szLineConv ) - 1 && i + 1 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xe0 ) { if ( j + 2 < sizeof ( szLineConv ) - 1 && i + 2 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else if <S2SV_ModStart> 0xf0 ) { if ( j + 3 < sizeof ( szLineConv ) - 1 && i + 3 < len ) { szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; szLineConv [ j ] = szLine [ i ] ; i ++ ; j ++ ; } else { break ; } <S2SV_ModEnd> } else { <S2SV_ModStart> ; } } if ( j < sizeof ( szLineConv ) - 1 && i < len ) szLineConv [ j ] = szLine [ i ] ; } if ( j >= sizeof ( szLineConv ) ) szLineConv [ sizeof ( szLineConv ) - 1 ] = 0 ; else <S2SV_ModEnd> szLineConv [ j
",gpac@gpac/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,CVE-2018-20763,https://github.com/gpac/gpac/commit/1c449a34fe0b50aaffb881bfb9d7c5ab0bb18cdd,2019-02-06T23:29Z
CWE-119,"CWE-119 static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , ""NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\n"" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }
","<S2SV_ModStart> * rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
",torvalds@linux/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,CVE-2014-3184,https://github.com/torvalds/linux/commit/4ab25786c87eb20857bbb715c3ae34ec8fd6a214,2014-09-28T10:55Z
CWE-787,"CWE-787 static int process_plane ( uint8 * in , int width , int height , uint8 * out , int size ) { UNUSED ( size ) ; int indexw ; int indexh ; int code ; int collen ; int replen ; int color ; int x ; int revcode ; uint8 * last_line ; uint8 * this_line ; uint8 * org_in ; uint8 * org_out ; org_in = in ; org_out = out ; last_line = 0 ; indexh = 0 ; while ( indexh < height ) { out = ( org_out + width * height * 4 ) - ( ( indexh + 1 ) * width * 4 ) ; color = 0 ; this_line = out ; indexw = 0 ; if ( last_line == 0 ) { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { color = CVAL ( in ) ; * out = color ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { * out = color ; out += 4 ; indexw ++ ; replen -- ; } } } else { while ( indexw < width ) { code = CVAL ( in ) ; replen = code & 0xf ; collen = ( code >> 4 ) & 0xf ; revcode = ( replen << 4 ) | collen ; if ( ( revcode <= 47 ) && ( revcode >= 16 ) ) { replen = revcode ; collen = 0 ; } <S2SV_StartBug> while ( collen > 0 ) <S2SV_EndBug> { x = CVAL ( in ) ; if ( x & 1 ) { x = x >> 1 ; x = x + 1 ; color = - x ; } else { x = x >> 1 ; color = x ; } x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; collen -- ; } <S2SV_StartBug> while ( replen > 0 ) <S2SV_EndBug> { x = last_line [ indexw * 4 ] + color ; * out = x ; out += 4 ; indexw ++ ; replen -- ; } } } indexh ++ ; last_line = this_line ; } return ( int ) ( in - org_in ) ; }
","<S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width && <S2SV_ModStart> } while ( indexw < width &&
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
CWE-119,"CWE-119 static int atusb_get_and_show_revision ( struct atusb * atusb ) { struct usb_device * usb_dev = atusb -> usb_dev ; <S2SV_StartBug> unsigned char buffer [ 3 ] ; <S2SV_EndBug> int ret ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_ID , ATUSB_REQ_FROM_DEV , 0 , 0 , buffer , 3 , 1000 ) ; if ( ret >= 0 ) { atusb -> fw_ver_maj = buffer [ 0 ] ; atusb -> fw_ver_min = buffer [ 1 ] ; atusb -> fw_hw_type = buffer [ 2 ] ; dev_info ( & usb_dev -> dev , ""Firmware:<S2SV_blank>major:<S2SV_blank>%u,<S2SV_blank>minor:<S2SV_blank>%u,<S2SV_blank>hardware<S2SV_blank>type:<S2SV_blank>%u\\n"" , atusb -> fw_ver_maj , atusb -> fw_ver_min , atusb -> fw_hw_type ) ; } if ( atusb -> fw_ver_maj == 0 && atusb -> fw_ver_min < 2 ) { dev_info ( & usb_dev -> dev , ""Firmware<S2SV_blank>version<S2SV_blank>(%u.%u)<S2SV_blank>predates<S2SV_blank>our<S2SV_blank>first<S2SV_blank>public<S2SV_blank>release."" , atusb -> fw_ver_maj , atusb -> fw_ver_min ) ; dev_info ( & usb_dev -> dev , ""Please<S2SV_blank>update<S2SV_blank>to<S2SV_blank>version<S2SV_blank>0.2<S2SV_blank>or<S2SV_blank>newer"" ) ; } <S2SV_StartBug> return ret ; <S2SV_EndBug> }
","<S2SV_ModStart> ; unsigned char * buffer ; int ret ; buffer = kmalloc ( 3 , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ) ; } kfree ( buffer ) ;
",torvalds@linux/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,CVE-2017-5548,https://github.com/torvalds/linux/commit/05a974efa4bdf6e2a150e3f27dc6fcf0a9ad5655,2017-02-06T06:59Z
CWE-401,"CWE-401 struct resource_pool * dce112_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }
","<S2SV_ModStart> -> base ; kfree ( pool ) ;
",torvalds@linux/104c307147ad379617472dd91a5bcb368d72bd6d,CVE-2019-19082,https://github.com/torvalds/linux/commit/104c307147ad379617472dd91a5bcb368d72bd6d,2019-11-18T06:15Z
CWE-200,"CWE-200 static void ParseCommon ( map_string_t * settings , const char * conf_filename ) { const char * value ; value = get_map_string_item_or_NULL ( settings , ""WatchCrashdumpArchiveDir"" ) ; if ( value ) { g_settings_sWatchCrashdumpArchiveDir = xstrdup ( value ) ; remove_map_string_item ( settings , ""WatchCrashdumpArchiveDir"" ) ; } value = get_map_string_item_or_NULL ( settings , ""MaxCrashReportsSize"" ) ; if ( value ) { char * end ; errno = 0 ; unsigned long ul = strtoul ( value , & end , 10 ) ; if ( errno || end == value || * end != '\\0' || ul > INT_MAX ) error_msg ( ""Error<S2SV_blank>parsing<S2SV_blank>%s<S2SV_blank>setting:<S2SV_blank>\'%s\'"" , ""MaxCrashReportsSize"" , value ) ; else g_settings_nMaxCrashReportsSize = ul ; remove_map_string_item ( settings , ""MaxCrashReportsSize"" ) ; } value = get_map_string_item_or_NULL ( settings , ""DumpLocation"" ) ; if ( value ) { g_settings_dump_location = xstrdup ( value ) ; remove_map_string_item ( settings , ""DumpLocation"" ) ; } else g_settings_dump_location = xstrdup ( DEFAULT_DUMP_LOCATION ) ; value = get_map_string_item_or_NULL ( settings , ""DeleteUploaded"" ) ; if ( value ) { g_settings_delete_uploaded = string_to_bool ( value ) ; remove_map_string_item ( settings , ""DeleteUploaded"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEnabled"" ) ; if ( value ) { g_settings_autoreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""AutoreportingEnabled"" ) ; } value = get_map_string_item_or_NULL ( settings , ""AutoreportingEvent"" ) ; if ( value ) { g_settings_autoreporting_event = xstrdup ( value ) ; remove_map_string_item ( settings , ""AutoreportingEvent"" ) ; } else g_settings_autoreporting_event = xstrdup ( ""report_uReport"" ) ; value = get_map_string_item_or_NULL ( settings , ""ShortenedReporting"" ) ; if ( value ) { g_settings_shortenedreporting = string_to_bool ( value ) ; remove_map_string_item ( settings , ""ShortenedReporting"" ) ; } else g_settings_shortenedreporting = 0 ; <S2SV_StartBug> GHashTableIter iter ; <S2SV_EndBug> const char * name ; init_map_string_iter ( & iter , settings ) ; while ( next_map_string_iter ( & iter , & name , & value ) ) { error_msg ( ""Unrecognized<S2SV_blank>variable<S2SV_blank>\'%s\'<S2SV_blank>in<S2SV_blank>\'%s\'"" , name , conf_filename ) ; } }
","<S2SV_ModStart> = 0 ; value = get_map_string_item_or_NULL ( settings , ""PrivateReports"" ) ; if ( value ) { g_settings_privatereports = string_to_bool ( value ) ; remove_map_string_item ( settings , ""PrivateReports"" ) ; }
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
CWE-358,"CWE-358 static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } <S2SV_StartBug> dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; <S2SV_EndBug> dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }
","<S2SV_ModStart> } dt -> proto = IP_GET_IPPROTO ( p ) ; dt ->
",inliniac@suricata/4a04f814b15762eb446a5ead4d69d021512df6f8,CVE-2017-7177,https://github.com/inliniac/suricata/commit/4a04f814b15762eb446a5ead4d69d021512df6f8,2017-03-18T20:59Z
CWE-284,"CWE-284 int sock_send_fd ( int sock_fd , const uint8_t * buf , int len , int send_fd ) { ssize_t ret ; struct msghdr msg ; unsigned char * buffer = ( unsigned char * ) buf ; memset ( & msg , 0 , sizeof ( msg ) ) ; struct cmsghdr * cmsg ; char msgbuf [ CMSG_SPACE ( 1 ) ] ; asrt ( send_fd != - 1 ) ; if ( sock_fd == - 1 || send_fd == - 1 ) return - 1 ; msg . msg_control = msgbuf ; msg . msg_controllen = sizeof msgbuf ; cmsg = CMSG_FIRSTHDR ( & msg ) ; cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof send_fd ) ; memcpy ( CMSG_DATA ( cmsg ) , & send_fd , sizeof send_fd ) ; int ret_len = len ; while ( len > 0 ) { struct iovec iv ; memset ( & iv , 0 , sizeof ( iv ) ) ; iv . iov_base = buffer ; iv . iov_len = len ; msg . msg_iov = & iv ; msg . msg_iovlen = 1 ; do { <S2SV_StartBug> ret = sendmsg ( sock_fd , & msg , MSG_NOSIGNAL ) ; <S2SV_EndBug> } while ( ret < 0 && errno == EINTR ) ; if ( ret < 0 ) { BTIF_TRACE_ERROR ( ""fd:%d,<S2SV_blank>send_fd:%d,<S2SV_blank>sendmsg<S2SV_blank>ret:%d,<S2SV_blank>errno:%d,<S2SV_blank>%s"" , sock_fd , send_fd , ( int ) ret , errno , strerror ( errno ) ) ; ret_len = - 1 ; break ; } buffer += ret ; len -= ret ; memset ( & msg , 0 , sizeof ( msg ) ) ; } BTIF_TRACE_DEBUG ( ""close<S2SV_blank>fd:%d<S2SV_blank>after<S2SV_blank>sent"" , send_fd ) ; close ( send_fd ) ; return ret_len ; }
","<S2SV_ModStart> { ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> msg , MSG_NOSIGNAL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-189,"CWE-189 void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; <S2SV_StartBug> req -> started = false ; <S2SV_EndBug> list_del ( & req -> list ) ; req -> remaining = 0 ; if ( req -> request . status == - EINPROGRESS ) req -> request . status = status ; if ( req -> trb ) usb_gadget_unmap_request_by_dev ( dwc -> sysdev , & req -> request , req -> direction ) ; req -> trb = NULL ; trace_dwc3_gadget_giveback ( req ) ; spin_unlock ( & dwc -> lock ) ; usb_gadget_giveback_request ( & dep -> endpoint , & req -> request ) ; spin_lock ( & dwc -> lock ) ; <S2SV_StartBug> if ( dep -> number > 1 ) <S2SV_EndBug> pm_runtime_put ( dwc -> dev ) ; }
","<S2SV_ModStart> -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/c91815b596245fd7da349ecc43c8def670d2269e,CVE-2019-14763,https://github.com/torvalds/linux/commit/c91815b596245fd7da349ecc43c8def670d2269e,2019-08-07T22:15Z
CWE-552,"CWE-552 static ssize_t _consolefs_write ( oe_fd_t * file_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( file_ ) ; <S2SV_StartBug> if ( ! file ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_write_ocall ( & ret , file -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> ( ! file || count > OE_SSIZE_MAX <S2SV_ModStart> OE_EINVAL ) ; if ( ret > ( ssize_t ) count ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> } } } }
","<S2SV_ModStart> write_ref_frames ( const VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_writer * w ) { const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; if ( segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { assert ( ! is_compound ) ; assert ( mbmi -> ref_frame [ 0 ] == get_segdata ( & <S2SV_ModEnd> cm -> seg <S2SV_ModStart> SEG_LVL_REF_FRAME ) ) ; } else { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { vpx_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else <S2SV_ModStart> ( ! is_compound == <S2SV_ModEnd> ( cm -> <S2SV_ModStart> -> reference_mode == <S2SV_ModEnd> SINGLE_REFERENCE ) ) <S2SV_ModStart> is_compound ) { vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != LAST_FRAME ; vpx_write <S2SV_ModEnd> ( w , <S2SV_ModStart> != GOLDEN_FRAME ; vpx_write <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-352,"CWE-352 static void doPost ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; <S2SV_StartBug> if ( ACTION ( RUN ) ) <S2SV_EndBug> handle_run ( req , res ) ; else if ( ACTION ( STATUS ) ) print_status ( req , res , 1 ) ; else if ( ACTION ( STATUS2 ) ) print_status ( req , res , 2 ) ; else if ( ACTION ( SUMMARY ) ) print_summary ( req , res ) ; else if ( ACTION ( REPORT ) ) _printReport ( req , res ) ; else if ( ACTION ( DOACTION ) ) <S2SV_StartBug> handle_do_action ( req , res ) ; <S2SV_EndBug> else <S2SV_StartBug> handle_action ( req , res ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ACTION ( RUNTIME ) ) handle_runtime_action ( req , res ) ; else if ( ACTION ( VIEWLOG ) ) do_viewlog <S2SV_ModEnd> ( req , <S2SV_ModStart> DOACTION ) ) handle_doaction <S2SV_ModEnd> ( req , <S2SV_ModStart> ) ; else handle_service_action <S2SV_ModEnd> ( req ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
CWE-190,"CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <S2SV_StartBug> case 'c' : return getnum ( fmt , 1 ) ; <S2SV_EndBug> case 'i' : case 'I' : { <S2SV_StartBug> int sz = getnum ( fmt , sizeof ( int ) ) ; <S2SV_EndBug> if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
","<S2SV_ModStart> return getnum ( L , <S2SV_ModStart> = getnum ( L ,
",antirez@redis/ef764dde1cca2f25d00686673d1bc89448819571,CVE-2020-14147,https://github.com/antirez/redis/commit/ef764dde1cca2f25d00686673d1bc89448819571,2020-06-15T18:15Z
CWE-295,"CWE-295 static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }
","<S2SV_ModStart> if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
",libressl-portable@openbsd/0654414afcce51a16d35d05060190a3ec4618d42,CVE-2018-8970,https://github.com/libressl-portable/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42,2018-03-24T21:29Z
CWE-119,"CWE-119 int module_load ( YR_SCAN_CONTEXT * context , YR_OBJECT * module_object , void * module_data , size_t module_data_size ) { set_integer ( 1 , module_object , ""constants.one"" ) ; set_integer ( 2 , module_object , ""constants.two"" ) ; set_string ( ""foo"" , module_object , ""constants.foo"" ) ; set_string ( """" , module_object , ""constants.empty"" ) ; set_integer ( 1 , module_object , ""struct_array[1].i"" ) ; set_integer ( 0 , module_object , ""integer_array[%i]"" , 0 ) ; set_integer ( 1 , module_object , ""integer_array[%i]"" , 1 ) ; set_integer ( 2 , module_object , ""integer_array[%i]"" , 2 ) ; <S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ; set_string ( ""baz"" , module_object , ""string_array[%i]"" , 2 ) ; set_sized_string ( ""foo\\0bar"" , 7 , module_object , ""string_array[%i]"" , 3 ) ; set_string ( ""foo"" , module_object , ""string_dict[%s]"" , ""foo"" ) ; set_string ( ""bar"" , module_object , ""string_dict[\\""bar\\""]"" ) ; set_string ( ""foo"" , module_object , ""struct_dict[%s].s"" , ""foo"" ) ; set_integer ( 1 , module_object , ""struct_dict[%s].i"" , ""foo"" ) ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> 2 ) ; set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;
",VirusTotal@yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,CVE-2017-11328,https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,2017-07-17T13:18Z
CWE-345,"CWE-345 static <S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> { HeaderIterator hi ; struct rpmtd_s td ; <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> break ; case RPMSIGTAG_PGP : <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 ) continue ; break ; case RPM_I18NSTRING_TYPE : continue ; break ; } <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> } } headerFreeIterator ( hi ) ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static rpmTagVal <S2SV_ModEnd> headerMergeLegacySigs ( Header <S2SV_ModStart> , Header sigh , char * * msg ) { const struct taglate_s * xl <S2SV_ModEnd> ; struct rpmtd_s <S2SV_ModStart> rpmtd_s td ; rpmtdReset ( & td ) ; for ( xl = xlateTags ; xl -> stag ; xl ++ ) { if ( headerIsEntry ( h , xl -> xtag ) ) break ; if ( headerGet ( sigh , xl -> stag , & td , HEADERGET_RAW | HEADERGET_MINMEM ) ) { if ( xl -> stag != xl -> xtag ) <S2SV_ModEnd> td . tag <S2SV_ModStart> . tag = xl -> xtag ; if ( td . type != rpmTagGetTagType ( <S2SV_ModEnd> td . tag <S2SV_ModStart> td . tag ) ) break ; if ( td . count < 1 || td . count > 16 * 1024 * 1024 ) break ; if ( xl -> count && td . count != xl -> count ) break ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! headerPut <S2SV_ModEnd> ( h , <S2SV_ModStart> ( h , <S2SV_ModEnd> & td , <S2SV_ModStart> , HEADERPUT_DEFAULT ) ) break ; rpmtdFreeData ( & td ) ; } } rpmtdFreeData ( & td ) ; if ( xl -> stag ) { rasprintf ( msg , ""invalid<S2SV_blank>signature<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>(%d)"" , rpmTagGetName ( xl -> xtag ) , xl -> xtag ) ; } return xl -> stag <S2SV_ModEnd> ; } <S2SV_null>
",rpm-software-management@rpm/d6a86b5e69e46cc283b1e06c92343319beb42e21,CVE-2021-20271,https://github.com/rpm-software-management/rpm/commit/d6a86b5e69e46cc283b1e06c92343319beb42e21,2021-03-26T17:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static PREDICTION_MODE <S2SV_ModEnd> read_intra_mode_y ( VP9_COMMON <S2SV_ModStart> * cm , MACROBLOCKD * xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> ) { const PREDICTION_MODE <S2SV_ModEnd> y_mode = read_intra_mode <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> y_mode_prob [ size_group <S2SV_ModStart> ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> <S2SV_ModEnd> y_mode [ size_group
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? ""RF64"" : ""RIFF"" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , ""WAVE"" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , ""fmt<S2SV_blank>"" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , ""data"" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , ""junk"" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , ""ds64"" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } return TRUE ; }
","<S2SV_ModStart> write_junk = 1 , table_length = 0 <S2SV_ModStart> ; DS64Chunk ds64_chunk ; CS64Chunk cs64_chunk <S2SV_ModStart> ds64_chunk ) ; total_riff_bytes += table_length * sizeof ( CS64Chunk ) ; if ( write_junk ) total_riff_bytes += <S2SV_ModEnd> sizeof ( junkchunk <S2SV_ModStart> ( ds64_chunk ) + ( table_length * sizeof ( CS64Chunk ) ) <S2SV_ModStart> sampleCount64 = total_samples ; ds64_chunk . tableLength = table_length <S2SV_ModStart> total_data_bytes ; } if ( table_length ) { strncpy ( cs64_chunk . ckID , ""dmmy"" , sizeof ( cs64_chunk . ckID ) ) ; cs64_chunk . chunkSize64 = 12345678 ; WavpackNativeToLittleEndian ( & cs64_chunk , CS64ChunkFormat ) ; } <S2SV_ModStart> ) ) ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } while ( table_length -- ) if ( ! DoWriteFile ( outfile , & cs64_chunk , sizeof ( cs64_chunk ) , & bcount ) || bcount != sizeof ( cs64_chunk ) ) { error_line ( ""can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!"" ) ; return FALSE ; } if ( <S2SV_ModEnd> ( write_junk &&
",dbry@WavPack/d5bf76b5a88d044a1be1d5656698e3ba737167e5,CVE-2018-6767,https://github.com/dbry/WavPack/commit/d5bf76b5a88d044a1be1d5656698e3ba737167e5,2018-02-06T22:29Z
CWE-416,"CWE-416 static PHP_MINIT_FUNCTION ( zip ) { # ifdef PHP_ZIP_USE_OO zend_class_entry ce ; memcpy ( & zip_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; zip_object_handlers . clone_obj = NULL ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; <S2SV_StartBug> zip_object_handlers . get_properties = php_zip_get_properties ; <S2SV_EndBug> zip_object_handlers . read_property = php_zip_read_property ; zip_object_handlers . has_property = php_zip_has_property ; INIT_CLASS_ENTRY ( ce , ""ZipArchive"" , zip_class_functions ) ; ce . create_object = php_zip_object_new ; zip_class_entry = zend_register_internal_class ( & ce TSRMLS_CC ) ; zend_hash_init ( & zip_prop_handlers , 0 , NULL , NULL , 1 ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""status"" , php_zip_status , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""statusSys"" , php_zip_status_sys , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""numFiles"" , php_zip_get_num_files , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""filename"" , NULL , NULL , php_zipobj_get_filename , IS_STRING TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""comment"" , NULL , php_zipobj_get_zip_comment , NULL , IS_STRING TSRMLS_CC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CREATE"" , ZIP_CREATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""EXCL"" , ZIP_EXCL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CHECKCONS"" , ZIP_CHECKCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""OVERWRITE"" , ZIP_OVERWRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_NOCASE"" , ZIP_FL_NOCASE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_NODIR"" , ZIP_FL_NODIR ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_COMPRESSED"" , ZIP_FL_COMPRESSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""FL_UNCHANGED"" , ZIP_FL_UNCHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFAULT"" , ZIP_CM_DEFAULT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_STORE"" , ZIP_CM_STORE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_SHRINK"" , ZIP_CM_SHRINK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_1"" , ZIP_CM_REDUCE_1 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_2"" , ZIP_CM_REDUCE_2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_3"" , ZIP_CM_REDUCE_3 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_REDUCE_4"" , ZIP_CM_REDUCE_4 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_IMPLODE"" , ZIP_CM_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFLATE"" , ZIP_CM_DEFLATE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_DEFLATE64"" , ZIP_CM_DEFLATE64 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_PKWARE_IMPLODE"" , ZIP_CM_PKWARE_IMPLODE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_BZIP2"" , ZIP_CM_BZIP2 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_LZMA"" , ZIP_CM_LZMA ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_TERSE"" , ZIP_CM_TERSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_LZ77"" , ZIP_CM_LZ77 ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_WAVPACK"" , ZIP_CM_WAVPACK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CM_PPMD"" , ZIP_CM_PPMD ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_OK"" , ZIP_ER_OK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_MULTIDISK"" , ZIP_ER_MULTIDISK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_RENAME"" , ZIP_ER_RENAME ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CLOSE"" , ZIP_ER_CLOSE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_SEEK"" , ZIP_ER_SEEK ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_READ"" , ZIP_ER_READ ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_WRITE"" , ZIP_ER_WRITE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CRC"" , ZIP_ER_CRC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_ZIPCLOSED"" , ZIP_ER_ZIPCLOSED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_NOENT"" , ZIP_ER_NOENT ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_EXISTS"" , ZIP_ER_EXISTS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_OPEN"" , ZIP_ER_OPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_TMPOPEN"" , ZIP_ER_TMPOPEN ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_ZLIB"" , ZIP_ER_ZLIB ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_MEMORY"" , ZIP_ER_MEMORY ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_CHANGED"" , ZIP_ER_CHANGED ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_COMPNOTSUPP"" , ZIP_ER_COMPNOTSUPP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_EOF"" , ZIP_ER_EOF ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INVAL"" , ZIP_ER_INVAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_NOZIP"" , ZIP_ER_NOZIP ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INTERNAL"" , ZIP_ER_INTERNAL ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_INCONS"" , ZIP_ER_INCONS ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_REMOVE"" , ZIP_ER_REMOVE ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""ER_DELETED"" , ZIP_ER_DELETED ) ; php_register_url_stream_wrapper ( ""zip"" , & php_stream_zip_wrapper TSRMLS_CC ) ; # endif le_zip_dir = zend_register_list_destructors_ex ( php_zip_free_dir , NULL , le_zip_dir_name , module_number ) ; le_zip_entry = zend_register_list_destructors_ex ( php_zip_free_entry , NULL , le_zip_entry_name , module_number ) ; return SUCCESS ; }
","<S2SV_ModStart> ; zip_object_handlers . get_gc = php_zip_get_gc ; zip_object_handlers .
",php@php-src/f6aef68089221c5ea047d4a74224ee3deead99a6,CVE-2016-5773,https://github.com/php/php-src/commit/f6aef68089221c5ea047d4a74224ee3deead99a6?w=1,2016-08-07T10:59Z
CWE-400,"CWE-400 <S2SV_StartBug> static void sample_hbp_handler ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { printk ( KERN_INFO ""%s<S2SV_blank>value<S2SV_blank>is<S2SV_blank>changed\\n"" , ksym_name ) ; dump_stack ( ) ; printk ( KERN_INFO ""Dump<S2SV_blank>stack<S2SV_blank>from<S2SV_blank>sample_hbp_handler\\n"" ) ; }
","<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-264,"CWE-264 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union { struct tpacket_hdr * h1 ; struct tpacket2_hdr * h2 ; void * raw ; } h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timeval tv ; struct timespec ts ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; macoff = netoff - maclen ; } if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < ( unsigned ) sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; if ( ! h . raw ) goto ring_is_full ; packet_increment_head ( & po -> rx_ring ) ; po -> stats . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } if ( ! po -> stats . tp_drops ) status &= ~ TP_STATUS_LOSING ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) tv = ktime_to_timeval ( skb -> tstamp ) ; else do_gettimeofday ( & tv ) ; h . h1 -> tp_sec = tv . tv_sec ; h . h1 -> tp_usec = tv . tv_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) ts = ktime_to_timespec ( skb -> tstamp ) ; else getnstimeofday ( & ts ) ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( vlan_tx_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; status |= TP_STATUS_VLAN_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; } <S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; __packet_set_status ( po , h . raw , status ) ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } # endif sk -> sk_data_ready ( sk , 0 ) ; drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : kfree_skb ( skb ) ; return 0 ; ring_is_full : po -> stats . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk , 0 ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
","<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
",torvalds@linux/13fcb7bd322164c67926ffe272846d4860196dc6,CVE-2011-2898,https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6,2012-05-24T23:55Z
CWE-476,"CWE-476 jp2_box_t * jp2_box_create ( int type ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; <S2SV_StartBug> if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { <S2SV_EndBug> return 0 ; } <S2SV_StartBug> memset ( box , 0 , sizeof ( jp2_box_t ) ) ; <S2SV_EndBug> box -> type = type ; box -> len = 0 ; if ( ! ( boxinfo = jp2_boxinfolookup ( type ) ) ) { return 0 ; } box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; return box ; }
","<S2SV_ModStart> ( box = jp2_box_create0 ( <S2SV_ModEnd> ) ) ) <S2SV_ModStart> 0 ; } <S2SV_ModEnd> box -> type
",mdadams@jasper/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,CVE-2017-6850,https://github.com/mdadams/jasper/commit/e96fc4fdd525fa0ede28074a7e2b1caf94b58b0d,2017-03-15T14:59Z
CWE-416,"CWE-416 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }
","<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) { <S2SV_EndBug> if ( eob > 1 ) <S2SV_StartBug> vp9_iwht4x4_16_add ( input , dest , stride ) ; <S2SV_EndBug> else <S2SV_StartBug> vp9_iwht4x4_1_add ( input , dest , stride ) ; <S2SV_EndBug> }
","<S2SV_ModStart> vp9_iwht4x4_add ( const tran_low_t <S2SV_ModEnd> * input , <S2SV_ModStart> > 1 ) vpx_iwht4x4_16_add <S2SV_ModEnd> ( input , <S2SV_ModStart> ) ; else vpx_iwht4x4_1_add <S2SV_ModEnd> ( input ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static int kvm_vm_ioctl_assign_device ( struct kvm * kvm , struct kvm_assigned_pci_dev * assigned_dev ) { int r = 0 , idx ; struct kvm_assigned_dev_kernel * match ; struct pci_dev * dev ; <S2SV_StartBug> if ( ! ( assigned_dev -> flags & KVM_DEV_ASSIGN_ENABLE_IOMMU ) ) <S2SV_EndBug> return - EINVAL ; mutex_lock ( & kvm -> lock ) ; idx = srcu_read_lock ( & kvm -> srcu ) ; match = kvm_find_assigned_dev ( & kvm -> arch . assigned_dev_head , assigned_dev -> assigned_dev_id ) ; if ( match ) { r = - EEXIST ; goto out ; } match = kzalloc ( sizeof ( struct kvm_assigned_dev_kernel ) , GFP_KERNEL ) ; if ( match == NULL ) { printk ( KERN_INFO ""%s:<S2SV_blank>Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory\\n"" , __func__ ) ; r = - ENOMEM ; goto out ; } dev = pci_get_domain_bus_and_slot ( assigned_dev -> segnr , assigned_dev -> busnr , assigned_dev -> devfn ) ; if ( ! dev ) { printk ( KERN_INFO ""%s:<S2SV_blank>host<S2SV_blank>device<S2SV_blank>not<S2SV_blank>found\\n"" , __func__ ) ; r = - EINVAL ; goto out_free ; } <S2SV_StartBug> if ( pci_enable_device ( dev ) ) { <S2SV_EndBug> printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>enable<S2SV_blank>PCI<S2SV_blank>device\\n"" , __func__ ) ; r = - EBUSY ; goto out_put ; } r = pci_request_regions ( dev , ""kvm_assigned_device"" ) ; if ( r ) { printk ( KERN_INFO ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>access<S2SV_blank>to<S2SV_blank>device<S2SV_blank>regions\\n"" , __func__ ) ; goto out_disable ; } pci_reset_function ( dev ) ; pci_save_state ( dev ) ; match -> pci_saved_state = pci_store_saved_state ( dev ) ; if ( ! match -> pci_saved_state ) printk ( KERN_DEBUG ""%s:<S2SV_blank>Couldn\'t<S2SV_blank>store<S2SV_blank>%s<S2SV_blank>saved<S2SV_blank>state\\n"" , __func__ , dev_name ( & dev -> dev ) ) ; match -> assigned_dev_id = assigned_dev -> assigned_dev_id ; match -> host_segnr = assigned_dev -> segnr ; match -> host_busnr = assigned_dev -> busnr ; match -> host_devfn = assigned_dev -> devfn ; match -> flags = assigned_dev -> flags ; match -> dev = dev ; spin_lock_init ( & match -> intx_lock ) ; match -> irq_source_id = - 1 ; match -> kvm = kvm ; match -> ack_notifier . irq_acked = kvm_assigned_dev_ack_irq ; list_add ( & match -> list , & kvm -> arch . assigned_dev_head ) ; if ( ! kvm -> arch . iommu_domain ) { r = kvm_iommu_map_guest ( kvm ) ; if ( r ) goto out_list_del ; } r = kvm_assign_device ( kvm , match ) ; if ( r ) goto out_list_del ; out : srcu_read_unlock ( & kvm -> srcu , idx ) ; mutex_unlock ( & kvm -> lock ) ; return r ; out_list_del : if ( pci_load_and_free_saved_state ( dev , & match -> pci_saved_state ) ) printk ( KERN_INFO ""%s:<S2SV_blank>Couldn\'t<S2SV_blank>reload<S2SV_blank>%s<S2SV_blank>saved<S2SV_blank>state\\n"" , __func__ , dev_name ( & dev -> dev ) ) ; list_del ( & match -> list ) ; pci_release_regions ( dev ) ; out_disable : pci_disable_device ( dev ) ; out_put : pci_dev_put ( dev ) ; out_free : kfree ( match ) ; srcu_read_unlock ( & kvm -> srcu , idx ) ; mutex_unlock ( & kvm -> lock ) ; return r ; }
","<S2SV_ModStart> * dev ; u8 header_type ; <S2SV_ModStart> out_free ; } pci_read_config_byte ( dev , PCI_HEADER_TYPE , & header_type ) ; if ( ( header_type & PCI_HEADER_TYPE ) != PCI_HEADER_TYPE_NORMAL ) { r = - EPERM ; goto out_put ; } r = probe_sysfs_permissions ( dev ) ; if ( r ) goto out_put ;
",torvalds@linux/c4e7f9022e506c6635a5037713c37118e23193e4,CVE-2011-4347,https://github.com/torvalds/linux/commit/c4e7f9022e506c6635a5037713c37118e23193e4,2013-06-08T13:05Z
CWE-119,"CWE-119 static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; <S2SV_StartBug> for ( cnt = 0 , i = 0 ; cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { <S2SV_EndBug> Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) vstart += verdef -> vd_aux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } <S2SV_StartBug> i += verdef -> vd_next ; <S2SV_EndBug> } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
","<S2SV_ModStart> = 0 ; i >= 0 && <S2SV_ModStart> out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; }
",radare@radare2/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4,CVE-2017-15385,https://github.com/radare/radare2/commit/21a6f570ba33fa9f52f1bba87f07acc4e8c178f4,2017-10-16T22:29Z
CWE-404,"CWE-404 static int nfs4_callback_svc ( void * vrqstp ) { int err ; struct svc_rqst * rqstp = vrqstp ; set_freezable ( ) ; <S2SV_StartBug> while ( ! kthread_should_stop ( ) ) { <S2SV_EndBug> err = svc_recv ( rqstp , MAX_SCHEDULE_TIMEOUT ) ; if ( err == - EAGAIN || err == - EINTR ) continue ; svc_process ( rqstp ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> while ( ! kthread_freezable_should_stop ( NULL <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { if ( signal_pending ( current ) ) flush_signals ( current ) ; <S2SV_ModStart> ) ; } svc_exit_thread ( rqstp ) ; module_put_and_exit ( 0 ) ;
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-200,"CWE-200 int readfile ( char_u * fname , char_u * sfname , linenr_T from , linenr_T lines_to_skip , linenr_T lines_to_read , exarg_T * eap , int flags ) { int fd = 0 ; int newfile = ( flags & READ_NEW ) ; int check_readonly ; int filtering = ( flags & READ_FILTER ) ; int read_stdin = ( flags & READ_STDIN ) ; int read_buffer = ( flags & READ_BUFFER ) ; int read_fifo = ( flags & READ_FIFO ) ; int set_options = newfile || read_buffer || ( eap != NULL && eap -> read_edit ) ; linenr_T read_buf_lnum = 1 ; colnr_T read_buf_col = 0 ; char_u c ; linenr_T lnum = from ; char_u * ptr = NULL ; char_u * buffer = NULL ; char_u * new_buffer = NULL ; char_u * line_start = NULL ; int wasempty ; colnr_T len ; long size = 0 ; char_u * p ; off_T filesize = 0 ; int skip_read = FALSE ; # ifdef FEAT_CRYPT char_u * cryptkey = NULL ; int did_ask_for_key = FALSE ; # endif # ifdef FEAT_PERSISTENT_UNDO context_sha256_T sha_ctx ; int read_undo_file = FALSE ; # endif int split = 0 ; # define UNKNOWN 0x0fffffff linenr_T linecnt ; int error = FALSE ; int ff_error = EOL_UNKNOWN ; long linerest = 0 ; # ifdef UNIX int perm = 0 ; int swap_mode = - 1 ; # else int perm ; # endif int fileformat = 0 ; int keep_fileformat = FALSE ; stat_T st ; int file_readonly ; linenr_T skip_count = 0 ; linenr_T read_count = 0 ; int msg_save = msg_scroll ; linenr_T read_no_eol_lnum = 0 ; int try_mac ; int try_dos ; int try_unix ; int file_rewind = FALSE ; # ifdef FEAT_MBYTE int can_retry ; linenr_T conv_error = 0 ; linenr_T illegal_byte = 0 ; int keep_dest_enc = FALSE ; int bad_char_behavior = BAD_REPLACE ; char_u * tmpname = NULL ; int fio_flags = 0 ; char_u * fenc ; int fenc_alloced ; char_u * fenc_next = NULL ; int advance_fenc = FALSE ; long real_size = 0 ; # ifdef USE_ICONV iconv_t iconv_fd = ( iconv_t ) - 1 ; # ifdef FEAT_EVAL int did_iconv = FALSE ; # endif # endif int converted = FALSE ; int notconverted = FALSE ; char_u conv_rest [ CONV_RESTLEN ] ; int conv_restlen = 0 ; # endif # ifdef FEAT_AUTOCMD buf_T * old_curbuf ; char_u * old_b_ffname ; char_u * old_b_fname ; int using_b_ffname ; int using_b_fname ; # endif # ifdef FEAT_AUTOCMD au_did_filetype = FALSE ; # endif curbuf -> b_no_eol_lnum = 0 ; if ( curbuf -> b_ffname == NULL && ! filtering && fname != NULL && vim_strchr ( p_cpo , CPO_FNAMER ) != NULL && ! ( flags & READ_DUMMY ) ) { if ( set_rw_fname ( fname , sfname ) == FAIL ) return FAIL ; } # ifdef FEAT_AUTOCMD old_curbuf = curbuf ; old_b_ffname = curbuf -> b_ffname ; old_b_fname = curbuf -> b_fname ; using_b_ffname = ( fname == curbuf -> b_ffname ) || ( sfname == curbuf -> b_ffname ) ; using_b_fname = ( fname == curbuf -> b_fname ) || ( sfname == curbuf -> b_fname ) ; # endif ex_no_reprint = TRUE ; need_fileinfo = FALSE ; if ( sfname == NULL ) sfname = fname ; # if defined ( UNIX ) fname = sfname ; # endif # ifdef FEAT_AUTOCMD if ( ! filtering && ! read_stdin && ! read_buffer ) { pos_T pos ; pos = curbuf -> b_op_start ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; if ( newfile ) { if ( apply_autocmds_exarg ( EVENT_BUFREADCMD , NULL , sfname , FALSE , curbuf , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif } else if ( apply_autocmds_exarg ( EVENT_FILEREADCMD , sfname , sfname , FALSE , NULL , eap ) ) # ifdef FEAT_EVAL return aborting ( ) ? FAIL : OK ; # else return OK ; # endif curbuf -> b_op_start = pos ; } # endif if ( ( shortmess ( SHM_OVER ) || curbuf -> b_help ) && p_verbose == 0 ) msg_scroll = FALSE ; else msg_scroll = TRUE ; if ( fname != NULL && * fname != NUL ) { p = fname + STRLEN ( fname ) ; if ( after_pathsep ( fname , p ) || STRLEN ( fname ) >= MAXPATHL ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""Illegal<S2SV_blank>file<S2SV_blank>name"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } } if ( ! read_stdin && ! read_buffer && ! read_fifo ) { # ifdef UNIX perm = mch_getperm ( fname ) ; if ( perm >= 0 && ! S_ISREG ( perm ) # ifdef S_ISFIFO && ! S_ISFIFO ( perm ) # endif # ifdef S_ISSOCK && ! S_ISSOCK ( perm ) # endif # ifdef OPEN_CHR_FILES && ! ( S_ISCHR ( perm ) && is_dev_fd_file ( fname ) ) # endif ) { int retval = FAIL ; if ( S_ISDIR ( perm ) ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; retval = NOTDONE ; } else filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>file"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return retval ; } # endif # if defined ( MSWIN ) if ( ! p_odev && mch_nodetype ( fname ) == NODE_WRITABLE ) { filemess ( curbuf , fname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>device<S2SV_blank>(disabled<S2SV_blank>with<S2SV_blank>\'opendevice\'<S2SV_blank>option)"" ) , 0 ) ; msg_end ( ) ; msg_scroll = msg_save ; return FAIL ; } # endif } set_file_options ( set_options , eap ) ; check_readonly = ( newfile && ( curbuf -> b_flags & BF_CHECK_RO ) ) ; if ( check_readonly && ! readonlymode ) curbuf -> b_p_ro = FALSE ; if ( newfile && ! read_stdin && ! read_buffer && ! read_fifo ) { if ( mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; # ifdef UNIX swap_mode = ( st . st_mode & 0644 ) | 0600 ; # endif # ifdef FEAT_CW_EDITOR ( void ) GetFSSpecFromPath ( curbuf -> b_ffname , & curbuf -> b_FSSpec ) ; # endif # ifdef VMS curbuf -> b_fab_rfm = st . st_fab_rfm ; curbuf -> b_fab_rat = st . st_fab_rat ; curbuf -> b_fab_mrs = st . st_fab_mrs ; # endif } else { curbuf -> b_mtime = 0 ; curbuf -> b_mtime_read = 0 ; curbuf -> b_orig_size = 0 ; curbuf -> b_orig_mode = 0 ; } curbuf -> b_flags &= ~ ( BF_NEW | BF_NEW_W ) ; } file_readonly = FALSE ; if ( read_stdin ) { # if defined ( MSWIN ) setmode ( 0 , O_BINARY ) ; # endif } else if ( ! read_buffer ) { # ifdef USE_MCH_ACCESS if ( # ifdef UNIX ! ( perm & 0222 ) || # endif mch_access ( ( char * ) fname , W_OK ) ) file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; # else if ( ! newfile || readonlymode || ( fd = mch_open ( ( char * ) fname , O_RDWR | O_EXTRA , 0 ) ) < 0 ) { file_readonly = TRUE ; fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ; } # endif } if ( fd < 0 ) { # ifndef UNIX int isdir_f ; # endif msg_scroll = msg_save ; # ifndef UNIX isdir_f = ( mch_isdir ( fname ) ) ; perm = mch_getperm ( fname ) ; if ( isdir_f ) { filemess ( curbuf , sfname , ( char_u * ) _ ( ""is<S2SV_blank>a<S2SV_blank>directory"" ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } else # endif if ( newfile ) { if ( perm < 0 # ifdef ENOENT && errno == ENOENT # endif ) { curbuf -> b_flags |= BF_NEW ; # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; return FAIL ; } # endif } if ( dir_of_file_exists ( fname ) ) filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>File]"" ) , 0 ) ; else filemess ( curbuf , sfname , ( char_u * ) _ ( ""[New<S2SV_blank>DIRECTORY]"" ) , 0 ) ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif # ifdef FEAT_MBYTE if ( eap != NULL ) set_forced_fenc ( eap ) ; # endif # ifdef FEAT_AUTOCMD apply_autocmds_exarg ( EVENT_BUFNEWFILE , sfname , sfname , FALSE , curbuf , eap ) ; # endif save_file_ff ( curbuf ) ; # if defined ( FEAT_AUTOCMD ) && defined ( FEAT_EVAL ) if ( aborting ( ) ) return FAIL ; # endif return OK ; } else { filemess ( curbuf , sfname , ( char_u * ) ( # ifdef EFBIG ( errno == EFBIG ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif # ifdef EOVERFLOW ( errno == EOVERFLOW ) ? _ ( ""[File<S2SV_blank>too<S2SV_blank>big]"" ) : # endif _ ( ""[Permission<S2SV_blank>Denied]"" ) ) , 0 ) ; curbuf -> b_p_ro = TRUE ; } } return FAIL ; } if ( ( check_readonly && file_readonly ) || curbuf -> b_help ) curbuf -> b_p_ro = TRUE ; if ( set_options ) { if ( ! read_buffer ) { curbuf -> b_p_eol = TRUE ; curbuf -> b_start_eol = TRUE ; } # ifdef FEAT_MBYTE curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; # endif } # ifdef FEAT_QUICKFIX if ( ! bt_dontwrite ( curbuf ) ) # endif { check_need_swap ( newfile ) ; # ifdef FEAT_AUTOCMD if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) ) ) { EMSG ( _ ( e_auchangedbuf ) ) ; if ( ! read_buffer ) close ( fd ) ; return FAIL ; } # endif # ifdef UNIX if ( swap_mode > 0 && curbuf -> b_ml . ml_mfp != NULL && curbuf -> b_ml . ml_mfp -> mf_fname != NULL ) <S2SV_StartBug> ( void ) mch_setperm ( curbuf -> b_ml . ml_mfp -> mf_fname , ( long ) swap_mode ) ; <S2SV_EndBug> # endif } # if defined ( HAS_SWAP_EXISTS_ACTION ) if ( swap_exists_action == SEA_QUIT ) { if ( ! read_buffer && ! read_stdin ) close ( fd ) ; return FAIL ; } # endif ++ no_wait_return ; curbuf -> b_op_start . lnum = ( ( from == 0 ) ? 1 : from ) ; curbuf -> b_op_start . col = 0 ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; # ifdef FEAT_AUTOCMD if ( ! read_buffer ) { int m = msg_scroll ; int n = msg_scrolled ; if ( ! read_stdin ) close ( fd ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( read_stdin ) apply_autocmds_exarg ( EVENT_STDINREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile ) apply_autocmds_exarg ( EVENT_BUFREADPRE , NULL , sfname , FALSE , curbuf , eap ) ; else apply_autocmds_exarg ( EVENT_FILEREADPRE , sfname , sfname , FALSE , NULL , eap ) ; try_mac = ( vim_strchr ( p_ffs , 'm' ) != NULL ) ; try_dos = ( vim_strchr ( p_ffs , 'd' ) != NULL ) ; try_unix = ( vim_strchr ( p_ffs , 'x' ) != NULL ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) { -- no_wait_return ; msg_scroll = msg_save ; curbuf -> b_p_ro = TRUE ; return FAIL ; } # endif if ( ! read_stdin && ( curbuf != old_curbuf || ( using_b_ffname && ( old_b_ffname != curbuf -> b_ffname ) ) || ( using_b_fname && ( old_b_fname != curbuf -> b_fname ) ) || ( fd = mch_open ( ( char * ) fname , O_RDONLY | O_EXTRA , 0 ) ) < 0 ) ) { -- no_wait_return ; msg_scroll = msg_save ; if ( fd < 0 ) EMSG ( _ ( ""E200:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>made<S2SV_blank>the<S2SV_blank>file<S2SV_blank>unreadable"" ) ) ; else EMSG ( _ ( ""E201:<S2SV_blank>*ReadPre<S2SV_blank>autocommands<S2SV_blank>must<S2SV_blank>not<S2SV_blank>change<S2SV_blank>current<S2SV_blank>buffer"" ) ) ; curbuf -> b_p_ro = TRUE ; return FAIL ; } } # endif wasempty = ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ; if ( ! recoverymode && ! filtering && ! ( flags & READ_DUMMY ) ) { if ( read_stdin ) { # ifndef ALWAYS_USE_GUI mch_msg ( _ ( ""Vim:<S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin...\\n"" ) ) ; # endif # ifdef FEAT_GUI if ( gui . in_use && ! gui . dying && ! gui . starting ) { p = ( char_u * ) _ ( ""Reading<S2SV_blank>from<S2SV_blank>stdin..."" ) ; gui_write ( p , ( int ) STRLEN ( p ) ) ; } # endif } else if ( ! read_buffer ) filemess ( curbuf , sfname , ( char_u * ) """" , 0 ) ; } msg_scroll = FALSE ; linecnt = curbuf -> b_ml . ml_line_count ; # ifdef FEAT_MBYTE if ( eap != NULL && eap -> bad_char != 0 ) { bad_char_behavior = eap -> bad_char ; if ( set_options ) curbuf -> b_bad_char = eap -> bad_char ; } else curbuf -> b_bad_char = 0 ; if ( eap != NULL && eap -> force_enc != 0 ) { fenc = enc_canonize ( eap -> cmd + eap -> force_enc ) ; fenc_alloced = TRUE ; keep_dest_enc = TRUE ; } else if ( curbuf -> b_p_bin ) { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else if ( curbuf -> b_help ) { char_u firstline [ 80 ] ; int fc ; fenc = ( char_u * ) ""latin1"" ; c = enc_utf8 ; if ( ! c && ! read_stdin ) { fc = fname [ STRLEN ( fname ) - 1 ] ; if ( TOLOWER_ASC ( fc ) == 'x' ) { len = read_eintr ( fd , firstline , 80 ) ; vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) ; for ( p = firstline ; p < firstline + len ; ++ p ) if ( * p >= 0x80 ) { c = TRUE ; break ; } } } if ( c ) { fenc_next = fenc ; fenc = ( char_u * ) ""utf-8"" ; if ( ! enc_utf8 ) keep_dest_enc = TRUE ; } fenc_alloced = FALSE ; } else if ( * p_fencs == NUL ) { fenc = curbuf -> b_p_fenc ; fenc_alloced = FALSE ; } else { fenc_next = p_fencs ; fenc = next_fenc ( & fenc_next ) ; fenc_alloced = TRUE ; } # endif retry : if ( file_rewind ) { if ( read_buffer ) { read_buf_lnum = 1 ; read_buf_col = 0 ; } else if ( read_stdin || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) != 0 ) { error = TRUE ; goto failed ; } while ( lnum > from ) ml_delete ( lnum -- , FALSE ) ; file_rewind = FALSE ; # ifdef FEAT_MBYTE if ( set_options ) { curbuf -> b_p_bomb = FALSE ; curbuf -> b_start_bomb = FALSE ; } conv_error = 0 ; # endif } if ( keep_fileformat ) keep_fileformat = FALSE ; else { if ( eap != NULL && eap -> force_ff != 0 ) { fileformat = get_fileformat_force ( curbuf , eap ) ; try_unix = try_dos = try_mac = FALSE ; } else if ( curbuf -> b_p_bin ) fileformat = EOL_UNIX ; else if ( * p_ffs == NUL ) fileformat = get_fileformat ( curbuf ) ; else fileformat = EOL_UNKNOWN ; } # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif if ( advance_fenc ) { advance_fenc = FALSE ; if ( eap != NULL && eap -> force_enc != 0 ) { notconverted = TRUE ; conv_error = 0 ; if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; if ( fenc_next != NULL ) { fenc = next_fenc ( & fenc_next ) ; fenc_alloced = ( fenc_next != NULL ) ; } else { fenc = ( char_u * ) """" ; fenc_alloced = FALSE ; } } if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; tmpname = NULL ; } } fio_flags = 0 ; converted = need_conversion ( fenc ) ; if ( converted ) { if ( STRCMP ( fenc , ENC_UCSBOM ) == 0 ) fio_flags = FIO_UCSBOM ; else if ( enc_utf8 || STRCMP ( p_enc , ""latin1"" ) == 0 ) fio_flags = get_fio_flags ( fenc ) ; # ifdef WIN3264 if ( fio_flags == 0 ) fio_flags = get_win_fio_flags ( fenc ) ; # endif # ifdef MACOS_CONVERT if ( fio_flags == 0 ) fio_flags = get_mac_fio_flags ( fenc ) ; # endif # ifdef USE_ICONV if ( fio_flags == 0 # ifdef FEAT_EVAL && ! did_iconv # endif ) iconv_fd = ( iconv_t ) my_iconv_open ( enc_utf8 ? ( char_u * ) ""utf-8"" : p_enc , fenc ) ; # endif # ifdef FEAT_EVAL if ( fio_flags == 0 && ! read_stdin && ! read_buffer && * p_ccv != NUL && ! read_fifo # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { # ifdef USE_ICONV did_iconv = FALSE ; # endif if ( tmpname == NULL ) { tmpname = readfile_charconvert ( fname , fenc , & fd ) ; if ( tmpname == NULL ) { advance_fenc = TRUE ; if ( fd < 0 ) { EMSG ( _ ( ""E202:<S2SV_blank>Conversion<S2SV_blank>made<S2SV_blank>file<S2SV_blank>unreadable!"" ) ) ; error = TRUE ; goto failed ; } goto retry ; } } } else # endif { if ( fio_flags == 0 # ifdef USE_ICONV && iconv_fd == ( iconv_t ) - 1 # endif ) { advance_fenc = TRUE ; goto retry ; } } } can_retry = ( * fenc != NUL && ! read_stdin && ! read_fifo && ! keep_dest_enc ) ; # endif if ( ! skip_read ) { linerest = 0 ; filesize = 0 ; skip_count = lines_to_skip ; read_count = lines_to_read ; # ifdef FEAT_MBYTE conv_restlen = 0 ; # endif # ifdef FEAT_PERSISTENT_UNDO read_undo_file = ( newfile && ( flags & READ_KEEP_UNDO ) == 0 && curbuf -> b_ffname != NULL && curbuf -> b_p_udf && ! filtering && ! read_fifo && ! read_stdin && ! read_buffer ) ; if ( read_undo_file ) sha256_start ( & sha_ctx ) ; # endif # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } # endif } while ( ! error && ! got_int ) { # if VIM_SIZEOF_INT <= 2 if ( linerest >= 0x7ff0 ) { ++ split ; * ptr = NL ; size = 1 ; } else # endif { if ( ! skip_read ) { # if VIM_SIZEOF_INT > 2 # if defined ( SSIZE_MAX ) && ( SSIZE_MAX < 0x10000L ) size = SSIZE_MAX ; # else size = 0x10000L ; # endif # else size = 0x7ff0L - linerest ; # endif for ( ; size >= 10 ; size = ( long ) ( ( long_u ) size >> 1 ) ) { if ( ( new_buffer = lalloc ( ( long_u ) ( size + linerest + 1 ) , FALSE ) ) != NULL ) break ; } if ( new_buffer == NULL ) { do_outofmem_msg ( ( long_u ) ( size * 2 + linerest + 1 ) ) ; error = TRUE ; break ; } if ( linerest ) mch_memmove ( new_buffer , ptr - linerest , ( size_t ) linerest ) ; vim_free ( buffer ) ; buffer = new_buffer ; ptr = buffer + linerest ; line_start = buffer ; # ifdef FEAT_MBYTE real_size = ( int ) size ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) size = size / ICONV_MULT ; else # endif if ( fio_flags & FIO_LATIN1 ) size = size / 2 ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) size = ( size * 2 / 3 ) & ~ 1 ; else if ( fio_flags & FIO_UCS4 ) size = ( size * 2 / 3 ) & ~ 3 ; else if ( fio_flags == FIO_UCSBOM ) size = size / ICONV_MULT ; # ifdef WIN3264 else if ( fio_flags & FIO_CODEPAGE ) size = size / ICONV_MULT ; # endif # ifdef MACOS_CONVERT else if ( fio_flags & FIO_MACROMAN ) size = size / ICONV_MULT ; # endif # endif # ifdef FEAT_MBYTE if ( conv_restlen > 0 ) { mch_memmove ( ptr , conv_rest , conv_restlen ) ; ptr += conv_restlen ; size -= conv_restlen ; } # endif if ( read_buffer ) { if ( read_buf_lnum > from ) size = 0 ; else { int n , ni ; long tlen ; tlen = 0 ; for ( ; ; ) { p = ml_get ( read_buf_lnum ) + read_buf_col ; n = ( int ) STRLEN ( p ) ; if ( ( int ) tlen + n + 1 > size ) { n = ( int ) ( size - tlen ) ; for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } read_buf_col += n ; break ; } else { for ( ni = 0 ; ni < n ; ++ ni ) { if ( p [ ni ] == NL ) ptr [ tlen ++ ] = NUL ; else ptr [ tlen ++ ] = p [ ni ] ; } ptr [ tlen ++ ] = NL ; read_buf_col = 0 ; if ( ++ read_buf_lnum > from ) { if ( ! curbuf -> b_p_eol ) -- tlen ; size = tlen ; break ; } } } } } else { size = read_eintr ( fd , ptr , size ) ; } # ifdef FEAT_CRYPT if ( filesize == 0 && size > 0 ) cryptkey = check_for_cryptkey ( cryptkey , ptr , & size , & filesize , newfile , sfname , & did_ask_for_key ) ; if ( cryptkey != NULL && curbuf -> b_cryptstate != NULL && size > 0 ) { if ( crypt_works_inplace ( curbuf -> b_cryptstate ) ) { crypt_decode_inplace ( curbuf -> b_cryptstate , ptr , size ) ; } else { char_u * newptr = NULL ; int decrypted_size ; decrypted_size = crypt_decode_alloc ( curbuf -> b_cryptstate , ptr , size , & newptr ) ; if ( size > 0 && decrypted_size == 0 ) continue ; if ( linerest == 0 ) { new_buffer = newptr ; } else { long_u new_size ; new_size = ( long_u ) ( decrypted_size + linerest + 1 ) ; new_buffer = lalloc ( new_size , FALSE ) ; if ( new_buffer == NULL ) { do_outofmem_msg ( new_size ) ; error = TRUE ; break ; } mch_memmove ( new_buffer , buffer , linerest ) ; if ( newptr != NULL ) mch_memmove ( new_buffer + linerest , newptr , decrypted_size ) ; } if ( new_buffer != NULL ) { vim_free ( buffer ) ; buffer = new_buffer ; new_buffer = NULL ; line_start = buffer ; ptr = buffer + linerest ; } size = decrypted_size ; } } # endif if ( size <= 0 ) { if ( size < 0 ) error = TRUE ; # ifdef FEAT_MBYTE else if ( conv_restlen > 0 ) { if ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = curbuf -> b_ml . ml_line_count - linecnt + 1 ; } else if ( illegal_byte == 0 ) illegal_byte = curbuf -> b_ml . ml_line_count - linecnt + 1 ; if ( bad_char_behavior == BAD_DROP ) { * ( ptr - conv_restlen ) = NUL ; conv_restlen = 0 ; } else { if ( bad_char_behavior != BAD_KEEP && ( fio_flags != 0 # ifdef USE_ICONV || iconv_fd != ( iconv_t ) - 1 # endif ) ) { while ( conv_restlen > 0 ) { * ( -- ptr ) = bad_char_behavior ; -- conv_restlen ; } } fio_flags = 0 ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif } } # endif } } skip_read = FALSE ; # ifdef FEAT_MBYTE if ( ( filesize == 0 # ifdef FEAT_CRYPT || ( cryptkey != NULL && filesize == crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) # endif ) && ( fio_flags == FIO_UCSBOM || ( ! curbuf -> b_p_bomb && tmpname == NULL && ( * fenc == 'u' || ( * fenc == NUL && enc_utf8 ) ) ) ) ) { char_u * ccname ; int blen ; if ( size < 2 || curbuf -> b_p_bin ) ccname = NULL ; else ccname = check_for_bom ( ptr , size , & blen , fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags ( fenc ) ) ; if ( ccname != NULL ) { filesize += blen ; size -= blen ; mch_memmove ( ptr , ptr + blen , ( size_t ) size ) ; if ( set_options ) { curbuf -> b_p_bomb = TRUE ; curbuf -> b_start_bomb = TRUE ; } } if ( fio_flags == FIO_UCSBOM ) { if ( ccname == NULL ) { advance_fenc = TRUE ; } else { if ( fenc_alloced ) vim_free ( fenc ) ; fenc = ccname ; fenc_alloced = FALSE ; } skip_read = TRUE ; goto retry ; } } ptr -= conv_restlen ; size += conv_restlen ; conv_restlen = 0 ; # endif if ( size <= 0 ) break ; # ifdef FEAT_MBYTE # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { const char * fromp ; char * top ; size_t from_size ; size_t to_size ; fromp = ( char * ) ptr ; from_size = size ; ptr += size ; top = ( char * ) ptr ; to_size = real_size - size ; while ( ( iconv ( iconv_fd , ( void * ) & fromp , & from_size , & top , & to_size ) == ( size_t ) - 1 && ICONV_ERRNO != ICONV_EINVAL ) || from_size > CONV_RESTLEN ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , ( char_u * ) top ) ; ++ fromp ; -- from_size ; if ( bad_char_behavior == BAD_KEEP ) { * top ++ = * ( fromp - 1 ) ; -- to_size ; } else if ( bad_char_behavior != BAD_DROP ) { * top ++ = bad_char_behavior ; -- to_size ; } } if ( from_size > 0 ) { mch_memmove ( conv_rest , ( char_u * ) fromp , from_size ) ; conv_restlen = ( int ) from_size ; } line_start = ptr - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( char_u * ) top - ptr ) ; } # endif # ifdef WIN3264 if ( fio_flags & FIO_CODEPAGE ) { char_u * src , * dst ; WCHAR ucs2buf [ 3 ] ; int ucs2len ; int codepage = FIO_GET_CP ( fio_flags ) ; int bytelen ; int found_bad ; char replstr [ 2 ] ; if ( bad_char_behavior > 0 ) replstr [ 0 ] = bad_char_behavior ; else replstr [ 0 ] = '?' ; replstr [ 1 ] = NUL ; src = ptr + real_size - size ; mch_memmove ( src , ptr , size ) ; dst = ptr ; size = size ; while ( size > 0 ) { found_bad = FALSE ; # ifdef CP_UTF8 if ( codepage == CP_UTF8 ) { bytelen = ( int ) utf_ptr2len_len ( src , size ) ; if ( bytelen > size ) { if ( bytelen <= CONV_RESTLEN ) break ; bytelen = size ; found_bad = TRUE ; } else { int u8c = utf_ptr2char ( src ) ; if ( u8c > 0xffff || ( * src >= 0x80 && bytelen == 1 ) ) found_bad = TRUE ; ucs2buf [ 0 ] = u8c ; ucs2len = 1 ; } } else # endif { for ( bytelen = 1 ; bytelen <= size && bytelen <= 3 ; ++ bytelen ) { ucs2len = MultiByteToWideChar ( codepage , MB_ERR_INVALID_CHARS , ( LPCSTR ) src , bytelen , ucs2buf , 3 ) ; if ( ucs2len > 0 ) break ; } if ( ucs2len == 0 ) { if ( size == 1 ) break ; found_bad = TRUE ; bytelen = 1 ; } } if ( ! found_bad ) { int i ; if ( enc_utf8 ) { for ( i = 0 ; i < ucs2len ; ++ i ) dst += utf_char2bytes ( ucs2buf [ i ] , dst ) ; } else { BOOL bad = FALSE ; int dstlen ; dstlen = WideCharToMultiByte ( enc_codepage , 0 , ( LPCWSTR ) ucs2buf , ucs2len , ( LPSTR ) dst , ( int ) ( src - dst ) , replstr , & bad ) ; if ( bad ) found_bad = TRUE ; else dst += dstlen ; } } if ( found_bad ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , dst ) ; if ( bad_char_behavior != BAD_DROP ) { if ( bad_char_behavior == BAD_KEEP ) { mch_memmove ( dst , src , bytelen ) ; dst += bytelen ; } else * dst ++ = bad_char_behavior ; } } src += bytelen ; size -= bytelen ; } if ( size > 0 ) { mch_memmove ( conv_rest , src , size ) ; conv_restlen = size ; } size = ( long ) ( dst - ptr ) ; } else # endif # ifdef MACOS_CONVERT if ( fio_flags & FIO_MACROMAN ) { if ( macroman2enc ( ptr , & size , real_size ) == FAIL ) goto rewind_retry ; } else # endif if ( fio_flags != 0 ) { int u8c ; char_u * dest ; char_u * tail = NULL ; dest = ptr + real_size ; if ( fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8 ) { p = ptr + size ; if ( fio_flags == FIO_UTF8 ) { tail = ptr + size - 1 ; while ( tail > ptr && ( * tail & 0xc0 ) == 0x80 ) -- tail ; if ( tail + utf_byte2len ( * tail ) <= ptr + size ) tail = NULL ; else p = tail ; } } else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { p = ptr + ( size & ~ 1 ) ; if ( size & 1 ) tail = p ; if ( ( fio_flags & FIO_UTF16 ) && p > ptr ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( u8c >= 0xd800 && u8c <= 0xdbff ) tail = p ; else p += 2 ; } } else { p = ptr + ( size & ~ 3 ) ; if ( size & 3 ) tail = p ; } if ( tail != NULL ) { conv_restlen = ( int ) ( ( ptr + size ) - tail ) ; mch_memmove ( conv_rest , ( char_u * ) tail , conv_restlen ) ; size -= conv_restlen ; } while ( p > ptr ) { if ( fio_flags & FIO_LATIN1 ) u8c = * -- p ; else if ( fio_flags & ( FIO_UCS2 | FIO_UTF16 ) ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( * -- p << 8 ) ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( * -- p << 8 ) ; } if ( ( fio_flags & FIO_UTF16 ) && u8c >= 0xdc00 && u8c <= 0xdfff ) { int u16c ; if ( p == ptr ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } if ( fio_flags & FIO_ENDIAN_L ) { u16c = ( * -- p << 8 ) ; u16c += * -- p ; } else { u16c = * -- p ; u16c += ( * -- p << 8 ) ; } u8c = 0x10000 + ( ( u16c & 0x3ff ) << 10 ) + ( u8c & 0x3ff ) ; if ( u16c < 0xd800 || u16c > 0xdbff ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } else if ( fio_flags & FIO_UCS4 ) { if ( fio_flags & FIO_ENDIAN_L ) { u8c = ( unsigned ) * -- p << 24 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 8 ; u8c += * -- p ; } else { u8c = * -- p ; u8c += ( unsigned ) * -- p << 8 ; u8c += ( unsigned ) * -- p << 16 ; u8c += ( unsigned ) * -- p << 24 ; } } else { if ( * -- p < 0x80 ) u8c = * p ; else { len = utf_head_off ( ptr , p ) ; p -= len ; u8c = utf_ptr2char ( p ) ; if ( len == 0 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) continue ; if ( bad_char_behavior != BAD_KEEP ) u8c = bad_char_behavior ; } } } if ( enc_utf8 ) { dest -= utf_char2len ( u8c ) ; ( void ) utf_char2bytes ( u8c , dest ) ; } else { -- dest ; if ( u8c >= 0x100 ) { if ( can_retry ) goto rewind_retry ; if ( conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) ++ dest ; else if ( bad_char_behavior == BAD_KEEP ) * dest = u8c ; else if ( eap != NULL && eap -> bad_char != 0 ) * dest = bad_char_behavior ; else * dest = 0xBF ; } else * dest = u8c ; } } line_start = dest - linerest ; mch_memmove ( line_start , buffer , ( size_t ) linerest ) ; size = ( long ) ( ( ptr + real_size ) - dest ) ; ptr = dest ; } else if ( enc_utf8 && ! curbuf -> b_p_bin ) { int incomplete_tail = FALSE ; for ( p = ptr ; ; ++ p ) { int todo = ( int ) ( ( ptr + size ) - p ) ; int l ; if ( todo <= 0 ) break ; if ( * p >= 0x80 ) { l = utf_ptr2len_len ( p , todo ) ; if ( l > todo && ! incomplete_tail ) { if ( p > ptr || filesize > 0 ) incomplete_tail = TRUE ; if ( p > ptr ) { conv_restlen = todo ; mch_memmove ( conv_rest , p , conv_restlen ) ; size -= conv_restlen ; break ; } } if ( l == 1 || l > todo ) { if ( can_retry && ! incomplete_tail ) break ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 && conv_error == 0 ) conv_error = readfile_linenr ( linecnt , ptr , p ) ; # endif if ( conv_error == 0 && illegal_byte == 0 ) illegal_byte = readfile_linenr ( linecnt , ptr , p ) ; if ( bad_char_behavior == BAD_DROP ) { mch_memmove ( p , p + 1 , todo - 1 ) ; -- p ; -- size ; } else if ( bad_char_behavior != BAD_KEEP ) * p = bad_char_behavior ; } else p += l - 1 ; } } if ( p < ptr + size && ! incomplete_tail ) { rewind_retry : # if defined ( FEAT_EVAL ) && defined ( USE_ICONV ) if ( * p_ccv != NUL && iconv_fd != ( iconv_t ) - 1 ) did_iconv = TRUE ; else # endif advance_fenc = TRUE ; file_rewind = TRUE ; goto retry ; } } # endif filesize += size ; if ( fileformat == EOL_UNKNOWN ) { if ( try_dos || try_unix ) { if ( try_mac ) try_mac = 1 ; for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) { if ( ! try_unix || ( try_dos && p > ptr && p [ - 1 ] == CAR ) ) fileformat = EOL_DOS ; else fileformat = EOL_UNIX ; break ; } else if ( * p == CAR && try_mac ) try_mac ++ ; } if ( fileformat == EOL_UNIX && try_mac ) { try_mac = 1 ; try_unix = 1 ; for ( ; p >= ptr && * p != CAR ; p -- ) ; if ( p >= ptr ) { for ( p = ptr ; p < ptr + size ; ++ p ) { if ( * p == NL ) try_unix ++ ; else if ( * p == CAR ) try_mac ++ ; } if ( try_mac > try_unix ) fileformat = EOL_MAC ; } } else if ( fileformat == EOL_UNKNOWN && try_mac == 1 ) fileformat = default_fileformat ( ) ; } if ( fileformat == EOL_UNKNOWN && try_mac ) fileformat = EOL_MAC ; if ( fileformat == EOL_UNKNOWN ) fileformat = default_fileformat ( ) ; if ( set_options ) set_fileformat ( fileformat , OPT_LOCAL ) ; } } if ( fileformat == EOL_MAC ) { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != CAR && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else if ( c == NL ) * ptr = CAR ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } else { -- ptr ; while ( ++ ptr , -- size >= 0 ) { if ( ( c = * ptr ) != NUL && c != NL ) continue ; if ( c == NUL ) * ptr = NL ; else { if ( skip_count == 0 ) { * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( fileformat == EOL_DOS ) { if ( ptr > line_start && ptr [ - 1 ] == CAR ) { ptr [ - 1 ] = NUL ; -- len ; } else if ( ff_error != EOL_DOS ) { if ( try_unix && ! read_stdin && ( read_buffer || vim_lseek ( fd , ( off_T ) 0L , SEEK_SET ) == 0 ) ) { fileformat = EOL_UNIX ; if ( set_options ) set_fileformat ( EOL_UNIX , OPT_LOCAL ) ; file_rewind = TRUE ; keep_fileformat = TRUE ; goto retry ; } ff_error = EOL_DOS ; } } if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) { error = TRUE ; break ; } # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif ++ lnum ; if ( -- read_count == 0 ) { error = TRUE ; line_start = ptr ; break ; } } else -- skip_count ; line_start = ptr + 1 ; } } } linerest = ( long ) ( ptr - line_start ) ; ui_breakcheck ( ) ; } failed : if ( error && read_count == 0 ) error = FALSE ; if ( ! error && ! got_int && linerest != 0 && ! ( ! curbuf -> b_p_bin && fileformat == EOL_DOS && * line_start == Ctrl_Z && ptr == line_start + 1 ) ) { if ( set_options ) curbuf -> b_p_eol = FALSE ; * ptr = NUL ; len = ( colnr_T ) ( ptr - line_start + 1 ) ; if ( ml_append ( lnum , line_start , len , newfile ) == FAIL ) error = TRUE ; else { # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) sha256_update ( & sha_ctx , line_start , len ) ; # endif read_no_eol_lnum = ++ lnum ; } } if ( set_options ) save_file_ff ( curbuf ) ; # ifdef FEAT_CRYPT if ( curbuf -> b_cryptstate != NULL ) { crypt_free_state ( curbuf -> b_cryptstate ) ; curbuf -> b_cryptstate = NULL ; } if ( cryptkey != NULL && cryptkey != curbuf -> b_p_key ) crypt_free_key ( cryptkey ) ; # endif # ifdef FEAT_MBYTE if ( set_options ) set_string_option_direct ( ( char_u * ) ""fenc"" , - 1 , fenc , OPT_FREE | OPT_LOCAL , 0 ) ; if ( fenc_alloced ) vim_free ( fenc ) ; # ifdef USE_ICONV if ( iconv_fd != ( iconv_t ) - 1 ) { iconv_close ( iconv_fd ) ; iconv_fd = ( iconv_t ) - 1 ; } # endif # endif if ( ! read_buffer && ! read_stdin ) close ( fd ) ; # ifdef HAVE_FD_CLOEXEC else { int fdflags = fcntl ( fd , F_GETFD ) ; if ( fdflags >= 0 && ( fdflags & FD_CLOEXEC ) == 0 ) ( void ) fcntl ( fd , F_SETFD , fdflags | FD_CLOEXEC ) ; } # endif vim_free ( buffer ) ; # ifdef HAVE_DUP if ( read_stdin ) { close ( 0 ) ; ignored = dup ( 2 ) ; } # endif # ifdef FEAT_MBYTE if ( tmpname != NULL ) { mch_remove ( tmpname ) ; vim_free ( tmpname ) ; } # endif -- no_wait_return ; if ( ! recoverymode ) { if ( newfile && wasempty && ! ( curbuf -> b_ml . ml_flags & ML_EMPTY ) ) { # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 0 ; # endif ml_delete ( curbuf -> b_ml . ml_line_count , FALSE ) ; # ifdef FEAT_NETBEANS_INTG netbeansFireChanges = 1 ; # endif -- linecnt ; } linecnt = curbuf -> b_ml . ml_line_count - linecnt ; if ( filesize == 0 ) linecnt = 0 ; if ( newfile || read_buffer ) { redraw_curbuf_later ( NOT_VALID ) ; # ifdef FEAT_DIFF diff_invalidate ( curbuf ) ; # endif # ifdef FEAT_FOLDING foldUpdateAll ( curwin ) ; # endif } else if ( linecnt ) appended_lines_mark ( from , linecnt ) ; # ifndef ALWAYS_USE_GUI if ( read_stdin ) { settmode ( TMODE_RAW ) ; starttermcap ( ) ; screenclear ( ) ; } # endif if ( got_int ) { if ( ! ( flags & READ_DUMMY ) ) { filemess ( curbuf , sfname , ( char_u * ) _ ( e_interr ) , 0 ) ; if ( newfile ) curbuf -> b_p_ro = TRUE ; } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif return OK ; } if ( ! filtering && ! ( flags & READ_DUMMY ) ) { msg_add_fname ( curbuf , sfname ) ; c = FALSE ; # ifdef UNIX # ifdef S_ISFIFO if ( S_ISFIFO ( perm ) ) { STRCAT ( IObuff , _ ( ""[fifo/socket]"" ) ) ; c = TRUE ; } # else # ifdef S_IFIFO if ( ( perm & S_IFMT ) == S_IFIFO ) { STRCAT ( IObuff , _ ( ""[fifo]"" ) ) ; c = TRUE ; } # endif # ifdef S_IFSOCK if ( ( perm & S_IFMT ) == S_IFSOCK ) { STRCAT ( IObuff , _ ( ""[socket]"" ) ) ; c = TRUE ; } # endif # endif # ifdef OPEN_CHR_FILES if ( S_ISCHR ( perm ) ) { STRCAT ( IObuff , _ ( ""[character<S2SV_blank>special]"" ) ) ; c = TRUE ; } # endif # endif if ( curbuf -> b_p_ro ) { STRCAT ( IObuff , shortmess ( SHM_RO ) ? _ ( ""[RO]"" ) : _ ( ""[readonly]"" ) ) ; c = TRUE ; } if ( read_no_eol_lnum ) { msg_add_eol ( ) ; c = TRUE ; } if ( ff_error == EOL_DOS ) { STRCAT ( IObuff , _ ( ""[CR<S2SV_blank>missing]"" ) ) ; c = TRUE ; } if ( split ) { STRCAT ( IObuff , _ ( ""[long<S2SV_blank>lines<S2SV_blank>split]"" ) ) ; c = TRUE ; } # ifdef FEAT_MBYTE if ( notconverted ) { STRCAT ( IObuff , _ ( ""[NOT<S2SV_blank>converted]"" ) ) ; c = TRUE ; } else if ( converted ) { STRCAT ( IObuff , _ ( ""[converted]"" ) ) ; c = TRUE ; } # endif # ifdef FEAT_CRYPT if ( cryptkey != NULL ) { crypt_append_msg ( curbuf ) ; c = TRUE ; } # endif # ifdef FEAT_MBYTE if ( conv_error != 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[CONVERSION<S2SV_blank>ERROR<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) conv_error ) ; c = TRUE ; } else if ( illegal_byte > 0 ) { sprintf ( ( char * ) IObuff + STRLEN ( IObuff ) , _ ( ""[ILLEGAL<S2SV_blank>BYTE<S2SV_blank>in<S2SV_blank>line<S2SV_blank>%ld]"" ) , ( long ) illegal_byte ) ; c = TRUE ; } else # endif if ( error ) { STRCAT ( IObuff , _ ( ""[READ<S2SV_blank>ERRORS]"" ) ) ; c = TRUE ; } if ( msg_add_fileformat ( fileformat ) ) c = TRUE ; # ifdef FEAT_CRYPT if ( cryptkey != NULL ) msg_add_lines ( c , ( long ) linecnt , filesize - crypt_get_header_len ( crypt_get_method_nr ( curbuf ) ) ) ; else # endif msg_add_lines ( c , ( long ) linecnt , filesize ) ; vim_free ( keep_msg ) ; keep_msg = NULL ; msg_scrolled_ign = TRUE ; # ifdef ALWAYS_USE_GUI if ( read_stdin || read_buffer ) p = msg_may_trunc ( FALSE , IObuff ) ; else # endif p = msg_trunc_attr ( IObuff , FALSE , 0 ) ; if ( read_stdin || read_buffer || restart_edit != 0 || ( msg_scrolled != 0 && ! need_wait_return ) ) set_keep_msg ( p , 0 ) ; msg_scrolled_ign = FALSE ; } if ( newfile && ( error # ifdef FEAT_MBYTE || conv_error != 0 || ( illegal_byte > 0 && bad_char_behavior != BAD_KEEP ) # endif ) ) curbuf -> b_p_ro = TRUE ; u_clearline ( ) ; if ( exmode_active ) curwin -> w_cursor . lnum = from + linecnt ; else curwin -> w_cursor . lnum = from + 1 ; check_cursor_lnum ( ) ; beginline ( BL_WHITE | BL_FIX ) ; curbuf -> b_op_start . lnum = from + 1 ; curbuf -> b_op_start . col = 0 ; curbuf -> b_op_end . lnum = from + linecnt ; curbuf -> b_op_end . col = 0 ; # ifdef WIN32 if ( newfile && ! read_stdin && ! read_buffer && mch_stat ( ( char * ) fname , & st ) >= 0 ) { buf_store_time ( curbuf , & st , fname ) ; curbuf -> b_mtime_read = curbuf -> b_mtime ; } # endif } msg_scroll = msg_save ; # ifdef FEAT_VIMINFO check_marks_read ( ) ; # endif curbuf -> b_no_eol_lnum = read_no_eol_lnum ; if ( flags & READ_KEEP_UNDO ) u_find_first_changed ( ) ; # ifdef FEAT_PERSISTENT_UNDO if ( read_undo_file ) { char_u hash [ UNDO_HASH_SIZE ] ; sha256_finish ( & sha_ctx , hash ) ; u_read_undo ( NULL , hash , fname ) ; } # endif # ifdef FEAT_AUTOCMD if ( ! read_stdin && ! read_fifo && ( ! read_buffer || sfname != NULL ) ) { int m = msg_scroll ; int n = msg_scrolled ; if ( set_options ) save_file_ff ( curbuf ) ; msg_scroll = TRUE ; if ( filtering ) apply_autocmds_exarg ( EVENT_FILTERREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; else if ( newfile || ( read_buffer && sfname != NULL ) ) { apply_autocmds_exarg ( EVENT_BUFREADPOST , NULL , sfname , FALSE , curbuf , eap ) ; if ( ! au_did_filetype && * curbuf -> b_p_ft != NUL ) apply_autocmds ( EVENT_FILETYPE , curbuf -> b_p_ft , curbuf -> b_fname , TRUE , curbuf ) ; } else apply_autocmds_exarg ( EVENT_FILEREADPOST , sfname , sfname , FALSE , NULL , eap ) ; if ( msg_scrolled == n ) msg_scroll = m ; # ifdef FEAT_EVAL if ( aborting ( ) ) return FAIL ; # endif } # endif if ( recoverymode && error ) return FAIL ; return OK ; }
","<S2SV_ModStart> != NULL ) { char_u * swap_fname = <S2SV_ModEnd> curbuf -> b_ml <S2SV_ModStart> ml_mfp -> mf_fname ; if ( ( swap_mode & 044 ) == 040 ) { stat_T swap_st ; if ( mch_stat ( ( char * ) swap_fname , & swap_st ) >= 0 && st . st_gid != swap_st . st_gid && fchown ( curbuf -> b_ml . ml_mfp -> mf_fd , - 1 , st . st_gid ) == - 1 ) swap_mode &= 0600 ; } ( void ) mch_setperm ( swap_fname <S2SV_ModStart> swap_mode ) ; }
",vim@vim/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8,CVE-2017-17087,https://github.com/vim/vim/commit/5a73e0ca54c77e067c3b12ea6f35e3e8681e8cf8,2017-12-01T08:29Z
CWE-000,"CWE-000 long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
","<S2SV_ModStart> long len ; qboolean isLocalConfig ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;
",JACoders@OpenJK/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,2017-03-14T22:59Z
CWE-119,"CWE-119 IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { <S2SV_StartBug> UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; <S2SV_EndBug> ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || <S2SV_StartBug> ( ps_pps -> i1_num_tile_columns > ps_sps -> i2_pic_wd_in_ctb ) || <S2SV_EndBug> ( ps_pps -> i1_num_tile_rows < 1 ) || <S2SV_StartBug> ( ps_pps -> i1_num_tile_rows > ps_sps -> i2_pic_ht_in_ctb ) ) <S2SV_EndBug> return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; ps_codec -> i4_pps_done = 1 ; return ret ; }
","<S2SV_ModStart> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; <S2SV_ModStart> -> i1_num_tile_columns > max_tile_cols <S2SV_ModEnd> ) || ( <S2SV_ModStart> -> i1_num_tile_rows > max_tile_rows <S2SV_ModEnd> ) ) return
",external@libhevc/ebaa71da6362c497310377df509651974401d258,CVE-2017-0637,https://android.googlesource.com/platform/external/libhevc/+/ebaa71da6362c497310377df509651974401d258,2017-06-14T13:29Z
CWE-000,"CWE-000 static int check_options ( int argc , char * * argv , char * operation ) { int i = 0 ; int num_found = 0 ; char config_file [ FN_REFLEN ] ; char plugin_name [ FN_REFLEN ] ; const char * basedir_prefix = ""--basedir="" ; int basedir_len = strlen ( basedir_prefix ) ; const char * datadir_prefix = ""--datadir="" ; int datadir_len = strlen ( datadir_prefix ) ; const char * plugin_dir_prefix = ""--plugin_dir="" ; int plugin_dir_len = strlen ( plugin_dir_prefix ) ; strcpy ( plugin_name , """" ) ; for ( i = 0 ; i < argc && num_found < 5 ; i ++ ) { if ( ! argv [ i ] ) { continue ; } if ( ( strcasecmp ( argv [ i ] , ""ENABLE"" ) == 0 ) || ( strcasecmp ( argv [ i ] , ""DISABLE"" ) == 0 ) ) { strcpy ( operation , argv [ i ] ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , basedir_prefix , basedir_len ) == 0 ) && ! opt_basedir ) { opt_basedir = my_strndup ( argv [ i ] + basedir_len , strlen ( argv [ i ] ) - basedir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , datadir_prefix , datadir_len ) == 0 ) && ! opt_datadir ) { opt_datadir = my_strndup ( argv [ i ] + datadir_len , strlen ( argv [ i ] ) - datadir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else if ( ( strncasecmp ( argv [ i ] , plugin_dir_prefix , plugin_dir_len ) == 0 ) && ! opt_plugin_dir ) { opt_plugin_dir = my_strndup ( argv [ i ] + plugin_dir_len , strlen ( argv [ i ] ) - plugin_dir_len , MYF ( MY_FAE ) ) ; num_found ++ ; } else { <S2SV_StartBug> strcpy ( plugin_name , argv [ i ] ) ; <S2SV_EndBug> strcpy ( config_file , argv [ i ] ) ; strcat ( config_file , "".ini"" ) ; } } if ( ! opt_basedir ) { fprintf ( stderr , ""ERROR:<S2SV_blank>Missing<S2SV_blank>--basedir<S2SV_blank>option.\\n"" ) ; return 1 ; } if ( ! opt_datadir ) { fprintf ( stderr , ""ERROR:<S2SV_blank>Missing<S2SV_blank>--datadir<S2SV_blank>option.\\n"" ) ; return 1 ; } if ( ! opt_plugin_dir ) { fprintf ( stderr , ""ERROR:<S2SV_blank>Missing<S2SV_blank>--plugin_dir<S2SV_blank>option.\\n"" ) ; return 1 ; } else if ( strlen ( plugin_name ) > 0 ) { if ( load_plugin_data ( plugin_name , config_file ) ) { return 1 ; } if ( strcasecmp ( plugin_data . name , plugin_name ) != 0 ) { fprintf ( stderr , ""ERROR:<S2SV_blank>plugin<S2SV_blank>name<S2SV_blank>requested<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>config<S2SV_blank>"" ""file<S2SV_blank>data.\\n"" ) ; return 1 ; } } else { fprintf ( stderr , ""ERROR:<S2SV_blank>No<S2SV_blank>plugin<S2SV_blank>specified.\\n"" ) ; return 1 ; } if ( ( strlen ( operation ) == 0 ) ) { fprintf ( stderr , ""ERROR:<S2SV_blank>missing<S2SV_blank>operation.<S2SV_blank>Please<S2SV_blank>specify<S2SV_blank>either<S2SV_blank>"" ""\'<plugin><S2SV_blank>ENABLE\'<S2SV_blank>or<S2SV_blank>\'<plugin><S2SV_blank>DISABLE\'.\\n"" ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> } else { if ( strlen ( argv [ i ] ) + 4 + 1 > FN_REFLEN ) { fprintf ( stderr , ""ERROR:<S2SV_blank>argument<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" ) ; return 1 ; }
",mysql@mysql-server/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,CVE-2016-0546,https://github.com/mysql/mysql-server/commit/0dbd5a8797ed4bd18e8b883988fb62177eb0f73f,2016-01-21T03:01Z
CWE-416,"CWE-416 static zend_always_inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , zend_long elements , int objprops ) { while ( elements -- > 0 ) { zval key , * data , d , * old_data ; zend_ulong idx ; ZVAL_UNDEF ( & key ) ; if ( ! php_var_unserialize_internal ( & key , p , max , NULL , classes ) ) { zval_dtor ( & key ) ; return 0 ; } data = NULL ; ZVAL_UNDEF ( & d ) ; if ( ! objprops ) { if ( Z_TYPE ( key ) == IS_LONG ) { idx = Z_LVAL ( key ) ; numeric_key : if ( UNEXPECTED ( ( old_data = zend_hash_index_find ( ht , idx ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_index_update ( ht , idx , & d ) ; } else { data = zend_hash_index_add_new ( ht , idx , & d ) ; } } else if ( Z_TYPE ( key ) == IS_STRING ) { if ( UNEXPECTED ( ZEND_HANDLE_NUMERIC ( Z_STR ( key ) , idx ) ) ) { goto numeric_key ; } if ( UNEXPECTED ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) ) { var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else { zval_dtor ( & key ) ; return 0 ; } } else { if ( EXPECTED ( Z_TYPE ( key ) == IS_STRING ) ) { string_key : if ( ( old_data = zend_hash_find ( ht , Z_STR ( key ) ) ) != NULL ) { if ( Z_TYPE_P ( old_data ) == IS_INDIRECT ) { old_data = Z_INDIRECT_P ( old_data ) ; } var_push_dtor ( var_hash , old_data ) ; data = zend_hash_update_ind ( ht , Z_STR ( key ) , & d ) ; } else { data = zend_hash_add_new ( ht , Z_STR ( key ) , & d ) ; } } else if ( Z_TYPE ( key ) == IS_LONG ) { convert_to_string ( & key ) ; goto string_key ; } else { zval_dtor ( & key ) ; return 0 ; } } if ( ! php_var_unserialize_internal ( data , p , max , var_hash , classes ) ) { zval_dtor ( & key ) ; return 0 ; } <S2SV_StartBug> if ( UNEXPECTED ( Z_ISUNDEF_P ( data ) ) ) { <S2SV_EndBug> if ( Z_TYPE ( key ) == IS_LONG ) { zend_hash_index_del ( ht , Z_LVAL ( key ) ) ; } else { zend_hash_del_ind ( ht , Z_STR ( key ) ) ; } } else { var_push_dtor ( var_hash , data ) ; <S2SV_StartBug> } <S2SV_EndBug> zval_dtor ( & key ) ; if ( elements && * ( * p - 1 ) != ';' && * ( * p - 1 ) != '}' ) { ( * p ) -- ; return 0 ; } } return 1 ; }
","<S2SV_ModStart> 0 ; } <S2SV_ModEnd> var_push_dtor ( var_hash <S2SV_ModStart> data ) ; <S2SV_ModEnd> zval_dtor ( &
",php@php-src/1a23ebc1fff59bf480ca92963b36eba5c1b904c4,CVE-2017-12932,https://github.com/php/php-src/commit/1a23ebc1fff59bf480ca92963b36eba5c1b904c4,2017-08-18T03:29Z
CWE-552,"CWE-552 static ssize_t _hostsock_recvmsg ( oe_fd_t * sock_ , struct oe_msghdr * msg , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! msg || ( msg -> msg_iovlen && ! msg -> msg_iov ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( msg -> msg_iov , ( int ) msg -> msg_iovlen , & buf , & buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_StartBug> { <S2SV_EndBug> if ( oe_syscall_recvmsg_ocall ( & ret , sock -> host_fd , msg -> msg_name , msg -> msg_namelen , <S2SV_StartBug> & msg -> msg_namelen , <S2SV_EndBug> buf , msg -> msg_iovlen , buf_size , msg -> msg_control , msg -> msg_controllen , <S2SV_StartBug> & msg -> msg_controllen , <S2SV_EndBug> flags ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ret == - 1 ) OE_RAISE_ERRNO ( oe_errno ) ; } <S2SV_StartBug> if ( oe_iov_sync ( msg -> msg_iov , ( int ) msg -> msg_iovlen , buf , buf_size ) != 0 ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; done : if ( buf ) oe_free ( buf ) ; return ret ; }
","<S2SV_ModStart> ; size_t buf_size = 0 ; size_t data_size = 0 ; oe_socklen_t namelen_out = 0 ; size_t controllen_out <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_ModStart> msg_namelen , & namelen_out <S2SV_ModEnd> , buf , <S2SV_ModStart> msg_controllen , & controllen_out <S2SV_ModEnd> , flags ) <S2SV_ModStart> } if ( ! msg -> msg_name ) msg -> msg_namelen = 0 ; else { if ( namelen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( msg -> msg_namelen >= namelen_out ) msg -> msg_namelen = namelen_out ; } if ( ! msg -> msg_control ) msg -> msg_controllen = 0 ; else { if ( msg -> msg_controllen >= controllen_out ) msg -> msg_controllen = controllen_out ; else msg -> msg_flags |= OE_MSG_CTRUNC ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if (
",openenclave@openenclave/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,CVE-2020-15224,https://github.com/openenclave/openenclave/commit/bcac8e7acb514429fee9e0b5d0c7a0308fd4d76b,2020-10-14T19:15Z
CWE-601,"CWE-601 int am_check_url ( request_rec * r , const char * url ) { const char * i ; for ( i = url ; * i ; i ++ ) { if ( * i >= 0 && * i < '<S2SV_blank>' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Control<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; } <S2SV_StartBug> } <S2SV_EndBug> return OK ; }
","<S2SV_ModStart> HTTP_BAD_REQUEST ; } if ( * i == '\\\\' ) { AM_LOG_RERROR ( APLOG_MARK , APLOG_ERR , HTTP_BAD_REQUEST , r , ""Backslash<S2SV_blank>character<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>URL."" ) ; return HTTP_BAD_REQUEST ; }
",Uninett@mod_auth_mellon/62041428a32de402e0be6ba45fe12df6a83bedb8,CVE-2019-3877,https://github.com/Uninett/mod_auth_mellon/commit/62041428a32de402e0be6ba45fe12df6a83bedb8,2019-03-27T13:29Z
CWE-189,"CWE-189 Datum hstore_from_arrays ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; Datum * key_datums ; bool * key_nulls ; int key_count ; Datum * value_datums ; bool * value_nulls ; int value_count ; ArrayType * key_array ; ArrayType * value_array ; int i ; if ( PG_ARGISNULL ( 0 ) ) PG_RETURN_NULL ( ) ; key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; if ( ARR_NDIM ( key_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; deconstruct_array ( key_array , TEXTOID , - 1 , false , 'i' , <S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> if ( PG_ARGISNULL ( 1 ) ) { value_array = NULL ; value_count = key_count ; value_datums = NULL ; value_nulls = NULL ; } else { value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; if ( ARR_NDIM ( value_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts"" ) ) ) ; if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds"" ) ) ) ; deconstruct_array ( value_array , TEXTOID , - 1 , false , 'i' , & value_datums , & value_nulls , & value_count ) ; Assert ( key_count == value_count ) ; } pairs = palloc ( key_count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < key_count ; ++ i ) { if ( key_nulls [ i ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key"" ) ) ) ; if ( ! value_nulls || value_nulls [ i ] ) { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; out = hstorePairs ( pairs , key_count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
","<S2SV_ModStart> , & key_count ) ; if ( key_count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""number<S2SV_blank>of<S2SV_blank>pairs<S2SV_blank>(%d)<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , key_count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) )
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-20,"CWE-20 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; int hexdump , ret ; u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; ret = lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE ) hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ( ndo , ""%s"" , tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/0b661e0aa61850234b64394585cf577aac570bf4,CVE-2019-15166,https://github.com/the-tcpdump-group/tcpdump/commit/0b661e0aa61850234b64394585cf577aac570bf4,2019-10-03T17:15Z
CWE-119,"CWE-119 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , <S2SV_StartBug> offset , <S2SV_EndBug> pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( ( flags & 0x04 ) && ( number_colormaps > 254 ) ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; if ( ( number_pixels * number_planes_filled ) != ( size_t ) ( number_pixels * number_planes_filled ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info = AcquireVirtualMemory ( image -> columns , image -> rows * MagickMax ( number_planes_filled , 4 ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes_filled , 4 ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ReadBlobLSBSignedShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; <S2SV_StartBug> if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) <S2SV_EndBug> { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { ValidateColormapValue ( image , * p & mask , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { ValidateColormapValue ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , one , pixel_info_length ; ssize_t count , offset <S2SV_ModEnd> , y ; <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length ) <S2SV_ModStart> ; if ( ( offset < 0 ) || ( <S2SV_ModStart> ) > pixel_info_length )
",ImageMagick@ImageMagick/139d4323c40d7363bfdd2382c3821a6f76d69430,CVE-2016-10050,https://github.com/ImageMagick/ImageMagick/commit/139d4323c40d7363bfdd2382c3821a6f76d69430,2017-03-23T17:59Z
CWE-59,"CWE-59 int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { rc = fsmVerify ( fpath , fi ) ; } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; <S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }
","<S2SV_ModStart> , psm , 0 ,
",rpm-software-management@rpm/404ef011c300207cdb1e531670384564aae04bdc,CVE-2017-7501,https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc,2017-11-22T22:29Z
CWE-000,"CWE-000 <S2SV_StartBug> static void sas_destruct_devices ( struct work_struct * work ) <S2SV_EndBug> { <S2SV_StartBug> struct domain_device * dev , * n ; <S2SV_EndBug> struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DESTRUCT , & port -> disc . pending ) ; list_for_each_entry_safe ( dev , n , & port -> destroy_list , disco_list_node ) { list_del_init ( & dev -> disco_list_node ) ; sas_remove_children ( & dev -> rphy -> dev ) ; sas_rphy_delete ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; } }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> void sas_destruct_devices ( <S2SV_ModStart> sas_destruct_devices ( struct asd_sas_port * port <S2SV_ModEnd> ) { struct <S2SV_ModStart> , * n <S2SV_ModEnd> ; list_for_each_entry_safe (
",torvalds@linux/0558f33c06bb910e2879e355192227a8e8f0219d,CVE-2017-18232,https://github.com/torvalds/linux/commit/0558f33c06bb910e2879e355192227a8e8f0219d,2018-03-15T04:29Z
CWE-835,"CWE-835 inline void update_rq_clock ( struct rq * rq ) <S2SV_StartBug> { <S2SV_EndBug> if ( ! rq -> skip_clock_update ) { int cpu = cpu_of ( rq ) ; <S2SV_StartBug> u64 irq_time ; <S2SV_EndBug> rq -> clock = sched_clock_cpu ( cpu ) ; irq_time = irq_time_cpu ( cpu ) ; if ( rq -> clock - irq_time > rq -> clock_task ) rq -> clock_task = rq -> clock - irq_time ; sched_irq_time_avg_update ( rq , irq_time ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * rq ) <S2SV_ModEnd> { int cpu <S2SV_ModStart> ; u64 irq_time ; if ( rq -> skip_clock_update ) return <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z
CWE-787,"CWE-787 <S2SV_StartBug> static int shash_no_setkey ( struct crypto_shash * tfm , const u8 * key , <S2SV_EndBug> unsigned int keylen ) { return - ENOSYS ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int shash_no_setkey (
",torvalds@linux/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,CVE-2017-17806,https://github.com/torvalds/linux/commit/af3ff8045bbf3e32f1a448542e73abb4c8ceb6f1,2017-12-20T23:29Z
CWE-189,"CWE-189 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }
","<S2SV_ModStart> pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn
",torvalds@linux/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,CVE-2014-3601,https://github.com/torvalds/linux/commit/350b8bdd689cd2ab2c67c8a86a0be86cfa0751a7,2014-09-01T01:55Z
CWE-20,"CWE-20 static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
","<S2SV_ModStart> gint64 offset ; <S2SV_ModEnd> char line [ <S2SV_ModStart> line [ NETSCREEN_LINE_LENGTH <S2SV_ModEnd> ] ; offset <S2SV_ModStart> return FALSE ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! parse_netscreen_packet <S2SV_ModEnd> ( wth -> <S2SV_ModStart> wth -> fh <S2SV_ModEnd> , & wth <S2SV_ModStart> wth -> frame_buffer , line
",wireshark@wireshark/6a140eca7b78b230f1f90a739a32257476513c78,CVE-2016-5357,https://github.com/wireshark/wireshark/commit/6a140eca7b78b230f1f90a739a32257476513c78,2016-08-07T16:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8_get_frame_corrupted ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctrl_id , va_list args ) { int * corrupted = va_arg ( args , int * ) ; VP8D_COMP * pbi = ( VP8D_COMP * ) ctx -> yv12_frame_buffers . pbi [ 0 ] ; if ( corrupted && pbi ) { <S2SV_StartBug> * corrupted = pbi -> common . frame_to_show -> corrupted ; <S2SV_EndBug> return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args <S2SV_ModStart> pbi ) { const YV12_BUFFER_CONFIG * const frame <S2SV_ModEnd> = pbi -> <S2SV_ModStart> common . frame_to_show ; if ( frame == NULL ) return VPX_CODEC_ERROR ; * corrupted = frame
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { <S2SV_StartBug> rq = blk_mq_tag_to_rq ( hctx -> tags , off + bit ) ; <S2SV_EndBug> if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
","<S2SV_ModStart> { rq = <S2SV_ModEnd> hctx -> tags <S2SV_ModStart> hctx -> tags -> rqs [ <S2SV_ModEnd> off + bit <S2SV_ModStart> off + bit ] <S2SV_ModEnd> ; if (
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
CWE-125,"CWE-125 int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; <S2SV_StartBug> match_length += callback_args -> forward_matches ; <S2SV_EndBug> if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_min ( match_length , MAX_MATCH_DATA ) ; FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matches_arena , match_data , new_match -> data_length , ( void * * ) & new_match -> data ) ) ; if ( result == ERROR_SUCCESS ) { new_match -> base = callback_args -> data_base ; new_match -> offset = match_offset ; new_match -> match_length = match_length ; new_match -> prev = NULL ; new_match -> next = NULL ; FAIL_ON_ERROR ( _yr_scan_add_match_to_list ( new_match , & string -> matches [ tidx ] , STRING_IS_GREEDY_REGEXP ( string ) ) ) ; } } return result ; }
","<S2SV_ModStart> callback_args -> forward_matches ; assert ( match_offset + match_length <= callback_args -> data_size )
",VirusTotal@yara/992480c30f75943e9cd6245bb2015c7737f9b661,CVE-2017-9465,https://github.com/VirusTotal/yara/commit/992480c30f75943e9cd6245bb2015c7737f9b661,2017-06-06T21:29Z
CWE-20,"CWE-20 static int netlink_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct scm_cookie scm ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied ; struct sk_buff * skb , * data_skb ; int err , ret ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; copied = 0 ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( skb == NULL ) goto out ; data_skb = skb ; # ifdef CONFIG_COMPAT_NETLINK_MESSAGES if ( unlikely ( skb_shinfo ( skb ) -> frag_list ) ) { if ( flags & MSG_CMSG_COMPAT ) data_skb = skb_shinfo ( skb ) -> frag_list ; } # endif <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> copied = data_skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( data_skb ) ; err = skb_copy_datagram_iovec ( data_skb , 0 , msg -> msg_iov , copied ) ; if ( msg -> msg_name ) { struct sockaddr_nl * addr = ( struct sockaddr_nl * ) msg -> msg_name ; addr -> nl_family = AF_NETLINK ; addr -> nl_pad = 0 ; addr -> nl_pid = NETLINK_CB ( skb ) . portid ; addr -> nl_groups = netlink_group_mask ( NETLINK_CB ( skb ) . dst_group ) ; msg -> msg_namelen = sizeof ( * addr ) ; } if ( nlk -> flags & NETLINK_RECV_PKTINFO ) netlink_cmsg_recv_pktinfo ( msg , skb ) ; if ( NULL == siocb -> scm ) { memset ( & scm , 0 , sizeof ( scm ) ) ; siocb -> scm = & scm ; } siocb -> scm -> creds = * NETLINK_CREDS ( skb ) ; if ( flags & MSG_TRUNC ) copied = data_skb -> len ; skb_free_datagram ( sk , skb ) ; if ( nlk -> cb_running && atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf / 2 ) { ret = netlink_dump ( sk ) ; if ( ret ) { sk -> sk_err = ret ; sk -> sk_error_report ( sk ) ; } } scm_recv ( sock , msg , siocb -> scm , flags ) ; out : netlink_rcv_wake ( sk ) ; return err ? : copied ; }
","<S2SV_ModStart> } # endif <S2SV_ModEnd> copied = data_skb
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-125,"CWE-125 static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , ""ptr"" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , ""byte"" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""word"" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""dword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""qword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""oword"" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , ""tbyte"" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , ""+-"" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
","<S2SV_ModStart> X86R_UNDEFINED ) { if ( reg_index < 2 ) { <S2SV_ModStart> = temp ; } <S2SV_ModStart> += temp ; if ( reg_index < 2 ) { <S2SV_ModStart> = X86R_UNDEFINED ; }
",radare@radare2/9b46d38dd3c4de6048a488b655c7319f845af185,CVE-2018-20456,https://github.com/radare/radare2/commit/9b46d38dd3c4de6048a488b655c7319f845af185,2018-12-25T19:29Z
CWE-59,"CWE-59 static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & LOOKUP_RCU ) { if ( unlazy_walk ( nd , NULL ) ) { error = - ECHILD ; goto out ; } } nd -> flags &= ~ LOOKUP_PARENT ; if ( unlikely ( nd -> last_type != LAST_NORM ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - ENOMEM ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - ENOENT ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ; <S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ; <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> error = 0 ; out : terminate_walk ( nd ) ; return error ; }
","<S2SV_ModStart> -> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
",torvalds@linux/295dc39d941dc2ae53d5c170365af4c9d5c16212,CVE-2014-5045,https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212,2014-08-01T11:13Z
CWE-835,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MaxTextExtent ] , text [ MaxTextExtent ] ; Image * image ; IndexPacket * indexes ; long x_offset , y_offset ; MagickBooleanType status ; MagickPixelPacket pixel ; QuantumAny range ; register ssize_t i , x ; register PixelPacket * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> matte = MagickFalse ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> matte = MagickTrue ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> colorspace = ( ColorspaceType ) type ; ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; ( void ) SetImageBackgroundColor ( image ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double blue , green , index , opacity , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; index = 0.0 ; opacity = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & opacity ) ; green = red ; blue = red ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & index ) ; break ; } default : { if ( image -> matte != MagickFalse ) { ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & opacity ) ; break ; } ( void ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; index *= 0.01 * range ; opacity *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . index = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( index + 0.5 ) , range ) ; pixel . opacity = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( opacity + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) continue ; SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; if ( image -> colorspace == CMYKColorspace ) { indexes = GetAuthenticIndexQueue ( image ) ; SetPixelIndex ( indexes , pixel . index ) ; } if ( image -> matte != MagickFalse ) SetPixelAlpha ( q , pixel . opacity ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }
",ImageMagick@ImageMagick/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,CVE-2017-11523,https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78,2017-07-22T21:29Z
CWE-772,"CWE-772 gpol_ret * get_policy_2_svc ( gpol_arg * arg , struct svc_req * rqstp ) { static gpol_ret ret ; kadm5_ret_t ret2 ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_principal_ent_rec caller_ent ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gpol_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_get_policy"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> name ; ret . code = KADM5_AUTH_GET ; if ( ! CHANGEPW_SERVICE ( rqstp ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , NULL , NULL ) ) ret . code = KADM5_OK ; else { ret . code = kadm5_get_principal ( handle -> lhandle , handle -> current_caller , & caller_ent , KADM5_PRINCIPAL_NORMAL_MASK ) ; if ( ret . code == KADM5_OK ) { if ( caller_ent . aux_attributes & KADM5_POLICY && strcmp ( caller_ent . policy , arg -> name ) == 0 ) { ret . code = KADM5_OK ; } else ret . code = KADM5_AUTH_GET ; ret2 = kadm5_free_principal_ent ( handle -> lhandle , & caller_ent ) ; ret . code = ret . code ? ret . code : ret2 ; } } if ( ret . code == KADM5_OK ) { ret . code = kadm5_get_policy ( handle , arg -> name , & ret . rec ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } else { log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-682,"CWE-682 static int find_low_bit ( unsigned int x ) { int i ; for ( i = 0 ; i <= 31 ; i ++ ) { <S2SV_StartBug> if ( x & ( 1 << i ) ) return i ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> x & ( 1U << ( unsigned int ) <S2SV_ModEnd> i ) )
",jsummers@imageworsener/a00183107d4b84bc8a714290e824ca9c68dac738,CVE-2017-8326,https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738,2017-04-29T20:59Z
CWE-772,"CWE-772 struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; if ( ret < local_nr_pages ) { ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ; <S2SV_StartBug> if ( len <= 0 ) <S2SV_EndBug> break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; <S2SV_StartBug> len -= bytes ; <S2SV_EndBug> offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : for ( j = 0 ; j < nr_pages ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; <S2SV_ModStart> ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ;
",torvalds@linux/95d78c28b5a85bacbc29b8dba7c04babb9b0d467,CVE-2017-12190,https://github.com/torvalds/linux/commit/95d78c28b5a85bacbc29b8dba7c04babb9b0d467,2017-11-22T18:29Z
CWE-362,"CWE-362 int ip_build_and_send_pkt ( struct sk_buff * skb , struct sock * sk , <S2SV_StartBug> __be32 saddr , __be32 daddr , struct ip_options * opt ) <S2SV_EndBug> { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = skb_rtable ( skb ) ; struct iphdr * iph ; <S2SV_StartBug> skb_push ( skb , sizeof ( struct iphdr ) + ( opt ? opt -> optlen : 0 ) ) ; <S2SV_EndBug> skb_reset_network_header ( skb ) ; iph = ip_hdr ( skb ) ; iph -> version = 4 ; iph -> ihl = 5 ; iph -> tos = inet -> tos ; if ( ip_dont_fragment ( sk , & rt -> dst ) ) iph -> frag_off = htons ( IP_DF ) ; else iph -> frag_off = 0 ; iph -> ttl = ip_select_ttl ( inet , & rt -> dst ) ; iph -> daddr = rt -> rt_dst ; iph -> saddr = rt -> rt_src ; iph -> protocol = sk -> sk_protocol ; ip_select_ident ( iph , & rt -> dst , sk ) ; <S2SV_StartBug> if ( opt && opt -> optlen ) { <S2SV_EndBug> <S2SV_StartBug> iph -> ihl += opt -> optlen >> 2 ; <S2SV_EndBug> <S2SV_StartBug> ip_options_build ( skb , opt , daddr , rt , 0 ) ; <S2SV_EndBug> } skb -> priority = sk -> sk_priority ; skb -> mark = sk -> sk_mark ; return ip_local_out ( skb ) ; }
","<S2SV_ModStart> daddr , struct ip_options_rcu <S2SV_ModEnd> * opt ) <S2SV_ModStart> ? opt -> opt . <S2SV_ModStart> && opt -> opt . <S2SV_ModStart> += opt -> opt . <S2SV_ModStart> ( skb , & opt ->
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-125,"CWE-125 static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || <S2SV_EndBug> ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( s ) { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 + n -> offset ; <S2SV_StartBug> if ( ( dataofs + s < dataofs ) || ( dataofs + s < s ) || <S2SV_EndBug> ( dataofs + s >= buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }
","<S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 12 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( en -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteDataFuji"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_fuji_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>"" ""buffer<S2SV_blank>(%u<S2SV_blank>>=<S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( en -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )
",libexif@libexif/435e21f05001fb03f9f186fa7cbc69454afd00d1,CVE-2020-13112,https://github.com/libexif/libexif/commit/435e21f05001fb03f9f186fa7cbc69454afd00d1,2020-05-21T16:15Z
CWE-787,"CWE-787 static int fetch_token ( OnigToken * tok , UChar * * src , UChar * end , ScanEnv * env ) { int r , num ; OnigCodePoint c ; OnigEncoding enc = env -> enc ; OnigSyntaxType * syn = env -> syntax ; UChar * prev ; UChar * p = * src ; PFETCH_READY ; start : if ( PEND ) { tok -> type = TK_EOT ; return tok -> type ; } tok -> type = TK_STRING ; tok -> base = 0 ; tok -> backp = p ; PFETCH ( c ) ; if ( IS_MC_ESC_CODE ( c , syn ) ) { if ( PEND ) return ONIGERR_END_PATTERN_AT_ESCAPE ; tok -> backp = p ; PFETCH ( c ) ; tok -> u . c = c ; tok -> escaped = 1 ; switch ( c ) { case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_ASTERISK_ZERO_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_PLUS_ONE_INF ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_QMARK_ZERO_ONE ) ) break ; tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; greedy_check : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_NON_GREEDY ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 0 ; tok -> u . repeat . possessive = 0 ; } else { possessive_check : if ( ! PEND && PPEEK_IS ( '+' ) && ( ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_REPEAT ) && tok -> type != TK_INTERVAL ) || ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL ) && tok -> type == TK_INTERVAL ) ) ) { PFETCH ( c ) ; tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 1 ; } else { tok -> u . repeat . greedy = 1 ; tok -> u . repeat . possessive = 0 ; } } break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case 'w' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 0 ; break ; case 'W' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_W_WORD ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_WORD ; tok -> u . prop . not = 1 ; break ; case 'b' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BOUND ; break ; case 'B' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_B_WORD_BOUND ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_NOT_WORD_BOUND ; break ; # ifdef USE_WORD_BEGIN_END case '<' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_BEGIN ; break ; case '>' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_LTGT_WORD_BEGIN_END ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . anchor = ANCHOR_WORD_END ; break ; # endif case 's' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 0 ; break ; case 'S' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_S_WHITE_SPACE ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_SPACE ; tok -> u . prop . not = 1 ; break ; case 'd' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 0 ; break ; case 'D' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_D_DIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_DIGIT ; tok -> u . prop . not = 1 ; break ; case 'h' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 0 ; break ; case 'H' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_H_XDIGIT ) ) break ; tok -> type = TK_CHAR_TYPE ; tok -> u . prop . ctype = ONIGENC_CTYPE_XDIGIT ; tok -> u . prop . not = 1 ; break ; case 'A' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; begin_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_BUF ; break ; case 'Z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_SEMI_END_BUF ; break ; case 'z' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_AZ_BUF_ANCHOR ) ) break ; end_buf : tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_END_BUF ; break ; case 'G' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_CAPITAL_G_BEGIN_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ANCHOR_BEGIN_POSITION ; break ; case '`' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto begin_buf ; break ; case '\\'' : if ( ! IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_GNU_BUF_ANCHOR ) ) break ; goto end_buf ; break ; case 'x' : if ( PEND ) break ; prev = p ; if ( PPEEK_IS ( '{' ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_BRACE_HEX8 ) ) { PINC ; num = scan_unsigned_hexadecimal_number ( & p , end , 8 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE ; if ( ! PEND ) { if ( ONIGENC_IS_CODE_XDIGIT ( enc , PPEEK ) ) return ONIGERR_TOO_LONG_WIDE_CHAR_VALUE ; } if ( ( p > prev + enclen ( enc , prev ) ) && ! PEND && PPEEK_IS ( '}' ) ) { PINC ; tok -> type = TK_CODE_POINT ; tok -> u . code = ( OnigCodePoint ) num ; } else { p = prev ; } } else if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_X_HEX2 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 2 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 16 ; tok -> u . c = num ; } break ; case 'u' : if ( PEND ) break ; prev = p ; if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_U_HEX4 ) ) { num = scan_unsigned_hexadecimal_number ( & p , end , 4 , enc ) ; if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; if ( p == prev ) { num = 0 ; } tok -> type = TK_CODE_POINT ; tok -> base = 16 ; tok -> u . code = ( OnigCodePoint ) num ; } break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : PUNFETCH ; prev = p ; num = onig_scan_unsigned_number ( & p , end , enc ) ; if ( num < 0 || num > ONIG_MAX_BACKREF_NUM ) { goto skip_backref ; } if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DECIMAL_BACKREF ) && ( num <= env -> num_mem || num <= 9 ) ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = num ; tok -> u . backref . by_name = 0 ; # ifdef USE_BACKREF_WITH_LEVEL tok -> u . backref . exist_level = 0 ; # endif break ; } skip_backref : if ( c == '8' || c == '9' ) { p = prev ; PINC ; break ; } p = prev ; case '0' : if ( IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ESC_OCTAL3 ) ) { prev = p ; num = scan_unsigned_octal_number ( & p , end , ( c == '0' ? 2 : 3 ) , enc ) ; <S2SV_StartBug> if ( num < 0 ) return ONIGERR_TOO_BIG_NUMBER ; <S2SV_EndBug> if ( p == prev ) { num = 0 ; } tok -> type = TK_RAW_BYTE ; tok -> base = 8 ; tok -> u . c = num ; } else if ( c != '0' ) { PINC ; } break ; # ifdef USE_NAMED_GROUP case 'k' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_K_NAMED_BACKREF ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { UChar * name_end ; int * backs ; int back_num ; prev = p ; # ifdef USE_BACKREF_WITH_LEVEL name_end = NULL_UCHARP ; r = fetch_name_with_level ( ( OnigCodePoint ) c , & p , end , & name_end , env , & back_num , & tok -> u . backref . level ) ; if ( r == 1 ) tok -> u . backref . exist_level = 1 ; else tok -> u . backref . exist_level = 0 ; # else r = fetch_name ( & p , end , & name_end , env , & back_num , 1 ) ; # endif if ( r < 0 ) return r ; if ( back_num != 0 ) { if ( back_num < 0 ) { back_num = BACKREF_REL_TO_ABS ( back_num , env ) ; if ( back_num <= 0 ) return ONIGERR_INVALID_BACKREF ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { if ( back_num > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ back_num ] ) ) return ONIGERR_INVALID_BACKREF ; } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 0 ; tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = back_num ; } else { num = onig_name_to_group_numbers ( env -> reg , prev , name_end , & backs ) ; if ( num <= 0 ) { onig_scan_env_set_error_string ( env , ONIGERR_UNDEFINED_NAME_REFERENCE , prev , name_end ) ; return ONIGERR_UNDEFINED_NAME_REFERENCE ; } if ( IS_SYNTAX_BV ( syn , ONIG_SYN_STRICT_CHECK_BACKREF ) ) { int i ; for ( i = 0 ; i < num ; i ++ ) { if ( backs [ i ] > env -> num_mem || IS_NULL ( SCANENV_MEM_NODES ( env ) [ backs [ i ] ] ) ) return ONIGERR_INVALID_BACKREF ; } } tok -> type = TK_BACKREF ; tok -> u . backref . by_name = 1 ; if ( num == 1 ) { tok -> u . backref . num = 1 ; tok -> u . backref . ref1 = backs [ 0 ] ; } else { tok -> u . backref . num = num ; tok -> u . backref . refs = backs ; } } } else PUNFETCH ; } break ; # endif # ifdef USE_SUBEXP_CALL case 'g' : if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_G_SUBEXP_CALL ) ) { PFETCH ( c ) ; if ( c == '<' || c == '\\'' ) { int gnum ; UChar * name_end ; prev = p ; r = fetch_name ( ( OnigCodePoint ) c , & p , end , & name_end , env , & gnum , 1 ) ; if ( r < 0 ) return r ; tok -> type = TK_CALL ; tok -> u . call . name = prev ; tok -> u . call . name_end = name_end ; tok -> u . call . gnum = gnum ; } else PUNFETCH ; } break ; # endif case 'Q' : if ( IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_CAPITAL_Q_QUOTE ) ) { tok -> type = TK_QUOTE_OPEN ; } break ; case 'p' : case 'P' : if ( ! PEND && PPEEK_IS ( '{' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CHAR_PROPERTY ) ) { PINC ; tok -> type = TK_CHAR_PROPERTY ; tok -> u . prop . not = ( c == 'P' ? 1 : 0 ) ; if ( ! PEND && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_ESC_P_BRACE_CIRCUMFLEX_NOT ) ) { PFETCH ( c ) ; if ( c == '^' ) { tok -> u . prop . not = ( tok -> u . prop . not == 0 ? 1 : 0 ) ; } else PUNFETCH ; } } break ; default : { OnigCodePoint c2 ; PUNFETCH ; num = fetch_escaped_value ( & p , end , env , & c2 ) ; if ( num < 0 ) return num ; if ( tok -> u . c != c2 ) { tok -> type = TK_CODE_POINT ; tok -> u . code = c2 ; } else { p = tok -> backp + enclen ( enc , tok -> backp ) ; } } break ; } } else { tok -> u . c = c ; tok -> escaped = 0 ; # ifdef USE_VARIABLE_META_CHARS if ( ( c != ONIG_INEFFECTIVE_META_CHAR ) && IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VARIABLE_META_CHARACTERS ) ) { if ( c == MC_ANYCHAR ( syn ) ) goto any_char ; else if ( c == MC_ANYTIME ( syn ) ) goto anytime ; else if ( c == MC_ZERO_OR_ONE_TIME ( syn ) ) goto zero_or_one_time ; else if ( c == MC_ONE_OR_MORE_TIME ( syn ) ) goto one_or_more_time ; else if ( c == MC_ANYCHAR_ANYTIME ( syn ) ) { tok -> type = TK_ANYCHAR_ANYTIME ; goto out ; } } # endif switch ( c ) { case '.' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_DOT_ANYCHAR ) ) break ; # ifdef USE_VARIABLE_META_CHARS any_char : # endif tok -> type = TK_ANYCHAR ; break ; case '*' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_ASTERISK_ZERO_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS anytime : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '+' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_PLUS_ONE_INF ) ) break ; # ifdef USE_VARIABLE_META_CHARS one_or_more_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 1 ; tok -> u . repeat . upper = REPEAT_INFINITE ; goto greedy_check ; break ; case '?' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_QMARK_ZERO_ONE ) ) break ; # ifdef USE_VARIABLE_META_CHARS zero_or_one_time : # endif tok -> type = TK_OP_REPEAT ; tok -> u . repeat . lower = 0 ; tok -> u . repeat . upper = 1 ; goto greedy_check ; break ; case '{' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACE_INTERVAL ) ) break ; r = fetch_range_quantifier ( & p , end , tok , env ) ; if ( r < 0 ) return r ; if ( r == 0 ) goto greedy_check ; else if ( r == 2 ) { if ( IS_SYNTAX_BV ( syn , ONIG_SYN_FIXED_INTERVAL_IS_GREEDY_ONLY ) ) goto possessive_check ; goto greedy_check ; } break ; case '|' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_VBAR_ALT ) ) break ; tok -> type = TK_ALT ; break ; case '(' : if ( ! PEND && PPEEK_IS ( '?' ) && IS_SYNTAX_OP2 ( syn , ONIG_SYN_OP2_QMARK_GROUP_EFFECT ) ) { PINC ; if ( ! PEND && PPEEK_IS ( '#' ) ) { PFETCH ( c ) ; while ( 1 ) { if ( PEND ) return ONIGERR_END_PATTERN_IN_GROUP ; PFETCH ( c ) ; if ( c == MC_ESC ( syn ) ) { if ( ! PEND ) PFETCH ( c ) ; } else { if ( c == ')' ) break ; } } goto start ; } PUNFETCH ; } if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_OPEN ; break ; case ')' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LPAREN_SUBEXP ) ) break ; tok -> type = TK_SUBEXP_CLOSE ; break ; case '^' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_BEGIN_BUF : ANCHOR_BEGIN_LINE ) ; break ; case '$' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_LINE_ANCHOR ) ) break ; tok -> type = TK_ANCHOR ; tok -> u . subtype = ( IS_SINGLELINE ( env -> option ) ? ANCHOR_SEMI_END_BUF : ANCHOR_END_LINE ) ; break ; case '[' : if ( ! IS_SYNTAX_OP ( syn , ONIG_SYN_OP_BRACKET_CC ) ) break ; tok -> type = TK_CC_OPEN ; break ; case ']' : if ( * src > env -> pattern ) CLOSE_BRACKET_WITHOUT_ESC_WARN ( env , ( UChar * ) ""]"" ) ; break ; case '#' : if ( IS_EXTEND ( env -> option ) ) { while ( ! PEND ) { PFETCH ( c ) ; if ( ONIGENC_IS_CODE_NEWLINE ( enc , c ) ) break ; } goto start ; break ; } break ; case '<S2SV_blank>' : case '\\t' : case '\\n' : case '\\r' : case '\\f' : if ( IS_EXTEND ( env -> option ) ) goto start ; break ; default : break ; } } # ifdef USE_VARIABLE_META_CHARS out : # endif * src = p ; return tok -> type ; }
","<S2SV_ModStart> num < 0 || num >= 256
",kkos@oniguruma/f015fbdd95f76438cd86366467bb2b39870dd7c6,CVE-2017-9226,https://github.com/kkos/oniguruma/commit/f015fbdd95f76438cd86366467bb2b39870dd7c6,2017-05-24T15:29Z
CWE-000,"CWE-000 void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { <S2SV_StartBug> void * dllhandle ; <S2SV_EndBug> if ( useSystemLib ) Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Trying<S2SV_blank>to<S2SV_blank>load<S2SV_blank>\\""%s\\""<S2SV_blank>from<S2SV_blank>\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading<S2SV_blank>\\""%s\\""<S2SV_blank>failed\\n"" , name ) ; } } return dllhandle ; }
","<S2SV_ModStart> * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , name ) ; return NULL ; }
",JACoders@OpenJK/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,CVE-2017-6903,https://github.com/JACoders/OpenJK/commit/b6ff2bcb1e4e6976d61e316175c6d7c99860fe20,2017-03-14T22:59Z
CWE-401,"CWE-401 int adis_update_scan_mode ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; const struct iio_chan_spec * chan ; unsigned int scan_count ; unsigned int i , j ; __be16 * tx , * rx ; kfree ( adis -> xfer ) ; kfree ( adis -> buffer ) ; if ( adis -> burst && adis -> burst -> en ) return adis_update_scan_mode_burst ( indio_dev , scan_mask ) ; scan_count = indio_dev -> scan_bytes / 2 ; adis -> xfer = kcalloc ( scan_count + 1 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kcalloc ( indio_dev -> scan_bytes , 2 , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> tx = rx + scan_count ; spi_message_init ( & adis -> msg ) ; for ( j = 0 ; j <= scan_count ; j ++ ) { adis -> xfer [ j ] . bits_per_word = 8 ; if ( j != scan_count ) adis -> xfer [ j ] . cs_change = 1 ; adis -> xfer [ j ] . len = 2 ; adis -> xfer [ j ] . delay_usecs = adis -> data -> read_delay ; if ( j < scan_count ) adis -> xfer [ j ] . tx_buf = & tx [ j ] ; if ( j >= 1 ) adis -> xfer [ j ] . rx_buf = & rx [ j - 1 ] ; spi_message_add_tail ( & adis -> xfer [ j ] , & adis -> msg ) ; } chan = indio_dev -> channels ; for ( i = 0 ; i < indio_dev -> num_channels ; i ++ , chan ++ ) { if ( ! test_bit ( chan -> scan_index , scan_mask ) ) continue ; if ( chan -> scan_type . storagebits == 32 ) * tx ++ = cpu_to_be16 ( ( chan -> address + 2 ) << 8 ) ; * tx ++ = cpu_to_be16 ( chan -> address << 8 ) ; } return 0 ; }
","<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
",torvalds@linux/ab612b1daf415b62c58e130cb3d0f30b255a14d0,CVE-2019-19060,https://github.com/torvalds/linux/commit/ab612b1daf415b62c58e130cb3d0f30b255a14d0,2019-11-18T06:15Z
CWE-119,"CWE-119 int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , ""openssl"" , sizeof ( ""openssl"" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>not<S2SV_blank>loaded"" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , ""%s.pubkey"" , fname ) ; pfp = php_stream_open_wrapper ( pfile , ""rb"" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>public<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>read"" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 , & sig , & tempsig ) ) { if ( pubkey ) { zend_string_release ( pubkey ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>verified"" ) ; } return FAILURE ; } if ( pubkey ) { zend_string_release ( pubkey ) ; } sig_len = tempsig ; # else in = BIO_new_mem_buf ( pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 ) ; if ( NULL == in ) { zend_string_release ( pubkey ) ; if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } key = PEM_read_bio_PUBKEY ( in , NULL , NULL , NULL ) ; BIO_free ( in ) ; zend_string_release ( pubkey ) ; if ( NULL == key ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } EVP_VerifyInit ( & md_ctx , mdtype ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; while ( read_size && ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { EVP_VerifyUpdate ( & md_ctx , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } if ( EVP_VerifyFinal ( & md_ctx , ( unsigned char * ) sig , sig_len , key ) != 1 ) { EVP_MD_CTX_cleanup ( & md_ctx ) ; if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>openssl<S2SV_blank>signature"" ) ; } return FAILURE ; } EVP_MD_CTX_cleanup ( & md_ctx ) ; # endif * signature_len = phar_hex_str ( ( const char * ) sig , sig_len , signature ) ; } break ; # ifdef PHAR_HASH_OK case PHAR_SIG_SHA512 : { unsigned char digest [ 64 ] ; PHP_SHA512_CTX context ; <S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA512Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA512Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_SHA256 : { unsigned char digest [ 32 ] ; PHP_SHA256_CTX context ; <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA256Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA256Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } # else case PHAR_SIG_SHA512 : case PHAR_SIG_SHA256 : if ( error ) { spprintf ( error , 0 , ""unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; # endif case PHAR_SIG_SHA1 : { unsigned char digest [ 20 ] ; PHP_SHA1_CTX context ; <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA1Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA1Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_MD5 : { unsigned char digest [ 16 ] ; PHP_MD5_CTX context ; <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug> break ; } default : if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>or<S2SV_blank>unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; } return SUCCESS ; }
","<S2SV_ModStart> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <S2SV_ModEnd> ) ) { <S2SV_ModStart> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; }
",php@php-src/0bfb970f43acd1e81d11be1154805f86655f15d5,CVE-2016-7414,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5?w=1,2016-09-17T21:59Z
CWE-119,"CWE-119 static void write_modes_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> vp9_writer * w , TOKENEXTRA * * tok , TOKENEXTRA * tok_end , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_StartBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) ; <S2SV_EndBug> const int bs = ( 1 << bsl ) / 4 ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; <S2SV_StartBug> MODE_INFO * m = cm -> mi_grid_visible [ mi_row * cm -> mi_stride + mi_col ] ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; partition = partition_lookup [ bsl ] [ m -> mbmi . sb_type ] ; write_partition ( cm , xd , bs , mi_row , mi_col , partition , bsize , w ) ; subsize = get_subsize ( bsize , partition ) ; if ( subsize < BLOCK_8X8 ) { write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; } else { switch ( partition ) { case PARTITION_NONE : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; break ; case PARTITION_HORZ : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_row + bs < cm -> mi_rows ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col ) ; break ; case PARTITION_VERT : write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col ) ; if ( mi_col + bs < cm -> mi_cols ) write_modes_b ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs ) ; break ; case PARTITION_SPLIT : write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row , mi_col + bs , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col , subsize ) ; write_modes_sb ( cpi , tile , w , tok , tok_end , mi_row + bs , mi_col + bs , subsize ) ; break ; default : assert ( 0 ) ; } } if ( bsize >= BLOCK_8X8 && ( bsize == BLOCK_8X8 || partition != PARTITION_SPLIT ) ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
","<S2SV_ModStart> const tile , vpx_writer * w , <S2SV_ModEnd> TOKENEXTRA * * <S2SV_ModStart> * tok , const TOKENEXTRA * const <S2SV_ModEnd> tok_end , int <S2SV_ModStart> bsize ) { const <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> ; const int <S2SV_ModStart> BLOCK_SIZE subsize ; const MODE_INFO * m = NULL ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; <S2SV_ModEnd> m = cm <S2SV_ModStart> + mi_col ] <S2SV_ModEnd> ; partition =
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ; <S2SV_StartBug> for ( row = 0 ; row < height ; row ++ ) <S2SV_EndBug> { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ; <S2SV_StartBug> if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) <S2SV_EndBug> derror ( ) ; } } }
","<S2SV_ModStart> ; row < raw_height <S2SV_ModEnd> ; row ++ <S2SV_ModStart> col < width && row < height
",LibRaw@LibRaw/f1394822a0152ceed77815eafa5cac4e8baab10a,CVE-2017-16909,https://github.com/LibRaw/LibRaw/commit/f1394822a0152ceed77815eafa5cac4e8baab10a,2018-12-07T22:29Z
CWE-119,"CWE-119 cJSON * cJSON_CreateString ( const char * string ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) { item -> type = cJSON_String ; item -> valuestring = cJSON_strdup ( string ) ; <S2SV_StartBug> } <S2SV_EndBug> return item ; }
","<S2SV_ModStart> string ) ; if ( ! item -> valuestring ) { cJSON_Delete ( item ) ; return 0 ; } } <S2SV_ModEnd> return item ;
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-119,"CWE-119 void vp9_setup_mask ( VP9_COMMON * const cm , const int mi_row , const int mi_col , <S2SV_StartBug> MODE_INFO * * mi_8x8 , const int mode_info_stride , <S2SV_EndBug> LOOP_FILTER_MASK * lfm ) { int idx_32 , idx_16 , idx_8 ; const loop_filter_info_n * const lfi_n = & cm -> lf_info ; <S2SV_StartBug> MODE_INFO * * mip = mi_8x8 ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mip2 = mi_8x8 ; <S2SV_EndBug> const int offset_32 [ ] = { 4 , ( mode_info_stride << 2 ) - 4 , 4 , - ( mode_info_stride << 2 ) - 4 } ; const int offset_16 [ ] = { 2 , ( mode_info_stride << 1 ) - 2 , 2 , - ( mode_info_stride << 1 ) - 2 } ; const int offset [ ] = { 1 , mode_info_stride - 1 , 1 , - mode_info_stride - 1 } ; const int shift_32_y [ ] = { 0 , 4 , 32 , 36 } ; const int shift_16_y [ ] = { 0 , 2 , 16 , 18 } ; const int shift_8_y [ ] = { 0 , 1 , 8 , 9 } ; const int shift_32_uv [ ] = { 0 , 2 , 8 , 10 } ; const int shift_16_uv [ ] = { 0 , 1 , 4 , 5 } ; int i ; const int max_rows = ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ? cm -> mi_rows - mi_row : MI_BLOCK_SIZE ) ; const int max_cols = ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ? cm -> mi_cols - mi_col : MI_BLOCK_SIZE ) ; <S2SV_StartBug> vp9_zero ( * lfm ) ; <S2SV_EndBug> switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_64X64 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; break ; case BLOCK_64X32 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; mip2 = mip + mode_info_stride * 4 ; if ( 4 >= max_rows ) break ; build_masks ( lfi_n , mip2 [ 0 ] , 32 , 8 , lfm ) ; break ; case BLOCK_32X64 : build_masks ( lfi_n , mip [ 0 ] , 0 , 0 , lfm ) ; mip2 = mip + 4 ; if ( 4 >= max_cols ) break ; build_masks ( lfi_n , mip2 [ 0 ] , 4 , 2 , lfm ) ; break ; default : for ( idx_32 = 0 ; idx_32 < 4 ; mip += offset_32 [ idx_32 ] , ++ idx_32 ) { const int shift_y = shift_32_y [ idx_32 ] ; const int shift_uv = shift_32_uv [ idx_32 ] ; const int mi_32_col_offset = ( ( idx_32 & 1 ) << 2 ) ; const int mi_32_row_offset = ( ( idx_32 >> 1 ) << 2 ) ; if ( mi_32_col_offset >= max_cols || mi_32_row_offset >= max_rows ) continue ; switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_32X32 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; break ; case BLOCK_32X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_32_row_offset + 2 >= max_rows ) continue ; mip2 = mip + mode_info_stride * 2 ; build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 16 , shift_uv + 4 , lfm ) ; break ; case BLOCK_16X32 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_32_col_offset + 2 >= max_cols ) continue ; mip2 = mip + 2 ; build_masks ( lfi_n , mip2 [ 0 ] , shift_y + 2 , shift_uv + 1 , lfm ) ; break ; default : for ( idx_16 = 0 ; idx_16 < 4 ; mip += offset_16 [ idx_16 ] , ++ idx_16 ) { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] ; const int shift_uv = shift_32_uv [ idx_32 ] + shift_16_uv [ idx_16 ] ; const int mi_16_col_offset = mi_32_col_offset + ( ( idx_16 & 1 ) << 1 ) ; const int mi_16_row_offset = mi_32_row_offset + ( ( idx_16 >> 1 ) << 1 ) ; if ( mi_16_col_offset >= max_cols || mi_16_row_offset >= max_rows ) continue ; switch ( mip [ 0 ] -> mbmi . sb_type ) { case BLOCK_16X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; break ; case BLOCK_16X8 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_16_row_offset + 1 >= max_rows ) continue ; mip2 = mip + mode_info_stride ; build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 8 , lfm ) ; break ; case BLOCK_8X16 : build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; if ( mi_16_col_offset + 1 >= max_cols ) continue ; mip2 = mip + 1 ; build_y_mask ( lfi_n , mip2 [ 0 ] , shift_y + 1 , lfm ) ; break ; default : { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] + shift_8_y [ 0 ] ; build_masks ( lfi_n , mip [ 0 ] , shift_y , shift_uv , lfm ) ; mip += offset [ 0 ] ; for ( idx_8 = 1 ; idx_8 < 4 ; mip += offset [ idx_8 ] , ++ idx_8 ) { const int shift_y = shift_32_y [ idx_32 ] + shift_16_y [ idx_16 ] + shift_8_y [ idx_8 ] ; const int mi_8_col_offset = mi_16_col_offset + ( ( idx_8 & 1 ) ) ; const int mi_8_row_offset = mi_16_row_offset + ( ( idx_8 >> 1 ) ) ; if ( mi_8_col_offset >= max_cols || mi_8_row_offset >= max_rows ) continue ; build_y_mask ( lfi_n , mip [ 0 ] , shift_y , lfm ) ; } break ; } } } break ; } } break ; } lfm -> left_y [ TX_16X16 ] |= lfm -> left_y [ TX_32X32 ] ; lfm -> above_y [ TX_16X16 ] |= lfm -> above_y [ TX_32X32 ] ; lfm -> left_uv [ TX_16X16 ] |= lfm -> left_uv [ TX_32X32 ] ; lfm -> above_uv [ TX_16X16 ] |= lfm -> above_uv [ TX_32X32 ] ; lfm -> left_y [ TX_8X8 ] |= lfm -> left_y [ TX_4X4 ] & left_border ; lfm -> left_y [ TX_4X4 ] &= ~ left_border ; lfm -> above_y [ TX_8X8 ] |= lfm -> above_y [ TX_4X4 ] & above_border ; lfm -> above_y [ TX_4X4 ] &= ~ above_border ; lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_4X4 ] & left_border_uv ; lfm -> left_uv [ TX_4X4 ] &= ~ left_border_uv ; lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_4X4 ] & above_border_uv ; lfm -> above_uv [ TX_4X4 ] &= ~ above_border_uv ; if ( mi_row + MI_BLOCK_SIZE > cm -> mi_rows ) { const uint64_t rows = cm -> mi_rows - mi_row ; const uint64_t mask_y = ( ( ( uint64_t ) 1 << ( rows << 3 ) ) - 1 ) ; const uint16_t mask_uv = ( ( ( uint16_t ) 1 << ( ( ( rows + 1 ) >> 1 ) << 2 ) ) - 1 ) ; for ( i = 0 ; i < TX_32X32 ; i ++ ) { lfm -> left_y [ i ] &= mask_y ; lfm -> above_y [ i ] &= mask_y ; lfm -> left_uv [ i ] &= mask_uv ; lfm -> above_uv [ i ] &= mask_uv ; } lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv ; if ( rows == 1 ) { lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] ; lfm -> above_uv [ TX_16X16 ] = 0 ; } if ( rows == 5 ) { lfm -> above_uv [ TX_8X8 ] |= lfm -> above_uv [ TX_16X16 ] & 0xff00 ; lfm -> above_uv [ TX_16X16 ] &= ~ ( lfm -> above_uv [ TX_16X16 ] & 0xff00 ) ; } } if ( mi_col + MI_BLOCK_SIZE > cm -> mi_cols ) { const uint64_t columns = cm -> mi_cols - mi_col ; <S2SV_StartBug> const uint64_t mask_y = ( ( ( 1 << columns ) - 1 ) ) * 0x0101010101010101 ; <S2SV_EndBug> const uint16_t mask_uv = ( ( 1 << ( ( columns + 1 ) >> 1 ) ) - 1 ) * 0x1111 ; const uint16_t mask_uv_int = ( ( 1 << ( columns >> 1 ) ) - 1 ) * 0x1111 ; for ( i = 0 ; i < TX_32X32 ; i ++ ) { lfm -> left_y [ i ] &= mask_y ; lfm -> above_y [ i ] &= mask_y ; lfm -> left_uv [ i ] &= mask_uv ; lfm -> above_uv [ i ] &= mask_uv ; } lfm -> int_4x4_y &= mask_y ; lfm -> int_4x4_uv &= mask_uv_int ; if ( columns == 1 ) { lfm -> left_uv [ TX_8X8 ] |= lfm -> left_uv [ TX_16X16 ] ; lfm -> left_uv [ TX_16X16 ] = 0 ; } if ( columns == 5 ) { lfm -> left_uv [ TX_8X8 ] |= ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; lfm -> left_uv [ TX_16X16 ] &= ~ ( lfm -> left_uv [ TX_16X16 ] & 0xcccc ) ; } } if ( mi_col == 0 ) { for ( i = 0 ; i < TX_32X32 ; i ++ ) { <S2SV_StartBug> lfm -> left_y [ i ] &= 0xfefefefefefefefe ; <S2SV_EndBug> lfm -> left_uv [ i ] &= 0xeeee ; } } assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> left_y [ TX_16X16 ] & lfm -> left_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> left_y [ TX_8X8 ] & lfm -> left_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_y & lfm -> left_y [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_16X16 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> left_uv [ TX_8X8 ] & lfm -> left_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_uv & lfm -> left_uv [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_16X16 ] & lfm -> above_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> above_y [ TX_8X8 ] & lfm -> above_y [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_y & lfm -> above_y [ TX_16X16 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_8X8 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_16X16 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> above_uv [ TX_8X8 ] & lfm -> above_uv [ TX_4X4 ] ) ) ; assert ( ! ( lfm -> int_4x4_uv & lfm -> above_uv [ TX_16X16 ] ) ) ; }
","<S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> , const int <S2SV_ModStart> * mip = mi <S2SV_ModEnd> ; MODE_INFO * <S2SV_ModStart> * mip2 = mi <S2SV_ModEnd> ; const int <S2SV_ModStart> ( * lfm ) ; assert ( mip [ 0 ] != NULL <S2SV_ModStart> ) ) * 0x0101010101010101ULL <S2SV_ModEnd> ; const uint16_t <S2SV_ModStart> i ] &= 0xfefefefefefefefeULL <S2SV_ModEnd> ; lfm ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 static struct dst_entry * inet6_csk_route_socket ( struct sock * sk , struct flowi6 * fl6 ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = sk -> sk_protocol ; fl6 -> daddr = sk -> sk_v6_daddr ; fl6 -> saddr = np -> saddr ; fl6 -> flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 -> flowlabel ) ; fl6 -> flowi6_oif = sk -> sk_bound_dev_if ; fl6 -> flowi6_mark = sk -> sk_mark ; fl6 -> fl6_sport = inet -> inet_sport ; fl6 -> fl6_dport = inet -> inet_dport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( fl6 ) ) ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> dst = __inet6_csk_dst_check ( sk , np -> dst_cookie ) ; <S2SV_EndBug> if ( ! dst ) { dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( ! IS_ERR ( dst ) ) __inet6_csk_dst_store ( sk , dst , NULL , NULL ) ; } return dst ; }
","<S2SV_ModStart> ) ) ; rcu_read_lock ( ) ; <S2SV_ModStart> ( fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt ) <S2SV_ModStart> final ) ; rcu_read_unlock ( ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-119,"CWE-119 static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) { int k ; MACROBLOCKD * xd = & x -> e_mbd ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; MODE_INFO * const mi = xd -> mi [ 0 ] ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ; const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; int idx , idy ; <S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> p -> src . stride ) ] ; <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> dst . stride ) ] ; int64_t thisdistortion = 0 , thissse = 0 ; int thisrate = 0 , ref ; const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; const int is_compound = has_second_ref ( & mi -> mbmi ) ; <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ ref ] . stride ) ] ; <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> k = i ; for ( idy = 0 ; idy < height / 4 ; ++ idy ) { for ( idx = 0 ; idx < width / 4 ; ++ idx ) { int64_t ssz , rd , rd1 , rd2 ; <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> k += ( idy * 2 + idx ) ; coeff = BLOCK_OFFSET ( p -> coeff , k ) ; <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> coeff , 8 ) ; <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ; rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ; rd = MIN ( rd1 , rd2 ) ; if ( rd >= best_yrd ) return INT64_MAX ; } } * distortion = thisdistortion >> 2 ; * labelyrate = thisrate ; * sse = thissse >> 2 ; return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ; }
","<S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> * kernel = vp9_filter_kernels [ <S2SV_ModEnd> mi -> mbmi <S2SV_ModStart> mbmi . interp_filter ] <S2SV_ModEnd> ; for ( <S2SV_ModStart> . buf [ vp9_raster_block_offset <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> ) ] ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor <S2SV_ModEnd> ( pre , <S2SV_ModStart> , height , ref , <S2SV_ModEnd> kernel , MV_PRECISION_Q3 <S2SV_ModStart> / 2 ) , xd -> bd <S2SV_ModStart> ) ; } else { vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; } # else vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , & xd -> block_refs [ ref ] -> sf , width , height , ref , kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; # endif } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vpx_highbd_subtract_block ( height , width , vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> . stride , dst , pd -> dst . stride , xd -> bd ) ; } else { vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; } # else vpx_subtract_block ( height , width , vp9_raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , dst , pd -> dst . stride ) ; # endif <S2SV_ModEnd> k = i <S2SV_ModStart> , rd2 ; tran_low_t <S2SV_ModEnd> * coeff ; <S2SV_ModStart> -> fwd_txm4x4 ( vp9_raster_block_offset_int16 <S2SV_ModEnd> ( BLOCK_8X8 , <S2SV_ModStart> iscan ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { thisdistortion += vp9_highbd_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz , xd -> bd ) ; } else { <S2SV_ModStart> ssz ) ; } # else thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 static ScreenCell * realloc_buffer ( VTermScreen * screen , ScreenCell * buffer , int new_rows , int new_cols ) { ScreenCell * new_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( ScreenCell ) * new_rows * new_cols ) ; int row , col ; for ( row = 0 ; row < new_rows ; row ++ ) { for ( col = 0 ; col < new_cols ; col ++ ) { ScreenCell * new_cell = new_buffer + row * new_cols + col ; if ( buffer && row < screen -> rows && col < screen -> cols ) * new_cell = buffer [ row * screen -> cols + col ] ; else { new_cell -> chars [ 0 ] = 0 ; new_cell -> pen = screen -> pen ; } } } <S2SV_StartBug> if ( buffer ) <S2SV_EndBug> vterm_allocator_free ( screen -> vt , buffer ) ; return new_buffer ; }
","<S2SV_ModStart> } } } <S2SV_ModEnd> vterm_allocator_free ( screen
",vim@vim/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,CVE-2018-20786,https://github.com/vim/vim/commit/cd929f7ba8cc5b6d6dcf35c8b34124e969fed6b8,2019-02-24T14:29Z
CWE-125,"CWE-125 static int rsvp_obj_print ( netdissect_options * ndo , const u_char * pptr , u_int plen , const u_char * tptr , const char * ident , u_int tlen , const struct rsvp_common_header * rsvp_com_header ) { const struct rsvp_object_header * rsvp_obj_header ; const u_char * obj_tptr ; union { const struct rsvp_obj_integrity_t * rsvp_obj_integrity ; const struct rsvp_obj_frr_t * rsvp_obj_frr ; } obj_ptr ; u_short rsvp_obj_len , rsvp_obj_ctype , obj_tlen , intserv_serv_tlen ; int hexdump , processed , padbytes , error_code , error_value , i , sigcheck ; union { float f ; uint32_t i ; } bw ; uint8_t namelen ; u_int action , subchannel ; while ( tlen >= sizeof ( struct rsvp_object_header ) ) { ND_TCHECK2 ( * tptr , sizeof ( struct rsvp_object_header ) ) ; rsvp_obj_header = ( const struct rsvp_object_header * ) tptr ; rsvp_obj_len = EXTRACT_16BITS ( rsvp_obj_header -> length ) ; rsvp_obj_ctype = rsvp_obj_header -> ctype ; if ( rsvp_obj_len % 4 ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4"" , ident , rsvp_obj_len ) ) ; return - 1 ; } if ( rsvp_obj_len < sizeof ( struct rsvp_object_header ) ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>%u<S2SV_blank><<S2SV_blank>%lu"" , ident , rsvp_obj_len , ( unsigned long ) sizeof ( const struct rsvp_object_header ) ) ) ; return - 1 ; } ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>Object<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%s"" , ident , tok2str ( rsvp_obj_values , ""Unknown"" , rsvp_obj_header -> class_num ) , rsvp_obj_header -> class_num , ( ( rsvp_obj_header -> class_num ) & 0x80 ) ? ""ignore"" : ""reject"" ) ) ; if ( rsvp_obj_header -> class_num > 128 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ( ( rsvp_obj_header -> class_num ) & 0x40 ) ? ""and<S2SV_blank>forward"" : ""silently"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>if<S2SV_blank>unknown],<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( rsvp_ctype_values , ""Unknown"" , ( ( rsvp_obj_header -> class_num ) << 8 ) + rsvp_obj_ctype ) , rsvp_obj_ctype , rsvp_obj_len ) ) ; if ( tlen < rsvp_obj_len ) { ND_PRINT ( ( ndo , ""%sERROR:<S2SV_blank>object<S2SV_blank>goes<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>objects<S2SV_blank>TLV"" , ident ) ) ; return - 1 ; } obj_tptr = tptr + sizeof ( struct rsvp_object_header ) ; obj_tlen = rsvp_obj_len - sizeof ( struct rsvp_object_header ) ; if ( ! ND_TTEST2 ( * tptr , rsvp_obj_len ) ) return - 1 ; hexdump = FALSE ; switch ( rsvp_obj_header -> class_num ) { case RSVP_OBJ_SESSION : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + 5 ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>DestAddress:<S2SV_blank>%s,<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>0x%02x"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + sizeof ( struct in6_addr ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[0x%02x],<S2SV_blank>DestPort<S2SV_blank>%u"" , ident , * ( obj_tptr + sizeof ( struct in6_addr ) + 1 ) , EXTRACT_16BITS ( obj_tptr + sizeof ( struct in6_addr ) + 2 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 36 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ip6addr_string ( ndo , obj_tptr + 20 ) ) ) ; obj_tlen -= 36 ; obj_tptr += 36 ; break ; case RSVP_CTYPE_14 : if ( obj_tlen < 26 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ip6addr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 26 ; obj_tptr += 26 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>P2MP<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : case RSVP_CTYPE_UNI_IPV4 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>EndPoint:<S2SV_blank>%s,<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>0x%04x,<S2SV_blank>Extended<S2SV_blank>Tunnel<S2SV_blank>ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ipaddr_string ( ndo , obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CONFIRM : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Receiver<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_NOTIFY_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < sizeof ( struct in_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in_addr ) ; obj_tptr += sizeof ( struct in_addr ) ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < sizeof ( struct in6_addr ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Notify<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= sizeof ( struct in6_addr ) ; obj_tptr += sizeof ( struct in6_addr ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SUGGESTED_LABEL : case RSVP_OBJ_UPSTREAM_LABEL : case RSVP_OBJ_RECOVERY_LABEL : case RSVP_OBJ_LABEL : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Generalized<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Waveband<S2SV_blank>ID:<S2SV_blank>%u%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>Label:<S2SV_blank>%u,<S2SV_blank>Stop<S2SV_blank>Label:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_STYLE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Reservation<S2SV_blank>Style:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]"" , ident , tok2str ( rsvp_resstyle_values , ""Unknown"" , EXTRACT_24BITS ( obj_tptr + 1 ) ) , * ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TEMPLATE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_REQ : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; case RSVP_CTYPE_2 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , "",%s<S2SV_blank>merge<S2SV_blank>capability"" , ( ( * ( obj_tptr + 4 ) ) & 0x80 ) ? ""no"" : """" ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 4 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 6 ) ) & 0xfff ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Maximum<S2SV_blank>VPI/VCI:<S2SV_blank>%u/%u"" , ident , ( EXTRACT_16BITS ( obj_tptr + 8 ) ) & 0xfff , ( EXTRACT_16BITS ( obj_tptr + 10 ) ) & 0xfff ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>L3<S2SV_blank>Protocol<S2SV_blank>ID:<S2SV_blank>%s"" , ident , tok2str ( ethertype_values , ""Unknown<S2SV_blank>Protocol<S2SV_blank>(0x%04x)"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Minimum/Maximum<S2SV_blank>DLCI:<S2SV_blank>%u/%u,<S2SV_blank>%s%s<S2SV_blank>bit<S2SV_blank>DLCI"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0x7fffff , ( EXTRACT_32BITS ( obj_tptr + 8 ) ) & 0x7fffff , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 0 ) ? ""10"" : """" , ( ( ( EXTRACT_16BITS ( obj_tptr + 4 ) >> 7 ) & 3 ) == 2 ) ? ""23"" : """" ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; case RSVP_CTYPE_4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>LSP<S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , tok2str ( gmpls_encoding_values , ""Unknown"" , * obj_tptr ) , * obj_tptr ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Payload<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , * ( obj_tptr + 1 ) ) , * ( obj_tptr + 1 ) , tok2str ( gmpls_payload_values , ""Unknown"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RRO : case RSVP_OBJ_ERO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : while ( obj_tlen >= 4 ) { u_char length ; ND_TCHECK2 ( * obj_tptr , 4 ) ; length = * ( obj_tptr + 1 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s,<S2SV_blank>length<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_xro_values , ""Unknown<S2SV_blank>%u"" , RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) , length ) ) ; if ( length == 0 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>ERROR:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>ERO<S2SV_blank>subtype"" , ident ) ) ; break ; } switch ( RSVP_OBJ_XRO_MASK_SUBOBJ ( * obj_tptr ) ) { u_char prefix_length ; case RSVP_OBJ_XRO_IPV4 : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; prefix_length = * ( obj_tptr + 6 ) ; if ( prefix_length != 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>Prefix<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>32"" , prefix_length ) ) ; goto invalid ; } ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>%s/%u,<S2SV_blank>Flags:<S2SV_blank>[%s]"" , RSVP_OBJ_XRO_MASK_LOOSE ( * obj_tptr ) ? ""Loose"" : ""Strict"" , ipaddr_string ( ndo , obj_tptr + 2 ) , * ( obj_tptr + 6 ) , bittok2str ( rsvp_obj_rro_flag_values , ""none"" , * ( obj_tptr + 7 ) ) ) ) ; break ; case RSVP_OBJ_XRO_LABEL : if ( length != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ERROR:<S2SV_blank>length<S2SV_blank>!=<S2SV_blank>8"" ) ) ; goto invalid ; } ND_TCHECK2 ( * obj_tptr , 8 ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%u"" , bittok2str ( rsvp_obj_rro_label_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) , tok2str ( rsvp_ctype_values , ""Unknown"" , * ( obj_tptr + 3 ) + 256 * RSVP_OBJ_RRO ) , * ( obj_tptr + 3 ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; } obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_HELLO : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Instance:<S2SV_blank>0x%08x,<S2SV_blank>Destination<S2SV_blank>Instance:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RESTART_CAPABILITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Restart<S2SV_blank><S2SV_blank>Time:<S2SV_blank>%ums,<S2SV_blank>Recovery<S2SV_blank>Time:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SESSION_ATTRIBUTE : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 4 ) return - 1 ; namelen = * ( obj_tptr + 3 ) ; if ( obj_tlen < 4 + namelen ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Session<S2SV_blank>Name:<S2SV_blank>"" , ident ) ) ; for ( i = 0 ; i < namelen ; i ++ ) safeputchar ( ndo , * ( obj_tptr + 4 + i ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Flags:<S2SV_blank>[%s]<S2SV_blank>(%#x)"" , ident , ( int ) * obj_tptr , ( int ) * ( obj_tptr + 1 ) , bittok2str ( rsvp_session_attribute_flag_values , ""none"" , * ( obj_tptr + 2 ) ) , * ( obj_tptr + 2 ) ) ) ; obj_tlen -= 4 + * ( obj_tptr + 3 ) ; obj_tptr += 4 + * ( obj_tptr + 3 ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_GENERALIZED_UNI : switch ( rsvp_obj_ctype ) { int subobj_type , af , subobj_len , total_subobj_len ; case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; total_subobj_len = obj_tlen ; while ( total_subobj_len > 0 ) { subobj_len = EXTRACT_16BITS ( obj_tptr ) ; subobj_type = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) >> 8 ; af = ( EXTRACT_16BITS ( obj_tptr + 2 ) ) & 0x00FF ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subobject<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>AF:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_generalized_uni_values , ""Unknown"" , subobj_type ) , subobj_type , tok2str ( af_values , ""Unknown"" , af ) , af , subobj_len ) ) ; if ( subobj_len == 0 ) goto invalid ; switch ( subobj_type ) { case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS : case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS : switch ( af ) { case AFNUM_INET : if ( subobj_len < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv4<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_INET6 : if ( subobj_len < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>UNI<S2SV_blank>IPv6<S2SV_blank>TNA<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr + 4 ) ) ) ; break ; case AFNUM_NSAP : if ( subobj_len ) { hexdump = TRUE ; } break ; } break ; case RSVP_GEN_UNI_SUBOBJ_DIVERSITY : if ( subobj_len ) { hexdump = TRUE ; } break ; case RSVP_GEN_UNI_SUBOBJ_EGRESS_LABEL : if ( subobj_len < 16 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>U-bit:<S2SV_blank>%x,<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u,<S2SV_blank>Logical<S2SV_blank>port<S2SV_blank>id:<S2SV_blank>%u,<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 31 ) , ( ( EXTRACT_32BITS ( obj_tptr + 4 ) ) & 0xFF ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case RSVP_GEN_UNI_SUBOBJ_SERVICE_LEVEL : if ( subobj_len < 8 ) { return - 1 ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Service<S2SV_blank>level:<S2SV_blank>%u"" , ident , ( EXTRACT_32BITS ( obj_tptr + 4 ) ) >> 24 ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; obj_tptr += subobj_len ; obj_tlen += subobj_len ; } if ( total_subobj_len ) { hexdump = TRUE ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_RSVP_HOP : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; if ( obj_tlen ) hexdump = TRUE ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Previous/Next<S2SV_blank>Interface:<S2SV_blank>%s,<S2SV_blank>Logical<S2SV_blank>Interface<S2SV_blank>Handle:<S2SV_blank>0x%08x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_TIME_VALUES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Refresh<S2SV_blank>Period:<S2SV_blank>%ums"" , ident , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SENDER_TSPEC : case RSVP_OBJ_ADSPEC : case RSVP_OBJ_FLOWSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_2 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Msg-Version:<S2SV_blank>%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , ( * obj_tptr & 0xf0 ) >> 4 , EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( obj_tlen >= 4 ) { intserv_serv_tlen = EXTRACT_16BITS ( obj_tptr + 2 ) << 2 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Service<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>break<S2SV_blank>bit<S2SV_blank>%s<S2SV_blank>set,<S2SV_blank>Service<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_intserv_service_type_values , ""unknown"" , * ( obj_tptr ) ) , * ( obj_tptr ) , ( * ( obj_tptr + 1 ) & 0x80 ) ? """" : ""not"" , intserv_serv_tlen ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; while ( intserv_serv_tlen >= 4 ) { processed = rsvp_intserv_print ( ndo , obj_tptr , obj_tlen ) ; if ( processed == 0 ) break ; obj_tlen -= processed ; intserv_serv_tlen -= processed ; obj_tptr += processed ; } } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FILTERSPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Source<S2SV_blank>Port:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_3 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flow<S2SV_blank>Label:<S2SV_blank>%u"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_24BITS ( obj_tptr + 17 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_TUNNEL_IPV6 : if ( obj_tlen < 20 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) ) ) ; obj_tlen -= 20 ; obj_tptr += 20 ; break ; case RSVP_CTYPE_13 : if ( obj_tlen < 40 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 18 ) , ident , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_16BITS ( obj_tptr + 38 ) ) ) ; obj_tlen -= 40 ; obj_tptr += 40 ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Source<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP-ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_12 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Tunnel<S2SV_blank>Sender<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>LSP<S2SV_blank>ID:<S2SV_blank>0x%04x"" ""%s<S2SV_blank><S2SV_blank>Sub-Group<S2SV_blank>Originator<S2SV_blank>ID:<S2SV_blank>%s,<S2SV_blank>Sub-Group<S2SV_blank>ID:<S2SV_blank>0x%04x"" , ident , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 6 ) , ident , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_16BITS ( obj_tptr + 12 ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_FASTREROUTE : obj_ptr . rsvp_obj_frr = ( const struct rsvp_obj_frr_t * ) obj_tptr ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( rsvp_obj_ctype ) { <S2SV_EndBug> case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include-any:<S2SV_blank>0x%08x,<S2SV_blank>Exclude-any:<S2SV_blank>0x%08x,<S2SV_blank>Include-all:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_all ) ) ) ; obj_tlen -= sizeof ( struct rsvp_obj_frr_t ) ; obj_tptr += sizeof ( struct rsvp_obj_frr_t ) ; break ; case RSVP_CTYPE_TUNNEL_IPV4 : if ( obj_tlen < 16 ) return - 1 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Setup<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Holding<S2SV_blank>Priority:<S2SV_blank>%u,<S2SV_blank>Hop-limit:<S2SV_blank>%u,<S2SV_blank>Bandwidth:<S2SV_blank>%.10g<S2SV_blank>Mbps"" , <S2SV_EndBug> ident , ( int ) obj_ptr . rsvp_obj_frr -> setup_prio , ( int ) obj_ptr . rsvp_obj_frr -> hold_prio , ( int ) obj_ptr . rsvp_obj_frr -> hop_limit , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Include<S2SV_blank>Colors:<S2SV_blank>0x%08x,<S2SV_blank>Exclude<S2SV_blank>Colors:<S2SV_blank>0x%08x"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> include_any ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> exclude_any ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_DETOUR : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_TUNNEL_IPV4 : while ( obj_tlen >= 8 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>PLR-ID:<S2SV_blank>%s,<S2SV_blank>Avoid-Node-ID:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) , ipaddr_string ( ndo , obj_tptr + 4 ) ) ) ; obj_tlen -= 8 ; obj_tptr += 8 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_CLASSTYPE : case RSVP_OBJ_CLASSTYPE_OLD : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>CT:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr ) & 0x7 ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ERROR_SPEC : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_3 : case RSVP_CTYPE_IPV4 : if ( obj_tlen < 8 ) return - 1 ; error_code = * ( obj_tptr + 5 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 6 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ipaddr_string ( ndo , obj_tptr ) , * ( obj_tptr + 4 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE : case RSVP_OBJ_ERROR_SPEC_CODE_DIFFSERV_TE_OLD : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_diffserv_te_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>Unknown<S2SV_blank>Error<S2SV_blank>Value<S2SV_blank>(%u)"" , error_value ) ) ; break ; } obj_tlen -= 8 ; obj_tptr += 8 ; break ; case RSVP_CTYPE_4 : case RSVP_CTYPE_IPV6 : if ( obj_tlen < 20 ) return - 1 ; error_code = * ( obj_tptr + 17 ) ; error_value = EXTRACT_16BITS ( obj_tptr + 18 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Node<S2SV_blank>Address:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[0x%02x]%s<S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s<S2SV_blank>(%u)"" , ident , ip6addr_string ( ndo , obj_tptr ) , * ( obj_tptr + 16 ) , ident , tok2str ( rsvp_obj_error_code_values , ""unknown"" , error_code ) , error_code ) ) ; switch ( error_code ) { case RSVP_OBJ_ERROR_SPEC_CODE_ROUTING : ND_PRINT ( ( ndo , "",<S2SV_blank>Error<S2SV_blank>Value:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( rsvp_obj_error_code_routing_values , ""unknown"" , error_value ) , error_value ) ) ; break ; default : break ; } obj_tlen -= 20 ; obj_tptr += 20 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_PROPERTIES : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; padbytes = EXTRACT_16BITS ( obj_tptr + 2 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TLV<S2SV_blank>count:<S2SV_blank>%u,<S2SV_blank>padding<S2SV_blank>bytes:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( obj_tptr ) , padbytes ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 2 + padbytes ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(0x%02x),<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_prop_tlv_values , ""unknown"" , * obj_tptr ) , * obj_tptr , * ( obj_tptr + 1 ) ) ) ; if ( obj_tlen < * ( obj_tptr + 1 ) ) return - 1 ; if ( * ( obj_tptr + 1 ) < 2 ) return - 1 ; print_unknown_data ( ndo , obj_tptr + 2 , ""\\n\\t\\t"" , * ( obj_tptr + 1 ) - 2 ) ; obj_tlen -= * ( obj_tptr + 1 ) ; obj_tptr += * ( obj_tptr + 1 ) ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_MESSAGE_ID : case RSVP_OBJ_MESSAGE_ID_ACK : case RSVP_OBJ_MESSAGE_ID_LIST : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : case RSVP_CTYPE_2 : if ( obj_tlen < 8 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[0x%02x],<S2SV_blank>epoch:<S2SV_blank>%u"" , ident , * obj_tptr , EXTRACT_24BITS ( obj_tptr + 1 ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message-ID<S2SV_blank>0x%08x<S2SV_blank>(%u)"" , ident , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_INTEGRITY : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_integrity_t ) ) return - 1 ; obj_ptr . rsvp_obj_integrity = ( const struct rsvp_obj_integrity_t * ) obj_tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Key-ID<S2SV_blank>0x%04x%08x,<S2SV_blank>Sequence<S2SV_blank>0x%08x%08x,<S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , EXTRACT_16BITS ( obj_ptr . rsvp_obj_integrity -> key_id ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> key_id + 2 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> sequence + 4 ) , bittok2str ( rsvp_obj_integrity_flag_values , ""none"" , obj_ptr . rsvp_obj_integrity -> flags ) ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>MD5-sum<S2SV_blank>0x%08x%08x%08x%08x<S2SV_blank>"" , ident , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 4 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 8 ) , EXTRACT_32BITS ( obj_ptr . rsvp_obj_integrity -> digest + 12 ) ) ) ; sigcheck = signature_verify ( ndo , pptr , plen , obj_ptr . rsvp_obj_integrity -> digest , rsvp_clear_checksum , rsvp_com_header ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s)"" , tok2str ( signature_check_values , ""Unknown"" , sigcheck ) ) ) ; obj_tlen += sizeof ( struct rsvp_obj_integrity_t ) ; obj_tptr += sizeof ( struct rsvp_obj_integrity_t ) ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_ADMIN_STATUS : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Flags<S2SV_blank>[%s]"" , ident , bittok2str ( rsvp_obj_admin_status_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_LABEL_SET : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < 4 ) return - 1 ; action = ( EXTRACT_16BITS ( obj_tptr ) >> 8 ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Action:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Label<S2SV_blank>type:<S2SV_blank>%u"" , ident , tok2str ( rsvp_obj_label_set_action_values , ""Unknown"" , action ) , action , ( ( EXTRACT_32BITS ( obj_tptr ) & 0x7F ) ) ) ) ; switch ( action ) { case LABEL_SET_INCLUSIVE_RANGE : case LABEL_SET_EXCLUSIVE_RANGE : if ( obj_tlen < 12 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Start<S2SV_blank>range:<S2SV_blank>%u,<S2SV_blank>End<S2SV_blank>range:<S2SV_blank>%u"" , ident , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; obj_tlen -= 12 ; obj_tptr += 12 ; break ; default : obj_tlen -= 4 ; obj_tptr += 4 ; subchannel = 1 ; while ( obj_tlen >= 4 ) { ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Subchannel<S2SV_blank>#%u:<S2SV_blank>%u"" , ident , subchannel , EXTRACT_32BITS ( obj_tptr ) ) ) ; obj_tptr += 4 ; obj_tlen -= 4 ; subchannel ++ ; } break ; } break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_S2L : switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_IPV4 : if ( obj_tlen < 4 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ipaddr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 4 ; obj_tptr += 4 ; break ; case RSVP_CTYPE_IPV6 : if ( obj_tlen < 16 ) return - 1 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Sub-LSP<S2SV_blank>destination<S2SV_blank>address:<S2SV_blank>%s"" , ident , ip6addr_string ( ndo , obj_tptr ) ) ) ; obj_tlen -= 16 ; obj_tptr += 16 ; break ; default : hexdump = TRUE ; } break ; case RSVP_OBJ_SCOPE : case RSVP_OBJ_POLICY_DATA : case RSVP_OBJ_ACCEPT_LABEL_SET : case RSVP_OBJ_PROTECTION : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct rsvp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , rsvp_obj_len - sizeof ( struct rsvp_object_header ) ) ; tptr += rsvp_obj_len ; tlen -= rsvp_obj_len ; } return 0 ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return - 1 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return - 1 ; }
","<S2SV_ModStart> ) obj_tptr ; switch ( rsvp_obj_ctype ) { case RSVP_CTYPE_1 : if ( obj_tlen < sizeof ( struct rsvp_obj_frr_t ) ) return - 1 ; <S2SV_ModStart> bandwidth ) ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - 1 ; bw . i = EXTRACT_32BITS ( obj_ptr . rsvp_obj_frr -> bandwidth ) ;
",the-tcpdump-group@tcpdump/3c8a2b0e91d8d8947e89384dacf6b54673083e71,CVE-2017-13048,https://github.com/the-tcpdump-group/tcpdump/commit/3c8a2b0e91d8d8947e89384dacf6b54673083e71,2017-09-14T06:29Z
CWE-119,"CWE-119 static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , <S2SV_StartBug> int uv_block_size , <S2SV_EndBug> int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel = <S2SV_StartBug> vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; <S2SV_EndBug> enum mv_precision mv_precision_uv ; int uv_stride ; <S2SV_StartBug> if ( uv_block_size == 8 ) { <S2SV_EndBug> uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } <S2SV_StartBug> vp9_build_inter_predictor ( y_mb_ptr , stride , <S2SV_EndBug> & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride , <S2SV_StartBug> & pred [ 256 ] , uv_block_size , <S2SV_EndBug> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride , <S2SV_StartBug> & pred [ 512 ] , uv_block_size , <S2SV_EndBug> & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }
","<S2SV_ModStart> stride , int uv_block_width , int uv_block_height <S2SV_ModEnd> , int mv_row <S2SV_ModStart> const kernel = vp9_filter_kernels [ <S2SV_ModEnd> xd -> mi <S2SV_ModStart> mbmi . interp_filter ] <S2SV_ModEnd> ; enum mv_precision <S2SV_ModStart> ; if ( uv_block_width <S2SV_ModEnd> == 8 ) <S2SV_ModStart> MV_PRECISION_Q3 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_highbd_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; vp9_highbd_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height , which_mv , kernel , mv_precision_uv , x , y , xd -> bd ) ; return ; } # endif <S2SV_ModStart> 256 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv , <S2SV_ModStart> 512 ] , uv_block_width , & mv , scale , uv_block_width , uv_block_height <S2SV_ModEnd> , which_mv ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; <S2SV_StartBug> show_object ( obj , NULL , name , data ) ; <S2SV_EndBug> continue ; } if ( ! path ) path = """" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , <S2SV_StartBug> NULL , path , data ) ; <S2SV_EndBug> continue ; } die ( ""unknown<S2SV_blank>pending<S2SV_blank>object<S2SV_blank>%s<S2SV_blank>(%s)"" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
","<S2SV_ModStart> ( obj , <S2SV_ModEnd> name , data <S2SV_ModStart> , show_object , & base <S2SV_ModEnd> , path ,
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-20,"CWE-20 static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> timeout = sock_rcvtimeo
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static void set_segment_id ( VP9_COMMON * cm , BLOCK_SIZE bsize , <S2SV_EndBug> int mi_row , int mi_col , int segment_id ) { <S2SV_StartBug> const int mi_offset = mi_row * cm -> mi_cols + mi_col ; <S2SV_EndBug> const int bw = num_8x8_blocks_wide_lookup [ bsize ] ; const int bh = num_8x8_blocks_high_lookup [ bsize ] ; const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ; const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ; int x , y ; assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ; <S2SV_StartBug> for ( y = 0 ; y < ymis ; y ++ ) <S2SV_EndBug> <S2SV_StartBug> for ( x = 0 ; x < xmis ; x ++ ) <S2SV_EndBug> <S2SV_StartBug> cm -> last_frame_seg_map [ mi_offset + y * cm -> mi_cols + x ] = segment_id ; <S2SV_EndBug> }
","<S2SV_ModStart> * cm , int mi_offset , int x_mis , int y_mis <S2SV_ModEnd> , int segment_id <S2SV_ModStart> segment_id ) { <S2SV_ModEnd> int x , <S2SV_ModStart> ; y < y_mis <S2SV_ModEnd> ; y ++ <S2SV_ModStart> ; x < x_mis <S2SV_ModEnd> ; x ++ <S2SV_ModStart> ) cm -> current_frame_seg_map <S2SV_ModEnd> [ mi_offset +
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z
CWE-19,"CWE-19 STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> } <S2SV_EndBug> retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; error = xfs_attr_node_addname ( args ) ; return ( error ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) return ( error ) ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) return ( error ) ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_StartBug> if ( args -> rmtblkno ) { <S2SV_EndBug> error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; xfs_attr3_leaf_remove ( bp , args ) ; if ( ( forkoff = xfs_attr_shortform_allfit ( bp , dp ) ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_shortform ( bp , args , forkoff ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; } return error ; }
","<S2SV_ModStart> -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; args -> rmtvaluelen = 0 ; <S2SV_ModStart> -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2 ;
",torvalds@linux/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,CVE-2015-0274,https://github.com/torvalds/linux/commit/8275cdd0e7ac550dcce2b3ef6d2fb3b808c1ae59,2015-03-16T10:59Z
CWE-434,"CWE-434 static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , ""unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d"" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; <S2SV_StartBug> nPath = ( int ) strlen ( zPath ) ; <S2SV_EndBug> mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( ""%s/"" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; nPath ++ ; } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , ""duplicate<S2SV_blank>name:<S2SV_blank>\\""%s\\"""" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }
","<S2SV_ModStart> ] ) ; if ( zPath == 0 ) zPath = """" ;
",sqlite@sqlite/54d501092d88c0cf89bec4279951f548fb0b8618,CVE-2019-19925,https://github.com/sqlite/sqlite/commit/54d501092d88c0cf89bec4279951f548fb0b8618,2019-12-24T17:15Z
CWE-119,"CWE-119 void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""Mb<S2SV_blank>mv<S2SV_blank>ref<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UV<S2SV_blank>Modes<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } <S2SV_StartBug> fprintf ( mvs , ""\\n"" ) ; <S2SV_EndBug> mb_index = 0 ; fprintf ( mvs , ""Mbs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; if ( mi [ mb_index ] . mbmi . mode == B_PRED ) fprintf ( mvs , ""%2d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . as_mode ) ; else fprintf ( mvs , ""xx<S2SV_blank>"" ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%5d:%-5d"" , mi [ mb_index ] . mbmi . mv . as_mv . row / 2 , mi [ mb_index ] . mbmi . mv . as_mv . col / 2 ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } fprintf ( mvs , ""\\n"" ) ; <S2SV_StartBug> mb_index = 0 ; <S2SV_EndBug> fprintf ( mvs , ""MVs<S2SV_blank>for<S2SV_blank>Frame<S2SV_blank>%d\\n"" , frame ) ; { int b_row ; for ( b_row = 0 ; b_row < 4 * rows ; b_row ++ ) { int b_col ; int bindex ; for ( b_col = 0 ; b_col < 4 * cols ; b_col ++ ) { mb_index = ( b_row >> 2 ) * ( cols + 1 ) + ( b_col >> 2 ) ; bindex = ( b_row & 3 ) * 4 + ( b_col & 3 ) ; fprintf ( mvs , ""%3d:%-3d<S2SV_blank>"" , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . row , mi [ mb_index ] . bmi [ bindex ] . mv . as_mv . col ) ; } fprintf ( mvs , ""\\n"" ) ; } } fprintf ( mvs , ""\\n"" ) ; fclose ( mvs ) ; }
","<S2SV_ModStart> , ""\\n"" ) <S2SV_ModEnd> ; fprintf ( <S2SV_ModStart> ""\\n"" ) ; <S2SV_ModEnd> fprintf ( mvs
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-362,"CWE-362 void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }
","<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> umap_lock ) ; skip_mm :
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-295,"CWE-295 NOEXPORT void transfer ( CLI * c ) { int timeout ; int pending ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L int has_pending = 0 , prev_has_pending ; # endif <S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> ssize_t num ; int err ; int sock_open_rd = 1 , sock_open_wr = 1 ; int shutdown_wants_read = 0 , shutdown_wants_write = 0 ; int read_wants_read = 0 , read_wants_write = 0 ; int write_wants_read = 0 , write_wants_write = 0 ; int sock_can_rd , sock_can_wr , ssl_can_rd , ssl_can_wr ; # ifdef USE_WIN32 unsigned long bytes ; # else int bytes ; # endif c -> sock_ptr = c -> ssl_ptr = 0 ; do { read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; s_poll_init ( c -> fds , 0 ) ; if ( sock_open_rd ) s_poll_add ( c -> fds , c -> sock_rfd -> fd , c -> sock_ptr < BUFFSIZE , 0 ) ; if ( sock_open_wr ) s_poll_add ( c -> fds , c -> sock_wfd -> fd , 0 , c -> ssl_ptr > 0 ) ; if ( SSL_get_shutdown ( c -> ssl ) != ( SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ) { s_poll_add ( c -> fds , c -> ssl_rfd -> fd , read_wants_read || write_wants_read || shutdown_wants_read , 0 ) ; s_poll_add ( c -> fds , c -> ssl_wfd -> fd , 0 , read_wants_write || write_wants_write || shutdown_wants_write ) ; } pending = SSL_pending ( c -> ssl ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L prev_has_pending = has_pending ; has_pending = SSL_has_pending ( c -> ssl ) ; pending = pending || ( has_pending && ! prev_has_pending ) ; # endif if ( read_wants_read && pending ) { timeout = 0 ; } else if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { timeout = c -> opt -> timeout_idle ; } else { timeout = c -> opt -> timeout_close ; } err = s_poll_wait ( c -> fds , timeout , 0 ) ; switch ( err ) { case - 1 : sockerror ( ""transfer:<S2SV_blank>s_poll_wait"" ) ; throw_exception ( c , 1 ) ; case 0 : if ( read_wants_read && pending ) break ; if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { s_log ( LOG_INFO , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTidle<S2SV_blank>exceeded:<S2SV_blank>sending<S2SV_blank>reset"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_ERR , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTclose<S2SV_blank>exceeded:<S2SV_blank>closing"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; return ; } sock_can_rd = s_poll_canread ( c -> fds , c -> sock_rfd -> fd ) ; sock_can_wr = s_poll_canwrite ( c -> fds , c -> sock_wfd -> fd ) ; ssl_can_rd = s_poll_canread ( c -> fds , c -> ssl_rfd -> fd ) ; ssl_can_wr = s_poll_canwrite ( c -> fds , c -> ssl_wfd -> fd ) ; if ( c -> sock_rfd -> fd == c -> sock_wfd -> fd ) { if ( ( sock_can_rd || sock_can_wr ) && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>fd"" ) ; } } else { if ( sock_can_rd && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>rfd"" ) ; } if ( sock_can_wr && s_poll_err ( c -> fds , c -> sock_wfd -> fd ) ) { err = get_socket_error ( c -> sock_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>wfd"" ) ; } } if ( c -> ssl_rfd -> fd == c -> ssl_wfd -> fd ) { if ( ( ssl_can_rd || ssl_can_wr ) && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>fd"" ) ; } } else { if ( ssl_can_rd && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>rfd"" ) ; } if ( c -> ssl_rfd -> fd != c -> ssl_wfd -> fd && ssl_can_wr && s_poll_err ( c -> fds , c -> ssl_wfd -> fd ) ) { err = get_socket_error ( c -> ssl_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>wfd"" ) ; } } if ( ! ( sock_can_rd || sock_can_wr || ssl_can_rd || ssl_can_wr ) ) { if ( s_poll_hup ( c -> fds , c -> sock_rfd -> fd ) || s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; sock_open_rd = sock_open_wr = 0 ; } else if ( s_poll_hup ( c -> fds , c -> ssl_rfd -> fd ) || s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) { s_log ( LOG_ERR , ""Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request"" ) ; throw_exception ( c , 1 ) ; } if ( shutdown_wants_read || shutdown_wants_write ) { <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> if ( num < 0 ) <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> else err = SSL_ERROR_NONE ; switch ( err ) { case SSL_ERROR_NONE : s_log ( LOG_INFO , ""SSL_shutdown<S2SV_blank>successfully<S2SV_blank>sent<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_wr && sock_can_wr ) { <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""writesocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_DEBUG , ""writesocket<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ; c -> ssl_ptr -= ( size_t ) num ; memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ; c -> sock_bytes += ( size_t ) num ; watchdog = 0 ; } } if ( sock_open_rd && sock_can_rd ) { <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ; switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""readsocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)"" ) ; sock_open_rd = 0 ; break ; default : c -> sock_ptr += ( size_t ) num ; watchdog = 0 ; } } read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) { <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> write_wants_write = 0 ; <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ; c -> sock_ptr -= ( size_t ) num ; memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ; c -> ssl_bytes += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; write_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; write_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , ""SSL_write"" ) ) <S2SV_EndBug> break ; if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; <S2SV_EndBug> if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { read_wants_read = 0 ; read_wants_write = 0 ; num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SYSCALL : if ( num && parse_socket_error ( c , ""SSL_read"" ) ) break ; if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_read/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_rd && s_poll_rdhup ( c -> fds , c -> sock_rfd -> fd ) && ( ioctlsocket ( c -> sock_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; sock_open_rd = 0 ; } if ( sock_open_wr && s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; sock_open_wr = 0 ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && s_poll_rdhup ( c -> fds , c -> ssl_rfd -> fd ) && ( ioctlsocket ( c -> ssl_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ; } if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) { sock_open_wr = 0 ; if ( ! c -> sock_wfd -> is_socket ) { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor"" ) ; sock_open_rd = 0 ; } else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) { s_log ( LOG_DEBUG , ""Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; } else { s_log ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; sock_open_rd = 0 ; } } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) { if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) { s_log ( LOG_DEBUG , ""Sending<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_write = 1 ; } else { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>SSLv2<S2SV_blank>socket"" ) ; if ( c -> ssl_rfd -> is_socket ) shutdown ( c -> ssl_rfd -> fd , SHUT_RD ) ; if ( c -> ssl_wfd -> is_socket ) shutdown ( c -> ssl_wfd -> fd , SHUT_WR ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( ++ watchdog > 100 ) { s_log ( LOG_ERR , ""transfer()<S2SV_blank>loop<S2SV_blank>executes<S2SV_blank>not<S2SV_blank>transferring<S2SV_blank>any<S2SV_blank>data"" ) ; s_log ( LOG_ERR , ""please<S2SV_blank>report<S2SV_blank>the<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>Michal.Trojnara@stunnel.org"" ) ; stunnel_info ( LOG_ERR ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d,<S2SV_blank>SSL_has_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) , SSL_has_pending ( c -> ssl ) ) ; # else s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) ) ; # endif s_log ( LOG_ERR , ""sock_open_rd=%s,<S2SV_blank>sock_open_wr=%s"" , sock_open_rd ? ""Y"" : ""n"" , sock_open_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""SSL_RECEIVED_SHUTDOWN=%s,<S2SV_blank>SSL_SENT_SHUTDOWN=%s"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ? ""Y"" : ""n"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""sock_can_rd=%s,<S2SV_blank>sock_can_wr=%s"" , sock_can_rd ? ""Y"" : ""n"" , sock_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""ssl_can_rd=%s,<S2SV_blank>ssl_can_wr=%s"" , ssl_can_rd ? ""Y"" : ""n"" , ssl_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""read_wants_read=%s,<S2SV_blank>read_wants_write=%s"" , read_wants_read ? ""Y"" : ""n"" , read_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""write_wants_read=%s,<S2SV_blank>write_wants_write=%s"" , write_wants_read ? ""Y"" : ""n"" , write_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""shutdown_wants_read=%s,<S2SV_blank>shutdown_wants_write=%s"" , shutdown_wants_read ? ""Y"" : ""n"" , shutdown_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""socket<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s),<S2SV_blank>"" ""TLS<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } } while ( sock_open_wr || ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) || shutdown_wants_read || shutdown_wants_write ) ; }
","<S2SV_ModStart> watchdog = 0 <S2SV_ModEnd> ; int err <S2SV_ModStart> shutdown_wants_write ) { int <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ; <S2SV_ModStart> break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> sock_can_wr ) { ssize_t <S2SV_ModStart> sock_can_rd ) { ssize_t <S2SV_ModStart> ) ) { int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> switch ( err <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ) <S2SV_ModStart> break ; case SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> : if ( parse_socket_error ( c , ""SSL_write"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_read"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; default :
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-190,"CWE-190 static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_StartBug> defaultoptions ( & h ) ; <S2SV_EndBug> lua_settop ( L , 2 ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_StartBug> luaL_checkstack ( L , 1 , ""too<S2SV_blank>many<S2SV_blank>results"" ) ; <S2SV_EndBug> switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; <S2SV_StartBug> lua_pushnumber ( L , res ) ; <S2SV_EndBug> break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , f ) ; <S2SV_EndBug> break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; <S2SV_StartBug> lua_pushnumber ( L , d ) ; <S2SV_EndBug> break ; } case 'c' : { if ( size == 0 ) { <S2SV_StartBug> if ( ! lua_isnumber ( L , - 1 ) ) <S2SV_EndBug> <S2SV_StartBug> luaL_error ( L , ""format<S2SV_blank>`c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" ) ; <S2SV_EndBug> size = lua_tonumber ( L , - 1 ) ; <S2SV_StartBug> lua_pop ( L , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" ) ; <S2SV_EndBug> } <S2SV_StartBug> lua_pushlstring ( L , data + pos , size ) ; <S2SV_EndBug> break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , ""unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data"" ) ; size = ( e - ( data + pos ) ) + 1 ; <S2SV_StartBug> lua_pushlstring ( L , data + pos , size - 1 ) ; <S2SV_EndBug> break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; <S2SV_StartBug> return lua_gettop ( L ) - 2 ; <S2SV_EndBug> }
","<S2SV_ModStart> - 1 ; int n = 0 ; <S2SV_ModStart> ( & h <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( L , 2 <S2SV_ModEnd> , ""too<S2SV_blank>many<S2SV_blank>results"" ) <S2SV_ModStart> res ) ; n ++ ; <S2SV_ModStart> f ) ; n ++ ; <S2SV_ModStart> d ) ; n ++ ; <S2SV_ModStart> { if ( n == 0 || <S2SV_ModStart> ( L , ""format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size"" <S2SV_ModEnd> ) ; size <S2SV_ModStart> 1 ) ; n -- ; <S2SV_ModStart> ( L , <S2SV_ModEnd> size <= ld <S2SV_ModStart> size <= ld && pos <= ld - size , <S2SV_ModEnd> 2 , ""data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short"" <S2SV_ModStart> , size ) ; n ++ <S2SV_ModStart> 1 ) ; n ++ ; <S2SV_ModStart> ) ; return n + 1 <S2SV_ModEnd> ; } <S2SV_null>
",antirez@redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,CVE-2018-11219,https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,2018-06-17T17:29Z
CWE-119,"CWE-119 static void update_golden_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; if ( cpi -> refresh_golden_frame ) { rc -> frames_since_golden = 0 ; <S2SV_StartBug> if ( ! rc -> source_alt_ref_pending ) <S2SV_EndBug> <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ; } else if ( ! cpi -> refresh_alt_ref_frame ) { if ( rc -> frames_till_gf_update_due > 0 ) rc -> frames_till_gf_update_due -- ; rc -> frames_since_golden ++ ; } }
","<S2SV_ModStart> -> source_alt_ref_pending ) { <S2SV_ModStart> = 0 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-284,"CWE-284 void btif_hl_select_monitor_callback ( fd_set * p_cur_set , fd_set * p_org_set ) { UNUSED ( p_org_set ) ; BTIF_TRACE_DEBUG ( ""entering<S2SV_blank>%s"" , __FUNCTION__ ) ; for ( const list_node_t * node = list_begin ( soc_queue ) ; node != list_end ( soc_queue ) ; node = list_next ( node ) ) { btif_hl_soc_cb_t * p_scb = list_node ( node ) ; if ( btif_hl_get_socket_state ( p_scb ) == BTIF_HL_SOC_STATE_W4_READ ) { if ( FD_ISSET ( p_scb -> socket_id [ 1 ] , p_cur_set ) ) { BTIF_TRACE_DEBUG ( ""read<S2SV_blank>data<S2SV_blank>state=<S2SV_blank>BTIF_HL_SOC_STATE_W4_READ"" ) ; btif_hl_mdl_cb_t * p_dcb = BTIF_HL_GET_MDL_CB_PTR ( p_scb -> app_idx , p_scb -> mcl_idx , p_scb -> mdl_idx ) ; assert ( p_dcb != NULL ) ; if ( p_dcb -> p_tx_pkt ) { BTIF_TRACE_ERROR ( ""Rcv<S2SV_blank>new<S2SV_blank>pkt<S2SV_blank>but<S2SV_blank>the<S2SV_blank>last<S2SV_blank>pkt<S2SV_blank>is<S2SV_blank>still<S2SV_blank>not<S2SV_blank>been"" ""<S2SV_blank><S2SV_blank>sent<S2SV_blank>tx_size=%d"" , p_dcb -> tx_size ) ; btif_hl_free_buf ( ( void * * ) & p_dcb -> p_tx_pkt ) ; } p_dcb -> p_tx_pkt = btif_hl_get_buf ( p_dcb -> mtu ) ; if ( p_dcb ) { <S2SV_StartBug> int r = ( int ) recv ( p_scb -> socket_id [ 1 ] , p_dcb -> p_tx_pkt , <S2SV_EndBug> <S2SV_StartBug> p_dcb -> mtu , MSG_DONTWAIT ) ; <S2SV_EndBug> if ( r > 0 ) { BTIF_TRACE_DEBUG ( ""btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>r<S2SV_blank>=%d"" , r ) ; p_dcb -> tx_size = r ; BTIF_TRACE_DEBUG ( ""btif_hl_select_monitor_callback<S2SV_blank>send<S2SV_blank>data<S2SV_blank>tx_size=%d"" , p_dcb -> tx_size ) ; BTA_HlSendData ( p_dcb -> mdl_handle , p_dcb -> tx_size ) ; } else { BTIF_TRACE_DEBUG ( ""btif_hl_select_monitor_callback<S2SV_blank>receive<S2SV_blank>failed<S2SV_blank>r=%d"" , r ) ; BTA_HlDchClose ( p_dcb -> mdl_handle ) ; } } } } } if ( list_is_empty ( soc_queue ) ) BTIF_TRACE_DEBUG ( ""btif_hl_select_monitor_queue<S2SV_blank>is<S2SV_blank>empty"" ) ; BTIF_TRACE_DEBUG ( ""leaving<S2SV_blank>%s"" , __FUNCTION__ ) ; }
","<S2SV_ModStart> ( int ) TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_DONTWAIT ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame."" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; ++ frame_cnt ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-369,"CWE-369 static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
","<S2SV_ModStart> * F_SECT_PER_TRACK ; if ( ! F_SECT_PER_TRACK ) return ;
",torvalds@linux/f3554aeb991214cbfafd17d55e2bfddb50282e32,CVE-2019-14284,https://github.com/torvalds/linux/commit/f3554aeb991214cbfafd17d55e2bfddb50282e32,2019-07-26T13:15Z
CWE-190,"CWE-190 static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { <S2SV_StartBug> uchar magicbuf [ MIF_MAGICLEN ] ; <S2SV_EndBug> char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( ""error:<S2SV_blank>bad<S2SV_blank>signature\\n"" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( ""mif_getline<S2SV_blank>failed\\n"" ) ; goto error ; } if ( buf [ 0 ] == '\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( ""header<S2SV_blank>line:<S2SV_blank>len=%d;<S2SV_blank>%s\\n"" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( ""jas_tvparser_create<S2SV_blank>failed\\n"" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>record<S2SV_blank>type\\n"" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp ) ) ) -> id ; jas_tvparser_destroy ( tvp ) ; tvp = 0 ; switch ( id ) { case MIF_CMPT : if ( mif_process_cmpt ( hdr , buf ) ) { jas_eprintf ( ""cannot<S2SV_blank>get<S2SV_blank>component<S2SV_blank>information\\n"" ) ; goto error ; } break ; case MIF_END : done = 1 ; break ; default : jas_eprintf ( ""invalid<S2SV_blank>header<S2SV_blank>information:<S2SV_blank>%s\\n"" , buf ) ; goto error ; break ; } } while ( ! done ) ; return hdr ; error : if ( hdr ) { mif_hdr_destroy ( hdr ) ; } if ( tvp ) { jas_tvparser_destroy ( tvp ) ; } return 0 ; }
","<S2SV_ModStart> in ) { jas_uchar <S2SV_ModEnd> magicbuf [ MIF_MAGICLEN
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-787,"CWE-787 WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i = 0 ; i < N ; i ++ ) { window_output [ i ] = x [ i ] * interp_window_coeff [ i ] ; } for ( i = 0 ; i < 2 * anal_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 5 ; j ++ ) { accu_r = accu_r + window_output [ i + j * 2 * anal_size ] ; } u [ i ] = accu_r ; } if ( anal_size == 40 ) { for ( i = 1 ; i < anal_size ; i ++ ) { FLOAT32 temp1 = u [ i ] + u [ 2 * anal_size - i ] ; FLOAT32 temp2 = u [ i ] - u [ 2 * anal_size - i ] ; u [ i ] = temp1 ; u [ 2 * anal_size - i ] = temp2 ; } for ( k = 0 ; k < anal_size ; k ++ ) { accu_r = u [ anal_size ] ; if ( k & 1 ) accu_i = u [ 0 ] ; else accu_i = - u [ 0 ] ; for ( l = 1 ; l < anal_size ; l ++ ) { accu_r = accu_r + u [ 0 + l ] * analy_cos_sin_tab [ 2 * l + 0 ] ; accu_i = accu_i + u [ 2 * anal_size - l ] * analy_cos_sin_tab [ 2 * l + 1 ] ; } analy_cos_sin_tab += ( 2 * anal_size ) ; * anal_buf ++ = ( FLOAT32 ) accu_r ; * anal_buf ++ = ( FLOAT32 ) accu_i ; } } else { FLOAT32 * ptr_u = u_in ; FLOAT32 * ptr_v = u_out ; for ( k = 0 ; k < anal_size * 2 ; k ++ ) { * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; * ptr_u ++ = ( ( * analy_cos_sin_tab ++ ) * u [ k ] ) ; } <S2SV_StartBug> if ( ixheaacd_cmplx_anal_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_cmplx_anal_fft ) ( u_in , u_out , anal_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < anal_size / 2 ; k ++ ) { * ( anal_buf + 1 ) = - * ptr_v ++ ; * anal_buf = * ptr_v ++ ; anal_buf += 2 ; * ( anal_buf + 1 ) = * ptr_v ++ ; * anal_buf = - * ptr_v ++ ; anal_buf += 2 ; } } } return 0 ; }
","<S2SV_ModStart> } if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_cmplx_anal_fft ) ) <S2SV_ModEnd> ( u_in ,
",external@libxaac/04e8cd58f075bec5892e369c8deebca9c67e855c,CVE-2018-9496,https://android.googlesource.com/platform/external/libxaac/+/04e8cd58f075bec5892e369c8deebca9c67e855c,2018-10-02T19:29Z
CWE-125,"CWE-125 static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }
","<S2SV_ModStart> trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
",the-tcpdump-group@tcpdump/7d3aba9f06899d0128ef46e8a2fa143c6fad8f62,CVE-2017-13024,https://github.com/the-tcpdump-group/tcpdump/commit/7d3aba9f06899d0128ef46e8a2fa143c6fad8f62,2017-09-14T06:29Z
CWE-704,"CWE-704 static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }
","<S2SV_ModStart> c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
",torvalds@linux/966031f340185eddd05affcf72b740549f056348,CVE-2018-18386,https://github.com/torvalds/linux/commit/966031f340185eddd05affcf72b740549f056348,2018-10-17T20:29Z
CWE-119,"CWE-119 <S2SV_StartBug> static void encode_uniform ( vp9_writer * w , int v ) { <S2SV_EndBug> const int l = 8 ; const int m = ( 1 << l ) - 191 ; if ( v < m ) { <S2SV_StartBug> vp9_write_literal ( w , v , l - 1 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp9_write_literal ( w , m + ( ( v - m ) >> 1 ) , l - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , ( v - m ) & 1 , 1 ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> void encode_uniform ( vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> m ) { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> } else { vpx_write_literal <S2SV_ModEnd> ( w , <S2SV_ModStart> 1 ) ; vpx_write_literal <S2SV_ModEnd> ( w ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-400,"CWE-400 static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { <S2SV_StartBug> fpm_globals . max_requests = wp -> config -> pm_max_requests ; <S2SV_EndBug> if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , ""[pool<S2SV_blank>%s]<S2SV_blank>child<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>initialize"" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
","<S2SV_ModStart> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket )
",php@php-src/69dee5c732fe982c82edb17d0dbc3e79a47748d8,CVE-2015-9253,https://github.com/php/php-src/commit/69dee5c732fe982c82edb17d0dbc3e79a47748d8,2018-02-19T19:29Z
CWE-119,"CWE-119 static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
","<S2SV_ModStart> ( ) ; if ( ! tbuf ) { return NULL ; }
",radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18,CVE-2017-6194,https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18,2017-04-03T05:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }
","<S2SV_ModStart> cJSON * item , printbuffer * p <S2SV_ModStart> item -> valuestring , p
",esnet@iperf/91f2fa59e8ed80dfbf400add0164ee0e508e412a,CVE-2016-4303,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,2016-09-26T14:59Z
CWE-20,"CWE-20 static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; <S2SV_StartBug> DPRINTF ( 4 , ( ""enabling<S2SV_blank>filegen<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>statistics<S2SV_blank>\'%s%s\'\\n"" , <S2SV_EndBug> filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; <S2SV_StartBug> filegen_flag = filegen -> flag ; <S2SV_EndBug> filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) { default : NTP_INSIST ( 0 ) ; break ; case T_None : filegen_type = FILEGEN_NONE ; break ; case T_Pid : filegen_type = FILEGEN_PID ; break ; case T_Day : filegen_type = FILEGEN_DAY ; break ; case T_Week : filegen_type = FILEGEN_WEEK ; break ; case T_Month : filegen_type = FILEGEN_MONTH ; break ; case T_Year : filegen_type = FILEGEN_YEAR ; break ; case T_Age : filegen_type = FILEGEN_AGE ; break ; } break ; case T_Flag : switch ( my_opts -> value . i ) { case T_Link : filegen_flag |= FGEN_FLAG_LINK ; break ; case T_Nolink : filegen_flag &= ~ FGEN_FLAG_LINK ; break ; case T_Enable : filegen_flag |= FGEN_FLAG_ENABLED ; break ; case T_Disable : filegen_flag &= ~ FGEN_FLAG_ENABLED ; break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>flag<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> value . i ) ; exit ( 1 ) ; } break ; default : msyslog ( LOG_ERR , ""Unknown<S2SV_blank>filegen<S2SV_blank>option<S2SV_blank>token<S2SV_blank>%d"" , my_opts -> attr ) ; exit ( 1 ) ; } } filegen_config ( filegen , filegen_file , filegen_type , filegen_flag ) ; } }
","<S2SV_ModStart> filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats<S2SV_blank>%s<S2SV_blank>unrecognized"" , filegen_string ) ; continue ; } <S2SV_ModStart> filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegen<S2SV_blank>category<S2SV_blank>\'%s\'<S2SV_blank>unrecognized"" , filegen_file ) ; continue ; }
",ntp-project@ntp/52e977d79a0c4ace997e5c74af429844da2f27be,CVE-2015-5195,https://github.com/ntp-project/ntp/commit/52e977d79a0c4ace997e5c74af429844da2f27be,2017-07-21T14:29Z
CWE-400,"CWE-400 asmlinkage void user_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir ; if ( ! ( current -> thread . flags & SPARC_FLAG_UNALIGNED ) || ( ( ( insn >> 30 ) & 3 ) != 3 ) ) goto kill_user ; dir = decode_direction ( insn ) ; if ( ! ok_for_user ( regs , insn , dir ) ) { goto kill_user ; } else { int err , size = decode_access_size ( insn ) ; unsigned long addr ; if ( floating_point_load_or_store_p ( insn ) ) { printk ( ""User<S2SV_blank>FPU<S2SV_blank>load/store<S2SV_blank>unaligned<S2SV_blank>unsupported.\\n"" ) ; goto kill_user ; } addr = compute_effective_address ( regs , insn ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) , size , ( unsigned long * ) addr , decode_signedness ( insn ) ) ; break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs ) ; break ; case both : printk ( ""Unaligned<S2SV_blank>SWAP<S2SV_blank>unsupported.\\n"" ) ; err = - EFAULT ; break ; default : unaligned_panic ( ""Impossible<S2SV_blank>user<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; goto out ; } if ( err ) goto kill_user ; else advance ( regs ) ; goto out ; } kill_user : user_mna_trap_fault ( regs , insn ) ; out : ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , addr
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-908,"CWE-908 static void cmd_anal_esil ( RCore * core , const char * input ) { RAnalEsil * esil = core -> anal -> esil ; ut64 addr = core -> offset ; ut64 adr ; char * n , * n1 ; int off ; int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; int iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; int romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; int stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; int noNULL = r_config_get_i ( core -> config , ""esil.noNULL"" ) ; ut64 until_addr = UT64_MAX ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; const char * until_expr = NULL ; RAnalOp * op ; switch ( input [ 0 ] ) { case 'p' : switch ( input [ 1 ] ) { case 'c' : if ( input [ 2 ] == '<S2SV_blank>' ) { r_core_cmdf ( core , ""ar<S2SV_blank>PC=%s"" , input + 3 ) ; r_core_cmd0 ( core , "".ar*"" ) ; } else { eprintf ( ""Missing<S2SV_blank>argument\\n"" ) ; } break ; case 0 : r_anal_pin_list ( core -> anal ) ; break ; case '-' : if ( input [ 2 ] ) addr = r_num_math ( core -> num , input + 2 ) ; r_anal_pin_unset ( core -> anal , addr ) ; break ; case '<S2SV_blank>' : r_anal_pin ( core -> anal , addr , input + 2 ) ; break ; default : r_core_cmd_help ( core , help_msg_aep ) ; break ; } break ; case 'r' : cmd_anal_reg ( core , input + 1 ) ; break ; case '*' : if ( core -> anal -> esil ) { r_cons_printf ( ""trap:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap ) ; r_cons_printf ( ""trap-code:<S2SV_blank>%d\\n"" , core -> anal -> esil -> trap_code ) ; } else { eprintf ( ""esil<S2SV_blank>vm<S2SV_blank>not<S2SV_blank>initialized.<S2SV_blank>run<S2SV_blank>`aei`\\n"" ) ; } break ; case '<S2SV_blank>' : if ( ! esil ) { if ( ! ( core -> anal -> esil = esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 1 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; break ; case 's' : switch ( input [ 1 ] ) { case '?' : eprintf ( ""See:<S2SV_blank>ae?~aes\\n"" ) ; break ; case 'l' : { ut64 pc = r_debug_reg_get ( core -> dbg , ""PC"" ) ; RAnalOp * op = r_core_anal_op ( core , pc ) ; if ( ! op ) { break ; } r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_debug_reg_set ( core -> dbg , ""PC"" , pc + op -> size ) ; r_anal_esil_set_pc ( esil , pc + op -> size ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'b' : if ( ! r_core_esil_step_back ( core ) ) { eprintf ( ""cannnot<S2SV_blank>step<S2SV_blank>back\\n"" ) ; } r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'u' : if ( input [ 2 ] == 'e' ) { until_expr = input + 3 ; } else { until_addr = r_num_math ( core -> num , input + 2 ) ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'o' : op = r_core_anal_op ( core , r_reg_getv ( core -> anal -> reg , r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ) ) ; if ( op && op -> type == R_ANAL_OP_TYPE_CALL ) { until_addr = op -> addr + op -> size ; } r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_anal_op_free ( op ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; case 'p' : n = strchr ( input , '<S2SV_blank>' ) ; n1 = n ? strchr ( n + 1 , '<S2SV_blank>' ) : NULL ; if ( ( ! n || ! n1 ) || ( ! ( n + 1 ) || ! ( n1 + 1 ) ) ) { eprintf ( ""aesp<S2SV_blank>[offset]<S2SV_blank>[num]\\n"" ) ; break ; } adr = r_num_math ( core -> num , n + 1 ) ; off = r_num_math ( core -> num , n1 + 1 ) ; cmd_aespc ( core , adr , off ) ; break ; case '<S2SV_blank>' : n = strchr ( input , '<S2SV_blank>' ) ; if ( ! ( n + 1 ) ) { r_core_esil_step ( core , until_addr , until_expr , NULL ) ; break ; } off = r_num_math ( core -> num , n + 1 ) ; cmd_aespc ( core , - 1 , off ) ; break ; default : r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; break ; } break ; case 'c' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aec ) ; } else if ( input [ 1 ] == 's' ) { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; ut64 newaddr ; int ret ; for ( ; ; ) { op = r_core_anal_op ( core , addr ) ; if ( ! op ) { break ; } if ( op -> type == R_ANAL_OP_TYPE_SWI ) { eprintf ( ""syscall<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } if ( op -> type == R_ANAL_OP_TYPE_TRAP ) { eprintf ( ""trap<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , addr ) ; break ; } ret = r_core_esil_step ( core , UT64_MAX , NULL , NULL ) ; r_anal_op_free ( op ) ; op = NULL ; if ( core -> anal -> esil -> trap || core -> anal -> esil -> trap_code ) { break ; } if ( ! ret ) break ; r_core_cmd0 ( core , "".ar*"" ) ; newaddr = r_num_get ( core -> num , pc ) ; if ( addr == newaddr ) { addr ++ ; break ; } else { addr = newaddr ; } } if ( op ) { r_anal_op_free ( op ) ; } } else { if ( input [ 1 ] == 'u' && input [ 2 ] == 'e' ) until_expr = input + 3 ; else if ( input [ 1 ] == 'u' ) until_addr = r_num_math ( core -> num , input + 2 ) ; else until_expr = ""0"" ; r_core_esil_step ( core , until_addr , until_expr , NULL ) ; r_core_cmd0 ( core , "".ar*"" ) ; } break ; case 'i' : switch ( input [ 1 ] ) { case 's' : case 'm' : cmd_esil_mem ( core , input + 2 ) ; break ; case 'p' : r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; break ; case '?' : cmd_esil_mem ( core , ""?"" ) ; break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } r_anal_esil_free ( esil ) ; core -> anal -> esil = NULL ; break ; case 0 : r_anal_esil_free ( esil ) ; { const char * pc = r_reg_get_name ( core -> anal -> reg , R_REG_NAME_PC ) ; if ( r_reg_getv ( core -> anal -> reg , pc ) == 0LL ) { r_core_cmd0 ( core , ""ar<S2SV_blank>PC=$$"" ) ; } } if ( ! ( esil = core -> anal -> esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ) ) { return ; } r_anal_esil_setup ( esil , core -> anal , romem , stats , noNULL ) ; esil -> verbose = ( int ) r_config_get_i ( core -> config , ""esil.verbose"" ) ; { const char * s = r_config_get ( core -> config , ""cmd.esil.intr"" ) ; if ( s ) { char * my = strdup ( s ) ; if ( my ) { r_config_set ( core -> config , ""cmd.esil.intr"" , my ) ; free ( my ) ; } } } break ; } break ; case 'k' : switch ( input [ 1 ] ) { case '\\0' : input = ""123*"" ; case '<S2SV_blank>' : if ( esil && esil -> stats ) { char * out = sdb_querys ( esil -> stats , NULL , 0 , input + 2 ) ; if ( out ) { r_cons_println ( out ) ; free ( out ) ; } } else { eprintf ( ""esil.stats<S2SV_blank>is<S2SV_blank>empty.<S2SV_blank>Run<S2SV_blank>\'aei\'\\n"" ) ; } break ; case '-' : if ( esil ) { sdb_reset ( esil -> stats ) ; } break ; } break ; case 'f' : { RListIter * iter ; RAnalBlock * bb ; RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM ) ; if ( fcn ) { r_list_foreach ( fcn -> bbs , iter , bb ) { ut64 pc = bb -> addr ; ut64 end = bb -> addr + bb -> size ; RAnalOp op ; ut8 * buf ; int ret , bbs = end - pc ; if ( bbs < 1 || bbs > 0xfffff ) { eprintf ( ""Invalid<S2SV_blank>block<S2SV_blank>size\\n"" ) ; } buf = calloc ( 1 , bbs + 1 ) ; r_io_read_at ( core -> io , pc , buf , bbs ) ; int left ; while ( pc < end ) { left = R_MIN ( end - pc , 32 ) ; r_asm_set_pc ( core -> assembler , pc ) ; ret = r_anal_op ( core -> anal , & op , addr , buf , left , R_ANAL_OP_MASK_ALL ) ; if ( ret ) { r_reg_set_value_by_role ( core -> anal -> reg , R_REG_NAME_PC , pc ) ; r_anal_esil_parse ( esil , R_STRBUF_SAFEGET ( & op . esil ) ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_stack_free ( esil ) ; pc += op . size ; } else { pc += 4 ; } } } } else { eprintf ( ""Cannot<S2SV_blank>find<S2SV_blank>function<S2SV_blank>at<S2SV_blank>0x%08"" PFMT64x ""\\n"" , core -> offset ) ; } } break ; case 't' : switch ( input [ 1 ] ) { case 'r' : { RAnalEsil * esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; <S2SV_StartBug> if ( ! esil ) <S2SV_EndBug> return ; r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; r_anal_esil_parse ( esil , input + 2 ) ; r_anal_esil_dumpstack ( esil ) ; r_anal_esil_free ( esil ) ; break ; } case 's' : switch ( input [ 2 ] ) { case 0 : r_anal_esil_session_list ( esil ) ; break ; case '+' : r_anal_esil_session_add ( esil ) ; break ; default : r_core_cmd_help ( core , help_msg_aets ) ; break ; } break ; default : eprintf ( ""Unknown<S2SV_blank>command.<S2SV_blank>Use<S2SV_blank>`aetr`.\\n"" ) ; break ; } break ; case 'A' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 + ( 1 << 1 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 + ( 1 << 2 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 + ( 1 << 3 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 + ( 1 << 4 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 + ( 1 << 5 ) , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; } } else { cmd_aea ( core , 1 , core -> offset , ( int ) r_num_math ( core -> num , input + 2 ) ) ; } break ; case 'a' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_msg_aea ) ; } else if ( input [ 1 ] == 'r' ) { cmd_aea ( core , 1 << 1 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'w' ) { cmd_aea ( core , 1 << 2 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'n' ) { cmd_aea ( core , 1 << 3 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'j' ) { cmd_aea ( core , 1 << 4 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == '*' ) { cmd_aea ( core , 1 << 5 , core -> offset , r_num_math ( core -> num , input + 2 ) ) ; } else if ( input [ 1 ] == 'f' ) { RAnalFunction * fcn = r_anal_get_fcn_in ( core -> anal , core -> offset , - 1 ) ; if ( fcn ) { switch ( input [ 2 ] ) { case 'j' : cmd_aea ( core , 1 << 4 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; default : cmd_aea ( core , 1 , fcn -> addr , r_anal_fcn_size ( fcn ) ) ; break ; } break ; } } else { const char * arg = input [ 1 ] ? input + 2 : """" ; ut64 len = r_num_math ( core -> num , arg ) ; cmd_aea ( core , 0 , core -> offset , len ) ; } break ; case 'x' : { char * hex ; int ret , bufsz ; input = r_str_trim_ro ( input + 1 ) ; hex = strdup ( input ) ; if ( ! hex ) { break ; } RAnalOp aop = R_EMPTY ; bufsz = r_hex_str2bin ( hex , ( ut8 * ) hex ) ; ret = r_anal_op ( core -> anal , & aop , core -> offset , ( const ut8 * ) hex , bufsz , R_ANAL_OP_MASK_ALL ) ; if ( ret > 0 ) { const char * str = R_STRBUF_SAFEGET ( & aop . esil ) ; char * str2 = r_str_newf ( ""<S2SV_blank>%s"" , str ) ; cmd_anal_esil ( core , str2 ) ; free ( str2 ) ; } r_anal_op_fini ( & aop ) ; break ; } case '?' : if ( input [ 1 ] == '?' ) { r_core_cmd_help ( core , help_detail_ae ) ; break ; } default : r_core_cmd_help ( core , help_msg_ae ) ; break ; } }
","<S2SV_ModStart> ! esil ) { return ; } <S2SV_ModEnd> r_anal_esil_to_reil_setup ( esil
",radare@radare2/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,CVE-2018-11383,https://github.com/radare/radare2/commit/9d348bcc2c4bbd3805e7eec97b594be9febbdf9a,2018-05-22T19:29Z
CWE-000,"CWE-000 static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }
","<S2SV_ModStart> sk_buff * skb ; int err <S2SV_ModStart> = 0 ; err = <S2SV_ModEnd> dump_one_state ( x <S2SV_ModStart> & info ) ; if ( err <S2SV_ModStart> ) ; return ERR_PTR ( err ) <S2SV_ModEnd> ; } return
",torvalds@linux/864745d291b5ba80ea0bd0edcbe67273de368836,CVE-2013-1826,https://github.com/torvalds/linux/commit/864745d291b5ba80ea0bd0edcbe67273de368836,2013-03-22T11:59Z
CWE-835,"CWE-835 static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { ""invalid"" , ""rsasig"" , ""shared-secret"" , ""dsssig"" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; ND_TCHECK ( * ext ) ; UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>len=%d<S2SV_blank>method=%s"" , len - 4 , <S2SV_EndBug> STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; <S2SV_StartBug> if ( 1 < ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>authdata=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , "")<S2SV_blank>"" ) ) ; <S2SV_StartBug> } else if ( ndo -> ndo_vflag && 4 < len ) { <S2SV_EndBug> if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } <S2SV_StartBug> return ( const u_char * ) ext + len ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }
","<S2SV_ModStart> ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>method=%s"" <S2SV_ModEnd> , len - <S2SV_ModStart> ; if ( len > 4 ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 1 <S2SV_ModEnd> ) { ND_PRINT <S2SV_ModStart> ndo -> ndo_vflag <S2SV_ModEnd> ) { if <S2SV_ModStart> trunc ; } }
",the-tcpdump-group@tcpdump/c2ef693866beae071a24b45c49f9674af1df4028,CVE-2017-12990,https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028,2017-09-14T06:29Z
CWE-416,"CWE-416 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
","<S2SV_ModStart> _ipmi_destroy_user ( user <S2SV_ModEnd> ) ; kref_put
",torvalds@linux/77f8269606bf95fcb232ee86f6da80886f1dfae8,CVE-2019-9003,https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8,2019-02-22T15:29Z
CWE-119,"CWE-119 static INLINE void store_pred_mv ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx ) { <S2SV_StartBug> vpx_memcpy ( ctx -> pred_mv , x -> pred_mv , sizeof ( x -> pred_mv ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ctx ) { memcpy <S2SV_ModEnd> ( ctx ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-617,"CWE-617 struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( ""alloc"" , ""allocate<S2SV_blank>a<S2SV_blank>new<S2SV_blank>management<S2SV_blank>address<S2SV_blank>(family:<S2SV_blank>%d)"" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ; <S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }
","<S2SV_ModStart> = family ; <S2SV_ModEnd> memcpy ( &
",vincentbernat@lldpd/793526f8884455f43daecd0a2c46772388417a00,CVE-2015-8012,https://github.com/vincentbernat/lldpd/commit/793526f8884455f43daecd0a2c46772388417a00,2020-01-28T19:15Z
CWE-119,"CWE-119 static void multiframe_quality_enhance_block ( int blksize , int qcurr , int qprev , unsigned char * y , unsigned char * u , unsigned char * v , int y_stride , int uv_stride , unsigned char * yd , unsigned char * ud , unsigned char * vd , int yd_stride , int uvd_stride ) { static const unsigned char VP8_ZEROS [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; int uvblksize = blksize >> 1 ; int qdiff = qcurr - qprev ; int i ; unsigned char * up ; unsigned char * udp ; unsigned char * vp ; unsigned char * vdp ; unsigned int act , actd , sad , usad , vsad , sse , thr , thrsq , actrisk ; if ( blksize == 16 ) { <S2SV_StartBug> actd = ( vp8_variance16x16 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> <S2SV_StartBug> act = ( vp8_variance16x16 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 128 ) >> 8 ; <S2SV_EndBug> # ifdef USE_SSD <S2SV_StartBug> sad = ( vp8_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> sad = ( sse + 128 ) >> 8 ; usad = ( vp8_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; usad = ( sse + 32 ) >> 6 ; <S2SV_StartBug> vsad = ( vp8_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> vsad = ( sse + 32 ) >> 6 ; # else sad = ( vp8_sad16x16 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 128 ) >> 8 ; usad = ( vp8_sad8x8 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; vsad = ( vp8_sad8x8 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 32 ) >> 6 ; # endif } else { actd = ( vp8_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_StartBug> act = ( vp8_variance8x8 ( y , y_stride , VP8_ZEROS , 0 , & sse ) + 32 ) >> 6 ; <S2SV_EndBug> # ifdef USE_SSD <S2SV_StartBug> sad = ( vp8_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ) ; <S2SV_EndBug> sad = ( sse + 32 ) >> 6 ; <S2SV_StartBug> usad = ( vp8_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ) ; <S2SV_EndBug> usad = ( sse + 8 ) >> 4 ; <S2SV_StartBug> vsad = ( vp8_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ) ; <S2SV_EndBug> vsad = ( sse + 8 ) >> 4 ; # else sad = ( vp8_sad8x8 ( y , y_stride , yd , yd_stride , UINT_MAX ) + 32 ) >> 6 ; usad = ( vp8_sad4x4 ( u , uv_stride , ud , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; vsad = ( vp8_sad4x4 ( v , uv_stride , vd , uvd_stride , UINT_MAX ) + 8 ) >> 4 ; # endif } actrisk = ( actd > act * 5 ) ; thr = ( qdiff >> 4 ) ; while ( actd >>= 1 ) thr ++ ; while ( qprev >>= 2 ) thr ++ ; # ifdef USE_SSD thrsq = thr * thr ; if ( sad < thrsq && 4 * usad < thrsq && 4 * vsad < thrsq && ! actrisk ) # else if ( sad < thr && 2 * usad < thr && 2 * vsad < thr && ! actrisk ) # endif { int ifactor ; # ifdef USE_SSD sad = int_sqrt ( sad ) ; # endif ifactor = ( sad << MFQE_PRECISION ) / thr ; ifactor >>= ( qdiff >> 5 ) ; if ( ifactor ) { apply_ifactor ( y , y_stride , yd , yd_stride , u , v , uv_stride , ud , vd , uvd_stride , blksize , ifactor ) ; } } else { if ( blksize == 16 ) { vp8_copy_mem16x16 ( y , y_stride , yd , yd_stride ) ; vp8_copy_mem8x8 ( u , uv_stride , ud , uvd_stride ) ; vp8_copy_mem8x8 ( v , uv_stride , vd , uvd_stride ) ; } else { vp8_copy_mem8x8 ( y , y_stride , yd , yd_stride ) ; for ( up = u , udp = ud , i = 0 ; i < uvblksize ; ++ i , up += uv_stride , udp += uvd_stride ) <S2SV_StartBug> vpx_memcpy ( udp , up , uvblksize ) ; <S2SV_EndBug> for ( vp = v , vdp = vd , i = 0 ; i < uvblksize ; ++ i , vp += uv_stride , vdp += uvd_stride ) <S2SV_StartBug> vpx_memcpy ( vdp , vp , uvblksize ) ; <S2SV_EndBug> } } }
","<S2SV_ModStart> actd = ( vpx_variance16x16 <S2SV_ModEnd> ( yd , <S2SV_ModStart> act = ( vpx_variance16x16 <S2SV_ModEnd> ( y , <S2SV_ModStart> # ifdef USE_SSD vpx_variance16x16 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sad = ( sse + 128 ) >> 8 ; vpx_variance8x8 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 32 ) >> 6 ; vpx_variance8x8 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 32 ) >> 6 ; # else sad = ( vpx_sad16x16 <S2SV_ModEnd> ( y , <S2SV_ModStart> yd , yd_stride ) + 128 ) >> 8 ; usad = ( vpx_sad8x8 ( u , uv_stride , ud , uvd_stride ) + 32 ) >> 6 ; vsad = ( vpx_sad8x8 ( v , uv_stride , vd , uvd_stride ) + 32 ) >> 6 ; # endif } else { actd = ( vpx_variance8x8 ( yd , yd_stride , VP8_ZEROS , 0 <S2SV_ModStart> & sse ) <S2SV_ModEnd> + 32 ) <S2SV_ModStart> >> 6 ; <S2SV_ModEnd> act = ( <S2SV_ModStart> act = ( vpx_variance8x8 <S2SV_ModEnd> ( y , <S2SV_ModStart> # ifdef USE_SSD vpx_variance8x8 ( y , y_stride , yd , yd_stride , & sse ) ; <S2SV_ModStart> sad = ( sse + 32 ) >> 6 ; vpx_variance4x4 ( u , uv_stride , ud , uvd_stride , & sse ) ; usad = ( sse + 8 ) >> 4 ; vpx_variance4x4 ( v , uv_stride , vd , uvd_stride , & sse ) ; vsad = ( sse + 8 ) >> 4 ; # else sad = ( vpx_sad8x8 <S2SV_ModEnd> ( y , <S2SV_ModStart> yd , yd_stride ) <S2SV_ModEnd> + 32 ) <S2SV_ModStart> usad = ( vpx_sad4x4 <S2SV_ModEnd> ( u , <S2SV_ModStart> ud , uvd_stride ) <S2SV_ModEnd> + 8 ) <S2SV_ModStart> vsad = ( vpx_sad4x4 <S2SV_ModEnd> ( v , <S2SV_ModStart> vd , uvd_stride <S2SV_ModEnd> ) + 8 <S2SV_ModStart> += uvd_stride ) memcpy <S2SV_ModEnd> ( udp , <S2SV_ModStart> += uvd_stride ) memcpy <S2SV_ModEnd> ( vdp ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , ""predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n"" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n"" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }
","<S2SV_ModStart> ( buffer , i +
",chromium@chromium/d82b03d21f7e581f9206ef1fec4959ae7b06b8eb,CVE-2011-3919,https://github.com/chromium/chromium/commit/d82b03d21f7e581f9206ef1fec4959ae7b06b8eb,2012-01-07T11:55Z
CWE-401,"CWE-401 static int adis_update_scan_mode_burst ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; unsigned int burst_length ; u8 * tx ; burst_length = ( indio_dev -> num_channels - 1 ) * sizeof ( u16 ) ; burst_length += adis -> burst -> extra_len ; adis -> xfer = kcalloc ( 2 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kzalloc ( burst_length + sizeof ( u16 ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> tx = adis -> buffer + burst_length ; <S2SV_EndBug> tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ; tx [ 1 ] = 0 ; adis -> xfer [ 0 ] . tx_buf = tx ; adis -> xfer [ 0 ] . bits_per_word = 8 ; adis -> xfer [ 0 ] . len = 2 ; adis -> xfer [ 1 ] . rx_buf = adis -> buffer ; adis -> xfer [ 1 ] . bits_per_word = 8 ; adis -> xfer [ 1 ] . len = burst_length ; spi_message_init ( & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 0 ] , & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 1 ] , & adis -> msg ) ; return 0 ; }
","<S2SV_ModStart> -> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
",torvalds@linux/9c0530e898f384c5d279bfcebd8bb17af1105873,CVE-2019-19061,https://github.com/torvalds/linux/commit/9c0530e898f384c5d279bfcebd8bb17af1105873,2019-11-18T06:15Z
CWE-119,"CWE-119 static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct strbuf * path , const char * name , void * cb_data ) { struct object * obj = & blob -> object ; <S2SV_StartBug> if ( ! revs -> blob_objects ) <S2SV_EndBug> return ; if ( ! obj ) die ( ""bad<S2SV_blank>blob<S2SV_blank>object"" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , path , name , cb_data ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> -> object ; size_t pathlen ; <S2SV_ModStart> |= SEEN ; pathlen = path -> len ; strbuf_addstr ( path , name ) ; <S2SV_ModStart> obj , path -> buf <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> cb_data ) ; strbuf_setlen ( path , pathlen ) ;
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-119,"CWE-119 int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\n"" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame."" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }
","<S2SV_ModStart> ( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-388,"CWE-388 static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return false ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return true ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : <S2SV_StartBug> if ( ! is_exception ( intr_info ) ) <S2SV_EndBug> return false ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return false ; else if ( is_debug ( intr_info ) && vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) return false ; else if ( is_breakpoint ( intr_info ) && vcpu -> guest_debug & KVM_GUESTDBG_USE_SW_BP ) return false ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return false ; case EXIT_REASON_TRIPLE_FAULT : return true ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return true ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return false ; return true ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return true ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : case EXIT_REASON_RDTSCP : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : case EXIT_REASON_INVEPT : case EXIT_REASON_INVVPID : return true ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_GDTR_IDTR : case EXIT_REASON_LDTR_TR : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_DESC ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return true ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_TRAP_FLAG : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_TRAP_FLAG ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return false ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_APIC_WRITE : case EXIT_REASON_EOI_INDUCED : return true ; case EXIT_REASON_EPT_VIOLATION : return false ; case EXIT_REASON_EPT_MISCONFIG : return false ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return true ; case EXIT_REASON_XSAVES : case EXIT_REASON_XRSTORS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_XSAVES ) ; case EXIT_REASON_PREEMPTION_TIMER : return false ; default : return true ; } }
","<S2SV_ModStart> : if ( is_nmi <S2SV_ModEnd> ( intr_info )
",torvalds@linux/ef85b67385436ddc1998f45f1d6a210f935b3388,CVE-2016-9588,https://github.com/torvalds/linux/commit/ef85b67385436ddc1998f45f1d6a210f935b3388,2016-12-28T07:59Z
CWE-284,"CWE-284 static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ; <S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> = 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-264,"CWE-264 struct sock * cookie_v6_check ( struct sock * sk , struct sk_buff * skb ) { struct tcp_options_received tcp_opt ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct dst_entry * dst ; __u8 rcv_wscale ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) ) goto out ; mss = __cookie_v6_check ( ipv6_hdr ( skb ) , th , cookie ) ; if ( mss == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , 0 , NULL ) ; if ( ! cookie_timestamp_decode ( & tcp_opt ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp6_request_sock_ops , sk , false ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> tfo_listener = false ; if ( security_inet_conn_request ( sk , skb , req ) ) goto out_free ; req -> mss = mss ; ireq -> ir_rmt_port = th -> source ; ireq -> ir_num = ntohs ( th -> dest ) ; ireq -> ir_v6_rmt_addr = ipv6_hdr ( skb ) -> saddr ; ireq -> ir_v6_loc_addr = ipv6_hdr ( skb ) -> daddr ; if ( ipv6_opt_accepted ( sk , skb , & TCP_SKB_CB ( skb ) -> header . h6 ) || np -> rxopt . bits . rxinfo || np -> rxopt . bits . rxoinfo || np -> rxopt . bits . rxhlim || np -> rxopt . bits . rxohlim ) { atomic_inc ( & skb -> users ) ; ireq -> pktopts = skb ; } ireq -> ir_iif = sk -> sk_bound_dev_if ; if ( ! sk -> sk_bound_dev_if && ipv6_addr_type ( & ireq -> ir_v6_rmt_addr ) & IPV6_ADDR_LINKLOCAL ) ireq -> ir_iif = tcp_v6_iif ( skb ) ; ireq -> ir_mark = inet_request_mark ( sk , skb ) ; req -> num_retrans = 0 ; ireq -> snd_wscale = tcp_opt . snd_wscale ; ireq -> sack_ok = tcp_opt . sack_ok ; ireq -> wscale_ok = tcp_opt . wscale_ok ; ireq -> tstamp_ok = tcp_opt . saw_tstamp ; req -> ts_recent = tcp_opt . saw_tstamp ? tcp_opt . rcv_tsval : 0 ; treq -> snt_synack . v64 = 0 ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_TCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , np -> opt , & final ) ; <S2SV_EndBug> fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = ireq -> ir_mark ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = inet_sk ( sk ) -> inet_sport ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) goto out_free ; } req -> rsk_window_clamp = tp -> window_clamp ? : dst_metric ( dst , RTAX_WINDOW ) ; tcp_select_initial_window ( tcp_full_space ( sk ) , req -> mss , & req -> rsk_rcv_wnd , & req -> rsk_window_clamp , ireq -> wscale_ok , & rcv_wscale , dst_metric ( dst , RTAX_INITRWND ) ) ; ireq -> rcv_wscale = rcv_wscale ; ireq -> ecn_ok = cookie_ecn_ok ( & tcp_opt , sock_net ( sk ) , dst ) ; ret = tcp_get_cookie_sock ( sk , skb , req , dst ) ; out : return ret ; out_free : reqsk_free ( req ) ; return NULL ; }
","<S2SV_ModStart> & fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-416,"CWE-416 PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; <S2SV_StartBug> zval * options = NULL , * classes = NULL ; <S2SV_EndBug> HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } <S2SV_StartBug> if ( ! php_var_unserialize_ex ( return_value , & p , p + buf_len , & var_hash , class_hash ) ) { <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } <S2SV_StartBug> zval_ptr_dtor ( return_value ) ; <S2SV_EndBug> if ( ! EG ( exception ) ) { php_error_docref ( NULL , E_NOTICE , ""Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>"" ZEND_LONG_FMT ""<S2SV_blank>of<S2SV_blank>%zd<S2SV_blank>bytes"" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; } RETURN_FALSE ; } <S2SV_StartBug> var_push_dtor ( & var_hash , return_value ) ; <S2SV_EndBug> PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; if ( class_hash ) { zend_hash_destroy ( class_hash ) ; FREE_HASHTABLE ( class_hash ) ; } }
","<S2SV_ModStart> classes = NULL ; zval * retval <S2SV_ModStart> ; } } retval = var_tmp_var ( & var_hash ) ; <S2SV_ModStart> ! php_var_unserialize_ex ( retval <S2SV_ModEnd> , & p <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> RETURN_FALSE ; } ZVAL_COPY ( return_value , retval <S2SV_ModEnd> ) ; PHP_VAR_UNSERIALIZE_DESTROY
",php@php-src/b2af4e8868726a040234de113436c6e4f6372d17,CVE-2016-9936,https://github.com/php/php-src/commit/b2af4e8868726a040234de113436c6e4f6372d17,2017-01-04T20:59Z
CWE-119,"CWE-119 int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }
","<S2SV_ModStart> gfn , page_size >> PAGE_SHIFT <S2SV_ModStart> pfn , page_size >> PAGE_SHIFT
",torvalds@linux/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,CVE-2014-8369,https://github.com/torvalds/linux/commit/3d32e4dbe71374a6780eaf51d719d76f9a9bf22f,2014-11-10T11:55Z
CWE-189,"CWE-189 TSQuery parse_tsquery ( char * buf , PushFunction pushval , Datum opaque , bool isplain ) { struct TSQueryParserStateData state ; int i ; TSQuery query ; int commonlen ; QueryItem * ptr ; ListCell * cell ; state . buffer = buf ; state . buf = buf ; state . state = ( isplain ) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND ; state . count = 0 ; state . polstr = NIL ; state . valstate = init_tsvector_parser ( state . buffer , true , true ) ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state , pushval , opaque ) ; close_tsvector_parser ( state . valstate ) ; if ( list_length ( state . polstr ) == 0 ) { ereport ( NOTICE , ( errmsg ( ""text-search<S2SV_blank>query<S2SV_blank>doesn\'t<S2SV_blank>contain<S2SV_blank>lexemes:<S2SV_blank>\\""%s\\"""" , state . buffer ) ) ) ; query = ( TSQuery ) palloc ( HDRSIZETQ ) ; SET_VARSIZE ( query , HDRSIZETQ ) ; query -> size = 0 ; return query ; <S2SV_StartBug> } <S2SV_EndBug> commonlen = COMPUTESIZE ( list_length ( state . polstr ) , state . sumlen ) ; query = ( TSQuery ) palloc0 ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = list_length ( state . polstr ) ; ptr = GETQUERY ( query ) ; i = 0 ; foreach ( cell , state . polstr ) { QueryItem * item = ( QueryItem * ) lfirst ( cell ) ; switch ( item -> type ) { case QI_VAL : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperand ) ) ; break ; case QI_VALSTOP : ptr [ i ] . type = QI_VALSTOP ; break ; case QI_OPR : memcpy ( & ptr [ i ] , item , sizeof ( QueryOperator ) ) ; break ; default : elog ( ERROR , ""unrecognized<S2SV_blank>QueryItem<S2SV_blank>type:<S2SV_blank>%d"" , item -> type ) ; } i ++ ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; findoprnd ( ptr , query -> size ) ; return query ; }
","<S2SV_ModStart> query ; } if ( TSQUERY_TOO_BIG ( list_length ( state . polstr ) , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""tsquery<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ) ) ;
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-190,"CWE-190 static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> ; addModuleArgument ( pParse <S2SV_ModEnd> , pParse ->
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-190,"CWE-190 static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; <S2SV_StartBug> if ( uniforms_offset < shader_rec_offset || <S2SV_EndBug> exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflow<S2SV_blank>in<S2SV_blank>exec<S2SV_blank>arguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>storage<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>"" ""in<S2SV_blank>bin/render<S2SV_blank>CLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> uniforms_u , ( void __user * ) ( uintptr_t ) args -> uniforms , args -> uniforms_size ) ) { ret = - EFAULT ; goto fail ; } bo = vc4_bo_create ( dev , exec_size , true ) ; if ( IS_ERR ( bo ) ) { DRM_ERROR ( ""Couldn\'t<S2SV_blank>allocate<S2SV_blank>BO<S2SV_blank>for<S2SV_blank>binning\\n"" ) ; ret = PTR_ERR ( bo ) ; goto fail ; } exec -> exec_bo = & bo -> base ; list_add_tail ( & to_vc4_bo ( & exec -> exec_bo -> base ) -> unref_head , & exec -> unref_list ) ; exec -> ct0ca = exec -> exec_bo -> paddr + bin_offset ; exec -> bin_u = bin ; exec -> shader_rec_v = exec -> exec_bo -> vaddr + shader_rec_offset ; exec -> shader_rec_p = exec -> exec_bo -> paddr + shader_rec_offset ; exec -> shader_rec_size = args -> shader_rec_size ; exec -> uniforms_v = exec -> exec_bo -> vaddr + uniforms_offset ; exec -> uniforms_p = exec -> exec_bo -> paddr + uniforms_offset ; exec -> uniforms_size = args -> uniforms_size ; ret = vc4_validate_bin_cl ( dev , exec -> exec_bo -> vaddr + bin_offset , bin , exec ) ; if ( ret ) goto fail ; ret = vc4_validate_shader_recs ( dev , exec ) ; if ( ret ) goto fail ; ret = vc4_wait_for_seqno ( dev , exec -> bin_dep_seqno , ~ 0ull , true ) ; fail : drm_free_large ( temp ) ; return ret ; }
","<S2SV_ModStart> ; if ( shader_rec_offset < args -> bin_cl_size ||
",torvalds@linux/0f2ff82e11c86c05d051cae32b58226392d33bbf,CVE-2017-5576,https://github.com/torvalds/linux/commit/0f2ff82e11c86c05d051cae32b58226392d33bbf,2017-02-06T06:59Z
CWE-120,"CWE-120 static void mt76_add_fragment ( struct mt76_dev * dev , struct mt76_queue * q , void * data , int len , bool more ) { struct page * page = virt_to_head_page ( data ) ; int offset = data - page_address ( page ) ; struct sk_buff * skb = q -> rx_head ; <S2SV_StartBug> offset += q -> buf_offset ; <S2SV_EndBug> <S2SV_StartBug> skb_add_rx_frag ( skb , skb_shinfo ( skb ) -> nr_frags , page , offset , len , <S2SV_EndBug> <S2SV_StartBug> q -> buf_size ) ; <S2SV_EndBug> if ( more ) return ; q -> rx_head = NULL ; dev -> drv -> rx_skb ( dev , q - dev -> q_rx , skb ) ; }
","<S2SV_ModStart> -> rx_head ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; if ( shinfo -> nr_frags < ARRAY_SIZE ( shinfo -> frags ) ) { <S2SV_ModStart> ( skb , shinfo <S2SV_ModEnd> -> nr_frags , <S2SV_ModStart> buf_size ) ; }
",torvalds@linux/b102f0c522cf668c8382c56a4f771b37d011cda2,CVE-2020-12465,https://github.com/torvalds/linux/commit/b102f0c522cf668c8382c56a4f771b37d011cda2,2020-04-29T19:15Z
CWE-674,"CWE-674 static int renameUnmapSelectCb ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i ; if ( pParse -> nErr ) return WRC_Abort ; <S2SV_StartBug> if ( ALWAYS ( p -> pEList ) ) { <S2SV_EndBug> ExprList * pList = p -> pEList ; for ( i = 0 ; i < pList -> nExpr ; i ++ ) { if ( pList -> a [ i ] . zName ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pList -> a [ i ] . zName ) ; } } } if ( ALWAYS ( p -> pSrc ) ) { SrcList * pSrc = p -> pSrc ; for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pSrc -> a [ i ] . zName ) ; } } renameWalkWith ( pWalker , p ) ; return WRC_Continue ; }
","<S2SV_ModStart> ; if ( p -> selFlags & SF_View ) return WRC_Prune ; if (
",sqlite@sqlite/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,CVE-2019-19645,https://github.com/sqlite/sqlite/commit/38096961c7cd109110ac21d3ed7dad7e0cb0ae06,2019-12-09T16:15Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; <S2SV_StartBug> ptr ++ ; <S2SV_EndBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; <S2SV_StartBug> val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; <S2SV_EndBug> val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u<S2SV_blank>"" , ( val_h << 16 ) + val_l ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> , val_l ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } ptr ++ ; length -= 2 ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> ) ) ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-400,"CWE-400 static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , 0 , <S2SV_EndBug> regs , address ) ; } else { tsk -> min_flt ++ ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 , 0 , <S2SV_EndBug> regs , address ) ; } if ( fault & VM_FAULT_RETRY ) { flags &= ~ FAULT_FLAG_ALLOW_RETRY ; goto retry ; } } clear_tsk_thread_flag ( tsk , TIF_PER_TRAP ) ; fault = 0 ; out_up : up_read ( & mm -> mmap_sem ) ; out : return fault ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address <S2SV_ModStart> PERF_COUNT_SW_PAGE_FAULTS_MIN , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-476,"CWE-476 int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; <S2SV_StartBug> size += service_name_tlv_length ; <S2SV_EndBug> } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> pr_debug ( ""SKB<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>SN<S2SV_blank>length<S2SV_blank>%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLCP_PDU_CONNECT , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , service_name_tlv , service_name_tlv_length ) ; llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( service_name_tlv ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }
","<S2SV_ModStart> service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
",torvalds@linux/58bdd544e2933a21a51eecf17c3f5f94038261b5,CVE-2019-12818,https://github.com/torvalds/linux/commit/58bdd544e2933a21a51eecf17c3f5f94038261b5,2019-06-14T02:29Z
CWE-200,"CWE-200 int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( ""size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
","<S2SV_ModStart> , timeo ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ) ) ; msg -> msg_namelen = sizeof ( * sin ) ;
",torvalds@linux/06b6a1cf6e776426766298d055bb3991957d90a7,CVE-2012-3430,https://github.com/torvalds/linux/commit/06b6a1cf6e776426766298d055bb3991957d90a7,2012-10-03T11:02Z
CWE-119,"CWE-119 int read_file ( struct sc_card * card , char * str_path , unsigned char * * data , size_t * data_len ) { struct sc_path path ; struct sc_file * file ; unsigned char * p ; int ok = 0 ; int r ; size_t len ; sc_format_path ( str_path , & path ) ; if ( SC_SUCCESS != sc_select_file ( card , & path , & file ) ) { goto err ; } <S2SV_StartBug> len = file ? file -> size : 4096 ; <S2SV_EndBug> p = realloc ( * data , len ) ; if ( ! p ) { goto err ; } * data = p ; * data_len = len ; r = sc_read_binary ( card , 0 , p , len , 0 ) ; if ( r < 0 ) goto err ; * data_len = r ; ok = 1 ; err : sc_file_free ( file ) ; return ok ; }
","<S2SV_ModStart> len = file && file -> size > 0
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-59,"CWE-59 static bool cgroupfs_mount_cgroup ( void * hdata , const char * root , int type ) { size_t bufsz = strlen ( root ) + sizeof ( ""/sys/fs/cgroup"" ) ; char * path = NULL ; char * * parts = NULL ; char * dirname = NULL ; char * abs_path = NULL ; char * abs_path2 = NULL ; struct cgfs_data * cgfs_d ; struct cgroup_process_info * info , * base_info ; int r , saved_errno = 0 ; cgfs_d = hdata ; if ( ! cgfs_d ) return false ; base_info = cgfs_d -> info ; if ( type == LXC_AUTO_CGROUP_FULL_NOSPEC ) type = LXC_AUTO_CGROUP_FULL_MIXED ; else if ( type == LXC_AUTO_CGROUP_NOSPEC ) type = LXC_AUTO_CGROUP_MIXED ; if ( type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>cgroups<S2SV_blank>into<S2SV_blank>container:<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>specified<S2SV_blank>internally"" ) ; errno = EINVAL ; return false ; } path = calloc ( 1 , bufsz ) ; if ( ! path ) return false ; snprintf ( path , bufsz , ""%s/sys/fs/cgroup"" , root ) ; <S2SV_StartBug> r = mount ( ""cgroup_root"" , path , ""tmpfs"" , MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_RELATIME , ""size=10240k,mode=755"" ) ; <S2SV_EndBug> if ( r < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>mount<S2SV_blank>tmpfs<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup<S2SV_blank>in<S2SV_blank>the<S2SV_blank>container"" ) ; return false ; } for ( info = base_info ; info ; info = info -> next ) { size_t subsystem_count , i ; struct cgroup_mount_point * mp = info -> designated_mount_point ; if ( ! mp ) mp = lxc_cgroup_find_mount_point ( info -> hierarchy , info -> cgroup_path , true ) ; if ( ! mp ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>original<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>cgroup<S2SV_blank>hierarchy<S2SV_blank>while<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>cgroup<S2SV_blank>filesystem"" ) ; goto out_error ; } subsystem_count = lxc_array_len ( ( void * * ) info -> hierarchy -> subsystems ) ; parts = calloc ( subsystem_count + 1 , sizeof ( char * ) ) ; if ( ! parts ) goto out_error ; for ( i = 0 ; i < subsystem_count ; i ++ ) { if ( ! strncmp ( info -> hierarchy -> subsystems [ i ] , ""name="" , 5 ) ) parts [ i ] = info -> hierarchy -> subsystems [ i ] + 5 ; else parts [ i ] = info -> hierarchy -> subsystems [ i ] ; } dirname = lxc_string_join ( "","" , ( const char * * ) parts , false ) ; if ( ! dirname ) goto out_error ; abs_path = lxc_append_paths ( path , dirname ) ; if ( ! abs_path ) goto out_error ; r = mkdir_p ( abs_path , 0755 ) ; if ( r < 0 && errno != EEXIST ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>subsystem<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s"" , dirname ) ; goto out_error ; } abs_path2 = lxc_append_paths ( abs_path , info -> cgroup_path ) ; if ( ! abs_path2 ) goto out_error ; if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED ) { if ( strcmp ( mp -> mount_prefix , ""/"" ) != 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>automatically<S2SV_blank>mount<S2SV_blank>cgroup-full<S2SV_blank>to<S2SV_blank>/sys/fs/cgroup/%s:<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>mount<S2SV_blank>point<S2SV_blank>for<S2SV_blank>this<S2SV_blank>cgroup<S2SV_blank>filesystem<S2SV_blank>that<S2SV_blank>has<S2SV_blank>access<S2SV_blank>to<S2SV_blank>the<S2SV_blank>root<S2SV_blank>cgroup"" , dirname ) ; goto out_error ; } r = mount ( mp -> mount_point , abs_path , ""none"" , MS_BIND , 0 ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s"" , mp -> mount_point , abs_path ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED ) { r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly"" , abs_path ) ; goto out_error ; } } if ( type == LXC_AUTO_CGROUP_FULL_MIXED ) { r = mount ( abs_path2 , abs_path2 , NULL , MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself"" , abs_path2 ) ; goto out_error ; } r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readwrite"" , abs_path2 ) ; goto out_error ; } } } else { r = mkdir_p ( abs_path2 , 0755 ) ; if ( r < 0 && errno != EEXIST ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>cgroup<S2SV_blank>directory<S2SV_blank>/sys/fs/cgroup/%s%s"" , dirname , info -> cgroup_path ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO ) { r = mount ( abs_path , abs_path , NULL , MS_BIND , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>onto<S2SV_blank>itself"" , abs_path ) ; goto out_error ; } r = mount ( NULL , abs_path , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly"" , abs_path ) ; goto out_error ; } } free ( abs_path ) ; abs_path = NULL ; abs_path = cgroup_to_absolute_path ( mp , info -> cgroup_path , NULL ) ; if ( ! abs_path ) goto out_error ; r = mount ( abs_path , abs_path2 , ""none"" , MS_BIND , 0 ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>bind-mounting<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s"" , abs_path , abs_path2 ) ; goto out_error ; } if ( type == LXC_AUTO_CGROUP_RO ) { r = mount ( NULL , abs_path2 , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL ) ; if ( r < 0 ) { SYSERROR ( ""error<S2SV_blank>re-mounting<S2SV_blank>%s<S2SV_blank>readonly"" , abs_path2 ) ; goto out_error ; } } } free ( abs_path ) ; free ( abs_path2 ) ; abs_path = NULL ; abs_path2 = NULL ; if ( subsystem_count > 1 ) { for ( i = 0 ; i < subsystem_count ; i ++ ) { abs_path = lxc_append_paths ( path , parts [ i ] ) ; if ( ! abs_path ) goto out_error ; r = symlink ( dirname , abs_path ) ; if ( r < 0 ) WARN ( ""could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>symlink<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s<S2SV_blank>in<S2SV_blank>/sys/fs/cgroup<S2SV_blank>of<S2SV_blank>container"" , parts [ i ] , dirname ) ; free ( abs_path ) ; abs_path = NULL ; } } free ( dirname ) ; free ( parts ) ; dirname = NULL ; parts = NULL ; } free ( path ) ; return true ; out_error : saved_errno = errno ; free ( path ) ; free ( dirname ) ; free ( parts ) ; free ( abs_path ) ; free ( abs_path2 ) ; errno = saved_errno ; return false ; }
","<S2SV_ModStart> ; r = safe_mount <S2SV_ModEnd> ( ""cgroup_root"" , <S2SV_ModStart> MS_RELATIME , ""size=10240k,mode=755"" , root
",lxc@lxc/592fd47a6245508b79fe6ac819fe6d3b2c1289be,CVE-2015-1335,https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be,2015-10-01T20:59Z
CWE-20,"CWE-20 static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%04X:"" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s"" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , ""UnknownPatternType"" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , ""UnableToUncompressImage"" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , ""NotEnoughPixelData"" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""UnableToReadImageData"" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""icc"" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , ""iptc"" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , ""UnableToCreateTemporaryFile"" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , ""ImproperImageHeader"" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , ""%.20gx%.20g"" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> , message ) \\\n{ <S2SV_ModEnd> if ( tile_image <S2SV_ModStart> ) ) ; \\\n} <S2SV_ModEnd> char geometry [ <S2SV_ModStart> ) break ; if ( <S2SV_ModEnd> fputc ( c <S2SV_ModStart> , file ) != c ) break
",ImageMagick@ImageMagick/6b6bff054d569a77973f2140c0e86366e6168a6c,CVE-2018-16643,https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c,2018-09-06T22:29Z
CWE-119,"CWE-119 static int kill_something_info ( int sig , struct siginfo * info , pid_t pid ) { int ret ; if ( pid > 0 ) { rcu_read_lock ( ) ; ret = kill_pid_info ( sig , info , find_vpid ( pid ) ) ; rcu_read_unlock ( ) ; return ret ; <S2SV_StartBug> } <S2SV_EndBug> read_lock ( & tasklist_lock ) ; if ( pid != - 1 ) { ret = __kill_pgrp_info ( sig , info , pid ? find_vpid ( - pid ) : task_pgrp ( current ) ) ; } else { int retval = 0 , count = 0 ; struct task_struct * p ; for_each_process ( p ) { if ( task_pid_vnr ( p ) > 1 && ! same_thread_group ( p , current ) ) { int err = group_send_sig_info ( sig , info , p ) ; ++ count ; if ( err != - EPERM ) retval = err ; } } ret = count ? retval : - ESRCH ; } read_unlock ( & tasklist_lock ) ; return ret ; }
","<S2SV_ModStart> ret ; } if ( pid == INT_MIN ) return - ESRCH ;
",torvalds@linux/4ea77014af0d6205b05503d1c7aac6eace11d473,CVE-2018-10124,https://github.com/torvalds/linux/commit/4ea77014af0d6205b05503d1c7aac6eace11d473,2018-04-16T14:29Z
CWE-264,"CWE-264 static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Getting<S2SV_blank>sb<S2SV_blank>failed"" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = ""Error<S2SV_blank>parsing<S2SV_blank>options"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Reading<S2SV_blank>sb<S2SV_blank>failed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()<S2SV_blank>failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>"" ""eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>"" ""known<S2SV_blank>incompatibilities\\n"" ) ; goto out_free ; } if ( check_ruid && ! uid_eq ( path . dentry -> d_inode -> i_uid , current_uid ( ) ) ) { rc = - EPERM ; printk ( KERN_ERR ""Mount<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(uid:<S2SV_blank>%d)<S2SV_blank>not<S2SV_blank>owned<S2SV_blank>by<S2SV_blank>"" ""requested<S2SV_blank>user<S2SV_blank>(uid:<S2SV_blank>%d)\\n"" , i_uid_read ( path . dentry -> d_inode ) , from_kuid ( & init_user_ns , current_uid ( ) ) ) ; goto out_free ; } ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; s -> s_flags = flags & ~ MS_POSIXACL ; s -> s_flags |= path . dentry -> d_sb -> s_flags & ( MS_RDONLY | MS_POSIXACL ) ; s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; <S2SV_StartBug> inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; <S2SV_EndBug> rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_make_root ( inode ) ; if ( ! s -> s_root ) { rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; root_info -> lower_path = path ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR ""%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n"" , err , rc ) ; return ERR_PTR ( rc ) ; }
","<S2SV_ModStart> = ECRYPTFS_SUPER_MAGIC ; s -> s_stack_depth = path . dentry -> d_sb -> s_stack_depth + 1 ; rc = - EINVAL ; if ( s -> s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH ) { pr_err ( ""eCryptfs:<S2SV_blank>maximum<S2SV_blank>fs<S2SV_blank>stacking<S2SV_blank>depth<S2SV_blank>exceeded\\n"" ) ; goto out_free ; }
",torvalds@linux/69c433ed2ecd2d3264efd7afec4439524b319121,CVE-2014-9922,https://github.com/torvalds/linux/commit/69c433ed2ecd2d3264efd7afec4439524b319121,2017-04-04T05:59Z
CWE-000,"CWE-000 bool_t auth_gssapi_unwrap_data ( OM_uint32 * major , OM_uint32 * minor , gss_ctx_id_t context , uint32_t seq_num , XDR * in_xdrs , bool_t ( * xdr_func ) ( ) , caddr_t xdr_ptr ) { gss_buffer_desc in_buf , out_buf ; XDR temp_xdrs ; uint32_t verf_seq_num ; int conf , qop ; unsigned int length ; PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>starting\\n"" ) ) ; * major = GSS_S_COMPLETE ; * minor = 0 ; in_buf . value = NULL ; out_buf . value = NULL ; if ( ! xdr_bytes ( in_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ) { PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>encrypted<S2SV_blank>data<S2SV_blank>failed\\n"" ) ) ; temp_xdrs . x_op = XDR_FREE ; ( void ) xdr_bytes ( & temp_xdrs , ( char * * ) & in_buf . value , & length , ( unsigned int ) - 1 ) ; return FALSE ; } in_buf . length = length ; * major = gss_unseal ( minor , context , & in_buf , & out_buf , & conf , & qop ) ; free ( in_buf . value ) ; if ( * major != GSS_S_COMPLETE ) return FALSE ; PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>%llu<S2SV_blank>bytes<S2SV_blank>data,<S2SV_blank>%llu<S2SV_blank>bytes<S2SV_blank>sealed\\n"" , ( unsigned long long ) out_buf . length , ( unsigned long long ) in_buf . length ) ) ; xdrmem_create ( & temp_xdrs , out_buf . value , out_buf . length , XDR_DECODE ) ; if ( ! xdr_u_int32 ( & temp_xdrs , & verf_seq_num ) ) { PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>verf_seq_num<S2SV_blank>failed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } if ( verf_seq_num != seq_num ) { PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>seq<S2SV_blank>%d<S2SV_blank>specified,<S2SV_blank>read<S2SV_blank>%d\\n"" , seq_num , verf_seq_num ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>unwrap<S2SV_blank>seq_num<S2SV_blank>%d<S2SV_blank>okay\\n"" , verf_seq_num ) ) ; if ( ! ( * xdr_func ) ( & temp_xdrs , xdr_ptr ) ) { PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>deserializing<S2SV_blank>arguments<S2SV_blank>failed\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; <S2SV_StartBug> xdr_free ( xdr_func , xdr_ptr ) ; <S2SV_EndBug> XDR_DESTROY ( & temp_xdrs ) ; return FALSE ; } PRINTF ( ( ""gssapi_unwrap_data:<S2SV_blank>succeeding\\n\\n"" ) ) ; gss_release_buffer ( minor , & out_buf ) ; XDR_DESTROY ( & temp_xdrs ) ; return TRUE ; }
","<S2SV_ModStart> out_buf ) ; <S2SV_ModEnd> XDR_DESTROY ( &
",krb5@krb5/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,CVE-2014-9421,https://github.com/krb5/krb5/commit/a197e92349a4aa2141b5dff12e9dd44c2a2166e3,2015-02-19T11:59Z
CWE-416,"CWE-416 int yr_object_copy ( YR_OBJECT * object , YR_OBJECT * * object_copy ) { YR_OBJECT * copy ; YR_OBJECT * o ; YR_STRUCTURE_MEMBER * structure_member ; YR_OBJECT_FUNCTION * func ; YR_OBJECT_FUNCTION * func_copy ; int i ; * object_copy = NULL ; FAIL_ON_ERROR ( yr_object_create ( object -> type , object -> identifier , NULL , & copy ) ) ; switch ( object -> type ) { case OBJECT_TYPE_INTEGER : <S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> break ; case OBJECT_TYPE_STRING : <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> break ; case OBJECT_TYPE_FUNCTION : func = ( YR_OBJECT_FUNCTION * ) object ; func_copy = ( YR_OBJECT_FUNCTION * ) copy ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( func -> return_obj , & func_copy -> return_obj ) , yr_object_destroy ( copy ) ) ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) func_copy -> prototypes [ i ] = func -> prototypes [ i ] ; break ; case OBJECT_TYPE_STRUCTURE : structure_member = ( ( YR_OBJECT_STRUCTURE * ) object ) -> members ; while ( structure_member != NULL ) { FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( structure_member -> object , & o ) , yr_object_destroy ( copy ) ) ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_structure_set_member ( copy , o ) , yr_free ( o ) ; yr_object_destroy ( copy ) ) ; structure_member = structure_member -> next ; } break ; case OBJECT_TYPE_ARRAY : yr_object_copy ( ( ( YR_OBJECT_ARRAY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_ARRAY * ) copy ) -> prototype_item = o ; break ; case OBJECT_TYPE_DICTIONARY : yr_object_copy ( ( ( YR_OBJECT_DICTIONARY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_DICTIONARY * ) copy ) -> prototype_item = o ; break ; default : assert ( FALSE ) ; } * object_copy = copy ; return ERROR_SUCCESS ; }
","<S2SV_ModStart> -> value = ( ( YR_OBJECT_INTEGER * ) object ) -> value <S2SV_ModEnd> ; break ; <S2SV_ModStart> case OBJECT_TYPE_STRING : if ( <S2SV_ModStart> YR_OBJECT_STRING * ) object ) -> value != NULL ) { ( ( YR_OBJECT_STRING * ) copy ) -> value = sized_string_dup ( ( ( YR_OBJECT_STRING * ) object ) -> value ) ; } else { ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; } break ; case OBJECT_TYPE_FLOAT : ( ( YR_OBJECT_DOUBLE * ) copy ) -> value = ( ( YR_OBJECT_DOUBLE * ) object ) -> value <S2SV_ModEnd> ; break ;
",VirusTotal@yara/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,CVE-2017-8929,https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,2017-05-14T22:29Z
CWE-125,"CWE-125 int git_delta_apply ( void * * out , size_t * out_len , const unsigned char * base , size_t base_len , const unsigned char * delta , size_t delta_len ) { const unsigned char * delta_end = delta + delta_len ; size_t base_sz , res_sz , alloc_sz ; unsigned char * res_dp ; * out = NULL ; * out_len = 0 ; if ( ( hdr_sz ( & base_sz , & delta , delta_end ) < 0 ) || ( base_sz != base_len ) ) { giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ; return - 1 ; } if ( hdr_sz ( & res_sz , & delta , delta_end ) < 0 ) { giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta:<S2SV_blank>base<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>given<S2SV_blank>data"" ) ; return - 1 ; } GITERR_CHECK_ALLOC_ADD ( & alloc_sz , res_sz , 1 ) ; res_dp = git__malloc ( alloc_sz ) ; GITERR_CHECK_ALLOC ( res_dp ) ; res_dp [ res_sz ] = '\\0' ; * out = res_dp ; * out_len = res_sz ; while ( delta < delta_end ) { unsigned char cmd = * delta ++ ; if ( cmd & 0x80 ) { size_t off = 0 , len = 0 ; if ( cmd & 0x01 ) off = * delta ++ ; if ( cmd & 0x02 ) off |= * delta ++ << 8UL ; if ( cmd & 0x04 ) off |= * delta ++ << 16UL ; <S2SV_StartBug> if ( cmd & 0x08 ) off |= * delta ++ << 24UL ; <S2SV_EndBug> if ( cmd & 0x10 ) len = * delta ++ ; if ( cmd & 0x20 ) len |= * delta ++ << 8UL ; if ( cmd & 0x40 ) len |= * delta ++ << 16UL ; if ( ! len ) len = 0x10000 ; if ( base_len < off + len || res_sz < len ) goto fail ; memcpy ( res_dp , base + off , len ) ; res_dp += len ; res_sz -= len ; } else if ( cmd ) { if ( delta_end - delta < cmd || res_sz < cmd ) goto fail ; memcpy ( res_dp , delta , cmd ) ; delta += cmd ; res_dp += cmd ; res_sz -= cmd ; } else { goto fail ; } } if ( delta != delta_end || res_sz ) goto fail ; return 0 ; fail : git__free ( * out ) ; * out = NULL ; * out_len = 0 ; giterr_set ( GITERR_INVALID , ""failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>delta"" ) ; return - 1 ; }
","<S2SV_ModStart> ) off |= ( ( unsigned ) <S2SV_ModStart> ++ << 24UL )
",libgit2@libgit2/3f461902dc1072acb8b7607ee65d0a0458ffac2a,CVE-2018-10887,https://github.com/libgit2/libgit2/commit/3f461902dc1072acb8b7607ee65d0a0458ffac2a,2018-07-10T14:29Z
CWE-125,"CWE-125 static stmt_ty <S2SV_StartBug> ast_for_with_stmt ( struct compiling * c , const node * n , int is_async ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int i , n_items , nch_minus_type , has_type_comment ; asdl_seq * items , * body ; string type_comment ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""Async<S2SV_blank>with<S2SV_blank>statements<S2SV_blank>are<S2SV_blank>only<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>Python<S2SV_blank>3.5<S2SV_blank>and<S2SV_blank>greater"" ) ; return NULL ; } REQ ( n , with_stmt ) ; has_type_comment = TYPE ( CHILD ( n , NCH ( n ) - 2 ) ) == TYPE_COMMENT ; nch_minus_type = NCH ( n ) - has_type_comment ; n_items = ( nch_minus_type - 2 ) / 2 ; items = _Ta3_asdl_seq_new ( n_items , c -> c_arena ) ; if ( ! items ) return NULL ; for ( i = 1 ; i < nch_minus_type - 2 ; i += 2 ) { withitem_ty item = ast_for_with_item ( c , CHILD ( n , i ) ) ; if ( ! item ) return NULL ; asdl_seq_SET ( items , ( i - 1 ) / 2 , item ) ; } body = ast_for_suite ( c , CHILD ( n , NCH ( n ) - 1 ) ) ; if ( ! body ) return NULL ; if ( has_type_comment ) type_comment = NEW_TYPE_COMMENT ( CHILD ( n , NCH ( n ) - 2 ) ) ; else type_comment = NULL ; if ( is_async ) <S2SV_StartBug> return AsyncWith ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; <S2SV_EndBug> else return With ( items , body , type_comment , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }
","<S2SV_ModStart> const node * n0 , bool <S2SV_ModEnd> is_async ) { <S2SV_ModStart> is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; <S2SV_ModStart> , LINENO ( n0 ) , n0 <S2SV_ModEnd> -> n_col_offset ,
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-319,"CWE-319 static int mincore_unmapped_range ( unsigned long addr , unsigned long end , struct mm_walk * walk ) { <S2SV_StartBug> walk -> private += __mincore_unmapped_range ( addr , end , <S2SV_EndBug> walk -> vma , walk -> private ) ; return 0 ; }
","<S2SV_ModStart> walk ) { unsigned char * vec = walk -> private ; unsigned long nr = ( end - addr ) >> PAGE_SHIFT ; memset ( vec , 0 , nr ) ; <S2SV_ModStart> -> private += nr <S2SV_ModEnd> ; return 0
",torvalds@linux/574823bfab82d9d8fa47f422778043fbb4b4f50e,CVE-2019-5489,https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e,2019-01-07T17:29Z
CWE-284,"CWE-284 int btsock_thread_add_fd ( int h , int fd , int type , int flags , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created.<S2SV_blank>socket<S2SV_blank>thread<S2SV_blank>may<S2SV_blank>not<S2SV_blank>initialized"" ) ; return FALSE ; } if ( flags & SOCK_THREAD_ADD_FD_SYNC ) { if ( ts [ h ] . thread_id == pthread_self ( ) ) { flags &= ~ SOCK_THREAD_ADD_FD_SYNC ; add_poll ( h , fd , type , flags , user_id ) ; return TRUE ; } APPL_TRACE_DEBUG ( ""THREAD_ADD_FD_SYNC<S2SV_blank>is<S2SV_blank>not<S2SV_blank>called<S2SV_blank>in<S2SV_blank>poll<S2SV_blank>thread,<S2SV_blank>fallback<S2SV_blank>to<S2SV_blank>async"" ) ; } sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( ""adding<S2SV_blank>fd:%d,<S2SV_blank>flags:0x%x"" , fd , flags ) ; <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-200,"CWE-200 static int copy_to_user_tmpl ( struct xfrm_policy * xp , struct sk_buff * skb ) { struct xfrm_user_tmpl vec [ XFRM_MAX_DEPTH ] ; int i ; if ( xp -> xfrm_nr == 0 ) return 0 ; for ( i = 0 ; i < xp -> xfrm_nr ; i ++ ) { struct xfrm_user_tmpl * up = & vec [ i ] ; struct xfrm_tmpl * kp = & xp -> xfrm_vec [ i ] ; <S2SV_StartBug> memcpy ( & up -> id , & kp -> id , sizeof ( up -> id ) ) ; <S2SV_EndBug> up -> family = kp -> encap_family ; memcpy ( & up -> saddr , & kp -> saddr , sizeof ( up -> saddr ) ) ; up -> reqid = kp -> reqid ; up -> mode = kp -> mode ; up -> share = kp -> share ; up -> optional = kp -> optional ; up -> aalgos = kp -> aalgos ; up -> ealgos = kp -> ealgos ; up -> calgos = kp -> calgos ; } return nla_put ( skb , XFRMA_TMPL , sizeof ( struct xfrm_user_tmpl ) * xp -> xfrm_nr , vec ) ; }
","<S2SV_ModStart> i ] ; memset ( up , 0 , sizeof ( * up ) ) ;
",torvalds@linux/1f86840f897717f86d523a13e99a447e6a5d2fa5,CVE-2012-6537,https://github.com/torvalds/linux/commit/1f86840f897717f86d523a13e99a447e6a5d2fa5,2013-03-15T20:55Z
CWE-119,"CWE-119 static void mspack_fmap_free ( void * mem ) { <S2SV_StartBug> free ( mem ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> mem ) { if ( mem ) { <S2SV_ModStart> mem ) ; mem = NULL ; } return ;
",vrtadmin@clamav-devel/a83773682e856ad6529ba6db8d1792e6d515d7f1,CVE-2017-6419,https://github.com/vrtadmin/clamav-devel/commit/a83773682e856ad6529ba6db8d1792e6d515d7f1,2017-08-07T03:29Z
CWE-190,"CWE-190 static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>gd2<S2SV_blank>header<S2SV_blank>info"" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( ""Got<S2SV_blank>file<S2SV_blank>code:<S2SV_blank>%s"" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>gd2<S2SV_blank>file"" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Version:<S2SV_blank>%d"" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>version:<S2SV_blank>%d"" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>x-size"" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>y-size"" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( ""Image<S2SV_blank>is<S2SV_blank>%dx%d"" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""ChunkSize:<S2SV_blank>%d"" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>chunk<S2SV_blank>size:<S2SV_blank>%d"" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Format:<S2SV_blank>%d"" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>data<S2SV_blank>format:<S2SV_blank>%d"" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>Wide"" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>vertically"" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries"" , nc ) ) ; <S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> if ( sidx <= 0 ) { goto fail1 ; } <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( ""gd2<S2SV_blank>header<S2SV_blank>complete"" ) ) ; return 1 ; fail1 : return 0 ; }
","<S2SV_ModStart> ) ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( cidx == NULL ) { goto fail1 ; }
",php@php-src/7722455726bec8c53458a32851d2a87982cf0eac,CVE-2016-5766,https://github.com/php/php-src/commit/7722455726bec8c53458a32851d2a87982cf0eac,2016-08-07T10:59Z
CWE-119,"CWE-119 static inline void queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock ( & hb -> lock ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }
","<S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
CWE-119,"CWE-119 int commonio_sort ( struct commonio_db * db , int ( * cmp ) ( const void * , const void * ) ) { struct commonio_entry * * entries , * ptr ; size_t n = 0 , i ; # if KEEP_NIS_AT_END struct commonio_entry * nis = NULL ; # endif for ( ptr = db -> head ; ( NULL != ptr ) # if KEEP_NIS_AT_END <S2SV_StartBug> && ( NULL != ptr -> line ) <S2SV_EndBug> <S2SV_StartBug> && ( ( '+' != ptr -> line [ 0 ] ) <S2SV_EndBug> <S2SV_StartBug> && ( '-' != ptr -> line [ 0 ] ) ) <S2SV_EndBug> # endif ; ptr = ptr -> next ) { n ++ ; } # if KEEP_NIS_AT_END <S2SV_StartBug> if ( ( NULL != ptr ) && ( NULL != ptr -> line ) ) { <S2SV_EndBug> nis = ptr ; } # endif if ( n <= 1 ) { return 0 ; } entries = malloc ( n * sizeof ( struct commonio_entry * ) ) ; if ( entries == NULL ) { return - 1 ; } n = 0 ; for ( ptr = db -> head ; # if KEEP_NIS_AT_END nis != ptr ; # else NULL != ptr ; # endif ptr = ptr -> next ) { entries [ n ] = ptr ; n ++ ; } qsort ( entries , n , sizeof ( struct commonio_entry * ) , cmp ) ; db -> head = entries [ 0 ] ; n -- ; # if KEEP_NIS_AT_END if ( NULL == nis ) # endif { db -> tail = entries [ n ] ; } db -> head -> prev = NULL ; db -> head -> next = entries [ 1 ] ; entries [ n ] -> prev = entries [ n - 1 ] ; # if KEEP_NIS_AT_END entries [ n ] -> next = nis ; # else entries [ n ] -> next = NULL ; # endif for ( i = 1 ; i < n ; i ++ ) { entries [ i ] -> prev = entries [ i - 1 ] ; entries [ i ] -> next = entries [ i + 1 ] ; } free ( entries ) ; db -> changed = true ; return 0 ; }
","<S2SV_ModStart> KEEP_NIS_AT_END && ( ( NULL == <S2SV_ModEnd> ptr -> line <S2SV_ModStart> -> line ) || ( ( '+' != ptr -> line [ 0 ] ) && ( '-' <S2SV_ModEnd> != ptr -> <S2SV_ModStart> 0 ] ) <S2SV_ModEnd> ) ) # <S2SV_ModStart> KEEP_NIS_AT_END if ( NULL != ptr <S2SV_ModEnd> ) { nis
",shadow-maint@shadow/954e3d2e7113e9ac06632aee3c69b8d818cc8952,CVE-2017-12424,https://github.com/shadow-maint/shadow/commit/954e3d2e7113e9ac06632aee3c69b8d818cc8952,2017-08-04T09:29Z
CWE-284,"CWE-284 static int process_cmd_sock ( int h ) { sock_cmd_t cmd = { - 1 , 0 , 0 , 0 , 0 } ; int fd = ts [ h ] . cmd_fdr ; <S2SV_StartBug> if ( recv ( fd , & cmd , sizeof ( cmd ) , MSG_WAITALL ) != sizeof ( cmd ) ) <S2SV_EndBug> { APPL_TRACE_ERROR ( ""recv<S2SV_blank>cmd<S2SV_blank>errno:%d"" , errno ) ; return FALSE ; } APPL_TRACE_DEBUG ( ""cmd.id:%d"" , cmd . id ) ; switch ( cmd . id ) { case CMD_ADD_FD : add_poll ( h , cmd . fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_REMOVE_FD : for ( int i = 1 ; i < MAX_POLL ; ++ i ) { poll_slot_t * poll_slot = & ts [ h ] . ps [ i ] ; if ( poll_slot -> pfd . fd == cmd . fd ) { remove_poll ( h , poll_slot , poll_slot -> flags ) ; break ; } } close ( cmd . fd ) ; break ; case CMD_WAKEUP : break ; case CMD_USER_PRIVATE : asrt ( ts [ h ] . cmd_callback ) ; if ( ts [ h ] . cmd_callback ) ts [ h ] . cmd_callback ( fd , cmd . type , cmd . flags , cmd . user_id ) ; break ; case CMD_EXIT : return FALSE ; default : APPL_TRACE_DEBUG ( ""unknown<S2SV_blank>cmd:<S2SV_blank>%d"" , cmd . id ) ; break ; } return TRUE ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , MSG_WAITALL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; <S2SV_StartBug> if ( ! stream ) <S2SV_EndBug> <S2SV_StartBug> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; <S2SV_EndBug> if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; <S2SV_StartBug> res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>config:<S2SV_blank>%s\\n"" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; <S2SV_StartBug> stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; <S2SV_EndBug> <S2SV_StartBug> stream -> config . write_webm = 1 ; <S2SV_EndBug> # if CONFIG_WEBM_IO <S2SV_StartBug> stream -> ebml . last_pts_ms = - 1 ; <S2SV_EndBug> # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }
","<S2SV_ModStart> ; if ( stream == NULL ) { <S2SV_ModEnd> fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" <S2SV_ModStart> ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>new<S2SV_blank>stream."" ) ; } <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> config . <S2SV_ModStart> ; stream -> ebml . last_pts_ns <S2SV_ModEnd> = - 1 <S2SV_ModStart> = - 1 ; stream -> ebml . writer = NULL ; stream -> ebml . segment = NULL
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 static int show_stream ( WriterContext * w , AVFormatContext * fmt_ctx , int stream_idx , InputStream * ist , int in_program ) { AVStream * stream = ist -> st ; AVCodecParameters * par ; AVCodecContext * dec_ctx ; char val_str [ 128 ] ; const char * s ; AVRational sar , dar ; AVBPrint pbuf ; const AVCodecDescriptor * cd ; int ret = 0 ; const char * profile = NULL ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM ) ; print_int ( ""index"" , stream -> index ) ; par = stream -> codecpar ; dec_ctx = ist -> dec_ctx ; if ( cd = avcodec_descriptor_get ( par -> codec_id ) ) { print_str ( ""codec_name"" , cd -> name ) ; if ( ! do_bitexact ) { print_str ( ""codec_long_name"" , cd -> long_name ? cd -> long_name : ""unknown"" ) ; } } else { print_str_opt ( ""codec_name"" , ""unknown"" ) ; if ( ! do_bitexact ) { print_str_opt ( ""codec_long_name"" , ""unknown"" ) ; } } if ( ! do_bitexact && ( profile = avcodec_profile_name ( par -> codec_id , par -> profile ) ) ) print_str ( ""profile"" , profile ) ; else { if ( par -> profile != FF_PROFILE_UNKNOWN ) { char profile_num [ 12 ] ; snprintf ( profile_num , sizeof ( profile_num ) , ""%d"" , par -> profile ) ; print_str ( ""profile"" , profile_num ) ; } else print_str_opt ( ""profile"" , ""unknown"" ) ; } s = av_get_media_type_string ( par -> codec_type ) ; if ( s ) print_str ( ""codec_type"" , s ) ; else print_str_opt ( ""codec_type"" , ""unknown"" ) ; # if FF_API_LAVF_AVCTX if ( dec_ctx ) print_q ( ""codec_time_base"" , dec_ctx -> time_base , '/' ) ; # endif print_str ( ""codec_tag_string"" , av_fourcc2str ( par -> codec_tag ) ) ; print_fmt ( ""codec_tag"" , ""0x%04"" PRIx32 , par -> codec_tag ) ; switch ( par -> codec_type ) { case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , par -> width ) ; print_int ( ""height"" , par -> height ) ; if ( dec_ctx ) { print_int ( ""coded_width"" , dec_ctx -> coded_width ) ; print_int ( ""coded_height"" , dec_ctx -> coded_height ) ; } print_int ( ""has_b_frames"" , par -> video_delay ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , NULL ) ; if ( sar . den ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; av_reduce ( & dar . num , & dar . den , par -> width * sar . num , par -> height * sar . den , 1024 * 1024 ) ; print_q ( ""display_aspect_ratio"" , dar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; print_str_opt ( ""display_aspect_ratio"" , ""N/A"" ) ; } s = av_get_pix_fmt_name ( par -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; print_int ( ""level"" , par -> level ) ; if ( par -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( par -> color_range ) ) ; else print_str_opt ( ""color_range"" , ""N/A"" ) ; if ( par -> color_space != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( par -> color_space ) ) ; if ( par -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( par -> color_trc ) ) ; <S2SV_StartBug> if ( par -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> print_str ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( par -> color_primaries ) ) ; if ( par -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( par -> chroma_location ) ) ; if ( par -> field_order == AV_FIELD_PROGRESSIVE ) print_str ( ""field_order"" , ""progressive"" ) ; else if ( par -> field_order == AV_FIELD_TT ) print_str ( ""field_order"" , ""tt"" ) ; else if ( par -> field_order == AV_FIELD_BB ) print_str ( ""field_order"" , ""bb"" ) ; else if ( par -> field_order == AV_FIELD_TB ) print_str ( ""field_order"" , ""tb"" ) ; else if ( par -> field_order == AV_FIELD_BT ) print_str ( ""field_order"" , ""bt"" ) ; else print_str_opt ( ""field_order"" , ""unknown"" ) ; # if FF_API_PRIVATE_OPT if ( dec_ctx && dec_ctx -> timecode_frame_start >= 0 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , dec_ctx -> timecode_frame_start ) ; print_str ( ""timecode"" , tcbuf ) ; } else { print_str_opt ( ""timecode"" , ""N/A"" ) ; } # endif if ( dec_ctx ) print_int ( ""refs"" , dec_ctx -> refs ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( par -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_val ( ""sample_rate"" , par -> sample_rate , unit_hertz_str ) ; print_int ( ""channels"" , par -> channels ) ; if ( par -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , par -> channels , par -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else { print_str_opt ( ""channel_layout"" , ""unknown"" ) ; } print_int ( ""bits_per_sample"" , av_get_bits_per_sample ( par -> codec_id ) ) ; break ; case AVMEDIA_TYPE_SUBTITLE : if ( par -> width ) print_int ( ""width"" , par -> width ) ; else print_str_opt ( ""width"" , ""N/A"" ) ; if ( par -> height ) print_int ( ""height"" , par -> height ) ; else print_str_opt ( ""height"" , ""N/A"" ) ; break ; } if ( dec_ctx && dec_ctx -> codec && dec_ctx -> codec -> priv_class && show_private_data ) { const AVOption * opt = NULL ; while ( opt = av_opt_next ( dec_ctx -> priv_data , opt ) ) { uint8_t * str ; if ( opt -> flags ) continue ; if ( av_opt_get ( dec_ctx -> priv_data , opt -> name , 0 , & str ) >= 0 ) { print_str ( opt -> name , str ) ; av_free ( str ) ; } } } if ( fmt_ctx -> iformat -> flags & AVFMT_SHOW_IDS ) print_fmt ( ""id"" , ""0x%x"" , stream -> id ) ; else print_str_opt ( ""id"" , ""N/A"" ) ; print_q ( ""r_frame_rate"" , stream -> r_frame_rate , '/' ) ; print_q ( ""avg_frame_rate"" , stream -> avg_frame_rate , '/' ) ; print_q ( ""time_base"" , stream -> time_base , '/' ) ; print_ts ( ""start_pts"" , stream -> start_time ) ; print_time ( ""start_time"" , stream -> start_time , & stream -> time_base ) ; print_ts ( ""duration_ts"" , stream -> duration ) ; print_time ( ""duration"" , stream -> duration , & stream -> time_base ) ; if ( par -> bit_rate > 0 ) print_val ( ""bit_rate"" , par -> bit_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""bit_rate"" , ""N/A"" ) ; # if FF_API_LAVF_AVCTX if ( stream -> codec -> rc_max_rate > 0 ) print_val ( ""max_bit_rate"" , stream -> codec -> rc_max_rate , unit_bit_per_second_str ) ; else print_str_opt ( ""max_bit_rate"" , ""N/A"" ) ; # endif if ( dec_ctx && dec_ctx -> bits_per_raw_sample > 0 ) print_fmt ( ""bits_per_raw_sample"" , ""%d"" , dec_ctx -> bits_per_raw_sample ) ; else print_str_opt ( ""bits_per_raw_sample"" , ""N/A"" ) ; if ( stream -> nb_frames ) print_fmt ( ""nb_frames"" , ""%"" PRId64 , stream -> nb_frames ) ; else print_str_opt ( ""nb_frames"" , ""N/A"" ) ; if ( nb_streams_frames [ stream_idx ] ) print_fmt ( ""nb_read_frames"" , ""%"" PRIu64 , nb_streams_frames [ stream_idx ] ) ; else print_str_opt ( ""nb_read_frames"" , ""N/A"" ) ; if ( nb_streams_packets [ stream_idx ] ) print_fmt ( ""nb_read_packets"" , ""%"" PRIu64 , nb_streams_packets [ stream_idx ] ) ; else print_str_opt ( ""nb_read_packets"" , ""N/A"" ) ; if ( do_show_data ) writer_print_data ( w , ""extradata"" , par -> extradata , par -> extradata_size ) ; writer_print_data_hash ( w , ""extradata_hash"" , par -> extradata , par -> extradata_size ) ; # define PRINT_DISPOSITION ( flagname , name ) do { print_int ( name , ! ! ( stream -> disposition & AV_DISPOSITION_ ## flagname ) ) ; } while ( 0 ) if ( do_show_stream_disposition ) { writer_print_section_header ( w , in_program ? SECTION_ID_PROGRAM_STREAM_DISPOSITION : SECTION_ID_STREAM_DISPOSITION ) ; PRINT_DISPOSITION ( DEFAULT , ""default"" ) ; PRINT_DISPOSITION ( DUB , ""dub"" ) ; PRINT_DISPOSITION ( ORIGINAL , ""original"" ) ; PRINT_DISPOSITION ( COMMENT , ""comment"" ) ; PRINT_DISPOSITION ( LYRICS , ""lyrics"" ) ; PRINT_DISPOSITION ( KARAOKE , ""karaoke"" ) ; PRINT_DISPOSITION ( FORCED , ""forced"" ) ; PRINT_DISPOSITION ( HEARING_IMPAIRED , ""hearing_impaired"" ) ; PRINT_DISPOSITION ( VISUAL_IMPAIRED , ""visual_impaired"" ) ; PRINT_DISPOSITION ( CLEAN_EFFECTS , ""clean_effects"" ) ; PRINT_DISPOSITION ( ATTACHED_PIC , ""attached_pic"" ) ; PRINT_DISPOSITION ( TIMED_THUMBNAILS , ""timed_thumbnails"" ) ; writer_print_section_footer ( w ) ; } if ( do_show_stream_tags ) ret = show_tags ( w , stream -> metadata , in_program ? SECTION_ID_PROGRAM_STREAM_TAGS : SECTION_ID_STREAM_TAGS ) ; if ( stream -> nb_side_data ) { print_pkt_side_data ( w , stream -> codecpar , stream -> side_data , stream -> nb_side_data , SECTION_ID_STREAM_SIDE_DATA_LIST , SECTION_ID_STREAM_SIDE_DATA ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; return ret ; }
","<S2SV_ModStart> ) ) ; print_primaries ( w , <S2SV_ModEnd> par -> color_primaries <S2SV_ModStart> par -> color_primaries <S2SV_ModEnd> ) ; if
",FFmpeg@FFmpeg/837cb4325b712ff1aab531bf41668933f61d75d2,CVE-2017-14225,https://github.com/FFmpeg/FFmpeg/commit/837cb4325b712ff1aab531bf41668933f61d75d2,2017-09-09T08:29Z
CWE-264,"CWE-264 void macvlan_common_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> netdev_ops = & macvlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> header_ops = & macvlan_hard_header_ops , dev -> ethtool_ops = & macvlan_ethtool_ops ; }
","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-22,"CWE-22 int main ( int argc , char * argv [ ] ) { static char buff [ 16384 ] ; struct cpio _cpio ; struct cpio * cpio ; const char * errmsg ; int uid , gid ; int opt ; cpio = & _cpio ; memset ( cpio , 0 , sizeof ( * cpio ) ) ; cpio -> buff = buff ; cpio -> buff_size = sizeof ( buff ) ; # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) { struct sigaction sa ; sigemptyset ( & sa . sa_mask ) ; sa . sa_flags = 0 ; sa . sa_handler = SIG_IGN ; sigaction ( SIGPIPE , & sa , NULL ) ; } # endif lafe_setprogname ( * argv , ""bsdcpio"" ) ; # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , """" ) == NULL ) lafe_warnc ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>default<S2SV_blank>locale"" ) ; # endif cpio -> uid_override = - 1 ; cpio -> gid_override = - 1 ; cpio -> argv = argv ; cpio -> argc = argc ; cpio -> mode = '\\0' ; cpio -> verbose = 0 ; cpio -> compress = '\\0' ; cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ; cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ; # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; # endif cpio -> bytes_per_block = 512 ; cpio -> filename = NULL ; cpio -> matching = archive_match_new ( ) ; if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) { switch ( opt ) { case '0' : cpio -> option_null = 1 ; break ; case 'A' : cpio -> option_append = 1 ; break ; case 'a' : cpio -> option_atime_restore = 1 ; break ; case 'B' : cpio -> bytes_per_block = 5120 ; break ; case OPTION_B64ENCODE : cpio -> add_filter = opt ; break ; case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ; if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , ""Invalid<S2SV_blank>blocksize<S2SV_blank>%s"" , cpio -> argument ) ; break ; case 'c' : cpio -> format = ""odc"" ; break ; case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ; break ; case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case 'F' : cpio -> filename = cpio -> argument ; break ; case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case OPTION_GRZIP : cpio -> compress = opt ; break ; case 'H' : cpio -> format = cpio -> argument ; break ; case 'h' : long_help ( ) ; break ; case 'I' : cpio -> filename = cpio -> argument ; break ; case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-i<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'J' : cpio -> compress = opt ; break ; case 'j' : cpio -> compress = opt ; break ; case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ; <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> break ; case 'L' : cpio -> option_follow_links = 1 ; break ; case 'l' : cpio -> option_link = 1 ; break ; case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ; break ; case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ; break ; case 'n' : cpio -> option_numeric_uid_gid = 1 ; break ; case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ; break ; case 'O' : cpio -> filename = cpio -> argument ; break ; case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-o<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-p<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; break ; case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ; break ; case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; break ; case OPTION_QUIET : cpio -> quiet = 1 ; break ; case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ; if ( errmsg ) { lafe_warnc ( - 1 , ""%s"" , errmsg ) ; usage ( ) ; } if ( uid != - 1 ) { cpio -> uid_override = uid ; cpio -> uname_override = NULL ; } if ( gid != - 1 ) { cpio -> gid_override = gid ; cpio -> gname_override = NULL ; } break ; case 'r' : cpio -> option_rename = 1 ; break ; case 't' : cpio -> option_list = 1 ; break ; case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; break ; case OPTION_UUENCODE : cpio -> add_filter = opt ; break ; case 'v' : cpio -> verbose ++ ; break ; case 'V' : cpio -> dot ++ ; break ; case OPTION_VERSION : version ( ) ; break ; # if 0 case 'W' : break ; # endif case 'y' : cpio -> compress = opt ; break ; case 'Z' : cpio -> compress = opt ; break ; case 'z' : cpio -> compress = opt ; break ; default : usage ( ) ; } } if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ; if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-t<S2SV_blank>requires<S2SV_blank>-i"" ) ; if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-n<S2SV_blank>requires<S2SV_blank>-it"" ) ; if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>--format<S2SV_blank>requires<S2SV_blank>-o"" ) ; if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-l<S2SV_blank>requires<S2SV_blank>-p"" ) ; if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ; switch ( cpio -> mode ) { case 'o' : if ( cpio -> format == NULL ) cpio -> format = ""odc"" ; mode_out ( cpio ) ; break ; case 'i' : while ( * cpio -> argv != NULL ) { if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; -- cpio -> argc ; ++ cpio -> argv ; } if ( cpio -> option_list ) mode_list ( cpio ) ; else mode_in ( cpio ) ; break ; case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , ""-p<S2SV_blank>mode<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>target<S2SV_blank>directory"" ) ; mode_pass ( cpio , * cpio -> argv ) ; break ; default : lafe_errc ( 1 , 0 , ""Must<S2SV_blank>specify<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>of<S2SV_blank>-i,<S2SV_blank>-o,<S2SV_blank>or<S2SV_blank>-p"" ) ; } archive_match_free ( cpio -> matching ) ; free_cache ( cpio -> gname_cache ) ; free_cache ( cpio -> uname_cache ) ; free ( cpio -> destdir ) ; passphrase_free ( cpio -> ppbuff ) ; return ( cpio -> return_value ) ; }
","<S2SV_ModStart> -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
",libarchive@libarchive/59357157706d47c365b2227739e17daba3607526,CVE-2015-2304,https://github.com/libarchive/libarchive/commit/59357157706d47c365b2227739e17daba3607526,2015-03-15T19:59Z
CWE-200,"CWE-200 int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ; <S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( ""Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n"" , rr -> u . NM . flags ) ; break ; } <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> truncate = 1 ; break ; } <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
","<S2SV_ModStart> = 0 ; char * p ; int len ; <S2SV_ModStart> break ; } len = <S2SV_ModEnd> rr -> len <S2SV_ModStart> len - 5 ; if ( retnamlen + len <S2SV_ModEnd> >= 254 ) <S2SV_ModStart> break ; } p = memchr ( rr -> u . NM . name , '\\0' , len ) ; if ( unlikely ( p ) ) len = p - rr -> u . NM . name ; memcpy ( retname + retnamlen <S2SV_ModEnd> , rr -> <S2SV_ModStart> . name , len <S2SV_ModEnd> ) ; retnamlen <S2SV_ModStart> ; retnamlen += len ; retname [ retnamlen ] = '\\0' <S2SV_ModEnd> ; break ;
",torvalds@linux/99d825822eade8d827a1817357cbf3f889a552d6,CVE-2016-4913,https://github.com/torvalds/linux/commit/99d825822eade8d827a1817357cbf3f889a552d6,2016-05-23T10:59Z
CWE-119,"CWE-119 static int dalvik_disassemble ( RAsm * a , RAsmOp * op , const ut8 * buf , int len ) { int vA , vB , vC , payload = 0 , i = ( int ) buf [ 0 ] ; int size = dalvik_opcodes [ i ] . len ; char str [ 1024 ] , * strasm ; ut64 offset ; const char * flag_str ; op -> buf_asm [ 0 ] = 0 ; if ( buf [ 0 ] == 0x00 ) { switch ( buf [ 1 ] ) { case 0x01 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d"" , array_size , first_key ) ; <S2SV_EndBug> size = 8 ; payload = 2 * ( array_size * 2 ) ; len = 0 ; } break ; case 0x02 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , ""sparse-switch-payload<S2SV_blank>%d"" , array_size ) ; <S2SV_EndBug> size = 4 ; payload = 2 * ( array_size * 4 ) ; len = 0 ; } break ; case 0x03 : if ( len > 7 ) { unsigned short elem_width = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; unsigned int array_size = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , ""fill-array-data-payload<S2SV_blank>%d,<S2SV_blank>%d"" , elem_width , array_size ) ; payload = 2 * ( ( array_size * elem_width + 1 ) / 2 ) ; } size = 8 ; len = 0 ; break ; default : break ; } } strasm = NULL ; if ( size <= len ) { strncpy ( op -> buf_asm , dalvik_opcodes [ i ] . name , sizeof ( op -> buf_asm ) - 1 ) ; strasm = strdup ( op -> buf_asm ) ; size = dalvik_opcodes [ i ] . len ; switch ( dalvik_opcodes [ i ] . fmt ) { case fmtop : break ; case fmtopvAvB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAAAvBBBB : vA = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vB = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAA : vA = ( int ) buf [ 1 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i"" , vA ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAcB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB : vA = ( int ) buf [ 1 ] ; { short sB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , vA , sB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; } break ; case fmtopvAAcBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ; if ( buf [ 0 ] == 0x17 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB0000 : vA = ( int ) buf [ 1 ] ; vB = 0 | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; if ( buf [ 0 ] == 0x19 ) { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x"" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08x"" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBBBBBBBBBBBBBB : vA = ( int ) buf [ 1 ] ; # define llint long long int llint lB = ( llint ) buf [ 2 ] | ( ( llint ) buf [ 3 ] << 8 ) | ( ( llint ) buf [ 4 ] << 16 ) | ( ( llint ) buf [ 5 ] << 24 ) | ( ( llint ) buf [ 6 ] << 32 ) | ( ( llint ) buf [ 7 ] << 40 ) | ( ( llint ) buf [ 8 ] << 48 ) | ( ( llint ) buf [ 9 ] << 56 ) ; # undef llint <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBvCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBcCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBcCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAA : vA = ( char ) buf [ 1 ] ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAA : vA = ( short ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + ( vB * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAAAAAA : vA = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>0x%08"" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBpCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , ""<S2SV_blank>v%i,<S2SV_blank>0x%08"" PFMT64x , vA , a -> pc + vB ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineI : vA = ( int ) ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; * str = 0 ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineIR : case fmtoptinvokeVSR : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> break ; } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>[%04x]"" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x1a ) { offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } } else if ( buf [ 0 ] == 0x1c || buf [ 0 ] == 0x1f || buf [ 0 ] == 0x22 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , flag_str ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptopvAvBoCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 'o' , vC ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , vA , vB , vC ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x ""]"" , vA , vB , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 't' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBtCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x20 || buf [ 0 ] == 0x23 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , vA , vB , vC ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 5 ] | ( buf [ 4 ] << 8 ) | ( buf [ 3 ] << 16 ) | ( buf [ 2 ] << 24 ) ) ; offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvCCCCmBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; if ( buf [ 0 ] == 0x25 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvXtBBBB : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i}"" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; case 5 : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ; break ; default : <S2SV_StartBug> sprintf ( str , ""<S2SV_blank>{}"" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; if ( buf [ 0 ] == 0x24 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>class+%i"" , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "",<S2SV_blank>method+%i"" , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeI : case fmtoptinvokeIR : case fmt00 : default : strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; free ( strasm ) ; strasm = NULL ; size = 2 ; } if ( strasm ) { strncpy ( op -> buf_asm , strasm , sizeof ( op -> buf_asm ) - 1 ) ; op -> buf_asm [ sizeof ( op -> buf_asm ) - 1 ] = 0 ; } else { strcpy ( op -> buf_asm , ""invalid"" ) ; } } else if ( len > 0 ) { strcpy ( op -> buf_asm , ""invalid<S2SV_blank>"" ) ; op -> size = len ; size = len ; } op -> payload = payload ; size += payload ; op -> size = size ; free ( strasm ) ; return size ; }
","<S2SV_ModStart> 24 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> -> buf_asm , sizeof ( op -> buf_asm ) , <S2SV_ModStart> 8 ) ; snprintf <S2SV_ModEnd> ( op -> <S2SV_ModStart> op -> buf_asm , sizeof ( op -> buf_asm ) <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 1 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i"" , <S2SV_ModStart> >> 4 ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%#04hx"" , <S2SV_ModStart> # undef llint snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i:v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i"" , <S2SV_ModStart> 3 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> 2 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 4 ] ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> str ) ; snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>[%04x]"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%"" PFMT64x <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>thing+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i"" , <S2SV_ModStart> 1 ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>string+%i"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>v%i,<S2SV_blank>0x%"" PFMT64x <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>%s"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i"" , <S2SV_ModStart> case 1 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i}"" , <S2SV_ModStart> case 2 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 3 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 4 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> case 5 : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}"" , <S2SV_ModStart> ; default : snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , ""<S2SV_blank>{}"" ) <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>class+%i"" , <S2SV_ModStart> flag_str ) { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x"" , <S2SV_ModStart> } else { snprintf ( str , sizeof ( str ) <S2SV_ModEnd> , "",<S2SV_blank>method+%i"" ,
",radare@radare2/f41e941341e44aa86edd4483c4487ec09a074257,CVE-2017-6448,https://github.com/radare/radare2/commit/f41e941341e44aa86edd4483c4487ec09a074257,2017-04-03T05:59Z
CWE-20,"CWE-20 bool_t dm9000IrqHandler ( NetInterface * interface ) { bool_t flag ; uint8_t status ; uint8_t mask ; Dm9000Context * context ; flag = FALSE ; context = ( Dm9000Context * ) interface -> nicContext ; <S2SV_StartBug> status = dm9000ReadReg ( DM9000_REG_ISR ) ; <S2SV_EndBug> if ( ( status & ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_LNKCHGI ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } <S2SV_StartBug> if ( ( status & ISR_PT ) != 0 ) <S2SV_EndBug> { if ( dm9000ReadReg ( DM9000_REG_NSR ) & ( NSR_TX2END | NSR_TX1END ) ) { if ( context -> queuedPackets > 0 ) { context -> queuedPackets -- ; } flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_ISR , ISR_PT ) ; <S2SV_EndBug> } if ( ( status & ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_REG_IMR ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_IMR , mask & ~ IMR_PRI ) ; <S2SV_EndBug> interface -> nicEvent = TRUE ; flag |= osSetEventFromIsr ( & netEvent ) ; } return flag ; }
","<S2SV_ModStart> = dm9000ReadReg ( DM9000_ISR ) ; if ( ( status & DM9000_ISR_LNKCHG ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_LNKCHGI <S2SV_ModEnd> ) ; interface <S2SV_ModStart> ( status & DM9000_ISR_PT ) != 0 ) { if ( ( dm9000ReadReg ( DM9000_NSR ) & ( DM9000_NSR_TX2END | DM9000_NSR_TX1END ) ) != 0 <S2SV_ModEnd> ) { if <S2SV_ModStart> } dm9000WriteReg ( DM9000_ISR , DM9000_ISR_PT ) ; } if ( ( status & DM9000_ISR_PR ) != 0 ) { mask = dm9000ReadReg ( DM9000_IMR <S2SV_ModEnd> ) ; dm9000WriteReg <S2SV_ModStart> ; dm9000WriteReg ( DM9000_IMR <S2SV_ModEnd> , mask & <S2SV_ModStart> mask & ~ DM9000_IMR_PRI <S2SV_ModEnd> ) ; interface
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 <S2SV_StartBug> int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , <S2SV_EndBug> vpx_codec_frame_buffer_t * fb ) { int i ; struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ; if ( ext_fb_list == NULL ) return - 1 ; for ( i = 0 ; i < ext_fb_list -> num_external_frame_buffers ; ++ i ) { if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ; } if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ; if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) { free ( ext_fb_list -> ext_fb [ i ] . data ) ; <S2SV_StartBug> ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ; <S2SV_EndBug> if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ; ext_fb_list -> ext_fb [ i ] . size = min_size ; } fb -> data = ext_fb_list -> ext_fb [ i ] . data ; fb -> size = ext_fb_list -> ext_fb [ i ] . size ; ext_fb_list -> ext_fb [ i ] . in_use = 1 ; fb -> priv = & ext_fb_list -> ext_fb [ i ] ; return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> uint8_t * ) calloc ( min_size , sizeof ( uint8_t ) <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }
","<S2SV_ModStart> ( d ) ; msg -> msg_namelen = 0
",torvalds@linux/e11e0455c0d7d3d62276a0c55d9dfbc16779d691,CVE-2013-3225,https://github.com/torvalds/linux/commit/e11e0455c0d7d3d62276a0c55d9dfbc16779d691,2013-04-22T11:41Z
CWE-20,"CWE-20 static int zip_read_mac_metadata ( struct archive_read * a , struct archive_entry * entry , struct zip_entry * rsrc ) { struct zip * zip = ( struct zip * ) a -> format -> data ; unsigned char * metadata , * mp ; int64_t offset = archive_filter_bytes ( & a -> archive , 0 ) ; size_t remaining_bytes , metadata_bytes ; ssize_t hsize ; int ret = ARCHIVE_OK , eof ; switch ( rsrc -> compression ) { <S2SV_StartBug> case 0 : <S2SV_EndBug> # ifdef HAVE_ZLIB_H case 8 : # endif break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Unsupported<S2SV_blank>ZIP<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(%s)"" , compression_name ( rsrc -> compression ) ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> uncompressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , <S2SV_StartBug> ( intmax_t ) rsrc -> uncompressed_size ) ; <S2SV_EndBug> return ( ARCHIVE_WARN ) ; } metadata = malloc ( ( size_t ) rsrc -> uncompressed_size ) ; if ( metadata == NULL ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Mac<S2SV_blank>metadata"" ) ; return ( ARCHIVE_FATAL ) ; } if ( offset < rsrc -> local_header_offset ) __archive_read_consume ( a , rsrc -> local_header_offset - offset ) ; else if ( offset != rsrc -> local_header_offset ) { __archive_read_seek ( a , rsrc -> local_header_offset , SEEK_SET ) ; } hsize = zip_get_local_file_header_size ( a , 0 ) ; __archive_read_consume ( a , hsize ) ; remaining_bytes = ( size_t ) rsrc -> compressed_size ; metadata_bytes = ( size_t ) rsrc -> uncompressed_size ; mp = metadata ; eof = 0 ; while ( ! eof && remaining_bytes ) { const unsigned char * p ; ssize_t bytes_avail ; size_t bytes_used ; p = __archive_read_ahead ( a , 1 , & bytes_avail ) ; if ( p == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Truncated<S2SV_blank>ZIP<S2SV_blank>file<S2SV_blank>header"" ) ; ret = ARCHIVE_WARN ; goto exit_mac_metadata ; } if ( ( size_t ) bytes_avail > remaining_bytes ) bytes_avail = remaining_bytes ; switch ( rsrc -> compression ) { case 0 : <S2SV_StartBug> memcpy ( mp , p , bytes_avail ) ; <S2SV_EndBug> bytes_used = ( size_t ) bytes_avail ; metadata_bytes -= bytes_used ; mp += bytes_used ; if ( metadata_bytes == 0 ) eof = 1 ; break ; # ifdef HAVE_ZLIB_H case 8 : { int r ; ret = zip_deflate_init ( a , zip ) ; if ( ret != ARCHIVE_OK ) goto exit_mac_metadata ; zip -> stream . next_in = ( Bytef * ) ( uintptr_t ) ( const void * ) p ; zip -> stream . avail_in = ( uInt ) bytes_avail ; zip -> stream . total_in = 0 ; zip -> stream . next_out = mp ; zip -> stream . avail_out = ( uInt ) metadata_bytes ; zip -> stream . total_out = 0 ; r = inflate ( & zip -> stream , 0 ) ; switch ( r ) { case Z_OK : break ; case Z_STREAM_END : eof = 1 ; break ; case Z_MEM_ERROR : archive_set_error ( & a -> archive , ENOMEM , ""Out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>ZIP<S2SV_blank>decompression"" ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""ZIP<S2SV_blank>decompression<S2SV_blank>failed<S2SV_blank>(%d)"" , r ) ; ret = ARCHIVE_FATAL ; goto exit_mac_metadata ; } bytes_used = zip -> stream . total_in ; metadata_bytes -= zip -> stream . total_out ; mp += zip -> stream . total_out ; break ; } # endif default : bytes_used = 0 ; break ; } __archive_read_consume ( a , bytes_used ) ; remaining_bytes -= bytes_used ; } archive_entry_copy_mac_metadata ( entry , metadata , ( size_t ) rsrc -> uncompressed_size - metadata_bytes ) ; exit_mac_metadata : __archive_read_seek ( a , offset , SEEK_SET ) ; zip -> decompress_init = 0 ; free ( metadata ) ; return ( ret ) ; }
","<S2SV_ModStart> case 0 : if ( rsrc -> uncompressed_size != rsrc -> compressed_size ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Malformed<S2SV_blank>OS<S2SV_blank>X<S2SV_blank>metadata<S2SV_blank>entry:<S2SV_blank>inconsistent<S2SV_blank>size"" ) ; return ( ARCHIVE_FATAL ) ; } <S2SV_ModStart> rsrc -> uncompressed_size ) ; return ( ARCHIVE_WARN ) ; } if ( rsrc -> compressed_size > ( 4 * 1024 * 1024 ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Mac<S2SV_blank>metadata<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%jd<S2SV_blank>><S2SV_blank>4M<S2SV_blank>bytes"" , ( intmax_t ) rsrc -> compressed_size <S2SV_ModStart> case 0 : if ( ( size_t ) bytes_avail > metadata_bytes ) bytes_avail = metadata_bytes ;
",libarchive@libarchive/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,CVE-2016-1541,https://github.com/libarchive/libarchive/commit/d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,2016-05-07T10:59Z
CWE-284,"CWE-284 void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Oops,<S2SV_blank>dev_handle<S2SV_blank>(%d)<S2SV_blank>is<S2SV_blank>invalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:<S2SV_blank>Found<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>device<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>handle<S2SV_blank>"" ""dev_status<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>bd_addr<S2SV_blank>=<S2SV_blank>[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>attr_mask<S2SV_blank>=<S2SV_blank>0x%04x,<S2SV_blank>sub_class<S2SV_blank>=<S2SV_blank>0x%02x,<S2SV_blank>app_id<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; } p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; break ; } p_dev = NULL ; } if ( p_dev == NULL ) { for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { if ( btif_hh_cb . devices [ i ] . dev_status == BTHH_CONN_STATE_UNKNOWN ) { p_dev = & btif_hh_cb . devices [ i ] ; p_dev -> dev_handle = dev_handle ; p_dev -> attr_mask = attr_mask ; p_dev -> sub_class = sub_class ; p_dev -> app_id = app_id ; p_dev -> local_vup = FALSE ; btif_hh_cb . device_num ++ ; <S2SV_StartBug> p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>uhid,<S2SV_blank>err:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return ; } else { APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>uhid<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> fd ) ; p_dev -> hh_keep_polling = 1 ; p_dev -> hh_poll_thread_id = create_thread ( btif_hh_poll_event_thread , p_dev ) ; } break ; } } } if ( p_dev == NULL ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Error:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>HID<S2SV_blank>devices<S2SV_blank>are<S2SV_blank>connected"" , __FUNCTION__ ) ; return ; } p_dev -> dev_status = BTHH_CONN_STATE_CONNECTED ; APPL_TRACE_DEBUG ( ""%s:<S2SV_blank>Return<S2SV_blank>device<S2SV_blank>status<S2SV_blank>%d"" , __FUNCTION__ , p_dev -> dev_status ) ; }
","<S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) ) <S2SV_ModStart> -> fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> | O_CLOEXEC ) )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-190,"CWE-190 static int readSeparateStripsIntoBuffer ( TIFF * in , uint8 * obuf , uint32 length , uint32 width , uint16 spp , struct dump_opts * dump ) { <S2SV_StartBug> int i , j , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; <S2SV_EndBug> int32 bytes_read = 0 ; <S2SV_StartBug> uint16 bps , nstrips , planar , strips_per_sample ; <S2SV_EndBug> uint32 src_rowsize , dst_rowsize , rows_processed , rps ; uint32 rows_this_strip = 0 ; tsample_t s ; tstrip_t strip ; tsize_t scanlinesize = TIFFScanlineSize ( in ) ; tsize_t stripsize = TIFFStripSize ( in ) ; unsigned char * srcbuffs [ MAX_SAMPLES ] ; unsigned char * buff = NULL ; unsigned char * dst = NULL ; if ( obuf == NULL ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Invalid<S2SV_blank>buffer<S2SV_blank>argument"" ) ; return ( 0 ) ; } memset ( srcbuffs , '\\0' , sizeof ( srcbuffs ) ) ; TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; if ( rps > length ) rps = length ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; src_rowsize = ( ( bps * width ) + 7 ) / 8 ; dst_rowsize = ( ( bps * width * spp ) + 7 ) / 8 ; dst = obuf ; if ( ( dump -> infile != NULL ) && ( dump -> level == 3 ) ) { dump_info ( dump -> infile , dump -> format , """" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Scanline<S2SV_blank>size,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , scanlinesize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d,<S2SV_blank>Shift<S2SV_blank>width<S2SV_blank>%d"" , bps , spp , shift_width ) ; } nstrips = TIFFNumberOfStrips ( in ) ; strips_per_sample = nstrips / spp ; for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { srcbuffs [ s ] = NULL ; buff = _TIFFmalloc ( stripsize ) ; if ( ! buff ) { TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>strip<S2SV_blank>read<S2SV_blank>buffer<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , s ) ; for ( i = 0 ; i < s ; i ++ ) _TIFFfree ( srcbuffs [ i ] ) ; return 0 ; } srcbuffs [ s ] = buff ; } rows_processed = 0 ; for ( j = 0 ; ( j < strips_per_sample ) && ( result == 1 ) ; j ++ ) { for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; strip = ( s * strips_per_sample ) + j ; bytes_read = TIFFReadEncodedStrip ( in , strip , buff , stripsize ) ; rows_this_strip = bytes_read / src_rowsize ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d"" , ( unsigned long ) strip , s + 1 ) ; result = 0 ; break ; } # ifdef DEVELMODE TIFFError ( """" , ""Strip<S2SV_blank>%2d,<S2SV_blank>read<S2SV_blank>%5d<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>%4d<S2SV_blank>scanlines,<S2SV_blank>shift<S2SV_blank>width<S2SV_blank>%d"" , strip , bytes_read , rows_this_strip , shift_width ) ; # endif } if ( rps > rows_this_strip ) rps = rows_this_strip ; dst = obuf + ( dst_rowsize * rows_processed ) ; if ( ( bps % 8 ) == 0 ) { if ( combineSeparateSamplesBytes ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } } else { switch ( shift_width ) { case 1 : if ( combineSeparateSamples8bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 2 : if ( combineSeparateSamples16bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 3 : if ( combineSeparateSamples24bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; case 4 : case 5 : case 6 : case 7 : case 8 : if ( combineSeparateSamples32bits ( srcbuffs , dst , width , rps , spp , bps , dump -> infile , dump -> format , dump -> level ) ) { result = 0 ; break ; } break ; default : TIFFError ( ""readSeparateStripsIntoBuffer"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth:<S2SV_blank>%d"" , bps ) ; result = 0 ; break ; } } if ( ( rows_processed + rps ) > length ) { rows_processed = length ; rps = length - rows_processed ; } else rows_processed += rps ; } for ( s = 0 ; ( s < spp ) && ( s < MAX_SAMPLES ) ; s ++ ) { buff = srcbuffs [ s ] ; if ( buff != NULL ) _TIFFfree ( buff ) ; } return ( result ) ; }
","<S2SV_ModStart> int i , bytes_per_sample , bytes_per_pixel , shift_width , result = 1 ; uint32 j <S2SV_ModEnd> ; int32 bytes_read <S2SV_ModStart> uint16 bps , planar ; uint32 nstrips ; uint32 <S2SV_ModEnd> strips_per_sample ; uint32
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,2016-11-22T19:59Z
CWE-264,"CWE-264 void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> <S2SV_StartBug> if ( opt ) <S2SV_EndBug> <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> = xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( <S2SV_ModEnd> opt -> tot_len <S2SV_ModStart> opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt <S2SV_ModStart> ) ; } }
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-20,"CWE-20 static int rfcomm_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rfcomm_dlc * d = rfcomm_pi ( sk ) -> dlc ; int len ; if ( test_and_clear_bit ( RFCOMM_DEFER_SETUP , & d -> flags ) ) { <S2SV_StartBug> rfcomm_dlc_accept ( d ) ; <S2SV_EndBug> msg -> msg_namelen = 0 ; return 0 ; } len = bt_sock_stream_recvmsg ( iocb , sock , msg , size , flags ) ; lock_sock ( sk ) ; if ( ! ( flags & MSG_PEEK ) && len > 0 ) atomic_sub ( len , & sk -> sk_rmem_alloc ) ; if ( atomic_read ( & sk -> sk_rmem_alloc ) <= ( sk -> sk_rcvbuf >> 2 ) ) rfcomm_dlc_unthrottle ( rfcomm_pi ( sk ) -> dlc ) ; release_sock ( sk ) ; return len ; }
","<S2SV_ModStart> ( d ) <S2SV_ModEnd> ; return 0
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-200,"CWE-200 static mode_t set_umask ( const char * optarg ) { long umask_long ; mode_t umask_val ; char * endptr ; umask_long = strtoll ( optarg , & endptr , 0 ) ; if ( * endptr || umask_long < 0 || umask_long & ~ 0777L ) { fprintf ( stderr , ""Invalid<S2SV_blank>--umask<S2SV_blank>option<S2SV_blank>%s"" , optarg ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } umask_val = umask_long & 0777 ; umask ( umask_val ) ; umask_cmdline = true ; return umask_val ; }
","<S2SV_ModStart> ) ; return 0
",acassen@keepalived/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,CVE-2018-19045,https://github.com/acassen/keepalived/commit/5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,2018-11-08T20:29Z
CWE-399,"CWE-399 int cib_remote_listen ( gpointer data ) { <S2SV_StartBug> int lpc = 0 ; <S2SV_EndBug> int csock = 0 ; <S2SV_StartBug> unsigned laddr ; <S2SV_EndBug> time_t now = 0 ; time_t start = time ( NULL ) ; struct sockaddr_in addr ; int ssock = * ( int * ) data ; <S2SV_StartBug> # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_EndBug> gnutls_session * session = NULL ; # endif cib_client_t * new_client = NULL ; <S2SV_StartBug> xmlNode * login = NULL ; <S2SV_EndBug> const char * user = NULL ; const char * pass = NULL ; const char * tmp = NULL ; # ifdef HAVE_DECL_NANOSLEEP const struct timespec sleepfast = { 0 , 10000000 } ; # endif static struct mainloop_fd_callbacks remote_client_fd_callbacks = { . dispatch = cib_remote_msg , . destroy = cib_remote_connection_destroy , } ; laddr = sizeof ( addr ) ; csock = accept ( ssock , ( struct sockaddr * ) & addr , & laddr ) ; crm_debug ( ""New<S2SV_blank>%s<S2SV_blank>connection<S2SV_blank>from<S2SV_blank>%s"" , ssock == remote_tls_fd ? ""secure"" : ""clear-text"" , inet_ntoa ( addr . sin_addr ) ) ; if ( csock == - 1 ) { crm_err ( ""accept<S2SV_blank>socket<S2SV_blank>failed"" ) ; return TRUE ; } <S2SV_StartBug> if ( ssock == remote_tls_fd ) { <S2SV_EndBug> # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_StartBug> session = create_tls_session ( csock , GNUTLS_SERVER ) ; <S2SV_EndBug> if ( session == NULL ) { crm_err ( ""TLS<S2SV_blank>session<S2SV_blank>creation<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } # endif } <S2SV_StartBug> do { <S2SV_EndBug> crm_trace ( ""Iter:<S2SV_blank>%d"" , lpc ++ ) ; if ( ssock == remote_tls_fd ) { # ifdef HAVE_GNUTLS_GNUTLS_H <S2SV_StartBug> login = crm_recv_remote_msg ( session , TRUE ) ; <S2SV_EndBug> # endif } else { <S2SV_StartBug> login = crm_recv_remote_msg ( GINT_TO_POINTER ( csock ) , FALSE ) ; <S2SV_EndBug> } if ( login != NULL ) { break ; } # ifdef HAVE_DECL_NANOSLEEP nanosleep ( & sleepfast , NULL ) ; # else sleep ( 1 ) ; # endif now = time ( NULL ) ; } while ( login == NULL && ( start - now ) < 4 ) ; crm_log_xml_info ( login , ""Login:<S2SV_blank>"" ) ; if ( login == NULL ) { goto bail ; } tmp = crm_element_name ( login ) ; if ( safe_str_neq ( tmp , ""cib_command"" ) ) { crm_err ( ""Wrong<S2SV_blank>tag:<S2SV_blank>%s"" , tmp ) ; goto bail ; } tmp = crm_element_value ( login , ""op"" ) ; if ( safe_str_neq ( tmp , ""authenticate"" ) ) { crm_err ( ""Wrong<S2SV_blank>operation:<S2SV_blank>%s"" , tmp ) ; goto bail ; } user = crm_element_value ( login , ""user"" ) ; pass = crm_element_value ( login , ""password"" ) ; if ( check_group_membership ( user , CRM_DAEMON_GROUP ) == FALSE ) { crm_err ( ""User<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>member<S2SV_blank>of<S2SV_blank>the<S2SV_blank>required<S2SV_blank>group"" ) ; goto bail ; } else if ( authenticate_user ( user , pass ) == FALSE ) { crm_err ( ""PAM<S2SV_blank>auth<S2SV_blank>failed"" ) ; goto bail ; } num_clients ++ ; new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ; new_client -> name = crm_element_value_copy ( login , ""name"" ) ; CRM_CHECK ( new_client -> id == NULL , free ( new_client -> id ) ) ; new_client -> id = crm_generate_uuid ( ) ; # if ENABLE_ACL new_client -> user = strdup ( user ) ; # endif new_client -> callback_id = NULL ; if ( ssock == remote_tls_fd ) { # ifdef HAVE_GNUTLS_GNUTLS_H new_client -> encrypted = TRUE ; new_client -> session = session ; # endif } else { new_client -> session = GINT_TO_POINTER ( csock ) ; } free_xml ( login ) ; login = create_xml_node ( NULL , ""cib_result"" ) ; crm_xml_add ( login , F_CIB_OPERATION , CRM_OP_REGISTER ) ; crm_xml_add ( login , F_CIB_CLIENTID , new_client -> id ) ; crm_send_remote_msg ( new_client -> session , login , new_client -> encrypted ) ; free_xml ( login ) ; new_client -> remote = mainloop_add_fd ( ""cib-remote-client"" , G_PRIORITY_DEFAULT , csock , new_client , & remote_client_fd_callbacks ) ; g_hash_table_insert ( client_list , new_client -> id , new_client ) ; return TRUE ; <S2SV_StartBug> bail : <S2SV_EndBug> if ( ssock == remote_tls_fd ) { # ifdef HAVE_GNUTLS_GNUTLS_H gnutls_bye ( * session , GNUTLS_SHUT_RDWR ) ; gnutls_deinit ( * session ) ; gnutls_free ( session ) ; # endif } close ( csock ) ; free_xml ( login ) ; return TRUE ; }
","<S2SV_ModStart> ) { int <S2SV_ModEnd> csock = 0 <S2SV_ModStart> ; unsigned laddr <S2SV_ModEnd> ; struct sockaddr_in <S2SV_ModStart> ) data ; int flag ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> static struct mainloop_fd_callbacks <S2SV_ModStart> } if ( ( flag = fcntl ( csock , F_GETFL ) ) >= 0 ) { if ( fcntl ( csock , F_SETFL , flag | O_NONBLOCK ) < 0 ) { crm_err ( ""fcntl()<S2SV_blank>write<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } } else { crm_err ( ""fcntl()<S2SV_blank>read<S2SV_blank>failed"" ) ; close ( csock ) ; return TRUE ; } if ( <S2SV_ModStart> HAVE_GNUTLS_GNUTLS_H session = crm_create_anon_tls_session <S2SV_ModEnd> ( csock , <S2SV_ModStart> csock , GNUTLS_SERVER , anon_cred_s <S2SV_ModStart> # endif } num_clients ++ ; new_client = calloc ( 1 , sizeof ( cib_client_t ) ) ; new_client -> id = crm_generate_uuid ( ) ; new_client -> callback_id = NULL ; new_client -> remote_auth_timeout = g_timeout_add ( REMOTE_AUTH_TIMEOUT , remote_auth_timeout_cb , new_client <S2SV_ModEnd> ) ; if <S2SV_ModStart> # ifdef HAVE_GNUTLS_GNUTLS_H new_client -> encrypted = TRUE ; new_client -> session = session <S2SV_ModEnd> ; # endif <S2SV_ModStart> } else { new_client -> session = <S2SV_ModEnd> GINT_TO_POINTER ( csock <S2SV_ModStart> ( csock ) ; } <S2SV_ModEnd> new_client -> remote <S2SV_ModStart> return TRUE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",ClusterLabs@pacemaker/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,CVE-2013-0281,https://github.com/ClusterLabs/pacemaker/commit/564f7cc2a51dcd2f28ab12a13394f31be5aa3c93,2013-11-23T11:55Z
CWE-119,"CWE-119 static Image * ReadHALDImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; size_t cube_size , level ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; level = 0 ; if ( * image_info -> filename != '\\0' ) level = StringToUnsignedLong ( image_info -> filename ) ; if ( level < 2 ) level = 8 ; status = MagickTrue ; cube_size = level * level ; image -> columns = ( size_t ) ( level * cube_size ) ; image -> rows = ( size_t ) ( level * cube_size ) ; <S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> { ssize_t blue , green , red ; register PixelPacket * restrict q ; if ( status == MagickFalse ) continue ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } blue = y / ( ssize_t ) level ; for ( green = 0 ; green < ( ssize_t ) cube_size ; green ++ ) { for ( red = 0 ; red < ( ssize_t ) cube_size ; red ++ ) { SetPixelRed ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * red / ( cube_size - 1.0 ) ) ) ) ; SetPixelGreen ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * green / ( cube_size - 1.0 ) ) ) ) ; SetPixelBlue ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * blue / ( cube_size - 1.0 ) ) ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) status = MagickFalse ; } return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-119,"CWE-119 int vp8_refining_search_sadx4 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int error_per_bit , int search_range , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { MV neighbors [ 4 ] = { { - 1 , 0 } , { 0 , - 1 } , { 0 , 1 } , { 1 , 0 } } ; int i , j ; short this_row_offset , this_col_offset ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; unsigned char * best_address = ( unsigned char * ) ( base_pre + d -> offset + ( ref_mv -> as_mv . row * pre_stride ) + ref_mv -> as_mv . col ) ; unsigned char * check_here ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; bestsad = fn_ptr -> sdf ( what , what_stride , best_address , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( ref_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; for ( i = 0 ; i < search_range ; i ++ ) { int best_site = - 1 ; int all_in = 1 ; all_in &= ( ( ref_mv -> as_mv . row - 1 ) > x -> mv_row_min ) ; all_in &= ( ( ref_mv -> as_mv . row + 1 ) < x -> mv_row_max ) ; all_in &= ( ( ref_mv -> as_mv . col - 1 ) > x -> mv_col_min ) ; all_in &= ( ( ref_mv -> as_mv . col + 1 ) < x -> mv_col_max ) ; if ( all_in ) { unsigned int sad_array [ 4 ] ; const unsigned char * block_offset [ 4 ] ; block_offset [ 0 ] = best_address - in_what_stride ; block_offset [ 1 ] = best_address - 1 ; block_offset [ 2 ] = best_address + 1 ; block_offset [ 3 ] = best_address + in_what_stride ; fn_ptr -> sdx4df ( what , what_stride , block_offset , in_what_stride , sad_array ) ; for ( j = 0 ; j < 4 ; j ++ ) { if ( sad_array [ j ] < bestsad ) { this_mv . as_mv . row = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_mv . as_mv . col = ref_mv -> as_mv . col + neighbors [ j ] . col ; sad_array [ j ] += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( sad_array [ j ] < bestsad ) { bestsad = sad_array [ j ] ; best_site = j ; } } } } else { for ( j = 0 ; j < 4 ; j ++ ) { this_row_offset = ref_mv -> as_mv . row + neighbors [ j ] . row ; this_col_offset = ref_mv -> as_mv . col + neighbors [ j ] . col ; if ( ( this_col_offset > x -> mv_col_min ) && ( this_col_offset < x -> mv_col_max ) && ( this_row_offset > x -> mv_row_min ) && ( this_row_offset < x -> mv_row_max ) ) { check_here = ( neighbors [ j ] . row ) * in_what_stride + neighbors [ j ] . col + best_address ; <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> if ( thissad < bestsad ) { this_mv . as_mv . row = this_row_offset ; this_mv . as_mv . col = this_col_offset ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , error_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_site = j ; } } } } } if ( best_site == - 1 ) break ; else { ref_mv -> as_mv . row += neighbors [ best_site ] . row ; ref_mv -> as_mv . col += neighbors [ best_site ] . col ; best_address += ( neighbors [ best_site ] . row ) * in_what_stride + neighbors [ best_site ] . col ; } } this_mv . as_mv . row = ref_mv -> as_mv . row * 8 ; this_mv . as_mv . col = ref_mv -> as_mv . col * 8 ; return fn_ptr -> vf ( what , what_stride , best_address , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }
","<S2SV_ModStart> best_address , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; <S2SV_StartBug> msg . msg_name = ( struct sockaddr * ) & address ; <S2SV_EndBug> <S2SV_StartBug> msg . msg_namelen = sizeof ( address ) ; <S2SV_EndBug> if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> . msg_name = addr ? <S2SV_ModStart> ) & address : NULL <S2SV_ModStart> . msg_namelen = 0 <S2SV_ModEnd> ; if (
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-125,"CWE-125 opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32 * * ) opj_malloc ( p_image -> numcomps * sizeof ( OPJ_UINT32 * ) ) ; if ( ! l_tmp_ptr ) { opj_free ( l_tmp_data ) ; return 00 ; } l_pi = opj_pi_create ( p_image , p_cp , p_tile_no ) ; if ( ! l_pi ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; return 00 ; } l_encoding_value_ptr = l_tmp_data ; for ( compno = 0 ; compno < p_image -> numcomps ; ++ compno ) { l_tmp_ptr [ compno ] = l_encoding_value_ptr ; l_encoding_value_ptr += l_data_stride ; } opj_get_all_encoding_parameters ( p_image , p_cp , p_tile_no , & l_tx0 , & l_tx1 , & l_ty0 , & l_ty1 , & l_dx_min , & l_dy_min , & l_max_prec , & l_max_res , l_tmp_ptr ) ; l_step_p = 1 ; l_step_c = l_max_prec * l_step_p ; l_step_r = p_image -> numcomps * l_step_c ; l_step_l = l_max_res * l_step_r ; l_current_pi = l_pi ; l_current_pi -> include = 00 ; if ( l_step_l <= ( SIZE_MAX / ( l_tcp -> numlayers + 1U ) ) ) { <S2SV_StartBug> l_current_pi -> include = ( OPJ_INT16 * ) opj_calloc ( ( l_tcp -> numlayers + 1 ) * l_step_l , sizeof ( OPJ_INT16 ) ) ; <S2SV_EndBug> } if ( ! l_current_pi -> include ) { opj_free ( l_tmp_data ) ; opj_free ( l_tmp_ptr ) ; opj_pi_destroy ( l_pi , l_bound ) ; return 00 ; } l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } ++ l_current_pi ; for ( pino = 1 ; pino < l_bound ; ++ pino ) { l_current_comp = l_current_pi -> comps ; l_img_comp = p_image -> comps ; l_tccp = l_tcp -> tccps ; l_current_pi -> tx0 = l_tx0 ; l_current_pi -> ty0 = l_ty0 ; l_current_pi -> tx1 = l_tx1 ; l_current_pi -> ty1 = l_ty1 ; l_current_pi -> step_p = l_step_p ; l_current_pi -> step_c = l_step_c ; l_current_pi -> step_r = l_step_r ; l_current_pi -> step_l = l_step_l ; for ( compno = 0 ; compno < l_current_pi -> numcomps ; ++ compno ) { opj_pi_resolution_t * l_res = l_current_comp -> resolutions ; l_encoding_value_ptr = l_tmp_ptr [ compno ] ; l_current_comp -> dx = l_img_comp -> dx ; l_current_comp -> dy = l_img_comp -> dy ; for ( resno = 0 ; resno < l_current_comp -> numresolutions ; resno ++ ) { l_res -> pdx = * ( l_encoding_value_ptr ++ ) ; l_res -> pdy = * ( l_encoding_value_ptr ++ ) ; l_res -> pw = * ( l_encoding_value_ptr ++ ) ; l_res -> ph = * ( l_encoding_value_ptr ++ ) ; ++ l_res ; } ++ l_current_comp ; ++ l_img_comp ; ++ l_tccp ; } l_current_pi -> include = ( l_current_pi - 1 ) -> include ; ++ l_current_pi ; } opj_free ( l_tmp_data ) ; l_tmp_data = 00 ; opj_free ( l_tmp_ptr ) ; l_tmp_ptr = 00 ; if ( l_tcp -> POC ) { opj_pi_update_decode_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } else { opj_pi_update_decode_not_poc ( l_pi , l_tcp , l_max_prec , l_max_res ) ; } return l_pi ; }
","<S2SV_ModStart> opj_calloc ( ( size_t ) ( <S2SV_ModStart> -> numlayers + 1U <S2SV_ModEnd> ) * l_step_l
",uclouvain@openjpeg/ef01f18dfc6780b776d0674ed3e7415c6ef54d24,CVE-2016-7163,https://github.com/uclouvain/openjpeg/commit/ef01f18dfc6780b776d0674ed3e7415c6ef54d24,2016-09-21T14:25Z
CWE-310,"CWE-310 static void read_conf ( FILE * conffile ) { char * buffer , * line , * val ; buffer = loadfile ( conffile ) ; for ( line = strtok ( buffer , ""\\r\\n"" ) ; line ; line = strtok ( NULL , ""\\r\\n"" ) ) { if ( ! strncmp ( line , ""export<S2SV_blank>"" , 7 ) ) continue ; val = strchr ( line , '=' ) ; if ( ! val ) { printf ( ""invalid<S2SV_blank>configuration<S2SV_blank>line\\n"" ) ; break ; } * val ++ = '\\0' ; if ( ! strcmp ( line , ""JSON_INDENT"" ) ) conf . indent = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_COMPACT"" ) ) conf . compact = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_ENSURE_ASCII"" ) ) conf . ensure_ascii = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_PRESERVE_ORDER"" ) ) conf . preserve_order = atoi ( val ) ; if ( ! strcmp ( line , ""JSON_SORT_KEYS"" ) ) conf . sort_keys = atoi ( val ) ; if ( ! strcmp ( line , ""STRIP"" ) ) conf . strip = atoi ( val ) ; <S2SV_StartBug> } <S2SV_EndBug> free ( buffer ) ; }
","<S2SV_ModStart> val ) ; if ( ! strcmp ( line , ""HASHSEED"" ) ) { conf . have_hashseed = 1 ; conf . hashseed = atoi ( val ) ; } else { conf . have_hashseed = 0 ; }
",akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z
CWE-125,"CWE-125 static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; <S2SV_StartBug> while ( readw ( chip -> DSPQ + JQS_wTail ) != readw ( chip -> DSPQ + JQS_wHead ) ) { <S2SV_EndBug> u16 wTmp ; snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * readw ( chip -> DSPQ + JQS_wHead ) ) ) ; <S2SV_StartBug> wTmp = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) <S2SV_EndBug> writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; <S2SV_StartBug> } <S2SV_EndBug> inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }
","<S2SV_ModStart> + DSPQ_DATA_BUFF ; u16 head , tail , size ; head <S2SV_ModEnd> = readw ( <S2SV_ModStart> + JQS_wHead ) ; tail = readw ( chip -> DSPQ + JQS_wTail ) ; size = <S2SV_ModEnd> readw ( chip <S2SV_ModStart> + JQS_wSize ) ; if ( head > size || tail > size ) goto out ; while ( head != tail ) { snd_msnd_eval_dsp_msg ( chip , readw ( pwDSPQData + 2 * head ) ) ; if ( ++ head > size ) head = 0 ; writew ( head <S2SV_ModEnd> , chip -> <S2SV_ModStart> ) ; } out :
",torvalds@linux/20e2b791796bd68816fa115f12be5320de2b8021,CVE-2017-9985,https://github.com/torvalds/linux/commit/20e2b791796bd68816fa115f12be5320de2b8021,2017-06-28T06:29Z
CWE-20,"CWE-20 static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { <S2SV_StartBug> idata -> status = IMAP_FATAL ; <S2SV_EndBug> return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS\\n"" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>number\\n"" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( ""MESSAGES"" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp ( ""RECENT"" , s , 6 ) == 0 ) status -> recent = count ; else if ( mutt_str_strncmp ( ""UIDNEXT"" , s , 7 ) == 0 ) status -> uidnext = count ; else if ( mutt_str_strncmp ( ""UIDVALIDITY"" , s , 11 ) == 0 ) status -> uidvalidity = count ; else if ( mutt_str_strncmp ( ""UNSEEN"" , s , 6 ) == 0 ) status -> unseen = count ; s = value ; if ( * s && * s != ')' ) s = imap_next_word ( s ) ; } mutt_debug ( 3 , ""%s<S2SV_blank>(UIDVALIDITY:<S2SV_blank>%u,<S2SV_blank>UIDNEXT:<S2SV_blank>%u)<S2SV_blank>%d<S2SV_blank>messages,<S2SV_blank>%d<S2SV_blank>recent,<S2SV_blank>%d<S2SV_blank>unseen\\n"" , status -> name , status -> uidvalidity , status -> uidnext , status -> messages , status -> recent , status -> unseen ) ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_STATUS ) { memcpy ( idata -> cmddata , status , sizeof ( struct ImapStatus ) ) ; return ; } mutt_debug ( 3 , ""Running<S2SV_blank>default<S2SV_blank>STATUS<S2SV_blank>handler\\n"" ) ; for ( inc = Incoming ; inc ; inc = inc -> next ) { if ( inc -> magic != MUTT_IMAP ) continue ; if ( imap_parse_path ( inc -> path , & mx ) < 0 ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>mailbox<S2SV_blank>%s,<S2SV_blank>skipping\\n"" , inc -> path ) ; continue ; } if ( imap_account_match ( & idata -> conn -> account , & mx . account ) ) { if ( mx . mbox ) { value = mutt_str_strdup ( mx . mbox ) ; imap_fix_path ( idata , mx . mbox , value , mutt_str_strlen ( value ) + 1 ) ; FREE ( & mx . mbox ) ; } else value = mutt_str_strdup ( ""INBOX"" ) ; if ( value && ( imap_mxcmp ( mailbox , value ) == 0 ) ) { mutt_debug ( 3 , ""Found<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>buffy<S2SV_blank>list<S2SV_blank>(OV:<S2SV_blank>%u<S2SV_blank>ON:<S2SV_blank>%u<S2SV_blank>U:<S2SV_blank>%d)\\n"" , mailbox , olduv , oldun , status -> unseen ) ; if ( MailCheckRecent ) { if ( olduv && olduv == status -> uidvalidity ) { if ( oldun < status -> uidnext ) new = ( status -> unseen > 0 ) ; } else if ( ! olduv && ! oldun ) { new = ( status -> recent > 0 ) ; } else new = ( status -> unseen > 0 ) ; } else new = ( status -> unseen > 0 ) ; # ifdef USE_SIDEBAR if ( ( inc -> new != new ) || ( inc -> msg_count != status -> messages ) || ( inc -> msg_unread != status -> unseen ) ) { mutt_menu_set_current_redraw ( REDRAW_SIDEBAR ) ; } # endif inc -> new = new ; if ( new_msg_count ) inc -> msg_count = status -> messages ; inc -> msg_unread = status -> unseen ; if ( inc -> new ) { status -> uidnext = oldun ; } FREE ( & value ) ; return ; } FREE ( & value ) ; } FREE ( & mx . mbox ) ; } }
","<S2SV_ModStart> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""Error<S2SV_blank>parsing<S2SV_blank>STATUS<S2SV_blank>mailbox\\n"" )
",neomutt@neomutt/3c49c44be9b459d9c616bcaef6eb5d51298c1741,CVE-2018-14351,https://github.com/neomutt/neomutt/commit/3c49c44be9b459d9c616bcaef6eb5d51298c1741,2018-07-17T17:29Z
CWE-119,"CWE-119 int main ( int argc , char * * argv ) { u8 * byteStrmStart ; u8 * byteStrm ; u32 strmLen ; u32 picSize ; H264SwDecInst decInst ; H264SwDecRet ret ; H264SwDecInput decInput ; H264SwDecOutput decOutput ; H264SwDecPicture decPicture ; H264SwDecInfo decInfo ; u32 picNumber ; FILE * finput ; FILE * foutput ; if ( argc < 2 ) { printf ( ""Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n"" , argv [ 0 ] ) ; return - 1 ; } foutput = fopen ( ""out.yuv"" , ""wb"" ) ; if ( foutput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } finput = fopen ( argv [ argc - 1 ] , ""rb"" ) ; if ( finput == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n"" ) ; return - 1 ; } fseek ( finput , 0L , SEEK_END ) ; strmLen = ( u32 ) ftell ( finput ) ; rewind ( finput ) ; <S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> if ( byteStrm == NULL ) { printf ( ""UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n"" ) ; return - 1 ; } fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; fclose ( finput ) ; ret = H264SwDecInit ( & decInst , 0 ) ; if ( ret != H264SWDEC_OK ) { printf ( ""DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n"" ) ; return - 1 ; } decInput . pStream = byteStrmStart ; decInput . dataLen = strmLen ; decInput . intraConcealmentMethod = 0 ; picNumber = 0 ; do { ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; switch ( ret ) { case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : ret = H264SwDecGetInfo ( decInst , & decInfo ) ; if ( ret != H264SWDEC_OK ) return - 1 ; picSize = decInfo . picWidth * decInfo . picHeight ; picSize = ( 3 * picSize ) / 2 ; printf ( ""Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n"" , decInfo . picWidth , decInfo . picHeight ) ; decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; break ; case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : case H264SWDEC_PIC_RDY : decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } break ; case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : printf ( ""EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n"" ) ; goto end ; default : printf ( ""UNRECOVERABLE<S2SV_blank>ERROR\\n"" ) ; return - 1 ; } } while ( decInput . dataLen > 0 ) ; end : while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( ""PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n"" , picNumber , decPicture . isIdrPicture ? ""IDR"" : ""NON-IDR"" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } H264SwDecRelease ( decInst ) ; fclose ( foutput ) ; free ( byteStrmStart ) ; return 0 ; }
","<S2SV_ModStart> ( u8 ) , <S2SV_ModEnd> strmLen ) ;
",frameworks@av/2b6f22dc64d456471a1dc6df09d515771d1427c8,CVE-2016-2463,https://android.googlesource.com/platform/frameworks/av/+/2b6f22dc64d456471a1dc6df09d515771d1427c8,2016-06-13T01:59Z
CWE-399,"CWE-399 static int sctp_process_param ( struct sctp_association * asoc , union sctp_params param , const union sctp_addr * peer_addr , gfp_t gfp ) { struct net * net = sock_net ( asoc -> base . sk ) ; union sctp_addr addr ; int i ; __u16 sat ; int retval = 1 ; sctp_scope_t scope ; time_t stale ; struct sctp_af * af ; union sctp_addr_param * addr_param ; struct sctp_transport * t ; struct sctp_endpoint * ep = asoc -> ep ; switch ( param . p -> type ) { case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 != asoc -> base . sk -> sk_family ) break ; goto do_addr_param ; case SCTP_PARAM_IPV4_ADDRESS : if ( ipv6_only_sock ( asoc -> base . sk ) ) break ; do_addr_param : af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; af -> from_addr_param ( & addr , param . addr , htons ( asoc -> peer . port ) , 0 ) ; scope = sctp_scope ( peer_addr ) ; if ( sctp_in_scope ( net , & addr , scope ) ) if ( ! sctp_assoc_add_peer ( asoc , & addr , gfp , SCTP_UNCONFIRMED ) ) return 0 ; break ; case SCTP_PARAM_COOKIE_PRESERVATIVE : if ( ! net -> sctp . cookie_preserve_enable ) break ; stale = ntohl ( param . life -> lifespan_increment ) ; asoc -> cookie_life = ktime_add_ms ( asoc -> cookie_life , stale ) ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : pr_debug ( ""%s:<S2SV_blank>unimplemented<S2SV_blank>SCTP_HOST_NAME_ADDRESS\\n"" , __func__ ) ; break ; case SCTP_PARAM_SUPPORTED_ADDRESS_TYPES : asoc -> peer . ipv4_address = 0 ; asoc -> peer . ipv6_address = 0 ; if ( peer_addr -> sa . sa_family == AF_INET6 ) asoc -> peer . ipv6_address = 1 ; else if ( peer_addr -> sa . sa_family == AF_INET ) asoc -> peer . ipv4_address = 1 ; sat = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; if ( sat ) sat /= sizeof ( __u16 ) ; for ( i = 0 ; i < sat ; ++ i ) { switch ( param . sat -> types [ i ] ) { case SCTP_PARAM_IPV4_ADDRESS : asoc -> peer . ipv4_address = 1 ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( PF_INET6 == asoc -> base . sk -> sk_family ) asoc -> peer . ipv6_address = 1 ; break ; case SCTP_PARAM_HOST_NAME_ADDRESS : asoc -> peer . hostname_address = 1 ; break ; default : break ; } } break ; case SCTP_PARAM_STATE_COOKIE : asoc -> peer . cookie_len = ntohs ( param . p -> length ) - sizeof ( sctp_paramhdr_t ) ; asoc -> peer . cookie = param . cookie -> body ; break ; case SCTP_PARAM_HEARTBEAT_INFO : break ; case SCTP_PARAM_UNRECOGNIZED_PARAMETERS : break ; case SCTP_PARAM_ECN_CAPABLE : asoc -> peer . ecn_capable = 1 ; break ; case SCTP_PARAM_ADAPTATION_LAYER_IND : asoc -> peer . adaptation_ind = ntohl ( param . aind -> adaptation_ind ) ; break ; case SCTP_PARAM_SET_PRIMARY : if ( ! net -> sctp . addip_enable ) goto fall_through ; addr_param = param . v + sizeof ( sctp_addip_param_t ) ; af = sctp_get_af_specific ( param_type2af ( param . p -> type ) ) ; <S2SV_StartBug> af -> from_addr_param ( & addr , addr_param , <S2SV_EndBug> htons ( asoc -> peer . port ) , 0 ) ; if ( ! af -> addr_valid ( & addr , NULL , NULL ) ) break ; t = sctp_assoc_lookup_paddr ( asoc , & addr ) ; if ( ! t ) break ; sctp_assoc_set_primary ( asoc , t ) ; break ; case SCTP_PARAM_SUPPORTED_EXT : sctp_process_ext_param ( asoc , param ) ; break ; case SCTP_PARAM_FWD_TSN_SUPPORT : if ( net -> sctp . prsctp_enable ) { asoc -> peer . prsctp_capable = 1 ; break ; } goto fall_through ; case SCTP_PARAM_RANDOM : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_random = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_random ) { retval = 0 ; break ; } break ; case SCTP_PARAM_HMAC_ALGO : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_hmacs = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_hmacs ) { retval = 0 ; break ; } sctp_auth_asoc_set_default_hmac ( asoc , param . hmac_algo ) ; break ; case SCTP_PARAM_CHUNKS : if ( ! ep -> auth_enable ) goto fall_through ; asoc -> peer . peer_chunks = kmemdup ( param . p , ntohs ( param . p -> length ) , gfp ) ; if ( ! asoc -> peer . peer_chunks ) retval = 0 ; break ; fall_through : default : pr_debug ( ""%s:<S2SV_blank>ignoring<S2SV_blank>param:%d<S2SV_blank>for<S2SV_blank>association:%p.\\n"" , __func__ , ntohs ( param . p -> type ) , asoc ) ; break ; } return retval ; }
","<S2SV_ModStart> ) ) ; if ( af == NULL ) break ;
",torvalds@linux/e40607cbe270a9e8360907cb1e62ddf0736e4864,CVE-2014-7841,https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864,2014-11-30T01:59Z
CWE-125,"CWE-125 static int print_lcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , lcpconfopts [ opt ] , opt , len ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x"" , opt ) ) ; return 0 ; } if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , lcpconfopts [ opt ] , opt , len ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x"" , opt ) ) ; return len ; } switch ( opt ) { case LCPOPT_VEXT : if ( len < 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( oui_values , ""Unknown"" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ; # if 0 ND_TCHECK ( p [ 5 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>kind:<S2SV_blank>0x%02x"" , p [ 5 ] ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Value:<S2SV_blank>0x"" ) ) ; for ( i = 0 ; i < len - 6 ; i ++ ) { ND_TCHECK ( p [ 6 + i ] ) ; ND_PRINT ( ( ndo , ""%02x"" , p [ 6 + i ] ) ) ; } # endif break ; case LCPOPT_MRU : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_ACCM : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_AP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%s"" , tok2str ( ppptype2str , ""Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)"" , EXTRACT_16BITS ( p + 2 ) ) ) ) ; switch ( EXTRACT_16BITS ( p + 2 ) ) { case PPP_CHAP : ND_TCHECK ( p [ 4 ] ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , tok2str ( authalg_values , ""Unknown<S2SV_blank>Auth<S2SV_blank>Alg<S2SV_blank>%u"" , p [ 4 ] ) ) ) ; break ; case PPP_PAP : case PPP_EAP : case PPP_SPAP : case PPP_SPAP_OLD : break ; default : print_unknown_data ( ndo , p , ""\\n\\t"" , len ) ; } break ; case LCPOPT_QP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , "":<S2SV_blank>LQR"" ) ) ; else ND_PRINT ( ( ndo , "":<S2SV_blank>unknown"" ) ) ; break ; case LCPOPT_MN : if ( len != 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_PFC : break ; case LCPOPT_ACFC : break ; case LCPOPT_LD : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>0x%04x"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_CBACK : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return 0 ; } ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; ND_TCHECK ( p [ 2 ] ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( ppp_callback_values , ""Unknown"" , p [ 2 ] ) , p [ 2 ] ) ) ; break ; case LCPOPT_MLMRRU : if ( len != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)"" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>%u"" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_MLED : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return 0 ; } ND_TCHECK ( p [ 2 ] ) ; switch ( p [ 2 ] ) { case MEDCLASS_NULL : ND_PRINT ( ( ndo , "":<S2SV_blank>Null"" ) ) ; break ; case MEDCLASS_LOCAL : ND_PRINT ( ( ndo , "":<S2SV_blank>Local"" ) ) ; break ; case MEDCLASS_IPV4 : if ( len != 7 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>7)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 4 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>IPv4<S2SV_blank>%s"" , ipaddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MAC : if ( len != 9 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>9)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 6 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>MAC<S2SV_blank>%s"" , etheraddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MNB : ND_PRINT ( ( ndo , "":<S2SV_blank>Magic-Num-Block"" ) ) ; break ; case MEDCLASS_PSNDN : ND_PRINT ( ( ndo , "":<S2SV_blank>PSNDN"" ) ) ; break ; default : ND_PRINT ( ( ndo , "":<S2SV_blank>Unknown<S2SV_blank>class<S2SV_blank>%u"" , p [ 2 ] ) ) ; break ; } break ; # if 0 case LCPOPT_DEP6 : case LCPOPT_FCSALT : case LCPOPT_SDP : case LCPOPT_NUMMODE : case LCPOPT_DEP12 : case LCPOPT_DEP14 : case LCPOPT_DEP15 : case LCPOPT_DEP16 : case LCPOPT_MLSSNHF : case LCPOPT_PROP : case LCPOPT_DCEID : case LCPOPT_MPP : case LCPOPT_LCPAOPT : case LCPOPT_COBS : case LCPOPT_PE : case LCPOPT_MLHF : case LCPOPT_I18N : case LCPOPT_SDLOS : case LCPOPT_PPPMUX : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|lcp]"" ) ) ; return 0 ; }
","<S2SV_ModStart> len ; } ND_TCHECK_24BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> len ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_32BITS ( p + 2 <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ; <S2SV_ModStart> 0 ; } ND_TCHECK_16BITS ( p + <S2SV_ModEnd> 2 ) ;
",the-tcpdump-group@tcpdump/7029d15f148ef24bb7c6668bc640f5470d085e5a,CVE-2017-13029,https://github.com/the-tcpdump-group/tcpdump/commit/7029d15f148ef24bb7c6668bc640f5470d085e5a,2017-09-14T06:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct16x16_add ( input , dest , stride , eob ) ; } else { vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ; } }
","<S2SV_ModStart> tx_type , const tran_low_t <S2SV_ModEnd> * input ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static int PARSER_FLAGS ( PyCompilerFlags * flags ) { int parser_flags = 0 ; if ( ! flags ) return 0 ; if ( flags -> cf_flags & PyCF_DONT_IMPLY_DEDENT ) parser_flags |= PyPARSE_DONT_IMPLY_DEDENT ; if ( flags -> cf_flags & PyCF_IGNORE_COOKIE ) parser_flags |= PyPARSE_IGNORE_COOKIE ; if ( flags -> cf_flags & CO_FUTURE_BARRY_AS_BDFL ) parser_flags |= PyPARSE_BARRY_AS_BDFL ; <S2SV_StartBug> return parser_flags ; <S2SV_EndBug> }
","<S2SV_ModStart> |= PyPARSE_BARRY_AS_BDFL ; if ( flags -> cf_flags & PyCF_TYPE_COMMENTS ) parser_flags |= PyPARSE_TYPE_COMMENTS ;
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-200,"CWE-200 static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; <S2SV_StartBug> strlcpy ( rakcipher . type , ""akcipher"" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_akcipher rakcipher ; strncpy <S2SV_ModEnd> ( rakcipher .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-000,"CWE-000 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
","<S2SV_ModStart> rq ) ; <S2SV_ModEnd> prev -> sched_class
",torvalds@linux/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,CVE-2011-4621,https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64,2012-05-17T11:00Z
CWE-000,"CWE-000 static int _nfs4_do_open_reclaim ( struct nfs_open_context * ctx , struct nfs4_state * state ) { struct nfs_delegation * delegation ; struct nfs4_opendata * opendata ; <S2SV_StartBug> int delegation_type = 0 ; <S2SV_EndBug> int status ; opendata = nfs4_open_recoverdata_alloc ( ctx , state ) ; if ( IS_ERR ( opendata ) ) return PTR_ERR ( opendata ) ; opendata -> o_arg . claim = NFS4_OPEN_CLAIM_PREVIOUS ; opendata -> o_arg . fh = NFS_FH ( state -> inode ) ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) != 0 ) delegation_type = delegation -> type ; rcu_read_unlock ( ) ; opendata -> o_arg . u . delegation_type = delegation_type ; status = nfs4_open_recover ( opendata , state ) ; nfs4_opendata_put ( opendata ) ; return status ; }
","<S2SV_ModStart> * opendata ; fmode_t <S2SV_ModEnd> delegation_type = 0
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-416,"CWE-416 static void test_modules ( ) { assert_true_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }
","<S2SV_ModStart> { assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL )
",VirusTotal@yara/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,CVE-2017-8929,https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,2017-05-14T22:29Z
CWE-119,"CWE-119 char * selaGetCombName ( SELA * sela , l_int32 size , l_int32 direction ) { char * selname ; <S2SV_StartBug> char combname [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 i , nsels , sx , sy , found ; SEL * sel ; PROCNAME ( ""selaGetCombName"" ) ; if ( ! sela ) return ( char * ) ERROR_PTR ( ""sela<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( direction != L_HORIZ && direction != L_VERT ) return ( char * ) ERROR_PTR ( ""invalid<S2SV_blank>direction"" , procName , NULL ) ; if ( direction == L_HORIZ ) <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dh"" , size ) ; <S2SV_EndBug> else <S2SV_StartBug> snprintf ( combname , L_BUF_SIZE , ""sel_comb_%dv"" , size ) ; <S2SV_EndBug> found = FALSE ; nsels = selaGetCount ( sela ) ; for ( i = 0 ; i < nsels ; i ++ ) { sel = selaGetSel ( sela , i ) ; selGetParameters ( sel , & sy , & sx , NULL , NULL ) ; if ( sy != 1 && sx != 1 ) continue ; selname = selGetName ( sel ) ; if ( ! strcmp ( selname , combname ) ) { found = TRUE ; break ; } } if ( found ) return stringNew ( selname ) ; else return ( char * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>found"" , procName , NULL ) ; }
","<S2SV_ModStart> char combname [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , ""sel_comb_%dh"" , <S2SV_ModStart> ( combname , L_BUFSIZE <S2SV_ModEnd> , ""sel_comb_%dv"" ,
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
CWE-362,"CWE-362 <S2SV_StartBug> static int mptctl_do_reset ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_diag_reset __user * urinfo = ( void __user * ) arg ; <S2SV_StartBug> struct mpt_ioctl_diag_reset krinfo ; <S2SV_EndBug> MPT_ADAPTER * iocp ; if ( copy_from_user ( & krinfo , urinfo , sizeof ( struct mpt_ioctl_diag_reset ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>mpt_ioctl_diag_reset<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , urinfo ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( mpt_verify_adapter ( krinfo . hdr . iocnum , & iocp ) < 0 ) { printk ( KERN_DEBUG MYNAM ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , krinfo . hdr . iocnum ) ; return - ENODEV ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_reset<S2SV_blank>called.\\n"" , iocp -> name ) ) ; if ( mpt_HardResetHandler ( iocp , CAN_SLEEP ) != 0 ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_do_reset<S2SV_blank>-<S2SV_blank>reset<S2SV_blank>failed.\\n"" , iocp -> name , __FILE__ , __LINE__ ) ; return - 1 ; } return 0 ; }
","<S2SV_ModStart> int mptctl_do_reset ( MPT_ADAPTER * iocp , <S2SV_ModStart> struct mpt_ioctl_diag_reset krinfo <S2SV_ModEnd> ; if ( <S2SV_ModStart> return - EFAULT <S2SV_ModEnd> ; } dctlprintk
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-404,"CWE-404 int nfs3svc_decode_readdirplusargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_readdirargs * args ) { int len ; u32 max_blocksize = svc_max_payload ( rqstp ) ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> cookie ) ; args -> verf = p ; p += 2 ; args -> dircount = ntohl ( * p ++ ) ; args -> count = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> count = min ( args -> count , max_blocksize ) ; <S2SV_EndBug> while ( len > 0 ) { struct page * p = * ( rqstp -> rq_next_page ++ ) ; if ( ! args -> buffer ) args -> buffer = page_address ( p ) ; len -= PAGE_SIZE ; } <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ++ ) ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ; } return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-200,"CWE-200 int equalizer_get_parameter ( effect_context_t * context , effect_param_t * p , uint32_t * size ) { equalizer_context_t * eq_ctxt = ( equalizer_context_t * ) context ; int voffset = ( ( p -> psize - 1 ) / sizeof ( int32_t ) + 1 ) * sizeof ( int32_t ) ; int32_t * param_tmp = ( int32_t * ) p -> data ; int32_t param = * param_tmp ++ ; int32_t param2 ; char * name ; void * value = p -> data + voffset ; int i ; ALOGV ( ""%s"" , __func__ ) ; p -> status = 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : case EQ_PARAM_CUR_PRESET : case EQ_PARAM_GET_NUM_OF_PRESETS : case EQ_PARAM_BAND_LEVEL : case EQ_PARAM_GET_BAND : if ( p -> vsize < sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int16_t ) ; break ; case EQ_PARAM_LEVEL_RANGE : if ( p -> vsize < 2 * sizeof ( int16_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int16_t ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : if ( p -> vsize < 2 * sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = 2 * sizeof ( int32_t ) ; break ; case EQ_PARAM_CENTER_FREQ : if ( p -> vsize < sizeof ( int32_t ) ) p -> status = - EINVAL ; p -> vsize = sizeof ( int32_t ) ; break ; case EQ_PARAM_GET_PRESET_NAME : break ; case EQ_PARAM_PROPERTIES : if ( p -> vsize < ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ) p -> status = - EINVAL ; p -> vsize = ( 2 + NUM_EQ_BANDS ) * sizeof ( uint16_t ) ; break ; default : p -> status = - EINVAL ; } * size = sizeof ( effect_param_t ) + voffset + p -> vsize ; if ( p -> status != 0 ) return 0 ; switch ( param ) { case EQ_PARAM_NUM_BANDS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_NUM_BANDS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) NUM_EQ_BANDS ; break ; case EQ_PARAM_LEVEL_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_LEVEL_RANGE"" , __func__ ) ; * ( int16_t * ) value = - 1500 ; * ( ( int16_t * ) value + 1 ) = 1500 ; break ; case EQ_PARAM_BAND_LEVEL : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_LEVEL"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int16_t * ) value = ( int16_t ) equalizer_get_band_level ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CENTER_FREQ : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CENTER_FREQ"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> p -> status = - EINVAL ; <S2SV_StartBug> break ; <S2SV_EndBug> } * ( int32_t * ) value = equalizer_get_center_frequency ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_BAND_FREQ_RANGE : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE"" , __func__ ) ; param2 = * param_tmp ; <S2SV_StartBug> if ( param2 >= NUM_EQ_BANDS ) { <S2SV_EndBug> <S2SV_StartBug> p -> status = - EINVAL ; <S2SV_EndBug> break ; } equalizer_get_band_freq_range ( eq_ctxt , param2 , ( uint32_t * ) value , ( ( uint32_t * ) value + 1 ) ) ; break ; case EQ_PARAM_GET_BAND : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_BAND"" , __func__ ) ; param2 = * param_tmp ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_band ( eq_ctxt , param2 ) ; break ; case EQ_PARAM_CUR_PRESET : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_CUR_PRESET"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_preset ( eq_ctxt ) ; break ; case EQ_PARAM_GET_NUM_OF_PRESETS : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_NUM_OF_PRESETS"" , __func__ ) ; * ( uint16_t * ) value = ( uint16_t ) equalizer_get_num_presets ( eq_ctxt ) ; break ; case EQ_PARAM_GET_PRESET_NAME : ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_GET_PRESET_NAME"" , __func__ ) ; param2 = * param_tmp ; ALOGV ( ""param2:<S2SV_blank>%d"" , param2 ) ; if ( param2 >= equalizer_get_num_presets ( eq_ctxt ) ) { p -> status = - EINVAL ; break ; } name = ( char * ) value ; strlcpy ( name , equalizer_get_preset_name ( eq_ctxt , param2 ) , p -> vsize - 1 ) ; name [ p -> vsize - 1 ] = 0 ; p -> vsize = strlen ( name ) + 1 ; break ; case EQ_PARAM_PROPERTIES : { ALOGV ( ""%s:<S2SV_blank>EQ_PARAM_PROPERTIES"" , __func__ ) ; int16_t * prop = ( int16_t * ) value ; prop [ 0 ] = ( int16_t ) equalizer_get_preset ( eq_ctxt ) ; prop [ 1 ] = ( int16_t ) NUM_EQ_BANDS ; for ( i = 0 ; i < NUM_EQ_BANDS ; i ++ ) { prop [ 2 + i ] = ( int16_t ) equalizer_get_band_level ( eq_ctxt , i ) ; } } break ; default : p -> status = - EINVAL ; break ; } return 0 ; }
","<S2SV_ModStart> if ( param2 < 0 || param2 <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32438598"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_LEVEL<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32436341"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_CENTER_FREQ<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; } <S2SV_ModStart> ; if ( param2 < 0 || <S2SV_ModStart> - EINVAL ; if ( param2 < 0 ) { android_errorWriteLog ( 0x534e4554 , ""32247948"" ) ; ALOGW ( ""\\tERROR<S2SV_blank>EQ_PARAM_BAND_FREQ_RANGE<S2SV_blank>band<S2SV_blank>%d"" , param2 ) ; }
",hardware@qcom@audio/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,CVE-2017-0402,https://android.googlesource.com/platform/hardware/qcom/audio/+/d72ea85c78a1a68bf99fd5804ad9784b4102fe57,2017-01-12T20:59Z
CWE-119,"CWE-119 void vp8_copy_mem8x8_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 8 ; r ++ ) { <S2SV_StartBug> # if ! ( CONFIG_FAST_UNALIGNED ) <S2SV_EndBug> dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; dst [ 3 ] = src [ 3 ] ; dst [ 4 ] = src [ 4 ] ; dst [ 5 ] = src [ 5 ] ; dst [ 6 ] = src [ 6 ] ; dst [ 7 ] = src [ 7 ] ; # else ( ( uint32_t * ) dst ) [ 0 ] = ( ( uint32_t * ) src ) [ 0 ] ; ( ( uint32_t * ) dst ) [ 1 ] = ( ( uint32_t * ) src ) [ 1 ] ; # endif src += src_stride ; dst += dst_stride ; } }
","<S2SV_ModStart> ++ ) { memcpy ( dst , src , 8 ) ; <S2SV_ModEnd> src += src_stride
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; <S2SV_StartBug> SDev = cd -> device ; <S2SV_EndBug> retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , <S2SV_StartBug> ( unsigned char * ) cgc -> sense , & sshdr , <S2SV_EndBug> cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""disc<S2SV_blank>change<S2SV_blank>detected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready<S2SV_blank>yet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROM<S2SV_blank>not<S2SV_blank>ready.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>there<S2SV_blank>"" ""is<S2SV_blank>a<S2SV_blank>disc<S2SV_blank>in<S2SV_blank>the<S2SV_blank>drive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat = err ; return err ; }
","<S2SV_ModStart> = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; <S2SV_ModStart> cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer <S2SV_ModStart> -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( cgc -> sense ) memcpy ( cgc -> sense , sense_buffer , sizeof ( * <S2SV_ModEnd> cgc -> sense <S2SV_ModStart> cgc -> sense ) <S2SV_ModEnd> ) ; if
",torvalds@linux/f7068114d45ec55996b9040e98111afa56e010fe,CVE-2018-11506,https://github.com/torvalds/linux/commit/f7068114d45ec55996b9040e98111afa56e010fe,2018-05-28T04:29Z
CWE-835,"CWE-835 static Image * ReadTXTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char colorspace [ MagickPathExtent ] , text [ MagickPathExtent ] ; Image * image ; long x_offset , y_offset ; PixelInfo pixel ; MagickBooleanType status ; QuantumAny range ; register ssize_t i , x ; register Quantum * q ; ssize_t count , type , y ; unsigned long depth , height , max_value , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( text , 0 , sizeof ( text ) ) ; ( void ) ReadBlobString ( image , text ) ; if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) != 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { width = 0 ; height = 0 ; max_value = 0 ; * colorspace = '\\0' ; count = ( ssize_t ) sscanf ( text + 32 , ""%lu,%lu,%lu,%s"" , & width , & height , & max_value , colorspace ) ; if ( ( count != 4 ) || ( width == 0 ) || ( height == 0 ) || ( max_value == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = width ; image -> rows = height ; for ( depth = 1 ; ( GetQuantumRange ( depth ) + 1 ) < max_value ; depth ++ ) ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; LocaleLower ( colorspace ) ; i = ( ssize_t ) strlen ( colorspace ) - 1 ; image -> alpha_trait = UndefinedPixelTrait ; if ( ( i > 0 ) && ( colorspace [ i ] == 'a' ) ) { colorspace [ i ] = '\\0' ; image -> alpha_trait = BlendPixelTrait ; } type = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , colorspace ) ; if ( type < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , ( ColorspaceType ) type , exception ) ; GetPixelInfo ( image , & pixel ) ; range = GetQuantumRange ( image -> depth ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { double alpha , black , blue , green , red ; red = 0.0 ; green = 0.0 ; blue = 0.0 ; black = 0.0 ; alpha = 0.0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ReadBlobString ( image , text ) == ( char * ) NULL ) break ; switch ( image -> colorspace ) { case GRAYColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & alpha ) ; green = red ; blue = red ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]"" , & x_offset , & y_offset , & red ) ; green = red ; blue = red ; break ; } case CMYKColorspace : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & black ) ; break ; } default : { if ( image -> alpha_trait != UndefinedPixelTrait ) { count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue , & alpha ) ; break ; } count = ( ssize_t ) sscanf ( text , ""%ld,%ld:<S2SV_blank>(%lf%*[%,]%lf%*[%,]%lf%*[%,]"" , & x_offset , & y_offset , & red , & green , & blue ) ; break ; } } if ( strchr ( text , '%' ) != ( char * ) NULL ) { red *= 0.01 * range ; green *= 0.01 * range ; blue *= 0.01 * range ; black *= 0.01 * range ; alpha *= 0.01 * range ; } if ( image -> colorspace == LabColorspace ) { green += ( range + 1 ) / 2.0 ; blue += ( range + 1 ) / 2.0 ; } pixel . red = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( red + 0.5 ) , range ) ; pixel . green = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( green + 0.5 ) , range ) ; pixel . blue = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( blue + 0.5 ) , range ) ; pixel . black = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( black + 0.5 ) , range ) ; pixel . alpha = ( MagickRealType ) ScaleAnyToQuantum ( ( QuantumAny ) ( alpha + 0.5 ) , range ) ; q = GetAuthenticPixels ( image , ( ssize_t ) x_offset , ( ssize_t ) y_offset , 1 , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) continue ; SetPixelViaPixelInfo ( image , & pixel , q ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } } <S2SV_StartBug> ( void ) ReadBlobString ( image , text ) ; <S2SV_EndBug> if ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( LocaleNCompare ( ( char * ) text , MagickID , strlen ( MagickID ) ) == 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; }
",ImageMagick@ImageMagick/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078,CVE-2017-11523,https://github.com/ImageMagick/ImageMagick/commit/83e0f8ffd7eeb7661b0ff83257da23d24ca7f078,2017-07-22T21:29Z
CWE-125,"CWE-125 void decnet_print ( netdissect_options * ndo , register const u_char * ap , register u_int length , register u_int caplen ) { register const union routehdr * rhp ; register int mflags ; int dst , src , hops ; u_int nsplen , pktlen ; const u_char * nspp ; if ( length < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK2 ( * ap , sizeof ( short ) ) ; pktlen = EXTRACT_LE_16BITS ( ap ) ; if ( pktlen < sizeof ( struct shorthdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( pktlen > length ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } length = pktlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ; mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; if ( mflags & RMF_PAD ) { u_int padlen = mflags & RMF_PADMASK ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""[pad:%d]<S2SV_blank>"" , padlen ) ) ; if ( length < padlen + 2 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK2 ( ap [ sizeof ( short ) ] , padlen ) ; ap += padlen ; length -= padlen ; caplen -= padlen ; rhp = ( const union routehdr * ) & ( ap [ sizeof ( short ) ] ) ; <S2SV_StartBug> mflags = EXTRACT_LE_8BITS ( rhp -> rh_short . sh_flags ) ; <S2SV_EndBug> } if ( mflags & RMF_FVER ) { ND_PRINT ( ( ndo , ""future-version-decnet"" ) ) ; ND_DEFAULTPRINT ( ap , min ( length , caplen ) ) ; return ; } if ( mflags & RMF_CTLMSG ) { if ( ! print_decnet_ctlmsg ( ndo , rhp , length , caplen ) ) goto trunc ; return ; } switch ( mflags & RMF_MASK ) { case RMF_LONG : if ( length < sizeof ( struct longhdr ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } ND_TCHECK ( rhp -> rh_long ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_dst . dne_remote . dne_nodeaddr ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_long . lg_src . dne_remote . dne_nodeaddr ) ; hops = EXTRACT_LE_8BITS ( rhp -> rh_long . lg_visits ) ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct longhdr ) ] ) ; nsplen = length - sizeof ( struct longhdr ) ; break ; case RMF_SHORT : ND_TCHECK ( rhp -> rh_short ) ; dst = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_dst ) ; src = EXTRACT_LE_16BITS ( rhp -> rh_short . sh_src ) ; hops = ( EXTRACT_LE_8BITS ( rhp -> rh_short . sh_visits ) & VIS_MASK ) + 1 ; nspp = & ( ap [ sizeof ( short ) + sizeof ( struct shorthdr ) ] ) ; nsplen = length - sizeof ( struct shorthdr ) ; break ; default : ND_PRINT ( ( ndo , ""unknown<S2SV_blank>message<S2SV_blank>flags<S2SV_blank>under<S2SV_blank>mask"" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) ap , min ( length , caplen ) ) ; return ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>"" , dnaddr_string ( ndo , src ) , dnaddr_string ( ndo , dst ) , pktlen ) ) ; if ( ndo -> ndo_vflag ) { if ( mflags & RMF_RQR ) ND_PRINT ( ( ndo , ""RQR<S2SV_blank>"" ) ) ; if ( mflags & RMF_RTS ) ND_PRINT ( ( ndo , ""RTS<S2SV_blank>"" ) ) ; if ( mflags & RMF_IE ) ND_PRINT ( ( ndo , ""IE<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""%d<S2SV_blank>hops<S2SV_blank>"" , hops ) ) ; } if ( ! print_nsp ( ndo , nspp , nsplen ) ) goto trunc ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; }
","<S2SV_ModStart> ] ) ; ND_TCHECK ( rhp -> rh_short . sh_flags ) ;
",the-tcpdump-group@tcpdump/c6e0531b5def26ecf912e8de6ade86cbdaed3751,CVE-2017-12899,https://github.com/the-tcpdump-group/tcpdump/commit/c6e0531b5def26ecf912e8de6ade86cbdaed3751,2017-09-14T06:29Z
CWE-20,"CWE-20 void rawSocketProcessEthPacket ( NetInterface * interface , EthHeader * header , const uint8_t * data , size_t length , NetRxAncillary * ancillary ) { uint_t i ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_RAW_ETH ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> protocol == SOCKET_ETH_PROTO_ALL ) { } else if ( socket -> protocol == SOCKET_ETH_PROTO_LLC ) { if ( ntohs ( header -> type ) > ETH_MTU ) continue ; } else { if ( ntohs ( header -> type ) != socket -> protocol ) continue ; } break ; } if ( i >= SOCKET_MAX_COUNT ) return ; if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + sizeof ( EthHeader ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= RAW_SOCKET_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + sizeof ( EthHeader ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> queueItem -> srcIpAddr = IP_ADDR_ANY ; queueItem -> destIpAddr = IP_ADDR_ANY ; queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferWrite ( queueItem -> buffer , queueItem -> offset , header , sizeof ( EthHeader ) ) ; netBufferWrite ( queueItem -> buffer , queueItem -> offset + sizeof ( EthHeader ) , data , length ) ; queueItem -> ancillary = * ancillary ; rawSocketUpdateEvents ( socket ) ; }
","<S2SV_ModStart> ; queueItem -> interface = interface ; queueItem ->
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-125,"CWE-125 void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; <S2SV_StartBug> register u_int amt ; <S2SV_EndBug> register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> if ( j == 1 <S2SV_StartBug> && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 <S2SV_EndBug> && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>dump"" ) ) ; break ; } <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d[%u]:"" , j , length ) ) ; else <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%d:"" , j ) ) ; <S2SV_EndBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> case RIP6_RESPONSE : <S2SV_StartBug> j = length / sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> if ( j * sizeof ( * ni ) != length - 4 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d:"" , j ) ) ; <S2SV_StartBug> trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ni = rp -> rip6_nets ; i >= sizeof ( * ni ) ; <S2SV_EndBug> <S2SV_StartBug> i -= sizeof ( * ni ) , ++ ni ) { <S2SV_EndBug> if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; rip6_entry_print ( ndo , ni , ni -> rip6_metric ) ; } <S2SV_StartBug> if ( trunc ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-%d<S2SV_blank>??<S2SV_blank>%u"" , rp -> rip6_cmd , length ) ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> if ( rp -> rip6_vers != RIP6_VERSION ) ND_PRINT ( ( ndo , ""<S2SV_blank>[vers<S2SV_blank>%d]"" , rp -> rip6_vers ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * ni ; unsigned int length_left ; u_int j ; ND_TCHECK ( rp -> rip6_cmd <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case RIP6_REQUEST : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> j == 1 ) { ND_TCHECK ( rp -> rip6_nets ) ; if ( <S2SV_ModEnd> rp -> rip6_nets <S2SV_ModStart> break ; } } <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( ndo , ""<S2SV_blank>ripng-req<S2SV_blank>%u:"" , j ) <S2SV_ModEnd> ) ; for <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> ) ; } if ( length_left != 0 ) goto trunc ; <S2SV_ModStart> case RIP6_RESPONSE : length_left = length ; if ( length_left < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) goto trunc ; length_left -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; j = length_left <S2SV_ModEnd> / sizeof ( <S2SV_ModStart> ni ) != length_left ) ND_PRINT ( ( ndo , ""<S2SV_blank>ripng-resp<S2SV_blank>%d[%u]:"" , j , length <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> for ( ni <S2SV_ModStart> -> rip6_nets ; length_left <S2SV_ModEnd> >= sizeof ( <S2SV_ModStart> ni ) ; length_left <S2SV_ModEnd> -= sizeof ( <S2SV_ModStart> ni ) { ND_TCHECK ( * ni ) ; <S2SV_ModStart> } if ( length_left != 0 ) goto trunc <S2SV_ModEnd> ; break ; <S2SV_ModStart> break ; } ND_TCHECK ( rp -> rip6_vers ) ; <S2SV_ModStart> ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""[|ripng]"" ) ) ; return ;
",the-tcpdump-group@tcpdump/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,CVE-2017-12992,https://github.com/the-tcpdump-group/tcpdump/commit/e942fb84fbe3a73a98a00d2a279425872b5fb9d2,2017-09-14T06:29Z
CWE-000,"CWE-000 IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_output_flag_present_flag = value ; BITS_PARSE ( ""num_extra_slice_header_bits"" , value , ps_bitstrm , 3 ) ; ps_pps -> i1_num_extra_slice_header_bits = value ; BITS_PARSE ( ""sign_data_hiding_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_sign_data_hiding_flag = value ; BITS_PARSE ( ""cabac_init_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cabac_init_present_flag = value ; UEV_PARSE ( ""num_ref_idx_l0_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l0_default_active = value + 1 ; UEV_PARSE ( ""num_ref_idx_l1_default_active_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_ref_idx_l1_default_active = value + 1 ; SEV_PARSE ( ""pic_init_qp_minus26"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_init_qp = value + 26 ; BITS_PARSE ( ""constrained_intra_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_constrained_intra_pred_flag = value ; BITS_PARSE ( ""transform_skip_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transform_skip_enabled_flag = value ; BITS_PARSE ( ""cu_qp_delta_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_cu_qp_delta_enabled_flag = value ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag ) { UEV_PARSE ( ""diff_cu_qp_delta_depth"" , value , ps_bitstrm ) ; ps_pps -> i1_diff_cu_qp_delta_depth = value ; } else { ps_pps -> i1_diff_cu_qp_delta_depth = 0 ; } ps_pps -> i1_log2_min_cu_qp_delta_size = ps_sps -> i1_log2_ctb_size - ps_pps -> i1_diff_cu_qp_delta_depth ; SEV_PARSE ( ""cb_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cb_qp_offset = value ; SEV_PARSE ( ""cr_qp_offset"" , value , ps_bitstrm ) ; ps_pps -> i1_pic_cr_qp_offset = value ; BITS_PARSE ( ""slicelevel_chroma_qp_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_slice_level_chroma_qp_offsets_present_flag = value ; BITS_PARSE ( ""weighted_pred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_pred_flag = value ; BITS_PARSE ( ""weighted_bipred_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_weighted_bipred_flag = value ; BITS_PARSE ( ""transquant_bypass_enable_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_transquant_bypass_enable_flag = value ; BITS_PARSE ( ""tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_tiles_enabled_flag = value ; <S2SV_StartBug> BITS_PARSE ( ""entropy_coding_sync_enabled_flag"" , value , ps_bitstrm , 1 ) ; <S2SV_EndBug> ps_pps -> i1_entropy_coding_sync_enabled_flag = value ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = 0 ; if ( ps_pps -> i1_tiles_enabled_flag ) { WORD32 wd = ALIGN64 ( ps_codec -> i4_wd ) ; WORD32 ht = ALIGN64 ( ps_codec -> i4_ht ) ; WORD32 max_tile_cols = ( wd + MIN_TILE_WD - 1 ) / MIN_TILE_WD ; WORD32 max_tile_rows = ( ht + MIN_TILE_HT - 1 ) / MIN_TILE_HT ; UEV_PARSE ( ""num_tile_columns_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_columns = value + 1 ; UEV_PARSE ( ""num_tile_rows_minus1"" , value , ps_bitstrm ) ; ps_pps -> i1_num_tile_rows = value + 1 ; if ( ( ps_pps -> i1_num_tile_columns < 1 ) || ( ps_pps -> i1_num_tile_columns > max_tile_cols ) || ( ps_pps -> i1_num_tile_rows < 1 ) || ( ps_pps -> i1_num_tile_rows > max_tile_rows ) ) return IHEVCD_INVALID_HEADER ; BITS_PARSE ( ""uniform_spacing_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_uniform_spacing_flag = value ; { WORD32 start ; WORD32 i , j ; start = 0 ; for ( i = 0 ; i < ps_pps -> i1_num_tile_columns ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_columns - 1 ) ) { UEV_PARSE ( ""column_width_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_wd_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns - ( i * ps_sps -> i2_pic_wd_in_ctb ) / ps_pps -> i1_num_tile_columns ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_rows ; j ++ ) { ps_tile = ps_pps -> ps_tile + j * ps_pps -> i1_num_tile_columns + i ; ps_tile -> u1_pos_x = start ; ps_tile -> u2_wd = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_wd_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } start = 0 ; for ( i = 0 ; i < ( ps_pps -> i1_num_tile_rows ) ; i ++ ) { tile_t * ps_tile ; if ( ! ps_pps -> i1_uniform_spacing_flag ) { if ( i < ( ps_pps -> i1_num_tile_rows - 1 ) ) { UEV_PARSE ( ""row_height_minus1[<S2SV_blank>i<S2SV_blank>]"" , value , ps_bitstrm ) ; value += 1 ; } else { value = ps_sps -> i2_pic_ht_in_ctb - start ; } } else { value = ( ( i + 1 ) * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows - ( i * ps_sps -> i2_pic_ht_in_ctb ) / ps_pps -> i1_num_tile_rows ; } for ( j = 0 ; j < ps_pps -> i1_num_tile_columns ; j ++ ) { ps_tile = ps_pps -> ps_tile + i * ps_pps -> i1_num_tile_columns + j ; ps_tile -> u1_pos_y = start ; ps_tile -> u2_ht = value ; } start += value ; if ( ( start > ps_sps -> i2_pic_ht_in_ctb ) || ( value <= 0 ) ) return IHEVCD_INVALID_HEADER ; } } BITS_PARSE ( ""loop_filter_across_tiles_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_tiles_enabled_flag = value ; } else { ps_pps -> i1_num_tile_columns = 1 ; ps_pps -> i1_num_tile_rows = 1 ; ps_pps -> i1_uniform_spacing_flag = 1 ; ps_pps -> ps_tile -> u1_pos_x = 0 ; ps_pps -> ps_tile -> u1_pos_y = 0 ; ps_pps -> ps_tile -> u2_wd = ps_sps -> i2_pic_wd_in_ctb ; ps_pps -> ps_tile -> u2_ht = ps_sps -> i2_pic_ht_in_ctb ; } BITS_PARSE ( ""loop_filter_across_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_loop_filter_across_slices_enabled_flag = value ; BITS_PARSE ( ""deblocking_filter_control_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_control_present_flag = value ; ps_pps -> i1_pic_disable_deblocking_filter_flag = 0 ; ps_pps -> i1_deblocking_filter_override_enabled_flag = 0 ; ps_pps -> i1_beta_offset_div2 = 0 ; ps_pps -> i1_tc_offset_div2 = 0 ; if ( ps_pps -> i1_deblocking_filter_control_present_flag ) { BITS_PARSE ( ""deblocking_filter_override_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_deblocking_filter_override_enabled_flag = value ; BITS_PARSE ( ""pic_disable_deblocking_filter_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pic_disable_deblocking_filter_flag = value ; if ( ! ps_pps -> i1_pic_disable_deblocking_filter_flag ) { SEV_PARSE ( ""pps_beta_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_beta_offset_div2 = value ; SEV_PARSE ( ""pps_tc_offset_div2"" , value , ps_bitstrm ) ; ps_pps -> i1_tc_offset_div2 = value ; } } BITS_PARSE ( ""pps_scaling_list_data_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_pps_scaling_list_data_present_flag = value ; if ( ps_pps -> i1_pps_scaling_list_data_present_flag ) { COPY_DEFAULT_SCALING_LIST ( ps_pps -> pi2_scaling_mat ) ; ihevcd_scaling_list_data ( ps_codec , ps_pps -> pi2_scaling_mat ) ; } BITS_PARSE ( ""lists_modification_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_lists_modification_present_flag = value ; UEV_PARSE ( ""log2_parallel_merge_level_minus2"" , value , ps_bitstrm ) ; ps_pps -> i1_log2_parallel_merge_level = value + 2 ; BITS_PARSE ( ""slice_header_extension_present_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_slice_header_extension_present_flag = value ; BITS_PARSE ( ""pps_extension_flag"" , value , ps_bitstrm , 1 ) ; if ( ( UWORD8 * ) ps_bitstrm -> pu4_buf > ps_bitstrm -> pu1_buf_max ) return IHEVCD_INVALID_PARAMETER ; ps_codec -> i4_pps_done = 1 ; return ret ; }
","<S2SV_ModStart> = value ; if ( ( ps_pps -> i1_tiles_enabled_flag ) && ( ps_sps -> i1_log2_ctb_size == 4 ) && ( ( ps_sps -> i2_pic_width_in_luma_samples >= 4096 ) || ( ps_sps -> i2_pic_height_in_luma_samples >= 4096 ) ) ) { return IHEVCD_INVALID_HEADER ; }
",external@libhevc/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,CVE-2017-0811,https://android.googlesource.com/platform/external/libhevc/+/25c0ffbe6a181b4a373c3c9b421ea449d457e6ed,2017-10-04T01:29Z
CWE-119,"CWE-119 int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> if ( pbi -> ready_for_new_data == 1 ) return ret ; <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> return ret ; pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> * time_end_stamp = 0 ; <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> # else <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> return ret ; }
","<S2SV_ModStart> * sd , <S2SV_ModEnd> vp9_ppflags_t * flags <S2SV_ModStart> flags ) { VP9_COMMON * const cm = & pbi -> common ; <S2SV_ModStart> - 1 ; # if ! CONFIG_VP9_POSTPROC ( void ) * flags ; # endif <S2SV_ModStart> return ret ; pbi -> ready_for_new_data = 1 ; if ( ! cm -> show_frame <S2SV_ModEnd> ) return ret <S2SV_ModStart> = 1 ; <S2SV_ModEnd> # if CONFIG_VP9_POSTPROC <S2SV_ModStart> # if CONFIG_VP9_POSTPROC if ( ! cm -> show_existing_frame ) { <S2SV_ModStart> = vp9_post_proc_frame ( cm <S2SV_ModEnd> , sd , <S2SV_ModStart> flags ) ; } else { * sd = * cm -> frame_to_show ; ret = 0 ; } <S2SV_ModStart> sd = * cm -> frame_to_show <S2SV_ModEnd> ; ret = <S2SV_ModStart> ; # endif vpx_clear_system_state <S2SV_ModEnd> ( ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 unsigned int get_random_int ( void ) { <S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> __u32 * hash = get_cpu_var ( get_random_int_hash ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> put_cpu_var ( get_random_int_hash ) ; return ret ; }
","<S2SV_ModStart> void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var (
",torvalds@linux/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,CVE-2011-3188,https://github.com/torvalds/linux/commit/6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,2012-05-24T23:55Z
CWE-862,"CWE-862 static int shm_create ( XShmSegmentInfo * shm , XImage * * ximg_ptr , int w , int h , char * name ) { XImage * xim ; static int reported_flip = 0 ; int db = 0 ; shm -> shmid = - 1 ; shm -> shmaddr = ( char * ) - 1 ; * ximg_ptr = NULL ; if ( nofb ) { return 1 ; } X_LOCK ; if ( ! using_shm || xform24to32 || raw_fb ) { xim = XCreateImage_wr ( dpy , default_visual , depth , ZPixmap , 0 , NULL , w , h , raw_fb ? 32 : BitmapPad ( dpy ) , 0 ) ; X_UNLOCK ; if ( xim == NULL ) { rfbErr ( ""XCreateImage(%s)<S2SV_blank>failed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XCreateImage(%s)<S2SV_blank>failed.\\n"" , name ) ; } return 0 ; } if ( db ) fprintf ( stderr , ""shm_create<S2SV_blank>simple<S2SV_blank>%d<S2SV_blank>%d\\t%p<S2SV_blank>%s\\n"" , w , h , ( void * ) xim , name ) ; xim -> data = ( char * ) malloc ( xim -> bytes_per_line * xim -> height ) ; if ( xim -> data == NULL ) { rfbErr ( ""XCreateImage(%s)<S2SV_blank>data<S2SV_blank>malloc<S2SV_blank>failed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XCreateImage(%s)<S2SV_blank>data<S2SV_blank>malloc"" ""<S2SV_blank>failed.\\n"" , name ) ; } return 0 ; } if ( flip_byte_order ) { char * order = flip_ximage_byte_order ( xim ) ; if ( ! reported_flip && ! quiet ) { rfbLog ( ""Changing<S2SV_blank>XImage<S2SV_blank>byte<S2SV_blank>order"" ""<S2SV_blank>to<S2SV_blank>%s\\n"" , order ) ; reported_flip = 1 ; } } * ximg_ptr = xim ; return 1 ; } if ( ! dpy ) { X_UNLOCK ; return 0 ; } xim = XShmCreateImage_wr ( dpy , default_visual , depth , ZPixmap , NULL , shm , w , h ) ; if ( xim == NULL ) { rfbErr ( ""XShmCreateImage(%s)<S2SV_blank>failed.\\n"" , name ) ; if ( quiet ) { fprintf ( stderr , ""XShmCreateImage(%s)<S2SV_blank>failed.\\n"" , name ) ; } X_UNLOCK ; return 0 ; } * ximg_ptr = xim ; # if HAVE_XSHM shm -> shmid = shmget ( IPC_PRIVATE , <S2SV_StartBug> xim -> bytes_per_line * xim -> height , IPC_CREAT | 0777 ) ; <S2SV_EndBug> if ( shm -> shmid == - 1 ) { rfbErr ( ""shmget(%s)<S2SV_blank>failed.\\n"" , name ) ; rfbLogPerror ( ""shmget"" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; X_UNLOCK ; return 0 ; } shm -> shmaddr = xim -> data = ( char * ) shmat ( shm -> shmid , 0 , 0 ) ; if ( shm -> shmaddr == ( char * ) - 1 ) { rfbErr ( ""shmat(%s)<S2SV_blank>failed.\\n"" , name ) ; rfbLogPerror ( ""shmat"" ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } shm -> readOnly = False ; if ( ! XShmAttach_wr ( dpy , shm ) ) { rfbErr ( ""XShmAttach(%s)<S2SV_blank>failed.\\n"" , name ) ; XDestroyImage ( xim ) ; * ximg_ptr = NULL ; shmdt ( shm -> shmaddr ) ; shm -> shmaddr = ( char * ) - 1 ; shmctl ( shm -> shmid , IPC_RMID , 0 ) ; shm -> shmid = - 1 ; X_UNLOCK ; return 0 ; } # endif X_UNLOCK ; return 1 ; }
","<S2SV_ModStart> , IPC_CREAT | 0600 <S2SV_ModEnd> ) ; if
",LibVNC@x11vnc/69eeb9f7baa14ca03b16c9de821f9876def7a36a,CVE-2020-29074,https://github.com/LibVNC/x11vnc/commit/69eeb9f7baa14ca03b16c9de821f9876def7a36a,2020-11-25T23:15Z
CWE-200,"CWE-200 int sbusfb_ioctl_helper ( unsigned long cmd , unsigned long arg , struct fb_info * info , int type , int fb_depth , unsigned long fb_size ) { switch ( cmd ) { case FBIOGTYPE : { struct fbtype __user * f = ( struct fbtype __user * ) arg ; if ( put_user ( type , & f -> fb_type ) || __put_user ( info -> var . yres , & f -> fb_height ) || __put_user ( info -> var . xres , & f -> fb_width ) || __put_user ( fb_depth , & f -> fb_depth ) || __put_user ( 0 , & f -> fb_cmsize ) || __put_user ( fb_size , & f -> fb_cmsize ) ) return - EFAULT ; return 0 ; } case FBIOPUTCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; struct fb_cmap cmap ; u16 red , green , blue ; u8 red8 , green8 , blue8 ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; cmap . len = 1 ; cmap . red = & red ; cmap . green = & green ; cmap . blue = & blue ; cmap . transp = NULL ; for ( i = 0 ; i < count ; i ++ ) { int err ; if ( get_user ( red8 , & ured [ i ] ) || get_user ( green8 , & ugreen [ i ] ) || get_user ( blue8 , & ublue [ i ] ) ) return - EFAULT ; red = red8 << 8 ; green = green8 << 8 ; blue = blue8 << 8 ; cmap . start = index + i ; err = fb_set_cmap ( & cmap , info ) ; if ( err ) return err ; } return 0 ; } case FBIOGETCMAP_SPARC : { struct fbcmap __user * c = ( struct fbcmap __user * ) arg ; unsigned char __user * ured ; unsigned char __user * ugreen ; unsigned char __user * ublue ; struct fb_cmap * cmap = & info -> cmap ; <S2SV_StartBug> int index , count , i ; <S2SV_EndBug> u8 red , green , blue ; if ( get_user ( index , & c -> index ) || __get_user ( count , & c -> count ) || __get_user ( ured , & c -> red ) || __get_user ( ugreen , & c -> green ) || __get_user ( ublue , & c -> blue ) ) return - EFAULT ; if ( index + count > cmap -> len ) return - EINVAL ; for ( i = 0 ; i < count ; i ++ ) { red = cmap -> red [ index + i ] >> 8 ; green = cmap -> green [ index + i ] >> 8 ; blue = cmap -> blue [ index + i ] >> 8 ; if ( put_user ( red , & ured [ i ] ) || put_user ( green , & ugreen [ i ] ) || put_user ( blue , & ublue [ i ] ) ) return - EFAULT ; } return 0 ; } default : return - EINVAL ; } }
","<S2SV_ModStart> * ublue ; unsigned <S2SV_ModStart> -> cmap ; unsigned
",torvalds@linux/250c6c49e3b68756b14983c076183568636e2bde,CVE-2018-6412,https://github.com/torvalds/linux/commit/250c6c49e3b68756b14983c076183568636e2bde,2018-01-31T07:29Z
CWE-119,"CWE-119 timestamp PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; # ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; # else double noresult = 0.0 ; # endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }
","<S2SV_ModStart> ( str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ) != 0 <S2SV_ModEnd> ) { errno
",postgres@postgres/4318daecc959886d001a6e79c6ea853e8b1dfb4b,CVE-2014-0063,https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b,2014-03-31T14:58Z
CWE-772,"CWE-772 static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MaxTextExtent ] , id [ MaxTextExtent ] , keyword [ MaxTextExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MaxTextExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MaxTextExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MaxTextExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MaxTextExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MaxTextExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""matte"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""matte-color"" ) == 0 ) { ( void ) QueryColorDatabase ( options , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""opaque"" ) == 0 ) { ssize_t matte ; matte = ParseCommandOption ( MagickBooleanOptions , MagickFalse , options ) ; if ( matte < 0 ) break ; image -> matte = ( MagickBooleanType ) matte ; break ; } if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> x_resolution = geometry_info . rho ; image -> y_resolution = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> y_resolution = image -> x_resolution ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MaxTextExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MaxTextExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MaxTextExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; ( void ) ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { <S2SV_StartBug> if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; p = colormap ; switch ( depth ) { default : ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; <S2SV_EndBug> if ( status == MagickFalse ) <S2SV_StartBug> { <S2SV_EndBug> InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> PseudoClass ) { image -> colormap = ( PixelPacket * ) AcquireQuantumMemory ( <S2SV_ModEnd> image -> colors <S2SV_ModStart> image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelPacket * ) NULL <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ) break ; if ( ( AcquireMagickResource ( WidthResource <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource <S2SV_ModStart> -> rows ) <S2SV_ModEnd> == MagickFalse ) <S2SV_ModStart> == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; <S2SV_ModEnd> status = PersistPixelCache
",ImageMagick@ImageMagick/4493d9ca1124564da17f9b628ef9d0f1a6be9738,CVE-2017-5507,https://github.com/ImageMagick/ImageMagick/commit/4493d9ca1124564da17f9b628ef9d0f1a6be9738,2017-03-24T15:59Z
CWE-264,"CWE-264 SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) <S2SV_StartBug> size = INT_MAX ; <S2SV_EndBug> sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; iov . iov_len = size ; iov . iov_base = ubuf ; iov_iter_init ( & msg . msg_iter , READ , & iov , 1 , size ) ; msg . msg_name = addr ? ( struct sockaddr * ) & address : NULL ; msg . msg_namelen = 0 ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
","<S2SV_ModStart> size = INT_MAX ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT
",torvalds@linux/4de930efc23b92ddf88ce91c405ee645fe6e27ea,CVE-2015-2686,https://github.com/torvalds/linux/commit/4de930efc23b92ddf88ce91c405ee645fe6e27ea,2016-05-02T10:59Z
CWE-000,"CWE-000 int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }
","<S2SV_ModStart> O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
",Yubico@pam-u2f/18b1914e32b74ff52000f10e97067e841e5fff62,CVE-2019-12210,https://github.com/Yubico/pam-u2f/commit/18b1914e32b74ff52000f10e97067e841e5fff62,2019-06-04T21:29Z
CWE-125,"CWE-125 static ssize_t parse8BIM ( Image * ifile , Image * ofile ) { char brkused , quoted , * line , * token , * newstr , * name ; int state , next ; unsigned char dataset ; unsigned int recnum ; int inputlen = MagickPathExtent ; MagickOffsetType savedpos , currentpos ; ssize_t savedolen = 0L , outputlen = 0L ; TokenInfo * token_info ; dataset = 0 ; recnum = 0 ; line = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * line ) ) ; if ( line == ( char * ) NULL ) return ( - 1 ) ; newstr = name = token = ( char * ) NULL ; savedpos = 0 ; token_info = AcquireTokenInfo ( ) ; while ( super_fgets ( & line , & inputlen , ifile ) != NULL ) { state = 0 ; next = 0 ; token = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * token ) ) ; if ( token == ( char * ) NULL ) break ; newstr = ( char * ) AcquireQuantumMemory ( ( size_t ) inputlen , sizeof ( * newstr ) ) ; if ( newstr == ( char * ) NULL ) break ; while ( Tokenizer ( token_info , 0 , token , ( size_t ) inputlen , line , """" , ""="" , ""\\"""" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( state == 0 ) { int state , next ; char brkused , quoted ; state = 0 ; next = 0 ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""#"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { switch ( state ) { case 0 : if ( strcmp ( newstr , ""8BIM"" ) == 0 ) dataset = 255 ; else dataset = ( unsigned char ) StringToLong ( newstr ) ; break ; case 1 : recnum = ( unsigned int ) StringToUnsignedLong ( newstr ) ; break ; case 2 : name = ( char * ) AcquireQuantumMemory ( strlen ( newstr ) + MagickPathExtent , sizeof ( * name ) ) ; if ( name ) ( void ) strcpy ( name , newstr ) ; break ; } state ++ ; } } else if ( state == 1 ) { int next ; ssize_t len ; char brkused , quoted ; next = 0 ; len = ( ssize_t ) strlen ( token ) ; while ( Tokenizer ( token_info , 0 , newstr , ( size_t ) inputlen , token , """" , ""&"" , """" , 0 , & brkused , & next , & quoted ) == 0 ) { if ( brkused && next > 0 ) { char * s = & token [ next - 1 ] ; len -= ( ssize_t ) convertHTMLcodes ( s , ( int ) strlen ( s ) ) ; } } if ( dataset == 255 ) { unsigned char nlen = 0 ; int i ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } ( void ) WriteBlobString ( ofile , ""8BIM"" ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) recnum ) ; outputlen += 6 ; if ( name ) nlen = ( unsigned char ) strlen ( name ) ; ( void ) WriteBlobByte ( ofile , nlen ) ; outputlen ++ ; for ( i = 0 ; i < nlen ; i ++ ) ( void ) WriteBlobByte ( ofile , ( unsigned char ) name [ i ] ) ; outputlen += nlen ; if ( ( nlen & 0x01 ) == 0 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } if ( recnum != IPTC_ID ) { ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) len ) ; outputlen += 4 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; if ( outputlen & 1 ) { ( void ) WriteBlobByte ( ofile , 0x00 ) ; outputlen ++ ; } } else { savedpos = TellBlob ( ofile ) ; if ( savedpos < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , 0xFFFFFFFFU ) ; outputlen += 4 ; savedolen = outputlen ; } } else { if ( len <= 0x7FFF ) { ( void ) WriteBlobByte ( ofile , 0x1c ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) dataset ) ; ( void ) WriteBlobByte ( ofile , ( unsigned char ) ( recnum & 0xff ) ) ; ( void ) WriteBlobMSBShort ( ofile , ( unsigned short ) len ) ; outputlen += 5 ; next = 0 ; outputlen += len ; <S2SV_StartBug> while ( len -- ) <S2SV_EndBug> ( void ) WriteBlobByte ( ofile , ( unsigned char ) token [ next ++ ] ) ; } } } state ++ ; } if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; } token_info = DestroyTokenInfo ( token_info ) ; if ( token != ( char * ) NULL ) token = DestroyString ( token ) ; if ( newstr != ( char * ) NULL ) newstr = DestroyString ( newstr ) ; if ( name != ( char * ) NULL ) name = DestroyString ( name ) ; line = DestroyString ( line ) ; if ( savedolen > 0 ) { MagickOffsetType offset ; ssize_t diff = outputlen - savedolen ; currentpos = TellBlob ( ofile ) ; if ( currentpos < 0 ) return ( - 1 ) ; offset = SeekBlob ( ofile , savedpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; ( void ) WriteBlobMSBLong ( ofile , ( unsigned int ) diff ) ; offset = SeekBlob ( ofile , currentpos , SEEK_SET ) ; if ( offset < 0 ) return ( - 1 ) ; savedolen = 0L ; } return outputlen ; }
","<S2SV_ModStart> ( len -- > 0 <S2SV_ModStart> ( len -- > 0
",ImageMagick@ImageMagick/f8c318d462270b03e77f082e2a3a32867cacd3c6,CVE-2016-7524,https://github.com/ImageMagick/ImageMagick/commit/f8c318d462270b03e77f082e2a3a32867cacd3c6,2020-02-06T14:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_encode_mv ( VP9_COMP * cpi , vp9_writer * w , <S2SV_EndBug> const MV * mv , const MV * ref , const nmv_context * mvctx , int usehp ) { const MV diff = { mv -> row - ref -> row , mv -> col - ref -> col } ; const MV_JOINT_TYPE j = vp9_get_mv_joint ( & diff ) ; usehp = usehp && vp9_use_mv_hp ( ref ) ; vp9_write_token ( w , vp9_mv_joint_tree , mvctx -> joints , & mv_joint_encodings [ j ] ) ; if ( mv_joint_vertical ( j ) ) encode_mv_component ( w , diff . row , & mvctx -> comps [ 0 ] , usehp ) ; if ( mv_joint_horizontal ( j ) ) encode_mv_component ( w , diff . col , & mvctx -> comps [ 1 ] , usehp ) ; <S2SV_StartBug> if ( ! cpi -> dummy_packing && cpi -> sf . auto_mv_step_size ) { <S2SV_EndBug> unsigned int maxv = MAX ( abs ( mv -> row ) , abs ( mv -> col ) ) >> 3 ; cpi -> max_mv_magnitude = MAX ( maxv , cpi -> max_mv_magnitude ) ; } }
","<S2SV_ModStart> * cpi , vpx_writer <S2SV_ModEnd> * w , <S2SV_ModStart> ; if ( <S2SV_ModEnd> cpi -> sf <S2SV_ModStart> cpi -> sf . mv
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> fill_variance ( a -> sum_square_error + b -> sum_square_error , <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> r ) { assert ( a -> log2_count == b -> log2_count ) ; <S2SV_ModStart> , a -> log2_count + 1 <S2SV_ModEnd> , r )
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 int vp9_prob_diff_update_savings_search ( const unsigned int * ct , <S2SV_StartBug> vp9_prob oldp , vp9_prob * bestp , <S2SV_EndBug> <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> const int old_b = cost_branch256 ( ct , oldp ) ; int bestsavings = 0 ; <S2SV_StartBug> vp9_prob newp , bestnewp = oldp ; <S2SV_EndBug> const int step = * bestp > oldp ? - 1 : 1 ; for ( newp = * bestp ; newp != oldp ; newp += step ) { const int new_b = cost_branch256 ( ct , newp ) ; const int update_b = prob_diff_update_cost ( newp , oldp ) + vp9_cost_upd256 ; const int savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } * bestp = bestnewp ; return bestsavings ; }
","<S2SV_ModStart> * ct , vpx_prob oldp , vpx_prob <S2SV_ModEnd> * bestp , <S2SV_ModStart> * bestp , vpx_prob <S2SV_ModEnd> upd ) { <S2SV_ModStart> = 0 ; vpx_prob <S2SV_ModEnd> newp , bestnewp
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-787,"CWE-787 static int sc_oberthur_read_file ( struct sc_pkcs15_card * p15card , const char * in_path , unsigned char * * out , size_t * out_len , int verify_pin ) { struct sc_context * ctx = p15card -> card -> ctx ; struct sc_card * card = p15card -> card ; struct sc_file * file = NULL ; struct sc_path path ; size_t sz ; int rv ; LOG_FUNC_CALLED ( ctx ) ; if ( ! in_path || ! out || ! out_len ) LOG_TEST_RET ( ctx , SC_ERROR_INVALID_ARGUMENTS , ""Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file"" ) ; sc_log ( ctx , ""read<S2SV_blank>file<S2SV_blank>\'%s\';<S2SV_blank>verify_pin:%i"" , in_path , verify_pin ) ; * out = NULL ; * out_len = 0 ; sc_format_path ( in_path , & path ) ; rv = sc_select_file ( card , & path , & file ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , ""Cannot<S2SV_blank>select<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>to<S2SV_blank>read"" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) sz = file -> size ; else sz = ( file -> record_length + 2 ) * file -> record_count ; * out = calloc ( sz , 1 ) ; if ( * out == NULL ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , SC_ERROR_OUT_OF_MEMORY , ""Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file"" ) ; } if ( file -> ef_structure == SC_FILE_EF_TRANSPARENT ) { rv = sc_read_binary ( card , 0 , * out , sz , 0 ) ; } else { <S2SV_StartBug> int rec ; <S2SV_EndBug> int offs = 0 ; <S2SV_StartBug> int rec_len = file -> record_length ; <S2SV_EndBug> <S2SV_StartBug> for ( rec = 1 ; ; rec ++ ) { <S2SV_EndBug> rv = sc_read_record ( card , rec , * out + offs + 2 , rec_len , SC_RECORD_BY_REC_NR ) ; if ( rv == SC_ERROR_RECORD_NOT_FOUND ) { rv = 0 ; break ; } else if ( rv < 0 ) { break ; } rec_len = rv ; * ( * out + offs ) = 'R' ; * ( * out + offs + 1 ) = rv ; offs += rv + 2 ; } sz = offs ; } sc_log ( ctx , ""read<S2SV_blank>oberthur<S2SV_blank>file<S2SV_blank>result<S2SV_blank>%i"" , rv ) ; if ( verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ) { struct sc_pkcs15_object * objs [ 0x10 ] , * pin_obj = NULL ; const struct sc_acl_entry * acl = sc_file_get_acl_entry ( file , SC_AC_OP_READ ) ; int ii ; rv = sc_pkcs15_get_objects ( p15card , SC_PKCS15_TYPE_AUTH_PIN , objs , 0x10 ) ; if ( rv != SC_SUCCESS ) { sc_file_free ( file ) ; LOG_TEST_RET ( ctx , rv , ""Cannot<S2SV_blank>read<S2SV_blank>oberthur<S2SV_blank>file:<S2SV_blank>get<S2SV_blank>AUTH<S2SV_blank>objects<S2SV_blank>error"" ) ; } for ( ii = 0 ; ii < rv ; ii ++ ) { struct sc_pkcs15_auth_info * auth_info = ( struct sc_pkcs15_auth_info * ) objs [ ii ] -> data ; sc_log ( ctx , ""compare<S2SV_blank>PIN/ACL<S2SV_blank>refs:%i/%i,<S2SV_blank>method:%i/%i"" , auth_info -> attrs . pin . reference , acl -> key_ref , auth_info -> auth_method , acl -> method ) ; if ( auth_info -> attrs . pin . reference == ( int ) acl -> key_ref && auth_info -> auth_method == ( unsigned ) acl -> method ) { pin_obj = objs [ ii ] ; break ; } } if ( ! pin_obj || ! pin_obj -> content . value ) { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED ; } else { rv = sc_pkcs15_verify_pin ( p15card , pin_obj , pin_obj -> content . value , pin_obj -> content . len ) ; if ( ! rv ) rv = sc_oberthur_read_file ( p15card , in_path , out , out_len , 0 ) ; } } ; sc_file_free ( file ) ; if ( rv < 0 ) { free ( * out ) ; * out = NULL ; * out_len = 0 ; } * out_len = sz ; LOG_FUNC_RETURN ( ctx , rv ) ; }
","<S2SV_ModStart> } else { size_t rec ; size_t <S2SV_ModEnd> offs = 0 <S2SV_ModStart> = 0 ; size_t <S2SV_ModEnd> rec_len = file <S2SV_ModStart> ++ ) { if ( rec > file -> record_count ) { rv = 0 ; break ; }
",OpenSC@OpenSC/6903aebfddc466d966c7b865fae34572bf3ed23e,CVE-2020-26570,https://github.com/OpenSC/OpenSC/commit/6903aebfddc466d966c7b865fae34572bf3ed23e,2020-10-06T02:15Z
CWE-119,"CWE-119 private int cdf_file_property_info ( struct magic_set * ms , const cdf_property_info_t * info , <S2SV_StartBug> size_t count , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { size_t i ; cdf_timestamp_t tp ; struct timespec ts ; char buf [ 64 ] ; const char * str = NULL ; const char * s ; int len ; <S2SV_StartBug> if ( ! NOTMIME ( ms ) ) <S2SV_EndBug> <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2mime ) ; <S2SV_EndBug> for ( i = 0 ; i < count ; i ++ ) { cdf_print_property_name ( buf , sizeof ( buf ) , info [ i ] . pi_id ) ; switch ( info [ i ] . pi_type ) { case CDF_NULL : break ; case CDF_SIGNED16 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%hd"" , buf , info [ i ] . pi_s16 ) == - 1 ) return - 1 ; break ; case CDF_SIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%d"" , buf , info [ i ] . pi_s32 ) == - 1 ) return - 1 ; break ; case CDF_UNSIGNED32 : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%u"" , buf , info [ i ] . pi_u32 ) == - 1 ) return - 1 ; break ; case CDF_FLOAT : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_f ) == - 1 ) return - 1 ; break ; case CDF_DOUBLE : if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%g"" , buf , info [ i ] . pi_d ) == - 1 ) return - 1 ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : len = info [ i ] . pi_str . s_len ; if ( len > 1 ) { char vbuf [ 1024 ] ; size_t j , k = 1 ; if ( info [ i ] . pi_type == CDF_LENGTH32_WSTRING ) k ++ ; s = info [ i ] . pi_str . s_buf ; for ( j = 0 ; j < sizeof ( vbuf ) && len -- ; j ++ , s += k ) { if ( * s == '\\0' ) break ; if ( isprint ( ( unsigned char ) * s ) ) vbuf [ j ] = * s ; } if ( j == sizeof ( vbuf ) ) -- j ; vbuf [ j ] = '\\0' ; if ( NOTMIME ( ms ) ) { if ( vbuf [ 0 ] ) { if ( file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , vbuf ) == - 1 ) return - 1 ; } } else if ( str == NULL && info [ i ] . pi_id == CDF_PROPERTY_NAME_OF_APPLICATION ) { str = cdf_app_to_mime ( vbuf , app2mime ) ; } } break ; case CDF_FILETIME : tp = info [ i ] . pi_tp ; if ( tp != 0 ) { char tbuf [ 64 ] ; if ( tp < 1000000000000000LL ) { cdf_print_elapsed_time ( tbuf , sizeof ( tbuf ) , tp ) ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , tbuf ) == - 1 ) return - 1 ; } else { char * c , * ec ; cdf_timestamp_to_timespec ( & ts , tp ) ; c = cdf_ctime ( & ts . tv_sec , tbuf ) ; if ( c != NULL && ( ec = strchr ( c , '\\n' ) ) != NULL ) * ec = '\\0' ; if ( NOTMIME ( ms ) && file_printf ( ms , "",<S2SV_blank>%s:<S2SV_blank>%s"" , buf , c ) == - 1 ) return - 1 ; } } break ; case CDF_CLIPBOARD : break ; default : return - 1 ; } } if ( ! NOTMIME ( ms ) ) { if ( str == NULL ) return 0 ; if ( file_printf ( ms , ""application/%s"" , str ) == - 1 ) return - 1 ; } return 1 ; }
","<S2SV_ModStart> count , const cdf_directory_t * root_storage <S2SV_ModEnd> ) { size_t <S2SV_ModStart> ( ms ) && root_storage <S2SV_ModStart> = cdf_clsid_to_mime ( root_storage -> d_storage_uuid <S2SV_ModEnd> , clsid2mime )
",file@file/6d209c1c489457397a5763bca4b28e43aac90391,CVE-2014-0207,https://github.com/file/file/commit/6d209c1c489457397a5763bca4b28e43aac90391,2014-07-09T11:07Z
CWE-119,"CWE-119 static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; <S2SV_StartBug> s -> chunksize = - 1 ; <S2SV_EndBug> for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , ""header=\'%s\'\\n"" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }
","<S2SV_ModStart> -> chunksize = UINT64_MAX <S2SV_ModEnd> ; for (
",FFmpeg@FFmpeg/2a05c8f813de6f2278827734bf8102291e7484aa,CVE-2016-10190,https://github.com/FFmpeg/FFmpeg/commit/2a05c8f813de6f2278827734bf8102291e7484aa,2017-02-09T15:59Z
CWE-755,"CWE-755 void AcpiNsTerminate ( void ) { ACPI_STATUS Status ; <S2SV_StartBug> ACPI_FUNCTION_TRACE ( NsTerminate ) ; <S2SV_EndBug> # ifdef ACPI_EXEC_APP { ACPI_OPERAND_OBJECT * Prev ; <S2SV_StartBug> ACPI_OPERAND_OBJECT * Next ; <S2SV_EndBug> Next = AcpiGbl_ModuleCodeList ; while ( Next ) { Prev = Next ; Next = Next -> Method . Mutex ; Prev -> Method . Mutex = NULL ; AcpiUtRemoveReference ( Prev ) ; } <S2SV_StartBug> } <S2SV_EndBug> # endif AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode ) ; Status = AcpiUtAcquireMutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( Status ) ) { return_VOID ; } AcpiNsDeleteNode ( AcpiGbl_RootNode ) ; ( void ) AcpiUtReleaseMutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespace<S2SV_blank>freed\\n"" ) ) ; return_VOID ; }
","<S2SV_ModStart> ACPI_STATUS Status ; <S2SV_ModEnd> ACPI_OPERAND_OBJECT * Prev <S2SV_ModStart> ACPI_OPERAND_OBJECT * Next ; ACPI_FUNCTION_TRACE ( NsTerminate ) <S2SV_ModStart> ) ; } <S2SV_ModEnd> AcpiNsDeleteNamespaceSubtree ( AcpiGbl_RootNode
",torvalds@linux/a23325b2e583556eae88ed3f764e457786bf4df6,CVE-2017-11472,https://github.com/torvalds/linux/commit/a23325b2e583556eae88ed3f764e457786bf4df6,2017-07-20T04:29Z
CWE-190,"CWE-190 static int growVTrans ( sqlite3 * db ) { const int ARRAY_INCR = 5 ; if ( ( db -> nVTrans % ARRAY_INCR ) == 0 ) { VTable * * aVTrans ; <S2SV_StartBug> int nBytes = sizeof ( sqlite3_vtab * ) * ( db -> nVTrans + ARRAY_INCR ) ; <S2SV_EndBug> aVTrans = sqlite3DbRealloc ( db , ( void * ) db -> aVTrans , nBytes ) ; if ( ! aVTrans ) { return SQLITE_NOMEM_BKPT ; } memset ( & aVTrans [ db -> nVTrans ] , 0 , sizeof ( sqlite3_vtab * ) * ARRAY_INCR ) ; db -> aVTrans = aVTrans ; } return SQLITE_OK ; }
","<S2SV_ModStart> * aVTrans ; sqlite3_int64 <S2SV_ModEnd> nBytes = sizeof <S2SV_ModStart> ) * ( ( sqlite3_int64 )
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-119,"CWE-119 static int64_t rd_pick_intra_sby_mode ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize , <S2SV_StartBug> int64_t tx_cache [ TX_MODES ] , <S2SV_EndBug> int64_t best_rd ) { <S2SV_StartBug> MB_PREDICTION_MODE mode ; <S2SV_EndBug> MB_PREDICTION_MODE mode_selected = DC_PRED ; MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * const mic = xd -> mi [ 0 ] ; int this_rate , this_rate_tokenonly , s ; int64_t this_distortion , this_rd ; TX_SIZE best_tx = TX_4X4 ; <S2SV_StartBug> int i ; <S2SV_EndBug> int * bmode_costs = x -> mbmode_cost ; if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) for ( i = 0 ; i < TX_MODES ; i ++ ) tx_cache [ i ] = INT64_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { int64_t local_tx_cache [ TX_MODES ] ; MODE_INFO * above_mi = xd -> mi [ - xd -> mi_stride ] ; MODE_INFO * left_mi = xd -> left_available ? xd -> mi [ - 1 ] : NULL ; if ( ! ( cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] & ( 1 << mode ) ) ) continue ; if ( cpi -> common . frame_type == KEY_FRAME ) { const MB_PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const MB_PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = x -> y_mode_costs [ A ] [ L ] ; <S2SV_StartBug> } <S2SV_EndBug> mic -> mbmi . mode = mode ; <S2SV_StartBug> intra_super_block_yrd ( cpi , x , & this_rate_tokenonly , & this_distortion , <S2SV_EndBug> <S2SV_StartBug> & s , NULL , bsize , local_tx_cache , best_rd ) ; <S2SV_EndBug> if ( this_rate_tokenonly == INT_MAX ) continue ; this_rate = this_rate_tokenonly + bmode_costs [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , this_rate , this_distortion ) ; if ( this_rd < best_rd ) { mode_selected = mode ; best_rd = this_rd ; best_tx = mic -> mbmi . tx_size ; * rate = this_rate ; * rate_tokenonly = this_rate_tokenonly ; * distortion = this_distortion ; * skippable = s ; } <S2SV_StartBug> if ( cpi -> sf . tx_size_search_method == USE_FULL_RD && this_rd < INT64_MAX ) { <S2SV_EndBug> for ( i = 0 ; i < TX_MODES && local_tx_cache [ i ] < INT64_MAX ; i ++ ) { const int64_t adj_rd = this_rd + local_tx_cache [ i ] - local_tx_cache [ cpi -> common . tx_mode ] ; if ( adj_rd < tx_cache [ i ] ) { tx_cache [ i ] = adj_rd ; } } } } mic -> mbmi . mode = mode_selected ; mic -> mbmi . tx_size = best_tx ; return best_rd ; }
","<S2SV_ModStart> bsize , int64_t <S2SV_ModEnd> best_rd ) { <S2SV_ModStart> best_rd ) { PREDICTION_MODE mode ; PREDICTION_MODE <S2SV_ModEnd> mode_selected = DC_PRED <S2SV_ModStart> TX_4X4 ; int * bmode_costs ; const MODE_INFO * above_mi = xd -> above_mi ; const MODE_INFO * left_mi = xd -> left_mi ; const PREDICTION_MODE A = vp9_above_block_mode ( mic , above_mi , 0 ) ; const PREDICTION_MODE L = vp9_left_block_mode ( mic , left_mi , 0 ) ; bmode_costs = cpi <S2SV_ModEnd> -> y_mode_costs [ <S2SV_ModStart> L ] ; memset ( x -> skip_txfm , SKIP_TXFM_NONE , sizeof ( x -> skip_txfm ) ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { if ( cpi -> sf . use_nonrd_pick_mode ) { if ( conditional_skipintra ( mode , mode_selected ) ) continue ; if ( * skippable ) break ; <S2SV_ModStart> = mode ; super_block_yrd <S2SV_ModEnd> ( cpi , <S2SV_ModStart> NULL , bsize <S2SV_ModEnd> , best_rd ) <S2SV_ModStart> s ; } <S2SV_ModEnd> } mic ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void show_psnr ( struct stream_state * stream ) { <S2SV_EndBug> int i ; double ovpsnr ; if ( ! stream -> psnr_count ) return ; fprintf ( stderr , ""Stream<S2SV_blank>%d<S2SV_blank>PSNR<S2SV_blank>(Overall/Avg/Y/U/V)"" , stream -> index ) ; <S2SV_StartBug> ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , <S2SV_EndBug> ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , ""<S2SV_blank>%.3f"" , ovpsnr ) ; for ( i = 0 ; i < 4 ; i ++ ) { fprintf ( stderr , ""<S2SV_blank>%.3f"" , stream -> psnr_totals [ i ] / stream -> psnr_count ) ; } fprintf ( stderr , ""\\n"" ) ; }
","<S2SV_ModStart> stream_state * stream , double peak <S2SV_ModStart> -> psnr_samples_total , peak <S2SV_ModEnd> , ( double
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }
","<S2SV_ModStart> r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||
",radareorg@radare2/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19,CVE-2018-20458,https://github.com/radareorg/radare2/commit/30f4c7b52a4e2dc0d0b1bae487d90f5437c69d19,2018-12-25T19:29Z
CWE-119,"CWE-119 static unsigned int get_sby_perpixel_diff_variance ( VP9_COMP * cpi , <S2SV_StartBug> MACROBLOCK * x , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bs ) { <S2SV_StartBug> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_EndBug> <S2SV_StartBug> int offset = ( mi_row * MI_SIZE ) * yv12 -> y_stride + ( mi_col * MI_SIZE ) ; <S2SV_EndBug> unsigned int var , sse ; <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> x -> plane [ 0 ] . src . stride , yv12 -> y_buffer + offset , yv12 -> y_stride , & sse ) ; return ROUND_POWER_OF_TWO ( var , num_pels_log2_lookup [ bs ] ) ; }
","<S2SV_ModStart> * cpi , const struct buf_2d * ref <S2SV_ModEnd> , int mi_row <S2SV_ModStart> bs ) { unsigned int sse , var ; uint8_t * last_y ; <S2SV_ModStart> const YV12_BUFFER_CONFIG * last <S2SV_ModEnd> = get_ref_frame_buffer ( <S2SV_ModStart> LAST_FRAME ) ; assert ( last != NULL ) ; last_y = & last -> y_buffer [ <S2SV_ModEnd> mi_row * MI_SIZE <S2SV_ModStart> mi_row * MI_SIZE * last <S2SV_ModEnd> -> y_stride + <S2SV_ModStart> -> y_stride + <S2SV_ModEnd> mi_col * MI_SIZE <S2SV_ModStart> mi_col * MI_SIZE ] <S2SV_ModEnd> ; var = <S2SV_ModStart> . vf ( ref -> buf , ref -> stride , last_y , last <S2SV_ModEnd> -> y_stride ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 <S2SV_StartBug> int sctp_verify_asconf ( const struct sctp_association * asoc , <S2SV_EndBug> <S2SV_StartBug> struct sctp_paramhdr * param_hdr , void * chunk_end , <S2SV_EndBug> struct sctp_paramhdr * * errp ) { <S2SV_StartBug> sctp_addip_param_t * asconf_param ; <S2SV_EndBug> union sctp_params param ; <S2SV_StartBug> int length , plen ; <S2SV_EndBug> <S2SV_StartBug> param . v = ( sctp_paramhdr_t * ) param_hdr ; <S2SV_EndBug> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> sctp_verify_asconf ( const <S2SV_ModStart> asoc , struct sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> , struct sctp_paramhdr <S2SV_ModStart> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> ; union sctp_params <S2SV_ModStart> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> param . v <S2SV_ModStart> param . v != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z
CWE-362,"CWE-362 void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; <S2SV_StartBug> struct net * net = sock_net ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> bh_lock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> <S2SV_StartBug> if ( sock_owned_by_user ( asoc -> base . sk ) ) { <S2SV_EndBug> pr_debug ( ""%s:<S2SV_blank>sock<S2SV_blank>is<S2SV_blank>busy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) <S2SV_StartBug> asoc -> base . sk -> sk_err = - error ; <S2SV_EndBug> out_unlock : <S2SV_StartBug> bh_unlock_sock ( asoc -> base . sk ) ; <S2SV_EndBug> sctp_transport_put ( transport ) ; }
","<S2SV_ModStart> asoc ; struct sock * sk = asoc -> base . sk ; struct <S2SV_ModStart> = sock_net ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ; bh_lock_sock ( <S2SV_ModEnd> sk ) ; <S2SV_ModStart> ( sock_owned_by_user ( <S2SV_ModEnd> sk ) ) <S2SV_ModStart> ( error ) <S2SV_ModEnd> sk -> sk_err <S2SV_ModStart> : bh_unlock_sock ( <S2SV_ModEnd> sk ) ;
",torvalds@linux/635682a14427d241bab7bbdeebb48a7d7b91638e,CVE-2015-8767,https://github.com/torvalds/linux/commit/635682a14427d241bab7bbdeebb48a7d7b91638e,2016-02-08T03:59Z
CWE-200,"CWE-200 static int copy_to_user_auth ( struct xfrm_algo_auth * auth , struct sk_buff * skb ) { struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ; <S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }
","<S2SV_ModStart> nla ) ; strncpy <S2SV_ModEnd> ( algo -> <S2SV_ModStart> auth -> alg_name , sizeof ( algo -> alg_name )
",torvalds@linux/4c87308bdea31a7b4828a51f6156e6f721a1fcc9,CVE-2012-6538,https://github.com/torvalds/linux/commit/4c87308bdea31a7b4828a51f6156e6f721a1fcc9,2013-03-15T20:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static int detect_flash ( const struct twopass_rc * twopass , int offset ) { <S2SV_EndBug> <S2SV_StartBug> FIRSTPASS_STATS next_frame ; <S2SV_EndBug> int flash_detected = 0 ; <S2SV_StartBug> if ( read_frame_stats ( twopass , & next_frame , offset ) != EOF ) { <S2SV_EndBug> <S2SV_StartBug> if ( next_frame . pcnt_second_ref > next_frame . pcnt_inter && <S2SV_EndBug> <S2SV_StartBug> next_frame . pcnt_second_ref >= 0.5 ) <S2SV_EndBug> flash_detected = 1 ; } return flash_detected ; }
","<S2SV_ModStart> detect_flash ( const TWO_PASS <S2SV_ModEnd> * twopass , <S2SV_ModStart> offset ) { const FIRSTPASS_STATS * const next_frame = <S2SV_ModEnd> read_frame_stats ( twopass <S2SV_ModStart> ( twopass , offset ) ; return next_frame != NULL && next_frame -> <S2SV_ModEnd> pcnt_second_ref > next_frame <S2SV_ModStart> pcnt_second_ref > next_frame -> <S2SV_ModEnd> pcnt_inter && next_frame <S2SV_ModStart> pcnt_inter && next_frame -> <S2SV_ModEnd> pcnt_second_ref >= 0.5 <S2SV_ModStart> pcnt_second_ref >= 0.5 <S2SV_ModEnd> ; } <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 static ssize_t userfaultfd_ctx_read ( struct userfaultfd_ctx * ctx , int no_wait , struct uffd_msg * msg ) { ssize_t ret ; DECLARE_WAITQUEUE ( wait , current ) ; struct userfaultfd_wait_queue * uwq ; LIST_HEAD ( fork_event ) ; struct userfaultfd_ctx * fork_nctx = NULL ; spin_lock ( & ctx -> fd_wqh . lock ) ; __add_wait_queue ( & ctx -> fd_wqh , & wait ) ; for ( ; ; ) { set_current_state ( TASK_INTERRUPTIBLE ) ; spin_lock ( & ctx -> fault_pending_wqh . lock ) ; uwq = find_userfault ( ctx ) ; if ( uwq ) { write_seqcount_begin ( & ctx -> refile_seq ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> fault_wqh , & uwq -> wq ) ; write_seqcount_end ( & ctx -> refile_seq ) ; * msg = uwq -> msg ; spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> fault_pending_wqh . lock ) ; spin_lock ( & ctx -> event_wqh . lock ) ; uwq = find_userfault_evt ( ctx ) ; if ( uwq ) { * msg = uwq -> msg ; if ( uwq -> msg . event == UFFD_EVENT_FORK ) { fork_nctx = ( struct userfaultfd_ctx * ) ( unsigned long ) uwq -> msg . arg . reserved . reserved1 ; list_move ( & uwq -> wq . entry , & fork_event ) ; <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> ret = 0 ; break ; } userfaultfd_event_complete ( ctx , uwq ) ; spin_unlock ( & ctx -> event_wqh . lock ) ; ret = 0 ; break ; } spin_unlock ( & ctx -> event_wqh . lock ) ; if ( signal_pending ( current ) ) { ret = - ERESTARTSYS ; break ; } if ( no_wait ) { ret = - EAGAIN ; break ; } spin_unlock ( & ctx -> fd_wqh . lock ) ; schedule ( ) ; spin_lock ( & ctx -> fd_wqh . lock ) ; } __remove_wait_queue ( & ctx -> fd_wqh , & wait ) ; __set_current_state ( TASK_RUNNING ) ; spin_unlock ( & ctx -> fd_wqh . lock ) ; if ( ! ret && msg -> event == UFFD_EVENT_FORK ) { ret = resolve_userfault_fork ( ctx , fork_nctx , msg ) ; <S2SV_StartBug> if ( ! ret ) { <S2SV_EndBug> spin_lock ( & ctx -> event_wqh . lock ) ; if ( ! list_empty ( & fork_event ) ) { <S2SV_StartBug> uwq = list_first_entry ( & fork_event , <S2SV_EndBug> typeof ( * uwq ) , wq . entry ) ; list_del ( & uwq -> wq . entry ) ; __add_wait_queue ( & ctx -> event_wqh , & uwq -> wq ) ; <S2SV_StartBug> userfaultfd_event_complete ( ctx , uwq ) ; <S2SV_EndBug> } <S2SV_StartBug> spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_EndBug> } } return ret ; }
","<S2SV_ModStart> fork_event ) ; userfaultfd_ctx_get ( fork_nctx ) ; <S2SV_ModStart> msg ) ; <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> ) ) { userfaultfd_ctx_put ( fork_nctx ) ; <S2SV_ModStart> wq ) ; if ( likely ( ! ret ) ) <S2SV_ModStart> ) ; } else { if ( ret ) userfaultfd_ctx_put ( fork_nctx ) ; } spin_unlock ( & ctx -> event_wqh . lock ) ; <S2SV_ModEnd> } return ret
",torvalds@linux/384632e67e0829deb8015ee6ad916b180049d252,CVE-2017-15126,https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252,2018-01-14T06:29Z
CWE-310,"CWE-310 static unsigned int do_decrypt ( const RIJNDAEL_context * ctx , unsigned char * bx , const unsigned char * ax ) { # ifdef USE_AMD64_ASM return _gcry_aes_amd64_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # elif defined ( USE_ARM_ASM ) return _gcry_aes_arm_decrypt_block ( ctx -> keyschdec , bx , ax , ctx -> rounds , <S2SV_StartBug> & dec_tables ) ; <S2SV_EndBug> # else return do_decrypt_fn ( ctx , bx , ax ) ; # endif }
","<S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; # <S2SV_ModStart> -> rounds , dec_tables . T <S2SV_ModEnd> ) ; #
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
CWE-125,"CWE-125 static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc , AV_LOG_TRACE , ""metadata<S2SV_blank>sets<S2SV_blank>count<S2SV_blank>%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""no<S2SV_blank>material<S2SV_blank>package<S2SV_blank>found\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } if ( ( component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , TimecodeComponent ) ) ) { mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; } } if ( ! ( material_track -> sequence = mxf_resolve_strong_ref ( mxf , & material_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>material<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; continue ; } for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_strong_ref ( mxf , & material_track -> sequence -> structural_components_refs [ j ] , TimecodeComponent ) ; if ( ! component ) continue ; mxf_tc = ( MXFTimecodeComponent * ) component ; flags = mxf_tc -> drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0 ; if ( av_timecode_init ( & tc , mxf_tc -> rate , flags , mxf_tc -> start_frame , mxf -> fc ) == 0 ) { mxf_add_timecode_metadata ( & mxf -> fc -> metadata , ""timecode"" , & tc ) ; break ; } } if ( material_track -> sequence -> structural_components_count > 1 ) av_log ( mxf -> fc , AV_LOG_WARNING , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>has<S2SV_blank>%d<S2SV_blank>components\\n"" , material_track -> track_id , material_track -> sequence -> structural_components_count ) ; for ( j = 0 ; j < material_track -> sequence -> structural_components_count ; j ++ ) { component = mxf_resolve_sourceclip ( mxf , & material_track -> sequence -> structural_components_refs [ j ] ) ; if ( ! component ) continue ; source_package = mxf_resolve_source_package ( mxf , component -> source_package_ul , component -> source_package_uid ) ; if ( ! source_package ) { av_log ( mxf -> fc , AV_LOG_TRACE , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>package<S2SV_blank>found\\n"" , material_track -> track_id ) ; continue ; } for ( k = 0 ; k < source_package -> tracks_count ; k ++ ) { if ( ! ( temp_track = mxf_resolve_strong_ref ( mxf , & source_package -> tracks_refs [ k ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( temp_track -> track_id == component -> source_track_id ) { source_track = temp_track ; break ; } } if ( ! source_track ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>no<S2SV_blank>corresponding<S2SV_blank>source<S2SV_blank>track<S2SV_blank>found\\n"" , material_track -> track_id ) ; break ; } for ( k = 0 ; k < mxf -> essence_container_data_count ; k ++ ) { MXFEssenceContainerData * essence_data ; if ( ! ( essence_data = mxf_resolve_strong_ref ( mxf , & mxf -> essence_container_data_refs [ k ] , EssenceContainerData ) ) ) { <S2SV_StartBug> av_log ( mxf , AV_LOG_TRACE , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>essence<S2SV_blank>container<S2SV_blank>data<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; <S2SV_EndBug> continue ; } if ( ! memcmp ( component -> source_package_ul , essence_data -> package_ul , sizeof ( UID ) ) && ! memcmp ( component -> source_package_uid , essence_data -> package_uid , sizeof ( UID ) ) ) { source_track -> body_sid = essence_data -> body_sid ; source_track -> index_sid = essence_data -> index_sid ; break ; } } if ( source_track && component ) break ; } if ( ! source_track || ! component || ! source_package ) { if ( ( ret = mxf_add_metadata_stream ( mxf , material_track ) ) ) goto fail_and_free ; continue ; } if ( ! ( source_track -> sequence = mxf_resolve_strong_ref ( mxf , & source_track -> sequence_ref , Sequence ) ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>source<S2SV_blank>track<S2SV_blank>sequence<S2SV_blank>strong<S2SV_blank>ref\\n"" ) ; ret = AVERROR_INVALIDDATA ; goto fail_and_free ; } if ( memcmp ( material_track -> sequence -> data_definition_ul , source_track -> sequence -> data_definition_ul , 16 ) ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""material<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>DataDefinition<S2SV_blank>mismatch\\n"" , material_track -> track_id ) ; continue ; } st = avformat_new_stream ( mxf -> fc , NULL ) ; if ( ! st ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>stream\\n"" ) ; ret = AVERROR ( ENOMEM ) ; goto fail_and_free ; } st -> id = material_track -> track_id ; st -> priv_data = source_track ; source_package -> descriptor = mxf_resolve_strong_ref ( mxf , & source_package -> descriptor_ref , AnyType ) ; descriptor = mxf_resolve_multidescriptor ( mxf , source_package -> descriptor , source_track -> track_id ) ; if ( descriptor && descriptor -> duration != AV_NOPTS_VALUE ) source_track -> original_duration = st -> duration = FFMIN ( descriptor -> duration , component -> duration ) ; else source_track -> original_duration = st -> duration = component -> duration ; if ( st -> duration == - 1 ) st -> duration = AV_NOPTS_VALUE ; st -> start_time = component -> start_position ; if ( material_track -> edit_rate . num <= 0 || material_track -> edit_rate . den <= 0 ) { av_log ( mxf -> fc , AV_LOG_WARNING , ""Invalid<S2SV_blank>edit<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>found<S2SV_blank>on<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>"" ""defaulting<S2SV_blank>to<S2SV_blank>25/1\\n"" , material_track -> edit_rate . num , material_track -> edit_rate . den , st -> index ) ; material_track -> edit_rate = ( AVRational ) { 25 , 1 } ; } avpriv_set_pts_info ( st , 64 , material_track -> edit_rate . den , material_track -> edit_rate . num ) ; source_track -> edit_rate = material_track -> edit_rate ; PRINT_KEY ( mxf -> fc , ""data<S2SV_blank>definition<S2SV_blank><S2SV_blank><S2SV_blank>ul"" , source_track -> sequence -> data_definition_ul ) ; codec_ul = mxf_get_codec_ul ( ff_mxf_data_definition_uls , & source_track -> sequence -> data_definition_ul ) ; st -> codecpar -> codec_type = codec_ul -> id ; if ( ! descriptor ) { av_log ( mxf -> fc , AV_LOG_INFO , ""source<S2SV_blank>track<S2SV_blank>%d:<S2SV_blank>stream<S2SV_blank>%d,<S2SV_blank>no<S2SV_blank>descriptor<S2SV_blank>found\\n"" , source_track -> track_id , st -> index ) ; continue ; } PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>codec<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ul"" , descriptor -> essence_codec_ul ) ; PRINT_KEY ( mxf -> fc , ""essence<S2SV_blank>container<S2SV_blank>ul"" , descriptor -> essence_container_ul ) ; essence_container_ul = & descriptor -> essence_container_ul ; source_track -> wrapping = ( mxf -> op == OPAtom ) ? ClipWrapped : mxf_get_wrapping_kind ( essence_container_ul ) ; if ( source_track -> wrapping == UnknownWrapped ) av_log ( mxf -> fc , AV_LOG_INFO , ""wrapping<S2SV_blank>of<S2SV_blank>stream<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unknown\\n"" , st -> index ) ; if ( IS_KLV_KEY ( essence_container_ul , mxf_encrypted_essence_container ) ) { av_log ( mxf -> fc , AV_LOG_INFO , ""broken<S2SV_blank>encrypted<S2SV_blank>mxf<S2SV_blank>file\\n"" ) ; for ( k = 0 ; k < mxf -> metadata_sets_count ; k ++ ) { MXFMetadataSet * metadata = mxf -> metadata_sets [ k ] ; if ( metadata -> type == CryptoContext ) { essence_container_ul = & ( ( MXFCryptoContext * ) metadata ) -> source_container_ul ; break ; } } } codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) { codec_ul = mxf_get_codec_ul ( ff_mxf_codec_uls , & descriptor -> codec_ul ) ; st -> codecpar -> codec_id = ( enum AVCodecID ) codec_ul -> id ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%s:<S2SV_blank>Universal<S2SV_blank>Label:<S2SV_blank>"" , avcodec_get_name ( st -> codecpar -> codec_id ) ) ; for ( k = 0 ; k < 16 ; k ++ ) { av_log ( mxf -> fc , AV_LOG_VERBOSE , ""%.2x"" , descriptor -> essence_codec_ul [ k ] ) ; if ( ! ( k + 1 & 19 ) || k == 5 ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""."" ) ; } av_log ( mxf -> fc , AV_LOG_VERBOSE , ""\\n"" ) ; mxf_add_umid_metadata ( & st -> metadata , ""file_package_umid"" , source_package ) ; if ( source_package -> name && source_package -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""file_package_name"" , source_package -> name , 0 ) ; if ( material_track -> name && material_track -> name [ 0 ] ) av_dict_set ( & st -> metadata , ""track_name"" , material_track -> name , 0 ) ; mxf_parse_physical_source_package ( mxf , source_track , st ) ; if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO ) { source_track -> intra_only = mxf_is_intra_only ( descriptor ) ; container_ul = mxf_get_codec_ul ( mxf_picture_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; st -> codecpar -> width = descriptor -> width ; st -> codecpar -> height = descriptor -> height ; switch ( descriptor -> frame_layout ) { case FullFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; break ; case OneField : av_log ( mxf -> fc , AV_LOG_INFO , ""OneField<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>isn\'t<S2SV_blank>currently<S2SV_blank>supported\\n"" ) ; break ; case MixedFields : break ; case SegmentedFrame : st -> codecpar -> field_order = AV_FIELD_PROGRESSIVE ; case SeparateFields : av_log ( mxf -> fc , AV_LOG_DEBUG , ""video_line_map:<S2SV_blank>(%d,<S2SV_blank>%d),<S2SV_blank>field_dominance:<S2SV_blank>%d\\n"" , descriptor -> video_line_map [ 0 ] , descriptor -> video_line_map [ 1 ] , descriptor -> field_dominance ) ; if ( ( descriptor -> video_line_map [ 0 ] > 0 ) && ( descriptor -> video_line_map [ 1 ] > 0 ) ) { if ( ( descriptor -> video_line_map [ 0 ] + descriptor -> video_line_map [ 1 ] ) % 2 ) { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_TT ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_TB ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } else { switch ( descriptor -> field_dominance ) { case MXF_FIELD_DOMINANCE_DEFAULT : case MXF_FIELD_DOMINANCE_FF : st -> codecpar -> field_order = AV_FIELD_BB ; break ; case MXF_FIELD_DOMINANCE_FL : st -> codecpar -> field_order = AV_FIELD_BT ; break ; default : avpriv_request_sample ( mxf -> fc , ""Field<S2SV_blank>dominance<S2SV_blank>%d<S2SV_blank>support"" , descriptor -> field_dominance ) ; } } } st -> codecpar -> height *= 2 ; break ; default : av_log ( mxf -> fc , AV_LOG_INFO , ""Unknown<S2SV_blank>frame<S2SV_blank>layout<S2SV_blank>type:<S2SV_blank>%d\\n"" , descriptor -> frame_layout ) ; } if ( st -> codecpar -> codec_id == AV_CODEC_ID_RAWVIDEO ) { st -> codecpar -> format = descriptor -> pix_fmt ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { pix_fmt_ul = mxf_get_codec_ul ( ff_mxf_pixel_format_uls , & descriptor -> essence_codec_ul ) ; st -> codecpar -> format = ( enum AVPixelFormat ) pix_fmt_ul -> id ; if ( st -> codecpar -> format == AV_PIX_FMT_NONE ) { st -> codecpar -> codec_tag = mxf_get_codec_ul ( ff_mxf_codec_tag_uls , & descriptor -> essence_codec_ul ) -> id ; if ( ! st -> codecpar -> codec_tag ) { if ( descriptor -> horiz_subsampling == 2 && descriptor -> vert_subsampling == 1 && descriptor -> component_depth == 8 ) { st -> codecpar -> format = AV_PIX_FMT_UYVY422 ; } } } } } st -> need_parsing = AVSTREAM_PARSE_HEADERS ; if ( material_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""material_track_origin"" , material_track -> sequence -> origin , 0 ) ; } if ( source_track -> sequence -> origin ) { av_dict_set_int ( & st -> metadata , ""source_track_origin"" , source_track -> sequence -> origin , 0 ) ; } if ( descriptor -> aspect_ratio . num && descriptor -> aspect_ratio . den ) st -> display_aspect_ratio = descriptor -> aspect_ratio ; } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) { container_ul = mxf_get_codec_ul ( mxf_sound_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE || ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_ALAW && ( enum AVCodecID ) container_ul -> id != AV_CODEC_ID_NONE ) ) st -> codecpar -> codec_id = ( enum AVCodecID ) container_ul -> id ; st -> codecpar -> channels = descriptor -> channels ; st -> codecpar -> bits_per_coded_sample = descriptor -> bits_per_sample ; if ( descriptor -> sample_rate . den > 0 ) { st -> codecpar -> sample_rate = descriptor -> sample_rate . num / descriptor -> sample_rate . den ; avpriv_set_pts_info ( st , 64 , descriptor -> sample_rate . den , descriptor -> sample_rate . num ) ; } else { av_log ( mxf -> fc , AV_LOG_WARNING , ""invalid<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>(%d/%d)<S2SV_blank>"" ""found<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>#%d,<S2SV_blank>time<S2SV_blank>base<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1/48000\\n"" , descriptor -> sample_rate . num , descriptor -> sample_rate . den , st -> index ) ; avpriv_set_pts_info ( st , 64 , 1 , 48000 ) ; } if ( st -> duration != AV_NOPTS_VALUE ) st -> duration = av_rescale_q ( st -> duration , av_inv_q ( material_track -> edit_rate ) , st -> time_base ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16LE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24LE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32LE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_PCM_S16BE ) { if ( descriptor -> bits_per_sample > 16 && descriptor -> bits_per_sample <= 24 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S24BE ; else if ( descriptor -> bits_per_sample == 32 ) st -> codecpar -> codec_id = AV_CODEC_ID_PCM_S32BE ; } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_MP2 ) { st -> need_parsing = AVSTREAM_PARSE_FULL ; } } else if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_DATA ) { enum AVMediaType type ; container_ul = mxf_get_codec_ul ( mxf_data_essence_container_uls , essence_container_ul ) ; if ( st -> codecpar -> codec_id == AV_CODEC_ID_NONE ) st -> codecpar -> codec_id = container_ul -> id ; type = avcodec_get_type ( st -> codecpar -> codec_id ) ; if ( type == AVMEDIA_TYPE_SUBTITLE ) st -> codecpar -> codec_type = type ; if ( container_ul -> desc ) av_dict_set ( & st -> metadata , ""data_type"" , container_ul -> desc , 0 ) ; } if ( descriptor -> extradata ) { if ( ! ff_alloc_extradata ( st -> codecpar , descriptor -> extradata_size ) ) { memcpy ( st -> codecpar -> extradata , descriptor -> extradata , descriptor -> extradata_size ) ; } } else if ( st -> codecpar -> codec_id == AV_CODEC_ID_H264 ) { int coded_width = mxf_get_codec_ul ( mxf_intra_only_picture_coded_width , & descriptor -> essence_codec_ul ) -> id ; if ( coded_width ) st -> codecpar -> width = coded_width ; ret = ff_generate_avci_extradata ( st ) ; if ( ret < 0 ) return ret ; } if ( st -> codecpar -> codec_type != AVMEDIA_TYPE_DATA && source_track -> wrapping != FrameWrapped ) { st -> need_parsing = AVSTREAM_PARSE_TIMESTAMPS ; } } ret = 0 ; fail_and_free : return ret ; }
","<S2SV_ModStart> av_log ( mxf -> fc
",FFmpeg@FFmpeg/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,CVE-2018-1999014,https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75,2018-07-23T15:29Z
CWE-20,"CWE-20 <S2SV_StartBug> int sctp_verify_asconf ( const struct sctp_association * asoc , <S2SV_EndBug> <S2SV_StartBug> struct sctp_paramhdr * param_hdr , void * chunk_end , <S2SV_EndBug> struct sctp_paramhdr * * errp ) { <S2SV_StartBug> sctp_addip_param_t * asconf_param ; <S2SV_EndBug> union sctp_params param ; <S2SV_StartBug> int length , plen ; <S2SV_EndBug> <S2SV_StartBug> param . v = ( sctp_paramhdr_t * ) param_hdr ; <S2SV_EndBug> while ( param . v <= chunk_end - sizeof ( sctp_paramhdr_t ) ) { length = ntohs ( param . p -> length ) ; * errp = param . p ; if ( param . v > chunk_end - length || length < sizeof ( sctp_paramhdr_t ) ) return 0 ; switch ( param . p -> type ) { case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : asconf_param = ( sctp_addip_param_t * ) param . v ; plen = ntohs ( asconf_param -> param_hdr . length ) ; if ( plen < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return 0 ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return 0 ; break ; default : break ; } param . v += WORD_ROUND ( length ) ; } if ( param . v != chunk_end ) return 0 ; return 1 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> bool <S2SV_ModEnd> sctp_verify_asconf ( const <S2SV_ModStart> asoc , struct sctp_chunk * chunk , bool addr_param_needed <S2SV_ModEnd> , struct sctp_paramhdr <S2SV_ModStart> errp ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) chunk -> chunk_hdr <S2SV_ModEnd> ; union sctp_params <S2SV_ModStart> sctp_params param ; bool addr_param_seen = false ; sctp_walk_params ( param , addip , addip_hdr . params ) { size_t length = ntohs ( param . p -> length ) ; * errp = param . p ; switch ( param . p -> type ) { case SCTP_PARAM_ERR_CAUSE : break ; case SCTP_PARAM_IPV4_ADDRESS : if ( length != sizeof ( sctp_ipv4addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_IPV6_ADDRESS : if ( length != sizeof ( sctp_ipv6addr_param_t ) ) return false ; addr_param_seen = true ; break ; case SCTP_PARAM_ADD_IP : case SCTP_PARAM_DEL_IP : case SCTP_PARAM_SET_PRIMARY : if ( addr_param_needed && ! addr_param_seen ) return false ; length = ntohs ( param . addip -> param_hdr . length ) ; if ( length < sizeof ( sctp_addip_param_t ) + sizeof ( sctp_paramhdr_t ) ) return false ; break ; case SCTP_PARAM_SUCCESS_REPORT : case SCTP_PARAM_ADAPTATION_LAYER_IND : if ( length != sizeof ( sctp_addip_param_t ) ) return false ; break ; default : return false ; } } if ( addr_param_needed && ! addr_param_seen ) return false ; if ( ! addr_param_needed && addr_param_seen ) return false ; if ( <S2SV_ModEnd> param . v <S2SV_ModStart> param . v != chunk -> chunk_end ) return false ; return true <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,CVE-2014-3673,https://github.com/torvalds/linux/commit/9de7922bc709eee2f609cd01d98aaedc4cf5ea74,2014-11-10T11:55Z
CWE-125,"CWE-125 static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; <S2SV_StartBug> tok -> level = 0 ; <S2SV_EndBug> tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; <S2SV_StartBug> return tok ; <S2SV_EndBug> }
","<S2SV_ModStart> level = 0 <S2SV_ModEnd> ; tok -> <S2SV_ModStart> = 0 ; tok -> async_always = 0 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-362,"CWE-362 static int newseg ( struct ipc_namespace * ns , struct ipc_params * params ) { key_t key = params -> key ; int shmflg = params -> flg ; size_t size = params -> u . size ; int error ; struct shmid_kernel * shp ; size_t numpages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; struct file * file ; char name [ 13 ] ; int id ; vm_flags_t acctflag = 0 ; if ( size < SHMMIN || size > ns -> shm_ctlmax ) return - EINVAL ; if ( numpages << PAGE_SHIFT < size ) return - ENOSPC ; if ( ns -> shm_tot + numpages < ns -> shm_tot || ns -> shm_tot + numpages > ns -> shm_ctlall ) return - ENOSPC ; shp = ipc_rcu_alloc ( sizeof ( * shp ) ) ; if ( ! shp ) return - ENOMEM ; shp -> shm_perm . key = key ; shp -> shm_perm . mode = ( shmflg & S_IRWXUGO ) ; shp -> mlock_user = NULL ; shp -> shm_perm . security = NULL ; error = security_shm_alloc ( shp ) ; if ( error ) { ipc_rcu_putref ( shp , ipc_rcu_free ) ; return error ; } sprintf ( name , ""SYSV%08x"" , key ) ; if ( shmflg & SHM_HUGETLB ) { struct hstate * hs ; size_t hugesize ; hs = hstate_sizelog ( ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; if ( ! hs ) { error = - EINVAL ; goto no_file ; } hugesize = ALIGN ( size , huge_page_size ( hs ) ) ; if ( shmflg & SHM_NORESERVE ) acctflag = VM_NORESERVE ; file = hugetlb_file_setup ( name , hugesize , acctflag , & shp -> mlock_user , HUGETLB_SHMFS_INODE , ( shmflg >> SHM_HUGE_SHIFT ) & SHM_HUGE_MASK ) ; } else { if ( ( shmflg & SHM_NORESERVE ) && sysctl_overcommit_memory != OVERCOMMIT_NEVER ) acctflag = VM_NORESERVE ; file = shmem_kernel_file_setup ( name , size , acctflag ) ; } error = PTR_ERR ( file ) ; if ( IS_ERR ( file ) ) goto no_file ; <S2SV_StartBug> id = ipc_addid ( & shm_ids ( ns ) , & shp -> shm_perm , ns -> shm_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { error = id ; goto no_id ; } <S2SV_StartBug> shp -> shm_cprid = task_tgid_vnr ( current ) ; <S2SV_EndBug> shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; list_add ( & shp -> shm_clist , & current -> sysvshm . shm_clist ) ; file_inode ( file ) -> i_ino = shp -> shm_perm . id ; ns -> shm_tot += numpages ; error = shp -> shm_perm . id ; ipc_unlock_object ( & shp -> shm_perm ) ; rcu_read_unlock ( ) ; return error ; no_id : if ( is_file_hugepages ( file ) && shp -> mlock_user ) user_shm_unlock ( size , shp -> mlock_user ) ; fput ( file ) ; no_file : ipc_rcu_putref ( shp , shm_rcu_free ) ; return error ; }
","<S2SV_ModStart> goto no_file ; shp -> shm_cprid = task_tgid_vnr ( current ) ; shp -> shm_lprid = 0 ; shp -> shm_atim = shp -> shm_dtim = 0 ; shp -> shm_ctim = get_seconds ( ) ; shp -> shm_segsz = size ; shp -> shm_nattch = 0 ; shp -> shm_file = file ; shp -> shm_creator = current ; <S2SV_ModStart> no_id ; } <S2SV_ModEnd> list_add ( &
",torvalds@linux/b9a532277938798b53178d5a66af6e2915cb27cf,CVE-2015-7613,https://github.com/torvalds/linux/commit/b9a532277938798b53178d5a66af6e2915cb27cf,2015-10-19T10:59Z
CWE-20,"CWE-20 static int parse_exports_table ( long long * table_start ) { int res ; <S2SV_StartBug> int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; <S2SV_EndBug> <S2SV_StartBug> long long export_index_table [ indexes ] ; <S2SV_EndBug> <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , <S2SV_EndBug> SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>export<S2SV_blank>index<S2SV_blank>table\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
","<S2SV_ModStart> = SQUASHFS_LOOKUP_BLOCKS ( ( long long ) sBlk . s . inodes ) ; int length = SQUASHFS_LOOKUP_BLOCK_BYTES ( ( long long ) <S2SV_ModStart> ; long long * export_index_table ; if ( length != ( * table_start - sBlk . s . lookup_table_start ) ) { ERROR ( ""parse_exports_table:<S2SV_blank>Bad<S2SV_blank>inode<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return FALSE ; } export_index_table = alloc_index_table ( indexes ) <S2SV_ModEnd> ; res = <S2SV_ModStart> . lookup_table_start , length , <S2SV_ModEnd> export_index_table ) ;
",plougher@squashfs-tools/f95864afe8833fe3ad782d714b41378e860977b1,CVE-2015-4646,https://github.com/plougher/squashfs-tools/commit/f95864afe8833fe3ad782d714b41378e860977b1,2017-04-13T17:59Z
CWE-200,"CWE-200 static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
","<S2SV_ModStart> ; if ( ! nfs_write_pageuptodate ( page , inode ) ) return 0 ; if ( <S2SV_ModStart> ; if ( <S2SV_ModEnd> inode -> i_flock <S2SV_ModStart> F_RDLCK ) ) <S2SV_ModEnd> return 1 ;
",torvalds@linux/263b4509ec4d47e0da3e753f85a39ea12d1eff24,CVE-2014-2038,https://github.com/torvalds/linux/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24,2014-02-28T06:18Z
CWE-119,"CWE-119 static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { <S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; <S2SV_StartBug> const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; <S2SV_EndBug> <S2SV_StartBug> TileBuffer tile_buffers [ 1 << 6 ] ; <S2SV_EndBug> int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) { <S2SV_StartBug> const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; <S2SV_EndBug> int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers , <S2SV_StartBug> vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; <S2SV_EndBug> for ( i = 0 ; i < num_threads ; ++ i ) { <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i ] ; <S2SV_EndBug> ++ pbi -> num_tile_workers ; <S2SV_StartBug> vp9_worker_init ( worker ) ; <S2SV_EndBug> CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; <S2SV_StartBug> if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { <S2SV_EndBug> vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tile<S2SV_blank>decoder<S2SV_blank>thread<S2SV_blank>creation<S2SV_blank>failed"" ) ; } } } for ( n = 0 ; n < num_workers ; ++ n ) { <S2SV_StartBug> pbi -> tile_workers [ n ] . hook = ( VP9WorkerHook ) tile_worker_hook ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_mi_cols ) ; <S2SV_StartBug> vpx_memset ( cm -> above_seg_context , 0 , <S2SV_EndBug> sizeof ( * cm -> above_seg_context ) * aligned_mi_cols ) ; <S2SV_StartBug> for ( n = 0 ; n < tile_cols ; ++ n ) { <S2SV_EndBug> const size_t size = <S2SV_StartBug> get_tile ( data_end , n == tile_cols - 1 , & cm -> error , & data ) ; <S2SV_EndBug> TileBuffer * const buf = & tile_buffers [ n ] ; buf -> data = data ; buf -> size = size ; buf -> col = n ; data += size ; } qsort ( tile_buffers , tile_cols , sizeof ( tile_buffers [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers + group_start , tile_buffers + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] ) ) ; tile_buffers [ group_end ] = largest ; group_start = group_end + 1 ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ n ] ; tile_data -> cm = cm ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; vp9_tile_init ( tile , tile_data -> cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader ) ; init_macroblockd ( cm , & tile_data -> xd ) ; vp9_zero ( tile_data -> xd . dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || n == tile_cols - 1 ) { vp9_worker_execute ( worker ) ; } else { <S2SV_StartBug> vp9_worker_launch ( worker ) ; <S2SV_EndBug> } if ( buf -> col == tile_cols - 1 ) { final_worker = i ; } ++ n ; } for ( ; i > 0 ; -- i ) { <S2SV_StartBug> VP9Worker * const worker = & pbi -> tile_workers [ i - 1 ] ; <S2SV_EndBug> <S2SV_StartBug> pbi -> mb . corrupted |= ! vp9_worker_sync ( worker ) ; <S2SV_EndBug> } if ( final_worker > - 1 ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ final_worker ] . data1 ; <S2SV_StartBug> bit_reader_end = vp9_reader_find_end ( & tile_data -> bit_reader ) ; <S2SV_EndBug> <S2SV_StartBug> final_worker = - 1 ; <S2SV_EndBug> } } return bit_reader_end ; }
","<S2SV_ModStart> pbi -> common ; const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) <S2SV_ModStart> ( pbi -> <S2SV_ModEnd> max_threads & ~ <S2SV_ModStart> tile_buffers [ 1 ] [ 1 <S2SV_ModStart> = pbi -> <S2SV_ModEnd> max_threads & ~ <S2SV_ModStart> pbi -> tile_workers ) ) ) ; assert ( ( sizeof ( * pbi -> tile_worker_data ) % 16 ) == 0 ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_data , vpx_memalign ( 32 , num_threads * sizeof ( * pbi -> tile_worker_data ) ) ) ; CHECK_MEM_ERROR ( cm , pbi -> tile_worker_info , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_worker_info <S2SV_ModStart> i ) { VPxWorker <S2SV_ModEnd> * const worker <S2SV_ModStart> -> num_tile_workers ; winterface -> init ( worker <S2SV_ModEnd> ) ; if <S2SV_ModStart> 1 && ! winterface -> reset <S2SV_ModEnd> ( worker ) <S2SV_ModStart> n ) { VPxWorker * const worker = & <S2SV_ModStart> [ n ] ; winterface -> sync ( worker ) ; worker -> <S2SV_ModEnd> hook = ( <S2SV_ModStart> hook = ( VPxWorkerHook <S2SV_ModEnd> ) tile_worker_hook ; <S2SV_ModStart> ) tile_worker_hook ; worker -> data1 = & pbi -> tile_worker_data [ n ] ; worker -> data2 = & pbi -> tile_worker_info [ n ] ; } memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_mi_cols ) ; memset <S2SV_ModEnd> ( cm -> <S2SV_ModStart> aligned_mi_cols ) ; get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ; qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ; { int group_start = 0 ; while ( group_start < tile_cols ) { const TileBuffer largest = tile_buffers [ 0 ] [ group_start ] ; const int group_end = MIN ( group_start + num_workers , tile_cols ) - 1 ; memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ; tile_buffers [ 0 ] [ group_end ] = largest ; group_start = group_end + 1 ; } } if ( ! cm -> frame_parallel_decoding_mode ) { int i ; for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_zero ( tile_data -> counts ) ; } } n = 0 ; while ( n < tile_cols ) { int i ; for ( i = 0 ; i < num_workers && n < tile_cols ; ++ i ) { VPxWorker * const worker = & pbi -> tile_workers [ i ] ; TileWorkerData * const tile_data = ( TileWorkerData * ) worker -> data1 ; TileInfo * const tile = ( TileInfo * ) worker -> data2 ; TileBuffer * const buf = & tile_buffers [ 0 ] [ n ] ; tile_data -> pbi = pbi ; tile_data -> xd = pbi -> mb ; tile_data -> xd . corrupted = 0 ; tile_data -> xd . counts = cm -> frame_parallel_decoding_mode ? 0 : & tile_data -> counts ; vp9_zero ( tile_data -> dqcoeff ) ; vp9_tile_init ( tile , cm , 0 , buf -> col ) ; vp9_tile_init ( & tile_data -> xd . tile , cm , 0 , buf -> col ) ; setup_token_decoder ( buf -> data , data_end , buf -> size , & cm -> error , & tile_data -> bit_reader , pbi -> decrypt_cb , pbi -> decrypt_state ) ; vp9_init_macroblockd ( cm , & tile_data -> xd , tile_data -> dqcoeff ) ; worker -> had_error = 0 ; if ( i == num_workers - 1 || <S2SV_ModEnd> n == tile_cols <S2SV_ModStart> tile_cols - 1 ) { winterface -> execute <S2SV_ModEnd> ( worker ) <S2SV_ModStart> } else { winterface -> launch <S2SV_ModEnd> ( worker ) <S2SV_ModStart> i ) { VPxWorker <S2SV_ModEnd> * const worker <S2SV_ModStart> corrupted |= ! winterface -> sync <S2SV_ModEnd> ( worker ) <S2SV_ModStart> ; bit_reader_end = vpx_reader_find_end <S2SV_ModEnd> ( & tile_data <S2SV_ModStart> - 1 ; } if ( n >= tile_cols && ! cm -> frame_parallel_decoding_mode ) { for ( i = 0 ; i < num_workers ; ++ i ) { TileWorkerData * const tile_data = ( TileWorkerData * ) pbi -> tile_workers [ i ] . data1 ; vp9_accumulate_frame_counts ( cm , & tile_data -> counts , 1 ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 unsigned int oom_badness ( struct task_struct * p , struct mem_cgroup * mem , const nodemask_t * nodemask , unsigned long totalpages ) { <S2SV_StartBug> int points ; <S2SV_EndBug> if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ; p = find_lock_task_mm ( p ) ; if ( ! p ) return 0 ; if ( atomic_read ( & p -> mm -> oom_disable_count ) ) { task_unlock ( p ) ; return 0 ; } if ( ! totalpages ) totalpages = 1 ; points = get_mm_rss ( p -> mm ) + p -> mm -> nr_ptes ; points += get_mm_counter ( p -> mm , MM_SWAPENTS ) ; points *= 1000 ; points /= totalpages ; task_unlock ( p ) ; if ( has_capability_noaudit ( p , CAP_SYS_ADMIN ) ) points -= 30 ; points += p -> signal -> oom_score_adj ; if ( points <= 0 ) return 1 ; return ( points < 1000 ) ? points : 1000 ; }
","<S2SV_ModStart> totalpages ) { long <S2SV_ModEnd> points ; if
",torvalds@linux/56c6a8a4aadca809e04276eabe5552935c51387f,CVE-2011-4097,https://github.com/torvalds/linux/commit/56c6a8a4aadca809e04276eabe5552935c51387f,2012-05-17T11:00Z
CWE-000,"CWE-000 IHEVCD_ERROR_T ihevcd_mv_buf_mgr_add_bufs ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 i ; WORD32 max_dpb_size ; WORD32 mv_bank_size_allocated ; WORD32 pic_mv_bank_size ; sps_t * ps_sps ; UWORD8 * pu1_buf ; mv_buf_t * ps_mv_buf ; ps_sps = ps_codec -> s_parse . ps_sps ; max_dpb_size = ps_sps -> ai1_sps_max_dec_pic_buffering [ ps_sps -> i1_sps_max_sub_layers - 1 ] ; max_dpb_size ++ ; <S2SV_StartBug> pu1_buf = ( UWORD8 * ) ps_codec -> pv_mv_bank_buf_base ; <S2SV_EndBug> ps_mv_buf = ( mv_buf_t * ) pu1_buf ; pu1_buf += max_dpb_size * sizeof ( mv_buf_t ) ; ps_codec -> ps_mv_buf = ps_mv_buf ; mv_bank_size_allocated = ps_codec -> i4_total_mv_bank_size - max_dpb_size * sizeof ( mv_buf_t ) ; pic_mv_bank_size = ihevcd_get_pic_mv_bank_size ( ALIGN64 ( ps_sps -> i2_pic_width_in_luma_samples ) * ALIGN64 ( ps_sps -> i2_pic_height_in_luma_samples ) ) ; for ( i = 0 ; i < max_dpb_size ; i ++ ) { WORD32 buf_ret ; WORD32 num_pu ; WORD32 num_ctb ; WORD32 pic_size ; pic_size = ALIGN64 ( ps_sps -> i2_pic_width_in_luma_samples ) * ALIGN64 ( ps_sps -> i2_pic_height_in_luma_samples ) ; num_pu = pic_size / ( MIN_PU_SIZE * MIN_PU_SIZE ) ; num_ctb = pic_size / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) ; mv_bank_size_allocated -= pic_mv_bank_size ; if ( mv_bank_size_allocated < 0 ) { ps_codec -> s_parse . i4_error_code = IHEVCD_INSUFFICIENT_MEM_MVBANK ; return IHEVCD_INSUFFICIENT_MEM_MVBANK ; } ps_mv_buf -> pu4_pic_pu_idx = ( UWORD32 * ) pu1_buf ; pu1_buf += ( num_ctb + 1 ) * sizeof ( WORD32 ) ; ps_mv_buf -> pu1_pic_pu_map = pu1_buf ; pu1_buf += num_pu ; ps_mv_buf -> pu1_pic_slice_map = ( UWORD16 * ) pu1_buf ; pu1_buf += ALIGN4 ( num_ctb * sizeof ( UWORD16 ) ) ; ps_mv_buf -> ps_pic_pu = ( pu_t * ) pu1_buf ; pu1_buf += num_pu * sizeof ( pu_t ) ; buf_ret = ihevc_buf_mgr_add ( ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr , ps_mv_buf , i ) ; if ( 0 != buf_ret ) { ps_codec -> s_parse . i4_error_code = IHEVCD_BUF_MGR_ERROR ; return IHEVCD_BUF_MGR_ERROR ; } ps_mv_buf ++ ; } return ret ; }
","<S2SV_ModStart> max_dpb_size ++ ; ps_codec -> i4_max_dpb_size = max_dpb_size ;
",external@libhevc/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,CVE-2017-0642,https://android.googlesource.com/platform/external/libhevc/+/913d9e8d93d6b81bb8eac3fc2c1426651f5b259d,2017-06-14T13:29Z
CWE-119,"CWE-119 static void set_good_speed_feature ( VP9_COMP * cpi , VP9_COMMON * cm , SPEED_FEATURES * sf , int speed ) { <S2SV_StartBug> sf -> adaptive_rd_thresh = 1 ; <S2SV_EndBug> sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { <S2SV_StartBug> sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; <S2SV_EndBug> <S2SV_StartBug> sf -> less_rectangular_check = 1 ; <S2SV_EndBug> <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search = 1 ; <S2SV_StartBug> sf -> auto_mv_step_size = 1 ; <S2SV_EndBug> sf -> adaptive_rd_thresh = 2 ; <S2SV_StartBug> sf -> subpel_iters_per_step = 1 ; <S2SV_EndBug> sf -> mode_skip_start = 10 ; sf -> adaptive_pred_interp_filter = 1 ; sf -> recode_loop = ALLOW_RECODE_KFARFGF ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC_H_V ; sf -> intra_y_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_StartBug> sf -> intra_uv_mode_mask [ TX_16X16 ] = INTRA_DC_H_V ; <S2SV_EndBug> } if ( speed >= 2 ) { <S2SV_StartBug> sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD <S2SV_EndBug> : USE_LARGESTALL ; <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = LAST_AND_INTRA_SPLIT_ONLY ; sf -> adaptive_pred_interp_filter = 2 ; sf -> reference_masking = 1 ; sf -> mode_search_skip_flags = FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER | FLAG_SKIP_COMP_BESTINTRA | FLAG_SKIP_INTRA_LOWVAR ; sf -> disable_filter_search_var_thresh = 100 ; sf -> comp_inter_joint_search_thresh = BLOCK_SIZES ; sf -> auto_min_max_partition_size = RELAXED_NEIGHBORING_MIN_MAX ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_LOW_MOTION ; <S2SV_EndBug> sf -> adjust_partitioning_from_last_frame = 1 ; sf -> last_partitioning_redo_frequency = 3 ; } if ( speed >= 3 ) { <S2SV_StartBug> if ( MIN ( cm -> width , cm -> height ) >= 720 ) <S2SV_EndBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; else sf -> disable_split_mask = DISABLE_ALL_INTER_SPLIT ; sf -> recode_loop = ALLOW_RECODE_KFMAXBW ; sf -> adaptive_rd_thresh = 3 ; sf -> mode_skip_start = 6 ; <S2SV_StartBug> sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; <S2SV_EndBug> sf -> use_fast_coef_costing = 1 ; } if ( speed >= 4 ) { sf -> use_square_partition_only = 1 ; sf -> tx_size_search_method = USE_LARGESTALL ; <S2SV_StartBug> sf -> disable_split_mask = DISABLE_ALL_SPLIT ; <S2SV_EndBug> <S2SV_StartBug> sf -> adaptive_rd_thresh = 4 ; <S2SV_EndBug> <S2SV_StartBug> sf -> mode_search_skip_flags |= FLAG_SKIP_COMP_REFMISMATCH | <S2SV_EndBug> FLAG_EARLY_TERMINATE ; sf -> disable_filter_search_var_thresh = 200 ; <S2SV_StartBug> sf -> use_lastframe_partitioning = LAST_FRAME_PARTITION_ALL ; <S2SV_EndBug> <S2SV_StartBug> sf -> use_lp32x32fdct = 1 ; <S2SV_EndBug> } if ( speed >= 5 ) { int i ; <S2SV_StartBug> sf -> partition_search_type = FIXED_PARTITION ; <S2SV_EndBug> sf -> optimize_coefficients = 0 ; <S2SV_StartBug> sf -> search_method = HEX ; <S2SV_EndBug> sf -> disable_filter_search_var_thresh = 500 ; for ( i = 0 ; i < TX_SIZES ; ++ i ) { <S2SV_StartBug> sf -> intra_y_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> <S2SV_StartBug> sf -> intra_uv_mode_mask [ i ] = INTRA_DC_ONLY ; <S2SV_EndBug> } cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ; } }
","<S2SV_ModStart> speed ) { const int boosted = frame_is_boosted ( cpi ) ; <S2SV_ModStart> adaptive_rd_thresh = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> 1 ) { if ( ( cpi -> twopass . fr_content_type == FC_GRAPHICS_ANIMATION ) || vp9_internal_image_edge ( cpi ) ) { sf -> use_square_partition_only = ! frame_is_boosted ( cpi ) ; } else { <S2SV_ModStart> cm ) ; } <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_rd_breakout = 1 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> ] = INTRA_DC_H_V ; sf -> tx_size_search_breakout = 1 ; sf -> partition_search_breakout_rate_thr = 80 <S2SV_ModStart> -> tx_size_search_method = frame_is_boosted <S2SV_ModEnd> ( cpi ) <S2SV_ModStart> : USE_LARGESTALL ; sf -> reference_masking = cpi -> oxcf . resize_mode != RESIZE_DYNAMIC ? 1 : 0 ; sf -> mode_search_skip_flags = <S2SV_ModEnd> ( cm -> <S2SV_ModStart> ( cm -> frame_type == KEY_FRAME ) ? 0 : <S2SV_ModEnd> FLAG_SKIP_INTRA_DIRMISMATCH | FLAG_SKIP_INTRA_BESTINTER <S2SV_ModStart> ; sf -> allow_partition_search_skip = 1 <S2SV_ModEnd> ; } if <S2SV_ModStart> 3 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> tx_size_search_method = frame_is_intra_only ( cm ) ? USE_FULL_RD : USE_LARGESTALL ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED ; sf -> adaptive_pred_interp_filter = 0 ; sf -> adaptive_mode_search = 1 ; sf -> cb_partition_search = ! boosted ; sf -> cb_pred_filter_search = 1 ; sf -> alt_ref_search_fp = 1 <S2SV_ModEnd> ; sf -> <S2SV_ModStart> ; sf -> intra_y_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> intra_uv_mode_mask [ TX_32X32 ] = INTRA_DC ; sf -> adaptive_interp_filter_search <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ; sf -> mv . search_method = BIGDIA ; sf -> mv . subpel_search_method = SUBPEL_TREE_PRUNED_MORE <S2SV_ModEnd> ; sf -> <S2SV_ModStart> = 4 ; if ( cm -> frame_type != KEY_FRAME ) <S2SV_ModStart> -> mode_search_skip_flags |= <S2SV_ModEnd> FLAG_EARLY_TERMINATE ; sf <S2SV_ModStart> ; sf -> <S2SV_ModEnd> use_lp32x32fdct = 1 <S2SV_ModStart> use_lp32x32fdct = 1 ; sf -> use_fast_coef_updates = ONE_LOOP_REDUCED ; sf -> use_fast_coef_costing = 1 ; sf -> motion_field_mode_search = ! boosted ; sf -> partition_search_breakout_rate_thr = 300 <S2SV_ModStart> ; sf -> <S2SV_ModEnd> optimize_coefficients = 0 <S2SV_ModStart> ; sf -> mv . <S2SV_ModStart> i ] = INTRA_DC <S2SV_ModEnd> ; sf -> <S2SV_ModStart> i ] = INTRA_DC ; } sf -> partition_search_breakout_rate_thr = 500 ; sf -> mv . reduce_first_step_size = 1 ; sf -> simple_model_rd_from_var = 1 <S2SV_ModEnd> ; } }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
","<S2SV_ModStart> const buffers [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> v_buffer <S2SV_ModEnd> } ; const <S2SV_ModStart> int strides [ 3 <S2SV_ModEnd> ] = { <S2SV_ModStart> src -> uv_stride <S2SV_ModEnd> } ; int
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-476,"CWE-476 static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; <S2SV_StartBug> px -> ft -> data = px ; <S2SV_EndBug> px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
","<S2SV_ModStart> size ) ; if ( ! px -> ft ) { return FALSE ; }
",bitlbee@bitlbee/30d598ce7cd3f136ee9d7097f39fa9818a272441,CVE-2017-5668,https://github.com/bitlbee/bitlbee/commit/30d598ce7cd3f136ee9d7097f39fa9818a272441,2017-03-14T14:59Z
CWE-264,"CWE-264 static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , ""sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>"" ""cmd=0x%x\\n"" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }
","<S2SV_ModStart> ; error = scsi_verify_blk_ioctl ( bdev , cmd ) ; if ( error < 0 ) return error ; error =
",torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e,CVE-2011-4127,https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e,2012-07-03T16:40Z
CWE-88,"CWE-88 static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> value ) ; if ( ! strcmp ( key , ""path"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_PATH , ""disallowed<S2SV_blank>submodule<S2SV_blank>path:<S2SV_blank>%s"" , value ) ;
",git@git/1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404,CVE-2018-17456,https://github.com/git/git/commit/1a7fd1fb2998002da6e9ff2ee46e1bdd25ee8404,2018-10-06T14:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_diff_update_prob ( vp9_reader * r , vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , DIFF_UPDATE_PROB ) ) { <S2SV_EndBug> const int delp = decode_term_subexp ( r ) ; <S2SV_StartBug> * p = ( vp9_prob ) inv_remap_prob ( delp , * p ) ; <S2SV_EndBug> } }
","<S2SV_ModStart> void vp9_diff_update_prob ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> * r , vpx_prob <S2SV_ModEnd> * p ) <S2SV_ModStart> { if ( vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> p = ( vpx_prob <S2SV_ModEnd> ) inv_remap_prob (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> , VCPU_SREG_LDTR , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if <S2SV_ModStart> , cpl , true , NULL <S2SV_ModEnd> ) ; if
",torvalds@linux/d1442d85cc30ea75f7d399474ca738e0bc96f715,CVE-2014-3647,https://github.com/torvalds/linux/commit/d1442d85cc30ea75f7d399474ca738e0bc96f715,2014-11-10T11:55Z
CWE-362,"CWE-362 <S2SV_StartBug> int ip_options_get_from_user ( struct net * net , struct ip_options * * optp , <S2SV_EndBug> unsigned char __user * data , int optlen ) { <S2SV_StartBug> struct ip_options * opt = ip_options_get_alloc ( optlen ) ; <S2SV_EndBug> if ( ! opt ) return - ENOMEM ; <S2SV_StartBug> if ( optlen && copy_from_user ( opt -> __data , data , optlen ) ) { <S2SV_EndBug> kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }
","<S2SV_ModStart> net , struct ip_options_rcu <S2SV_ModEnd> * * optp <S2SV_ModStart> ) { struct ip_options_rcu <S2SV_ModEnd> * opt = <S2SV_ModStart> ( opt -> opt .
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-119,"CWE-119 static int write_superframe_index ( vpx_codec_alg_priv_t * ctx ) { uint8_t marker = 0xc0 ; unsigned int mask ; int mag , index_sz ; assert ( ctx -> pending_frame_count ) ; assert ( ctx -> pending_frame_count <= 8 ) ; marker |= ctx -> pending_frame_count - 1 ; for ( mag = 0 , mask = 0xff ; mag < 4 ; mag ++ ) { if ( ctx -> pending_frame_magnitude < mask ) break ; mask <<= 8 ; mask |= 0xff ; } marker |= mag << 3 ; index_sz = 2 + ( mag + 1 ) * ctx -> pending_frame_count ; if ( ctx -> pending_cx_data_sz + index_sz < ctx -> cx_data_sz ) { uint8_t * x = ctx -> pending_cx_data + ctx -> pending_cx_data_sz ; <S2SV_StartBug> int i , j ; <S2SV_EndBug> * x ++ = marker ; for ( i = 0 ; i < ctx -> pending_frame_count ; i ++ ) { unsigned int this_sz = ( unsigned int ) ctx -> pending_frame_sizes [ i ] ; for ( j = 0 ; j <= mag ; j ++ ) { * x ++ = this_sz & 0xff ; this_sz >>= 8 ; } } * x ++ = marker ; ctx -> pending_cx_data_sz += index_sz ; <S2SV_StartBug> } <S2SV_EndBug> return index_sz ; }
","<S2SV_ModStart> , j ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA uint8_t marker_test = 0xc0 ; int mag_test = 2 ; int frames_test = 4 ; int index_sz_test = 2 + mag_test * frames_test ; marker_test |= frames_test - 1 ; marker_test |= ( mag_test - 1 ) << 3 ; * x ++ = marker_test ; for ( i = 0 ; i < mag_test * frames_test ; ++ i ) * x ++ = 0 ; * x ++ = marker_test ; ctx -> pending_cx_data_sz += index_sz_test ; printf ( ""Added<S2SV_blank>supplemental<S2SV_blank>superframe<S2SV_blank>data\\n"" ) ; # endif <S2SV_ModStart> += index_sz ; # ifdef TEST_SUPPLEMENTAL_SUPERFRAME_DATA index_sz += index_sz_test ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp9_loop_filter_frame_init ( VP9_COMMON * cm , int default_filt_lvl ) { int seg_id ; const int scale = 1 << ( default_filt_lvl >> 5 ) ; loop_filter_info_n * const lfi = & cm -> lf_info ; struct loopfilter * const lf = & cm -> lf ; const struct segmentation * const seg = & cm -> seg ; if ( lf -> last_sharpness_level != lf -> sharpness_level ) { update_sharpness ( lfi , lf -> sharpness_level ) ; lf -> last_sharpness_level = lf -> sharpness_level ; } for ( seg_id = 0 ; seg_id < MAX_SEGMENTS ; seg_id ++ ) { int lvl_seg = default_filt_lvl ; <S2SV_StartBug> if ( vp9_segfeature_active ( seg , seg_id , SEG_LVL_ALT_LF ) ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_get_segdata ( seg , seg_id , SEG_LVL_ALT_LF ) ; <S2SV_EndBug> lvl_seg = clamp ( seg -> abs_delta == SEGMENT_ABSDATA ? data : default_filt_lvl + data , 0 , MAX_LOOP_FILTER ) ; } if ( ! lf -> mode_ref_delta_enabled ) { <S2SV_StartBug> vpx_memset ( lfi -> lvl [ seg_id ] , lvl_seg , sizeof ( lfi -> lvl [ seg_id ] ) ) ; <S2SV_EndBug> } else { int ref , mode ; const int intra_lvl = lvl_seg + lf -> ref_deltas [ INTRA_FRAME ] * scale ; lfi -> lvl [ seg_id ] [ INTRA_FRAME ] [ 0 ] = clamp ( intra_lvl , 0 , MAX_LOOP_FILTER ) ; for ( ref = LAST_FRAME ; ref < MAX_REF_FRAMES ; ++ ref ) { for ( mode = 0 ; mode < MAX_MODE_LF_DELTAS ; ++ mode ) { const int inter_lvl = lvl_seg + lf -> ref_deltas [ ref ] * scale + lf -> mode_deltas [ mode ] * scale ; lfi -> lvl [ seg_id ] [ ref ] [ mode ] = clamp ( inter_lvl , 0 , MAX_LOOP_FILTER ) ; } } } } }
","<S2SV_ModStart> ; if ( segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> int data = get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> mode_ref_delta_enabled ) { memset <S2SV_ModEnd> ( lfi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }
","<S2SV_ModStart> = 0 ; uint32 <S2SV_ModEnd> strip , nstrips
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b#diff-c8b4b355f9b5c06d585b23138e1c185f,2016-11-22T19:59Z
CWE-119,"CWE-119 gboolean _pango_emoji_iter_next ( PangoEmojiIter * iter ) { PangoEmojiType current_emoji_type = PANGO_EMOJI_TYPE_INVALID ; if ( iter -> end == iter -> text_end ) return FALSE ; iter -> start = iter -> end ; for ( ; iter -> end < iter -> text_end ; iter -> end = g_utf8_next_char ( iter -> end ) ) { gunichar ch = g_utf8_get_char ( iter -> end ) ; if ( ( ! ( ch == kZeroWidthJoinerCharacter && ! iter -> is_emoji ) && ch != kVariationSelector15Character && ch != kVariationSelector16Character && ch != kCombiningEnclosingCircleBackslashCharacter && ! _pango_Is_Regional_Indicator ( ch ) && ! ( ( ch == kLeftSpeechBubbleCharacter || ch == kRainbowCharacter || ch == kMaleSignCharacter || ch == kFemaleSignCharacter || ch == kStaffOfAesculapiusCharacter ) && ! iter -> is_emoji ) ) || current_emoji_type == PANGO_EMOJI_TYPE_INVALID ) { current_emoji_type = _pango_get_emoji_type ( ch ) ; } if ( g_utf8_next_char ( iter -> end ) < iter -> text_end ) { gunichar peek_char = g_utf8_get_char ( g_utf8_next_char ( iter -> end ) ) ; if ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_EMOJI && peek_char == kVariationSelector15Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_TEXT ; } if ( ( current_emoji_type == PANGO_EMOJI_TYPE_EMOJI_TEXT || _pango_Is_Emoji_Keycap_Base ( ch ) ) && peek_char == kVariationSelector16Character ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( _pango_Is_Emoji_Keycap_Base ( ch ) && peek_char == kCombiningEnclosingKeycapCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } ; if ( _pango_Is_Regional_Indicator ( ch ) && _pango_Is_Regional_Indicator ( peek_char ) ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } if ( ( ch == kEyeCharacter || ch == kWavingWhiteFlagCharacter ) && peek_char == kZeroWidthJoinerCharacter ) { current_emoji_type = PANGO_EMOJI_TYPE_EMOJI_EMOJI ; } } if ( iter -> is_emoji == ( gboolean ) 2 ) iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; if ( iter -> is_emoji == PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ) { iter -> is_emoji = ! PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; <S2SV_StartBug> return TRUE ; <S2SV_EndBug> } } iter -> is_emoji = PANGO_EMOJI_TYPE_IS_EMOJI ( current_emoji_type ) ; return TRUE ; }
","<S2SV_ModStart> current_emoji_type ) ; if ( iter -> start == iter -> end ) iter -> end = g_utf8_next_char ( iter -> end ) ;
",GNOME@pango/71aaeaf020340412b8d012fe23a556c0420eda5f,CVE-2018-15120,https://github.com/GNOME/pango/commit/71aaeaf020340412b8d012fe23a556c0420eda5f,2018-08-24T19:29Z
CWE-400,"CWE-400 static void xen_irq_init ( unsigned irq ) { struct irq_info * info ; # ifdef CONFIG_SMP cpumask_copy ( irq_get_affinity_mask ( irq ) , cpumask_of ( 0 ) ) ; # endif info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( info == NULL ) panic ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n"" , irq ) ; info -> type = IRQT_UNBOUND ; info -> refcnt = - 1 ; set_info_for_irq ( irq , info ) ; <S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> }
","<S2SV_ModStart> info ) ; INIT_LIST_HEAD ( & info -> eoi_list ) ;
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-77,"CWE-77 static int save_dev ( blkid_dev dev , FILE * file ) { struct list_head * p ; if ( ! dev || dev -> bid_name [ 0 ] != '/' ) return 0 ; DBG ( SAVE , ul_debug ( ""device<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s"" , dev -> bid_name , dev -> bid_type ? dev -> bid_type : ""(null)"" ) ) ; fprintf ( file , ""<device<S2SV_blank>DEVNO=\\""0x%04lx\\""<S2SV_blank>TIME=\\""%ld.%ld\\"""" , ( unsigned long ) dev -> bid_devno , ( long ) dev -> bid_time , ( long ) dev -> bid_utime ) ; if ( dev -> bid_pri ) fprintf ( file , ""<S2SV_blank>PRI=\\""%d\\"""" , dev -> bid_pri ) ; list_for_each ( p , & dev -> bid_tags ) { blkid_tag tag = list_entry ( p , struct blkid_struct_tag , bit_tags ) ; <S2SV_StartBug> fprintf ( file , ""<S2SV_blank>%s=\\""%s\\"""" , tag -> bit_name , tag -> bit_val ) ; <S2SV_EndBug> } fprintf ( file , "">%s</device>\\n"" , dev -> bid_name ) ; return 0 ; }
","<S2SV_ModStart> bit_tags ) ; fputc ( '<S2SV_blank>' , file ) ; fputs ( <S2SV_ModEnd> tag -> bit_name <S2SV_ModStart> -> bit_name , file ) ; fputc ( '=' , file ) ; save_quoted ( <S2SV_ModStart> tag -> bit_val , file
",karelzak@util-linux/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,CVE-2014-9114,https://github.com/karelzak/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc,2017-03-31T16:59Z
CWE-200,"CWE-200 static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
","<S2SV_ModStart> media_pad_desc pad ; memset ( & pad , 0 , sizeof ( pad ) ) ; <S2SV_ModStart> ) continue ; memset ( & link , 0 , sizeof ( link ) ) ;
",torvalds@linux/c88e739b1fad662240e99ecbd0bdaac871717987,CVE-2014-9895,https://github.com/torvalds/linux/commit/c88e739b1fad662240e99ecbd0bdaac871717987,2016-08-06T10:59Z
CWE-119,"CWE-119 static void write_frame_size ( const VP9_COMMON * cm , <S2SV_StartBug> struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ; <S2SV_EndBug> write_display_size ( cm , wb ) ; }
","<S2SV_ModStart> cm , struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 16 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static OM_uint32 kg_unseal_v1_iov ( krb5_context context , OM_uint32 * minor_status , krb5_gss_ctx_id_rec * ctx , gss_iov_buffer_desc * iov , int iov_count , size_t token_wrapper_len , int * conf_state , gss_qop_t * qop_state , int toktype ) { OM_uint32 code ; gss_iov_buffer_t header ; gss_iov_buffer_t trailer ; unsigned char * ptr ; int sealalg ; int signalg ; krb5_checksum cksum ; krb5_checksum md5cksum ; size_t cksum_len = 0 ; size_t conflen = 0 ; int direction ; krb5_ui_4 seqnum ; OM_uint32 retval ; size_t sumlen ; krb5_keyusage sign_usage = KG_USAGE_SIGN ; md5cksum . length = cksum . length = 0 ; md5cksum . contents = cksum . contents = NULL ; header = kg_locate_header_iov ( iov , iov_count , toktype ) ; assert ( header != NULL ) ; trailer = kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_TRAILER ) ; if ( trailer != NULL && trailer -> buffer . length != 0 ) { <S2SV_StartBug> * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; <S2SV_EndBug> return GSS_S_DEFECTIVE_TOKEN ; } <S2SV_StartBug> if ( header -> buffer . length < token_wrapper_len + 14 ) { <S2SV_EndBug> * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ptr = ( unsigned char * ) header -> buffer . value + token_wrapper_len ; signalg = ptr [ 0 ] ; signalg |= ptr [ 1 ] << 8 ; sealalg = ptr [ 2 ] ; sealalg |= ptr [ 3 ] << 8 ; if ( ptr [ 4 ] != 0xFF || ptr [ 5 ] != 0xFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype != KG_TOK_WRAP_MSG && sealalg != 0xFFFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( toktype == KG_TOK_WRAP_MSG && ! ( sealalg == 0xFFFF || sealalg == ctx -> sealalg ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ( ctx -> sealalg == SEAL_ALG_NONE && signalg > 1 ) || ( ctx -> sealalg == SEAL_ALG_1 && signalg != SGN_ALG_3 ) || ( ctx -> sealalg == SEAL_ALG_DES3KD && signalg != SGN_ALG_HMAC_SHA1_DES3_KD ) || ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 && signalg != SGN_ALG_HMAC_MD5 ) ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_HMAC_MD5 : cksum_len = 8 ; if ( toktype != KG_TOK_WRAP_MSG ) sign_usage = 15 ; break ; case SGN_ALG_3 : cksum_len = 16 ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : cksum_len = 20 ; break ; default : * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } code = kg_get_seq_num ( context , ctx -> seq , ptr + 14 , ptr + 6 , & direction , & seqnum ) ; if ( code != 0 ) { * minor_status = code ; return GSS_S_BAD_SIG ; } if ( toktype == KG_TOK_WRAP_MSG ) { if ( sealalg != 0xFFFF ) { if ( ctx -> sealalg == SEAL_ALG_MICROSOFT_RC4 ) { unsigned char bigend_seqnum [ 4 ] ; krb5_keyblock * enc_key ; size_t i ; store_32_be ( seqnum , bigend_seqnum ) ; code = krb5_k_key_keyblock ( context , ctx -> enc , & enc_key ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } assert ( enc_key -> length == 16 ) ; for ( i = 0 ; i < enc_key -> length ; i ++ ) ( ( char * ) enc_key -> contents ) [ i ] ^= 0xF0 ; code = kg_arcfour_docrypt_iov ( context , enc_key , 0 , & bigend_seqnum [ 0 ] , 4 , iov , iov_count ) ; krb5_free_keyblock ( context , enc_key ) ; } else { code = kg_decrypt_iov ( context , 0 , ( ( ctx -> gss_flags & GSS_C_DCE_STYLE ) != 0 ) , 0 , 0 , ctx -> enc , KG_USAGE_SEAL , NULL , iov , iov_count ) ; } if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } } conflen = kg_confounder_size ( context , ctx -> enc -> keyblock . enctype ) ; } if ( header -> buffer . length != token_wrapper_len + 14 + cksum_len + conflen ) { retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_MD2_5 : case SGN_ALG_DES_MAC : case SGN_ALG_3 : md5cksum . checksum_type = CKSUMTYPE_RSA_MD5 ; break ; case SGN_ALG_HMAC_MD5 : md5cksum . checksum_type = CKSUMTYPE_HMAC_MD5_ARCFOUR ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : md5cksum . checksum_type = CKSUMTYPE_HMAC_SHA1_DES3 ; break ; default : abort ( ) ; } code = krb5_c_checksum_length ( context , md5cksum . checksum_type , & sumlen ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } md5cksum . length = sumlen ; code = kg_make_checksum_iov_v1 ( context , md5cksum . checksum_type , cksum_len , ctx -> seq , ctx -> enc , sign_usage , iov , iov_count , toktype , & md5cksum ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } switch ( signalg ) { case SGN_ALG_DES_MAC_MD5 : case SGN_ALG_3 : code = kg_encrypt_inplace ( context , ctx -> seq , KG_USAGE_SEAL , ( g_OID_equal ( ctx -> mech_used , gss_mech_krb5_old ) ? ctx -> seq -> keyblock . contents : NULL ) , md5cksum . contents , 16 ) ; if ( code != 0 ) { retval = GSS_S_FAILURE ; goto cleanup ; } cksum . length = cksum_len ; cksum . contents = md5cksum . contents + 16 - cksum . length ; code = k5_bcmp ( cksum . contents , ptr + 14 , cksum . length ) ; break ; case SGN_ALG_HMAC_SHA1_DES3_KD : case SGN_ALG_HMAC_MD5 : code = k5_bcmp ( md5cksum . contents , ptr + 14 , cksum_len ) ; break ; default : code = 0 ; retval = GSS_S_DEFECTIVE_TOKEN ; goto cleanup ; break ; } if ( code != 0 ) { code = 0 ; retval = GSS_S_BAD_SIG ; goto cleanup ; } if ( toktype == KG_TOK_WRAP_MSG && ( ctx -> gss_flags & GSS_C_DCE_STYLE ) == 0 ) { retval = kg_fixup_padding_iov ( & code , iov , iov_count ) ; if ( retval != GSS_S_COMPLETE ) goto cleanup ; } if ( conf_state != NULL ) * conf_state = ( sealalg != 0xFFFF ) ; if ( qop_state != NULL ) * qop_state = GSS_C_QOP_DEFAULT ; if ( ( ctx -> initiate && direction != 0xff ) || ( ! ctx -> initiate && direction != 0 ) ) { * minor_status = ( OM_uint32 ) G_BAD_DIRECTION ; retval = GSS_S_BAD_SIG ; } code = 0 ; retval = g_order_check ( & ctx -> seqstate , ( gssint_uint64 ) seqnum ) ; cleanup : krb5_free_checksum_contents ( context , & md5cksum ) ; * minor_status = code ; return retval ; }
","<S2SV_ModStart> OM_uint32 ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ctx -> seq == NULL ) { * minor_status = 0 <S2SV_ModStart> < token_wrapper_len + 22 <S2SV_ModEnd> ) { *
",krb5@krb5/e6ae703ae597d798e310368d52b8f38ee11c6a73,CVE-2014-4342,https://github.com/krb5/krb5/commit/e6ae703ae597d798e310368d52b8f38ee11c6a73,2014-07-20T11:12Z
CWE-787,"CWE-787 int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( ""[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer"" ) ; return - 1 ; } memset ( & strm , '\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }
","<S2SV_ModStart> mz_ulong crc ; int max_input_expansion = ( ( int ) ( in_len / 32000 ) + 1 ) * 5 ; out_size = 10 + 8 + max_input_expansion + in_len <S2SV_ModEnd> ; out_buf =
",fluent@fluent-bit/cadff53c093210404aed01c4cf586adb8caa07af,CVE-2020-35963,https://github.com/fluent/fluent-bit/commit/cadff53c093210404aed01c4cf586adb8caa07af,2021-01-03T19:15Z
CWE-200,"CWE-200 static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }
","<S2SV_ModStart> ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ;
",ImageMagick@ImageMagick/51b0ae01709adc1e4a9245e158ef17b85a110960,CVE-2017-13143,https://github.com/ImageMagick/ImageMagick/commit/51b0ae01709adc1e4a9245e158ef17b85a110960,2017-08-23T06:29Z
CWE-125,"CWE-125 static expr_ty FstringParser_Finish ( FstringParser * state , struct compiling * c , const node * n ) { asdl_seq * seq ; FstringParser_check_invariants ( state ) ; <S2SV_StartBug> if ( state -> expr_list . size == 0 ) { <S2SV_EndBug> if ( ! state -> last_str ) { state -> last_str = PyUnicode_FromStringAndSize ( NULL , 0 ) ; if ( ! state -> last_str ) goto error ; } return make_str_node_and_del ( & state -> last_str , c , n ) ; } if ( state -> last_str ) { expr_ty str = make_str_node_and_del ( & state -> last_str , c , n ) ; if ( ! str || ExprList_Append ( & state -> expr_list , str ) < 0 ) goto error ; } assert ( state -> last_str == NULL ) ; seq = ExprList_Finish ( & state -> expr_list , c -> c_arena ) ; if ( ! seq ) goto error ; <S2SV_StartBug> if ( seq -> size == 1 ) <S2SV_EndBug> return seq -> elements [ 0 ] ; return JoinedStr ( seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; error : FstringParser_Dealloc ( state ) ; return NULL ; }
","<S2SV_ModStart> ; if ( ! state -> fmode ) { assert ( ! <S2SV_ModStart> expr_list . size ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> goto error ; <S2SV_ModEnd> return JoinedStr (
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-189,"CWE-189 int sysMapFile ( const char * fn , MemMapping * pMap ) { memset ( pMap , 0 , sizeof ( * pMap ) ) ; if ( fn && fn [ 0 ] == '@' ) { FILE * mapf = fopen ( fn + 1 , ""r"" ) ; if ( mapf == NULL ) { LOGV ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , fn + 1 , strerror ( errno ) ) ; return - 1 ; } if ( sysMapBlockFile ( mapf , pMap ) != 0 ) { LOGW ( ""Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n"" , fn ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } fclose ( mapf ) ; } else { int fd = open ( fn , O_RDONLY , 0 ) ; if ( fd < 0 ) { LOGE ( ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>\'%s\':<S2SV_blank>%s\\n"" , fn , strerror ( errno ) ) ; return - 1 ; } if ( sysMapFD ( fd , pMap ) != 0 ) { LOGE ( ""Map<S2SV_blank>of<S2SV_blank>\'%s\'<S2SV_blank>failed\\n"" , fn ) ; close ( fd ) ; return - 1 ; } close ( fd ) ; } return 0 ; }
","<S2SV_ModStart> fn ) ; fclose ( mapf ) ;
",bootable@recovery/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,CVE-2016-0849,https://android.googlesource.com/platform/bootable/recovery/+/28a566f7731b4cb76d2a9ba16d997ac5aeb07dad,2016-04-18T00:59Z
CWE-264,"CWE-264 static void mincore_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , unsigned char * vec ) { unsigned long next ; pmd_t * pmd ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( mincore_huge_pmd ( vma , pmd , addr , next , vec ) ) { vec += ( next - addr ) >> PAGE_SHIFT ; continue ; } } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ; vec += ( next - addr ) >> PAGE_SHIFT ; } while ( pmd ++ , addr = next , addr != end ) ; }
","<S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-787,"CWE-787 static void iriap_getvaluebyclass_indication ( struct iriap_cb * self , struct sk_buff * skb ) { struct ias_object * obj ; struct ias_attrib * attrib ; int name_len ; int attr_len ; char name [ IAS_MAX_CLASSNAME + 1 ] ; char attr [ IAS_MAX_ATTRIBNAME + 1 ] ; __u8 * fp ; int n ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ; IRDA_ASSERT ( self != NULL , return ; ) ; IRDA_ASSERT ( self -> magic == IAS_MAGIC , return ; ) ; IRDA_ASSERT ( skb != NULL , return ; ) ; fp = skb -> data ; n = 1 ; name_len = fp [ n ++ ] ; <S2SV_StartBug> memcpy ( name , fp + n , name_len ) ; n += name_len ; <S2SV_EndBug> name [ name_len ] = '\\0' ; <S2SV_StartBug> attr_len = fp [ n ++ ] ; <S2SV_EndBug> memcpy ( attr , fp + n , attr_len ) ; n += attr_len ; attr [ attr_len ] = '\\0' ; IRDA_DEBUG ( 4 , ""LM-IAS:<S2SV_blank>Looking<S2SV_blank>up<S2SV_blank>%s:<S2SV_blank>%s\\n"" , name , attr ) ; obj = irias_find_object ( name ) ; if ( obj == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:<S2SV_blank>Object<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; iriap_getvaluebyclass_response ( self , 0x1235 , IAS_CLASS_UNKNOWN , & irias_missing ) ; return ; } IRDA_DEBUG ( 4 , ""LM-IAS:<S2SV_blank>found<S2SV_blank>%s,<S2SV_blank>id=%d\\n"" , obj -> name , obj -> id ) ; attrib = irias_find_attrib ( obj , attr ) ; if ( attrib == NULL ) { IRDA_DEBUG ( 2 , ""LM-IAS:<S2SV_blank>Attribute<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>found\\n"" , attr ) ; iriap_getvaluebyclass_response ( self , obj -> id , IAS_ATTRIB_UNKNOWN , & irias_missing ) ; return ; } iriap_getvaluebyclass_response ( self , obj -> id , IAS_SUCCESS , attrib -> value ) ; }
","<S2SV_ModStart> ++ ] ; IRDA_ASSERT ( name_len < IAS_MAX_CLASSNAME + 1 , return ; ) ; <S2SV_ModStart> n ++ ] ; IRDA_ASSERT ( attr_len < IAS_MAX_ATTRIBNAME + 1 , return ; )
",torvalds@linux/d370af0ef7951188daeb15bae75db7ba57c67846,CVE-2011-1180,https://github.com/torvalds/linux/commit/d370af0ef7951188daeb15bae75db7ba57c67846,2013-06-08T13:05Z
CWE-19,"CWE-19 static int ext4_xattr_block_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; error = 0 ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; error = ext4_xattr_list_entries ( dentry , BFIRST ( bh ) , buffer , buffer_size ) ; cleanup : brelse ( bh ) ; return error ; }
","<S2SV_ModStart> error ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache =
",torvalds@linux/82939d7999dfc1f1998c4b1c12e2f19edbdff272,CVE-2015-8952,https://github.com/torvalds/linux/commit/82939d7999dfc1f1998c4b1c12e2f19edbdff272,2016-10-16T21:59Z
CWE-125,"CWE-125 static int init_normalization ( struct compiling * c ) { PyObject * m = PyImport_ImportModuleNoBlock ( ""unicodedata"" ) ; if ( ! m ) return 0 ; c -> c_normalize = PyObject_GetAttrString ( m , ""normalize"" ) ; Py_DECREF ( m ) ; if ( ! c -> c_normalize ) return 0 ; <S2SV_StartBug> c -> c_normalize_args = Py_BuildValue ( ""(sN)"" , ""NFKC"" , Py_None ) ; <S2SV_EndBug> if ( ! c -> c_normalize_args ) { Py_CLEAR ( c -> c_normalize ) ; return 0 ; } PyTuple_SET_ITEM ( c -> c_normalize_args , 1 , NULL ) ; return 1 ; }
","<S2SV_ModStart> return 0 ; <S2SV_ModEnd> return 1 ;
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-20,"CWE-20 error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT1 , hashTable [ 0 ] ) ; <S2SV_EndBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT2 , hashTable [ 1 ] ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT3 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EHT4 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT3 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>EHT4<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_REG_EHT4 ) ) ; <S2SV_EndBug> return NO_ERROR ; }
","<S2SV_ModStart> ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , ENC624J600_EHT1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT3 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , ENC624J600_EHT4 <S2SV_ModEnd> ) ) ;
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-119,"CWE-119 static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , <S2SV_StartBug> MB_PREDICTION_MODE mode , TX_SIZE tx_size , <S2SV_EndBug> int up_available , int left_available , int right_available , int x , int y , int plane ) { int i ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , left_col , 64 ) ; <S2SV_EndBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> once ( init_intra_pred_fn_ptrs ) ; <S2SV_EndBug> if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; <S2SV_StartBug> vpx_memset ( left_col , 129 , 64 ) ; <S2SV_EndBug> if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; for ( ; i < bs ; ++ i ) left_col [ i ] = ref [ ( extend_bottom - 1 ) * ref_stride - 1 ] ; } } else { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } <S2SV_StartBug> } <S2SV_EndBug> if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { <S2SV_StartBug> if ( x0 + 2 * bs <= frame_width ) { <S2SV_EndBug> <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , 2 * bs ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; <S2SV_StartBug> if ( right_available && bs == 4 ) { <S2SV_EndBug> vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , bs ) ; vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { vpx_memcpy ( above_row , above_ref , r ) ; vpx_memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { if ( bs == 4 && right_available && left_available ) { const_above_row = above_ref ; } else { <S2SV_StartBug> vpx_memcpy ( above_row , above_ref , bs ) ; <S2SV_EndBug> <S2SV_StartBug> if ( bs == 4 && right_available ) <S2SV_EndBug> vpx_memcpy ( above_row + bs , above_ref + bs , bs ) ; else vpx_memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } <S2SV_StartBug> } <S2SV_EndBug> } else { vpx_memset ( above_row , 127 , bs * 2 ) ; <S2SV_StartBug> above_row [ - 1 ] = 127 ; <S2SV_EndBug> } if ( mode == DC_PRED ) { dc_pred [ left_available ] [ up_available ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } else { pred [ mode ] [ tx_size ] ( dst , dst_stride , const_above_row , left_col ) ; } }
","<S2SV_ModStart> int dst_stride , PREDICTION_MODE <S2SV_ModEnd> mode , TX_SIZE <S2SV_ModStart> int i ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> uint8_t , left_col [ 32 ] ) ; DECLARE_ALIGNED ( 16 , uint8_t , above_data [ 64 + 16 ] <S2SV_ModEnd> ) ; uint8_t <S2SV_ModStart> plane ] ; <S2SV_ModEnd> if ( plane <S2SV_ModStart> + y ; if ( extend_modes [ mode ] & NEED_LEFT ) { <S2SV_ModEnd> if ( left_available <S2SV_ModStart> ; } } else { memset ( left_col , 129 , bs ) ; } } if ( extend_modes [ mode ] & NEED_ABOVE ) { <S2SV_ModStart> ( x0 + <S2SV_ModEnd> bs <= frame_width <S2SV_ModStart> frame_width ) { memcpy ( above_row , above_ref , bs ) ; } else if ( x0 <S2SV_ModEnd> <= frame_width ) <S2SV_ModStart> - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + bs - frame_width ) ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { memcpy ( above_row , above_ref , bs ) ; } } above_row [ - 1 ] = left_available ? above_ref [ - 1 ] : 129 ; } else { memset ( above_row , 127 , bs ) ; above_row [ - 1 ] = 127 ; } } if ( extend_modes [ mode ] & NEED_ABOVERIGHT ) { if ( up_available ) { const uint8_t * above_ref = ref - ref_stride ; if ( xd -> mb_to_right_edge < 0 ) { if ( x0 + 2 * bs <= frame_width ) { if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , 2 * bs ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 + bs <= frame_width ) { const int r = frame_width - x0 ; if ( right_available && bs == 4 ) { memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } else { memcpy ( above_row , above_ref , bs ) ; memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } else if ( x0 <= frame_width ) { const int r = frame_width - x0 ; memcpy ( above_row , above_ref , r ) ; memset ( above_row + r , above_row [ r - 1 ] , x0 + 2 * bs - frame_width ) ; } } else { <S2SV_ModEnd> if ( bs <S2SV_ModStart> 4 && right_available && left_available ) { const_above_row = above_ref ; } else { memcpy ( above_row , above_ref , bs ) ; if ( bs == 4 && right_available ) memcpy ( above_row + bs , above_ref + bs , bs ) ; else memset ( above_row + bs , above_row [ bs - 1 ] , bs ) ; } } <S2SV_ModEnd> above_row [ - <S2SV_ModStart> 129 ; } else { memset <S2SV_ModEnd> ( above_row , <S2SV_ModStart> = 127 ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }
","<S2SV_ModStart> tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/0048b4837affd153897ed1222283492070027aa9,CVE-2015-9016,https://github.com/torvalds/linux/commit/0048b4837affd153897ed1222283492070027aa9,2018-04-05T18:29Z
CWE-399,"CWE-399 int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else { <S2SV_StartBug> int i , ubits = BN_num_bits ( u ) , vbits = BN_num_bits ( v ) , <S2SV_EndBug> top = p -> top ; BN_ULONG * udp , * bdp , * vdp , * cdp ; bn_wexpand ( u , top ) ; udp = u -> d ; for ( i = u -> top ; i < top ; i ++ ) udp [ i ] = 0 ; u -> top = top ; bn_wexpand ( b , top ) ; bdp = b -> d ; bdp [ 0 ] = 1 ; for ( i = 1 ; i < top ; i ++ ) bdp [ i ] = 0 ; b -> top = top ; bn_wexpand ( c , top ) ; cdp = c -> d ; for ( i = 0 ; i < top ; i ++ ) cdp [ i ] = 0 ; c -> top = top ; vdp = v -> d ; while ( 1 ) { while ( ubits && ! ( udp [ 0 ] & 1 ) ) { BN_ULONG u0 , u1 , b0 , b1 , mask ; u0 = udp [ 0 ] ; b0 = bdp [ 0 ] ; mask = ( BN_ULONG ) 0 - ( b0 & 1 ) ; b0 ^= p -> d [ 0 ] & mask ; for ( i = 0 ; i < top - 1 ; i ++ ) { u1 = udp [ i + 1 ] ; udp [ i ] = ( ( u0 >> 1 ) | ( u1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; u0 = u1 ; b1 = bdp [ i + 1 ] ^ ( p -> d [ i + 1 ] & mask ) ; bdp [ i ] = ( ( b0 >> 1 ) | ( b1 << ( BN_BITS2 - 1 ) ) ) & BN_MASK2 ; b0 = b1 ; } udp [ i ] = u0 >> 1 ; bdp [ i ] = b0 >> 1 ; ubits -- ; } <S2SV_StartBug> if ( ubits <= BN_BITS2 && udp [ 0 ] == 1 ) <S2SV_EndBug> <S2SV_StartBug> break ; <S2SV_EndBug> if ( ubits < vbits ) { i = ubits ; ubits = vbits ; vbits = i ; tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; udp = vdp ; vdp = v -> d ; bdp = cdp ; cdp = c -> d ; } for ( i = 0 ; i < top ; i ++ ) { udp [ i ] ^= vdp [ i ] ; bdp [ i ] ^= cdp [ i ] ; } if ( ubits == vbits ) { BN_ULONG ul ; int utop = ( ubits - 1 ) / BN_BITS2 ; while ( ( ul = udp [ utop ] ) == 0 && utop ) utop -- ; ubits = utop * BN_BITS2 + BN_num_bits_word ( ul ) ; } } bn_correct_top ( b ) ; } # endif if ( ! BN_copy ( r , b ) ) goto err ; bn_check_top ( r ) ; ret = 1 ; err : # ifdef BN_DEBUG bn_correct_top ( c ) ; bn_correct_top ( u ) ; bn_correct_top ( v ) ; # endif BN_CTX_end ( ctx ) ; return ret ; }
","<S2SV_ModStart> { int i ; int <S2SV_ModEnd> ubits = BN_num_bits <S2SV_ModStart> ( u ) ; int <S2SV_ModEnd> vbits = BN_num_bits <S2SV_ModStart> ( v ) ; int <S2SV_ModEnd> top = p <S2SV_ModStart> ubits <= BN_BITS2 ) { if ( <S2SV_ModEnd> udp [ 0 <S2SV_ModStart> 0 ] == 0 ) goto err ; if ( udp [ 0 ] == <S2SV_ModStart> ) break ; }
",openssl@openssl/4924b37ee01f71ae19c94a8934b80eeb2f677932,CVE-2015-1788,https://github.com/openssl/openssl/commit/4924b37ee01f71ae19c94a8934b80eeb2f677932,2015-06-12T19:59Z
CWE-119,"CWE-119 static int vol_prc_lib_release ( effect_handle_t handle ) { struct listnode * node , * temp_node_next ; vol_listener_context_t * context = NULL ; vol_listener_context_t * recv_contex = ( vol_listener_context_t * ) handle ; <S2SV_StartBug> int status = - 1 ; <S2SV_EndBug> bool recompute_flag = false ; int active_stream_count = 0 ; <S2SV_StartBug> ALOGV ( ""%s<S2SV_blank>context<S2SV_blank>%p"" , __func__ , handle ) ; <S2SV_EndBug> <S2SV_StartBug> pthread_mutex_lock ( & vol_listner_init_lock ) ; <S2SV_EndBug> list_for_each_safe ( node , temp_node_next , & vol_effect_list ) { context = node_to_item ( node , struct vol_listener_context_s , effect_list_node ) ; <S2SV_StartBug> if ( ( memcmp ( & ( context -> desc -> uuid ) , & ( recv_contex -> desc -> uuid ) , sizeof ( effect_uuid_t ) ) == 0 ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> session_id == recv_contex -> session_id ) <S2SV_EndBug> <S2SV_StartBug> && ( context -> stream_type == recv_contex -> stream_type ) ) { <S2SV_EndBug> ALOGV ( ""---<S2SV_blank>Found<S2SV_blank>something<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>---"" ) ; <S2SV_StartBug> list_remove ( & context -> effect_list_node ) ; <S2SV_EndBug> PRINT_STREAM_TYPE ( context -> stream_type ) ; if ( context -> dev_id && AUDIO_DEVICE_OUT_SPEAKER ) { recompute_flag = true ; } free ( context ) ; status = 0 ; } else { ++ active_stream_count ; } } if ( status != 0 ) { ALOGE ( ""something<S2SV_blank>wrong<S2SV_blank>...<S2SV_blank><<<---<S2SV_blank>Found<S2SV_blank>NOTHING<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>...<S2SV_blank>????<S2SV_blank>--->>>>>"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( active_stream_count == 0 ) { current_gain_dep_cal_level = - 1 ; current_vol = 0.0 ; } if ( recompute_flag ) { check_and_set_gain_dep_cal ( ) ; } if ( dumping_enabled ) { dump_list_l ( ) ; } pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ; }
","<S2SV_ModStart> status = - EINVAL <S2SV_ModEnd> ; bool recompute_flag <S2SV_ModStart> = 0 ; uint32_t session_id ; uint32_t stream_type ; effect_uuid_t uuid ; <S2SV_ModStart> handle ) ; if ( recv_contex == NULL ) { return status ; } <S2SV_ModStart> & vol_listner_init_lock ) ; session_id = recv_contex -> session_id ; stream_type = recv_contex -> stream_type ; uuid = recv_contex -> desc -> uuid <S2SV_ModStart> ) , & uuid <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> -> session_id == <S2SV_ModEnd> session_id ) && <S2SV_ModStart> -> stream_type == <S2SV_ModEnd> stream_type ) ) <S2SV_ModStart> ; list_remove ( node <S2SV_ModEnd> ) ; PRINT_STREAM_TYPE <S2SV_ModStart> ""something<S2SV_blank>wrong<S2SV_blank>...<S2SV_blank><<<---<S2SV_blank>Found<S2SV_blank>NOTHING<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>...<S2SV_blank>????<S2SV_blank>--->>>>>"" ) ; pthread_mutex_unlock ( & vol_listner_init_lock ) ; return status ;
",hardware@qcom@audio/ebbb82365172337c6c250c6cac4e326970a9e351,CVE-2016-0839,https://android.googlesource.com/platform/hardware/qcom/audio/+/ebbb82365172337c6c250c6cac4e326970a9e351,2016-04-18T00:59Z
CWE-617,"CWE-617 krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { <S2SV_StartBug> return KRB5KDC_ERR_BADOPTION ; <S2SV_EndBug> } if ( ! krb5_principal_compare ( kdc_context , server -> princ , <S2SV_StartBug> server_princ ) ) { <S2SV_EndBug> return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = ""EVIDENCE_TKT_NOT_FORWARDABLE"" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = ""NOT_ALLOWED_TO_DELEGATE"" ; return errcode ; } return 0 ; }
","<S2SV_ModStart> ) ) { * status = ""INVALID_S4U2PROXY_OPTIONS"" ; <S2SV_ModStart> ) ) { * status = ""EVIDENCE_TICKET_MISMATCH"" ;
",krb5@krb5/ffb35baac6981f9e8914f8f3bffd37f284b85970,CVE-2017-11368,https://github.com/krb5/krb5/commit/ffb35baac6981f9e8914f8f3bffd37f284b85970,2017-08-09T18:29Z
CWE-284,"CWE-284 __be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( host_error < 0 ) <S2SV_StartBug> goto out_release ; <S2SV_EndBug> if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; } <S2SV_StartBug> out_release : <S2SV_EndBug> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }
","<S2SV_ModStart> ; if ( <S2SV_ModEnd> S_ISDIR ( inode <S2SV_ModStart> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( <S2SV_ModStart> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl
",torvalds@linux/999653786df6954a31044528ac3f7a5dadca08f4,CVE-2016-1237,https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4,2016-06-29T14:10Z
CWE-704,"CWE-704 void xgroupCommand ( client * c ) { const char * help [ ] = { ""CREATE<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>consumer<S2SV_blank>group."" , ""SETID<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><id<S2SV_blank>or<S2SV_blank>$><S2SV_blank><S2SV_blank>--<S2SV_blank>Set<S2SV_blank>the<S2SV_blank>current<S2SV_blank>group<S2SV_blank>ID."" , ""DELGROUP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>group."" , ""DELCONSUMER<S2SV_blank><key><S2SV_blank><groupname><S2SV_blank><consumer><S2SV_blank>--<S2SV_blank>Remove<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>conusmer."" , ""HELP<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>--<S2SV_blank>Prints<S2SV_blank>this<S2SV_blank>help."" , NULL } ; stream * s = NULL ; sds grpname = NULL ; streamCG * cg = NULL ; char * opt = c -> argv [ 1 ] -> ptr ; if ( c -> argc >= 4 ) { robj * o = lookupKeyWriteOrReply ( c , c -> argv [ 2 ] , shared . nokeyerr ) ; <S2SV_StartBug> if ( o == NULL ) return ; <S2SV_EndBug> s = o -> ptr ; grpname = c -> argv [ 3 ] -> ptr ; if ( ( cg = streamLookupCG ( s , grpname ) ) == NULL && ( ! strcasecmp ( opt , ""SETID"" ) || ! strcasecmp ( opt , ""DELCONSUMER"" ) ) ) { addReplyErrorFormat ( c , ""-NOGROUP<S2SV_blank>No<S2SV_blank>such<S2SV_blank>consumer<S2SV_blank>group<S2SV_blank>\'%s\'<S2SV_blank>"" ""for<S2SV_blank>key<S2SV_blank>name<S2SV_blank>\'%s\'"" , ( char * ) grpname , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } } if ( ! strcasecmp ( opt , ""CREATE"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } streamCG * cg = streamCreateCG ( s , grpname , sdslen ( grpname ) , & id ) ; if ( cg ) { addReply ( c , shared . ok ) ; server . dirty ++ ; } else { addReplySds ( c , sdsnew ( ""-BUSYGROUP<S2SV_blank>Consumer<S2SV_blank>Group<S2SV_blank>name<S2SV_blank>already<S2SV_blank>exists\\r\\n"" ) ) ; } } else if ( ! strcasecmp ( opt , ""SETID"" ) && c -> argc == 5 ) { streamID id ; if ( ! strcmp ( c -> argv [ 4 ] -> ptr , ""$"" ) ) { id = s -> last_id ; } else if ( streamParseIDOrReply ( c , c -> argv [ 4 ] , & id , 0 ) != C_OK ) { return ; } cg -> last_id = id ; addReply ( c , shared . ok ) ; } else if ( ! strcasecmp ( opt , ""DESTROY"" ) && c -> argc == 4 ) { if ( cg ) { raxRemove ( s -> cgroups , ( unsigned char * ) grpname , sdslen ( grpname ) , NULL ) ; streamFreeCG ( cg ) ; addReply ( c , shared . cone ) ; } else { addReply ( c , shared . czero ) ; } } else if ( ! strcasecmp ( opt , ""DELCONSUMER"" ) && c -> argc == 5 ) { long long pending = streamDelConsumer ( cg , c -> argv [ 4 ] -> ptr ) ; addReplyLongLong ( c , pending ) ; server . dirty ++ ; } else if ( ! strcasecmp ( opt , ""HELP"" ) ) { addReplyHelp ( c , help ) ; } else { addReply ( c , shared . syntaxerr ) ; } }
","<S2SV_ModStart> o == NULL || checkType ( c , o , OBJ_STREAM )
",antirez@redis/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,CVE-2018-12453,https://github.com/antirez/redis/commit/c04082cf138f1f51cedf05ee9ad36fb6763cafc6,2018-06-16T17:29Z
CWE-119,"CWE-119 char * _single_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 ) { len ++ ; } chr = malloc ( len + 1 ) ; len = 0 ; while ( in [ len ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; return chr ; }
","<S2SV_ModStart> ) { return NULL <S2SV_ModEnd> ; } while
",lurcher@unixODBC/45ef78e037f578b15fc58938a3a3251655e71d6f,CVE-2018-7485,https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f,2018-02-26T14:29Z
CWE-119,"CWE-119 void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }
","<S2SV_ModStart> ) ) { memset <S2SV_ModEnd> ( cpi ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp8_create_common ( VP8_COMMON * oci ) { vp8_machine_specific_config ( oci ) ; vp8_init_mbmode_probs ( oci ) ; vp8_default_bmode_probs ( oci -> fc . bmode_prob ) ; oci -> mb_no_coeff_skip = 1 ; oci -> no_lpf = 0 ; oci -> filter_type = NORMAL_LOOPFILTER ; oci -> use_bilinear_mc_filter = 0 ; oci -> full_pixel = 0 ; oci -> multi_token_partition = ONE_PARTITION ; oci -> clamp_type = RECON_CLAMP_REQUIRED ; <S2SV_StartBug> vpx_memset ( oci -> ref_frame_sign_bias , 0 , sizeof ( oci -> ref_frame_sign_bias ) ) ; <S2SV_EndBug> oci -> copy_buffer_to_gf = 0 ; oci -> copy_buffer_to_arf = 0 ; }
","<S2SV_ModStart> = RECON_CLAMP_REQUIRED ; memset <S2SV_ModEnd> ( oci ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; <S2SV_StartBug> int n , len ; <S2SV_EndBug> skb -> sk = NULL ; <S2SV_StartBug> memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; <S2SV_EndBug> len = ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; <S2SV_StartBug> if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { <S2SV_EndBug> rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_digis [ n ] ; make_rose -> neighbour = neigh ; make_rose -> device = dev ; make_rose -> facilities = facilities ; make_rose -> neighbour -> use ++ ; if ( rose_sk ( sk ) -> defer ) { make_rose -> state = ROSE_STATE_5 ; } else { rose_write_internal ( make , ROSE_CALL_ACCEPTED ) ; make_rose -> state = ROSE_STATE_3 ; rose_start_idletimer ( make ) ; } make_rose -> condition = 0x00 ; make_rose -> vs = 0 ; make_rose -> va = 0 ; make_rose -> vr = 0 ; make_rose -> vl = 0 ; sk -> sk_ack_backlog ++ ; rose_insert_socket ( make ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; rose_start_heartbeat ( make ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk , skb -> len ) ; return 1 ; }
","<S2SV_ModStart> ; int n <S2SV_ModEnd> ; skb -> <S2SV_ModStart> rose_facilities_struct ) ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> -> data + ROSE_CALL_REQ_FACILITIES_OFF , skb -> len - ROSE_CALL_REQ_FACILITIES_OFF , <S2SV_ModEnd> & facilities )
",torvalds@linux/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,CVE-2011-4914,https://github.com/torvalds/linux/commit/e0bccd315db0c2f919e7fcf9cb60db21d9986f52,2012-06-21T23:55Z
CWE-119,"CWE-119 static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder"" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , ""Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\n"" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , ""Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec"" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }
","<S2SV_ModStart> : 0 ; # if CONFIG_VP9_HIGHBITDEPTH flags |= stream -> config . use_16bit_internal ? VPX_CODEC_USE_HIGHBITDEPTH : 0 ; # endif <S2SV_ModStart> -> codec -> codec_interface <S2SV_ModEnd> ( ) , <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-399,"CWE-399 static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; <S2SV_StartBug> unsigned int link_count ; <S2SV_EndBug> bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; make_bad_inode ( inode ) ; return ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { <S2SV_StartBug> struct buffer_head * nbh = NULL ; <S2SV_EndBug> struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; <S2SV_StartBug> if ( ie -> indirectICB . extLength && <S2SV_EndBug> <S2SV_StartBug> ( nbh = udf_read_ptagged ( inode -> i_sb , & loc , 0 , <S2SV_EndBug> & ident ) ) ) { if ( ident == TAG_IDENT_FE || ident == TAG_IDENT_EFE ) { memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; brelse ( bh ) ; brelse ( ibh ) ; brelse ( nbh ) ; __udf_read_inode ( inode ) ; return ; } <S2SV_StartBug> brelse ( nbh ) ; <S2SV_EndBug> } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; brelse ( bh ) ; make_bad_inode ( inode ) ; return ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; if ( udf_alloc_i_data ( inode , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ) { make_bad_inode ( inode ) ; return ; } memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , inode -> i_sb -> s_blocksize - sizeof ( struct unallocSpaceEntry ) ) ; return ; } read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) link_count = 1 ; set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; make_bad_inode ( inode ) ; return ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else make_bad_inode ( inode ) ; } brelse ( bh ) ; }
","<S2SV_ModStart> int link_count ; unsigned int indirections = 0 ; reread : <S2SV_ModStart> ) { struct <S2SV_ModEnd> kernel_lb_addr loc ; <S2SV_ModStart> indirectICB . extLength ) { brelse ( bh ) ; brelse ( ibh ) ; memcpy ( & iinfo -> i_location <S2SV_ModEnd> , & loc <S2SV_ModStart> & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; make_bad_inode <S2SV_ModEnd> ( inode ) <S2SV_ModStart> return ; } goto reread <S2SV_ModEnd> ; } }
",torvalds@linux/c03aa9f6e1f938618e6db2e23afef0574efeeb65,CVE-2014-6410,https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65,2014-09-28T10:55Z
CWE-190,"CWE-190 static int uvesafb_setcmap ( struct fb_cmap * cmap , struct fb_info * info ) { struct uvesafb_pal_entry * entries ; int shift = 16 - dac_width ; int i , err = 0 ; if ( info -> var . bits_per_pixel == 8 ) { if ( cmap -> start + cmap -> len > info -> cmap . start + info -> cmap . len || cmap -> start < info -> cmap . start ) return - EINVAL ; <S2SV_StartBug> entries = kmalloc ( sizeof ( * entries ) * cmap -> len , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! entries ) return - ENOMEM ; for ( i = 0 ; i < cmap -> len ; i ++ ) { entries [ i ] . red = cmap -> red [ i ] >> shift ; entries [ i ] . green = cmap -> green [ i ] >> shift ; entries [ i ] . blue = cmap -> blue [ i ] >> shift ; entries [ i ] . pad = 0 ; } err = uvesafb_setpalette ( entries , cmap -> len , cmap -> start , info ) ; kfree ( entries ) ; } else { for ( i = 0 ; i < cmap -> len ; i ++ ) { err |= uvesafb_setcolreg ( cmap -> start + i , cmap -> red [ i ] , cmap -> green [ i ] , cmap -> blue [ i ] , 0 , info ) ; } } return err ; }
","<S2SV_ModStart> ; entries = kmalloc_array ( cmap -> len , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> * entries ) , <S2SV_ModEnd> GFP_KERNEL ) ;
",torvalds@linux/9f645bcc566a1e9f921bdae7528a01ced5bc3713,CVE-2018-13406,https://github.com/torvalds/linux/commit/9f645bcc566a1e9f921bdae7528a01ced5bc3713,2018-07-06T14:29Z
CWE-119,"CWE-119 unsigned int X509v3_addr_get_afi ( const IPAddressFamily * f ) { <S2SV_StartBug> return ( ( f != NULL && <S2SV_EndBug> <S2SV_StartBug> f -> addressFamily != NULL && f -> addressFamily -> data != NULL ) <S2SV_EndBug> <S2SV_StartBug> ? ( ( f -> addressFamily -> data [ 0 ] << 8 ) | ( f -> addressFamily -> data [ 1 ] ) ) <S2SV_EndBug> : 0 ) ; }
","<S2SV_ModStart> f ) { if ( f == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> f -> addressFamily == NULL || <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> addressFamily -> data == NULL || f -> addressFamily -> length < 2 ) return 0 ; return <S2SV_ModEnd> ( f -> <S2SV_ModStart> 8 ) | <S2SV_ModEnd> f -> addressFamily <S2SV_ModStart> [ 1 ] <S2SV_ModEnd> ; } <S2SV_null>
",openssl@openssl/068b963bb7afc57f5bdd723de0dd15e7795d5822,CVE-2017-3735,https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822,2017-08-28T19:29Z
CWE-362,"CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , ""tty_ioctl"" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <S2SV_StartBug> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <S2SV_EndBug> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }
","<S2SV_ModStart> TIOCGETD : return tiocgetd ( tty , <S2SV_ModEnd> p ) ;
",torvalds@linux/5c17c861a357e9458001f021a7afa7aab9937439,CVE-2016-0723,https://github.com/torvalds/linux/commit/5c17c861a357e9458001f021a7afa7aab9937439,2016-02-08T03:59Z
CWE-787,"CWE-787 static PixelChannels * * AcquirePixelThreadSet ( const Image * images ) { const Image * next ; PixelChannels * * pixels ; register ssize_t i ; size_t columns , <S2SV_StartBug> number_threads ; <S2SV_EndBug> <S2SV_StartBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; <S2SV_EndBug> <S2SV_StartBug> pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; <S2SV_StartBug> ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_EndBug> columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( columns , sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; for ( j = 0 ; j < ( ssize_t ) columns ; j ++ ) { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }
","<S2SV_ModStart> size_t columns , rows ; rows = MagickMax ( GetImageListLength ( images ) , <S2SV_ModEnd> ( size_t ) <S2SV_ModStart> ( ThreadResource ) ) <S2SV_ModStart> ) AcquireQuantumMemory ( rows , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> NULL ) ; columns = MaxPixelChannels ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( i = 0 <S2SV_ModEnd> ; i < <S2SV_ModStart> ( ssize_t ) rows <S2SV_ModEnd> ; i ++
",ImageMagick@ImageMagick/025e77fcb2f45b21689931ba3bf74eac153afa48,CVE-2019-13307,https://github.com/ImageMagick/ImageMagick/commit/025e77fcb2f45b21689931ba3bf74eac153afa48,2019-07-05T01:15Z
CWE-125,"CWE-125 static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>sum<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>off<S2SV_blank>0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",<S2SV_blank>seq<S2SV_blank>%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; af = EXTRACT_16BITS ( bp ) ; sreoff = * ( bp + 2 ) ; srelen = * ( bp + 3 ) ; bp += 4 ; len -= 4 ; if ( af == 0 && srelen == 0 ) break ; if ( ! gre_sre_print ( ndo , af , sreoff , srelen , bp , len ) ) goto trunc ; if ( len < srelen ) goto trunc ; bp += srelen ; len -= srelen ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>proto<S2SV_blank>%s<S2SV_blank>(0x%04x)"" , tok2str ( ethertype_values , ""unknown"" , prot ) , prot ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>length<S2SV_blank>%u"" , length ) ) ; if ( ndo -> ndo_vflag < 1 ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; switch ( prot ) { case ETHERTYPE_IP : ip_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPV6 : ip6_print ( ndo , bp , len ) ; break ; case ETHERTYPE_MPLS : mpls_print ( ndo , bp , len ) ; break ; case ETHERTYPE_IPX : ipx_print ( ndo , bp , len ) ; break ; case ETHERTYPE_ATALK : atalk_print ( ndo , bp , len ) ; break ; case ETHERTYPE_GRE_ISO : <S2SV_StartBug> isoclns_print ( ndo , bp , len , ndo -> ndo_snapend - bp ) ; <S2SV_EndBug> break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len , ndo -> ndo_snapend - bp , NULL , NULL ) ; break ; default : ND_PRINT ( ( ndo , ""gre-proto-0x%x"" , prot ) ) ; } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> bp , len ) ; break ; case ETHERTYPE_TEB : ether_print ( ndo , bp , len <S2SV_ModStart> ndo_snapend - bp <S2SV_ModEnd> , NULL ,
",the-tcpdump-group@tcpdump/1dcd10aceabbc03bf571ea32b892c522cbe923de,CVE-2017-12897,https://github.com/the-tcpdump-group/tcpdump/commit/1dcd10aceabbc03bf571ea32b892c522cbe923de,2017-09-14T06:29Z
CWE-119,"CWE-119 <S2SV_StartBug> void vp9_rc_init ( const VP9_CONFIG * oxcf , int pass , RATE_CONTROL * rc ) { <S2SV_EndBug> <S2SV_StartBug> if ( pass == 0 && oxcf -> end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = oxcf -> worst_allowed_q ; <S2SV_EndBug> rc -> avg_frame_qindex [ 2 ] = oxcf -> worst_allowed_q ; } else { <S2SV_StartBug> rc -> avg_frame_qindex [ 0 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> oxcf -> best_allowed_q ) / 2 ; <S2SV_StartBug> rc -> avg_frame_qindex [ 1 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> oxcf -> best_allowed_q ) / 2 ; <S2SV_StartBug> rc -> avg_frame_qindex [ 2 ] = ( oxcf -> worst_allowed_q + <S2SV_EndBug> oxcf -> best_allowed_q ) / 2 ; } <S2SV_StartBug> rc -> last_q [ 0 ] = oxcf -> best_allowed_q ; <S2SV_EndBug> rc -> last_q [ 1 ] = oxcf -> best_allowed_q ; rc -> last_q [ 2 ] = oxcf -> best_allowed_q ; rc -> buffer_level = oxcf -> starting_buffer_level ; rc -> bits_off_target = oxcf -> starting_buffer_level ; rc -> rolling_target_bits = rc -> av_per_frame_bandwidth ; rc -> rolling_actual_bits = rc -> av_per_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> av_per_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> av_per_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> baseline_gf_interval = DEFAULT_GF_INTERVAL ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q ) ; rc -> rate_correction_factor = 1.0 ; rc -> key_frame_rate_correction_factor = 1.0 ; rc -> gf_rate_correction_factor = 1.0 ; }
","<S2SV_ModStart> vp9_rc_init ( const VP9EncoderConfig <S2SV_ModEnd> * oxcf , <S2SV_ModStart> rc ) { int i ; <S2SV_ModStart> && oxcf -> rc_mode == VPX_CBR <S2SV_ModEnd> ) { rc <S2SV_ModStart> -> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = oxcf <S2SV_ModStart> -> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = oxcf <S2SV_ModStart> -> avg_frame_qindex [ KEY_FRAME <S2SV_ModEnd> ] = ( <S2SV_ModStart> -> avg_frame_qindex [ INTER_FRAME <S2SV_ModEnd> ] = ( <S2SV_ModStart> / 2 ; } rc -> last_q [ KEY_FRAME ] = oxcf -> best_allowed_q ; rc -> last_q [ INTER_FRAME ] = oxcf -> worst_allowed_q ; rc -> buffer_level = rc -> starting_buffer_level ; rc -> bits_off_target = rc -> starting_buffer_level ; rc -> rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_target_bits = rc -> avg_frame_bandwidth ; rc -> long_rolling_actual_bits = rc -> avg_frame_bandwidth ; rc -> total_actual_bits = 0 ; rc -> total_target_bits = 0 ; rc -> total_target_vs_actual = 0 ; rc -> frames_since_key = 8 ; rc -> this_key_frame_forced = 0 ; rc -> next_key_frame_forced = 0 ; rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 0 ; rc -> frames_till_gf_update_due = 0 ; rc -> ni_av_qi = oxcf -> worst_allowed_q ; rc -> ni_tot_qi = 0 ; rc -> ni_frames = 0 ; rc -> tot_q = 0.0 ; rc -> avg_q = vp9_convert_qindex_to_q ( oxcf -> worst_allowed_q , oxcf -> bit_depth ) ; for ( i = 0 ; i < RATE_FACTOR_LEVELS ; ++ i ) { rc -> rate_correction_factors [ i ] = 1.0 ; } rc -> min_gf_interval = oxcf -> min_gf_interval ; rc -> max_gf_interval = oxcf -> max_gf_interval ; if ( rc -> min_gf_interval == 0 ) rc -> min_gf_interval = vp9_rc_get_default_min_gf_interval ( oxcf -> width , oxcf -> height , oxcf -> init_framerate ) ; if ( rc -> max_gf_interval == 0 ) rc -> max_gf_interval = vp9_rc_get_default_max_gf_interval ( oxcf -> init_framerate , rc -> min_gf_interval ) ; rc -> baseline_gf_interval = ( rc -> min_gf_interval + rc -> max_gf_interval <S2SV_ModEnd> ) / 2 <S2SV_ModStart> 2 ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-000,"CWE-000 static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , struct iovec * iovec ) { <S2SV_StartBug> if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) <S2SV_EndBug> return - EFAULT ; iovec -> iov_base = buf ; <S2SV_StartBug> iovec -> iov_len = kiocb -> ki_nbytes ; <S2SV_EndBug> * nr_segs = 1 ; return 0 ; }
","<S2SV_ModStart> iovec ) { size_t len = kiocb -> ki_nbytes ; if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> iov_len = len <S2SV_ModEnd> ; * nr_segs
",torvalds@linux/c4f4b82694fe48b02f7a881a1797131a6dad1364,CVE-2015-8830,https://github.com/torvalds/linux/commit/c4f4b82694fe48b02f7a881a1797131a6dad1364,2016-05-02T10:59Z
CWE-787,"CWE-787 static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , ""process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d"" , type ) ; } s -> p = next_order ; }
","<S2SV_ModStart> * next_order ; struct stream packet = * s ; <S2SV_ModStart> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; }
",rdesktop@rdesktop/4dca546d04321a610c1835010b5dad85163b65e1,CVE-2018-8800,https://github.com/rdesktop/rdesktop/commit/4dca546d04321a610c1835010b5dad85163b65e1,2019-02-05T20:29Z
CWE-20,"CWE-20 static int mxf_read_primer_pack ( void * arg , AVIOContext * pb , int tag , int size , UID uid , int64_t klv_offset ) { MXFContext * mxf = arg ; int item_num = avio_rb32 ( pb ) ; int item_len = avio_rb32 ( pb ) ; if ( item_len != 18 ) { avpriv_request_sample ( pb , ""Primer<S2SV_blank>pack<S2SV_blank>item<S2SV_blank>length<S2SV_blank>%d"" , item_len ) ; return AVERROR_PATCHWELCOME ; } <S2SV_StartBug> if ( item_num > 65536 ) { <S2SV_EndBug> av_log ( mxf -> fc , AV_LOG_ERROR , ""item_num<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large\\n"" , item_num ) ; return AVERROR_INVALIDDATA ; } if ( mxf -> local_tags ) av_log ( mxf -> fc , AV_LOG_VERBOSE , ""Multiple<S2SV_blank>primer<S2SV_blank>packs\\n"" ) ; av_free ( mxf -> local_tags ) ; mxf -> local_tags_count = 0 ; mxf -> local_tags = av_calloc ( item_num , item_len ) ; if ( ! mxf -> local_tags ) return AVERROR ( ENOMEM ) ; mxf -> local_tags_count = item_num ; avio_read ( pb , mxf -> local_tags , item_num * item_len ) ; return 0 ; }
","<S2SV_ModStart> item_num > 65536 || item_num < 0
",FFmpeg@FFmpeg/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad,CVE-2017-14169,https://github.com/FFmpeg/FFmpeg/commit/9d00fb9d70ee8c0cc7002b89318c5be00f1bbdad,2017-09-07T06:29Z
CWE-404,"CWE-404 int nfssvc_decode_readlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_readlinkargs * args ) { p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; <S2SV_StartBug> args -> buffer = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; <S2SV_EndBug> <S2SV_StartBug> return xdr_argsize_check ( rqstp , p ) ; <S2SV_EndBug> }
","<S2SV_ModStart> return 0 ; if ( ! xdr_argsize_check ( rqstp , p ) ) return 0 ; <S2SV_ModStart> ) ; return 1 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/c70422f760c120480fee4de6c38804c72aa26bc1,CVE-2017-9059,https://github.com/torvalds/linux/commit/c70422f760c120480fee4de6c38804c72aa26bc1,2017-05-18T06:29Z
CWE-476,"CWE-476 GF_Err MergeTrack ( GF_TrackBox * trak , GF_TrackFragmentBox * traf , GF_MovieFragmentBox * moof_box , u64 moof_offset , s32 compressed_diff , u64 * cumulated_offset , Bool is_first_merge ) { u32 i , j , chunk_size , track_num ; u64 base_offset , data_offset , traf_duration ; u32 def_duration , DescIndex , def_size , def_flags ; u32 duration , size , flags , prev_trun_data_offset , sample_index ; u8 pad , sync ; u16 degr ; Bool first_samp_in_traf = GF_TRUE ; Bool store_traf_map = GF_FALSE ; u8 * moof_template = NULL ; u32 moof_template_size = 0 ; Bool is_seg_start = GF_FALSE ; u64 seg_start = 0 , sidx_start = 0 , sidx_end = 0 , frag_start = 0 , last_dts = 0 ; GF_TrackFragmentRunBox * trun ; GF_TrunEntry * ent ; # ifdef GF_ENABLE_CTRN GF_TrackFragmentBox * traf_ref = NULL ; # endif GF_Err stbl_AppendTime ( GF_SampleTableBox * stbl , u32 duration , u32 nb_pack ) ; GF_Err stbl_AppendSize ( GF_SampleTableBox * stbl , u32 size , u32 nb_pack ) ; GF_Err stbl_AppendChunk ( GF_SampleTableBox * stbl , u64 offset ) ; GF_Err stbl_AppendSampleToChunk ( GF_SampleTableBox * stbl , u32 DescIndex , u32 samplesInChunk ) ; GF_Err stbl_AppendCTSOffset ( GF_SampleTableBox * stbl , s32 CTSOffset ) ; GF_Err stbl_AppendRAP ( GF_SampleTableBox * stbl , u8 isRap ) ; GF_Err stbl_AppendPadding ( GF_SampleTableBox * stbl , u8 padding ) ; GF_Err stbl_AppendDegradation ( GF_SampleTableBox * stbl , u16 DegradationPriority ) ; if ( trak -> Header -> trackID != traf -> tfhd -> trackID ) return GF_OK ; if ( ! trak -> Media -> information -> sampleTable || ! trak -> Media -> information -> sampleTable -> SampleSize || ! trak -> Media -> information -> sampleTable -> TimeToSample || ! trak -> Media -> information -> sampleTable -> SampleToChunk || ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { return GF_ISOM_INVALID_FILE ; } if ( ! traf -> trex -> track ) traf -> trex -> track = trak ; DescIndex = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DESC ) ? traf -> tfhd -> sample_desc_index : traf -> trex -> def_sample_desc_index ; if ( ! DescIndex ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>0,<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" ) ) ; DescIndex = 1 ; } else if ( DescIndex > gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>default<S2SV_blank>sample<S2SV_blank>description<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>sample<S2SV_blank>description(s),<S2SV_blank>likely<S2SV_blank>broken<S2SV_blank>!<S2SV_blank>Fixing<S2SV_blank>to<S2SV_blank>1\\n"" , DescIndex , gf_list_count ( trak -> Media -> information -> sampleTable -> SampleDescription -> child_boxes ) ) ) ; DescIndex = 1 ; } # ifdef GF_ENABLE_CTRN if ( traf -> trex -> inherit_from_traf_id ) { u32 traf_count = gf_list_count ( moof_box -> TrackList ) ; for ( i = 0 ; i < traf_count ; i ++ ) { GF_TrackFragmentBox * atraf = gf_list_get ( moof_box -> TrackList , i ) ; if ( atraf -> tfhd && atraf -> tfhd -> trackID == traf -> trex -> inherit_from_traf_id ) { traf_ref = atraf ; break ; } } } # endif def_duration = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_DUR ) ? traf -> tfhd -> def_sample_duration : traf -> trex -> def_sample_duration ; def_size = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_SIZE ) ? traf -> tfhd -> def_sample_size : traf -> trex -> def_sample_size ; def_flags = ( traf -> tfhd -> flags & GF_ISOM_TRAF_SAMPLE_FLAGS ) ? traf -> tfhd -> def_sample_flags : traf -> trex -> def_sample_flags ; base_offset = moof_offset ; if ( traf -> tfhd -> flags & GF_ISOM_TRAF_BASE_OFFSET ) base_offset = traf -> tfhd -> base_data_offset ; else if ( ! ( traf -> tfhd -> flags & GF_ISOM_MOOF_BASE_OFFSET ) ) base_offset = * cumulated_offset ; chunk_size = 0 ; prev_trun_data_offset = 0 ; data_offset = 0 ; traf_duration = 0 ; if ( traf -> tfdt && is_first_merge ) { # ifndef GPAC_DISABLE_LOG if ( trak -> moov -> mov -> NextMoofNumber && trak -> present_in_scalable_segment && trak -> sample_count_at_seg_start && ( trak -> dts_at_seg_start != traf -> tfdt -> baseMediaDecodeTime ) ) { s32 drift = ( s32 ) ( ( s64 ) traf -> tfdt -> baseMediaDecodeTime - ( s64 ) trak -> dts_at_seg_start ) ; if ( drift < 0 ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Warning:<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>less<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>-<S2SV_blank>using<S2SV_blank>tfdt\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } else { GF_LOG ( GF_LOG_INFO , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>TFDT<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>higher<S2SV_blank>than<S2SV_blank>cumulated<S2SV_blank>timing<S2SV_blank>"" LLD ""<S2SV_blank>(last<S2SV_blank>sample<S2SV_blank>got<S2SV_blank>extended<S2SV_blank>in<S2SV_blank>duration)\\n"" , traf -> tfdt -> baseMediaDecodeTime , trak -> dts_at_seg_start ) ) ; } } # endif trak -> dts_at_seg_start = traf -> tfdt -> baseMediaDecodeTime ; } else if ( traf -> tfxd ) { trak -> dts_at_seg_start = traf -> tfxd -> absolute_time_in_track_timescale ; } if ( traf -> tfxd ) { trak -> last_tfxd_value = traf -> tfxd -> absolute_time_in_track_timescale ; trak -> last_tfxd_value += traf -> tfxd -> fragment_duration_in_track_timescale ; } if ( traf -> tfrf ) { if ( trak -> tfrf ) gf_isom_box_del_parent ( & trak -> child_boxes , ( GF_Box * ) trak -> tfrf ) ; trak -> tfrf = traf -> tfrf ; gf_list_del_item ( traf -> child_boxes , traf -> tfrf ) ; gf_list_add ( trak -> child_boxes , trak -> tfrf ) ; } if ( trak -> moov -> mov -> signal_frag_bounds ) { store_traf_map = GF_TRUE ; if ( is_first_merge ) { GF_MovieFragmentBox * moof_clone = NULL ; gf_isom_box_freeze_order ( ( GF_Box * ) moof_box ) ; gf_isom_clone_box ( ( GF_Box * ) moof_box , ( GF_Box * * ) & moof_clone ) ; if ( moof_clone ) { GF_BitStream * bs ; for ( i = 0 ; i < gf_list_count ( moof_clone -> TrackList ) ; i ++ ) { GF_TrackFragmentBox * traf_clone = gf_list_get ( moof_clone -> TrackList , i ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> TrackRuns ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroups ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sampleGroupsDescription ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sub_samples ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_offsets ) ; gf_isom_box_array_reset_parent ( & traf_clone -> child_boxes , traf_clone -> sai_sizes ) ; if ( traf_clone -> sample_encryption ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sample_encryption ) ; traf_clone -> sample_encryption = NULL ; } if ( traf_clone -> sdtp ) { gf_isom_box_del_parent ( & traf_clone -> child_boxes , ( GF_Box * ) traf_clone -> sdtp ) ; traf_clone -> sdtp = NULL ; } } gf_isom_box_size ( ( GF_Box * ) moof_clone ) ; bs = gf_bs_new ( NULL , 0 , GF_BITSTREAM_WRITE ) ; if ( trak -> moov -> mov -> seg_styp ) { gf_isom_box_size ( trak -> moov -> mov -> seg_styp ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_styp , bs ) ; } if ( trak -> moov -> mov -> root_sidx ) { gf_isom_box_size ( ( GF_Box * ) trak -> moov -> mov -> root_sidx ) ; gf_isom_box_write ( ( GF_Box * ) trak -> moov -> mov -> root_sidx , bs ) ; } if ( trak -> moov -> mov -> seg_ssix ) { gf_isom_box_size ( trak -> moov -> mov -> seg_ssix ) ; gf_isom_box_write ( trak -> moov -> mov -> seg_ssix , bs ) ; } gf_isom_box_write ( ( GF_Box * ) moof_clone , bs ) ; gf_isom_box_del ( ( GF_Box * ) moof_clone ) ; gf_bs_get_content ( bs , & moof_template , & moof_template_size ) ; gf_bs_del ( bs ) ; } } if ( trak -> moov -> mov -> seg_styp ) { is_seg_start = GF_TRUE ; seg_start = trak -> moov -> mov -> styp_start_offset ; } if ( trak -> moov -> mov -> root_sidx ) { is_seg_start = GF_TRUE ; sidx_start = trak -> moov -> mov -> sidx_start_offset ; sidx_end = trak -> moov -> mov -> sidx_end_offset ; if ( ! seg_start || ( sidx_start < seg_start ) ) seg_start = sidx_start ; } frag_start = trak -> moov -> mov -> current_top_box_start ; } else if ( trak -> moov -> mov -> store_traf_map ) { store_traf_map = GF_TRUE ; } sample_index = 0 ; i = 0 ; while ( ( trun = ( GF_TrackFragmentRunBox * ) gf_list_enum ( traf -> TrackRuns , & i ) ) ) { for ( j = 0 ; j < trun -> sample_count ; j ++ ) { GF_Err e ; s32 cts_offset = 0 ; if ( j < trun -> nb_samples ) { ent = & trun -> samples [ j ] ; } else { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>enough<S2SV_blank>trun<S2SV_blank>entries<S2SV_blank>(%d)<S2SV_blank>compared<S2SV_blank>to<S2SV_blank>sample<S2SV_blank>count<S2SV_blank>(%d)<S2SV_blank>in<S2SV_blank>run\\n"" , traf -> trex -> trackID , trun -> nb_samples , trun -> sample_count ) ) ; break ; } size = def_size ; duration = def_duration ; flags = def_flags ; cts_offset = ent -> CTS_Offset ; # ifdef GF_ENABLE_CTRN if ( trun -> use_ctrn ) { if ( ! j && ( trun -> ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE ) ) { if ( trun -> ctrn_first_dur ) duration = ent -> Duration ; if ( trun -> ctrn_first_size ) size = ent -> size ; if ( trun -> ctrn_first_ctts ) flags = ent -> flags ; } else { if ( trun -> ctrn_dur ) duration = ent -> Duration ; if ( trun -> ctrn_size ) size = ent -> size ; if ( trun -> ctrn_sample_flags ) flags = ent -> flags ; } if ( trun -> ctrn_flags & 0xF0 ) { GF_TrunEntry * ref_entry ; if ( ! traf_ref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>to<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>reference<S2SV_blank>traf<S2SV_blank>not<S2SV_blank>found\\n"" , traf -> trex -> trackID , traf -> trex -> inherit_from_traf_id ) ) ; break ; } ref_entry = traf_get_sample_entry ( traf_ref , sample_index ) ; if ( ! ref_entry ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[iso<S2SV_blank>file]<S2SV_blank>Track<S2SV_blank>%d<S2SV_blank>use<S2SV_blank>traf<S2SV_blank>inheritance<S2SV_blank>but<S2SV_blank>sample<S2SV_blank>%d<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>reference<S2SV_blank>traf\\n"" , traf -> trex -> trackID , sample_index + 1 ) ) ; break ; } if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR ) duration = ref_entry -> Duration ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE ) size = ref_entry -> size ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS ) flags = ref_entry -> flags ; if ( trun -> ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO ) cts_offset = ref_entry -> CTS_Offset ; } } else # endif { if ( trun -> flags & GF_ISOM_TRUN_DURATION ) duration = ent -> Duration ; if ( trun -> flags & GF_ISOM_TRUN_SIZE ) size = ent -> size ; if ( trun -> flags & GF_ISOM_TRUN_FLAGS ) { flags = ent -> flags ; } else if ( ! j && ( trun -> flags & GF_ISOM_TRUN_FIRST_FLAG ) ) { flags = trun -> first_sample_flags ; } } sample_index ++ ; ent -> size = size ; ent -> Duration = duration ; ent -> flags = flags ; ent -> CTS_Offset = cts_offset ; last_dts += duration ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) { trak -> Media -> information -> sampleTable -> SampleSize = ( GF_SampleSizeBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSZ ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleSize ) return GF_OUT_OF_MEM ; } e = stbl_AppendSize ( trak -> Media -> information -> sampleTable , size , ent -> nb_pack ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) { trak -> Media -> information -> sampleTable -> TimeToSample = ( GF_TimeToSampleBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STTS ) ; if ( ! trak -> Media -> information -> sampleTable -> TimeToSample ) return GF_OUT_OF_MEM ; } e = stbl_AppendTime ( trak -> Media -> information -> sampleTable , duration , ent -> nb_pack ) ; if ( e ) return e ; if ( ! j ) { u64 final_offset ; data_offset = base_offset ; if ( trun -> flags & GF_ISOM_TRUN_DATA_OFFSET ) { data_offset += trun -> data_offset ; chunk_size = 0 ; prev_trun_data_offset = trun -> data_offset ; if ( trun -> data_offset >= 0 ) { data_offset -= compressed_diff ; prev_trun_data_offset -= compressed_diff ; } } else if ( prev_trun_data_offset ) { data_offset += prev_trun_data_offset + chunk_size ; } else { data_offset += chunk_size ; if ( ( i == 1 ) && ( trun -> data_offset >= 0 ) ) { data_offset -= compressed_diff ; } } final_offset = data_offset ; if ( trak -> moov -> compressed_diff ) { final_offset += trak -> moov -> compressed_diff ; } if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) { trak -> Media -> information -> sampleTable -> ChunkOffset = gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STCO ) ; if ( ! trak -> Media -> information -> sampleTable -> ChunkOffset ) return GF_OUT_OF_MEM ; } e = stbl_AppendChunk ( trak -> Media -> information -> sampleTable , final_offset ) ; if ( e ) return e ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) { trak -> Media -> information -> sampleTable -> SampleToChunk = ( GF_SampleToChunkBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_STSC ) ; if ( ! trak -> Media -> information -> sampleTable -> SampleToChunk ) return GF_OUT_OF_MEM ; } e = stbl_AppendSampleToChunk ( trak -> Media -> information -> sampleTable , DescIndex , trun -> sample_count ) ; if ( e ) return e ; } chunk_size += size ; if ( store_traf_map && first_samp_in_traf ) { first_samp_in_traf = GF_FALSE ; e = stbl_AppendTrafMap ( trak -> Media -> information -> sampleTable , is_seg_start , seg_start , frag_start , moof_template , moof_template_size , sidx_start , sidx_end ) ; if ( e ) return e ; moof_template = NULL ; moof_template_size = 0 ; } if ( ent -> nb_pack > 1 ) { j += ent -> nb_pack - 1 ; traf_duration += ent -> nb_pack * duration ; continue ; } traf_duration += duration ; e = stbl_AppendCTSOffset ( trak -> Media -> information -> sampleTable , cts_offset ) ; if ( e ) return e ; sync = GF_ISOM_GET_FRAG_SYNC ( flags ) ; if ( trak -> Media -> information -> sampleTable -> no_sync_found && sync ) { trak -> Media -> information -> sampleTable -> no_sync_found = 0 ; } e = stbl_AppendRAP ( trak -> Media -> information -> sampleTable , sync ) ; if ( e ) return e ; pad = GF_ISOM_GET_FRAG_PAD ( flags ) ; if ( pad ) { e = stbl_AppendPadding ( trak -> Media -> information -> sampleTable , pad ) ; if ( e ) return e ; } degr = GF_ISOM_GET_FRAG_DEG ( flags ) ; if ( degr ) { e = stbl_AppendDegradation ( trak -> Media -> information -> sampleTable , degr ) ; if ( e ) return e ; } e = stbl_AppendDependencyType ( trak -> Media -> information -> sampleTable , GF_ISOM_GET_FRAG_LEAD ( flags ) , GF_ISOM_GET_FRAG_DEPENDS ( flags ) , GF_ISOM_GET_FRAG_DEPENDED ( flags ) , GF_ISOM_GET_FRAG_REDUNDANT ( flags ) ) ; if ( e ) return e ; } } if ( trak -> moov -> mov -> is_smooth && ! traf -> tfdt && ! traf -> tfxd ) { if ( is_first_merge ) trak -> dts_at_seg_start = trak -> dts_at_next_seg_start ; trak -> dts_at_next_seg_start += last_dts ; } if ( traf_duration && trak -> editBox && trak -> editBox -> editList ) { for ( i = 0 ; i < gf_list_count ( trak -> editBox -> editList -> entryList ) ; i ++ ) { GF_EdtsEntry * edts_e = gf_list_get ( trak -> editBox -> editList -> entryList , i ) ; if ( edts_e -> was_empty_dur ) { u64 extend_dur = traf_duration ; extend_dur *= trak -> moov -> mvhd -> timeScale ; extend_dur /= trak -> Media -> mediaHeader -> timeScale ; edts_e -> segmentDuration += extend_dur ; } else if ( ! edts_e -> segmentDuration ) { edts_e -> was_empty_dur = GF_TRUE ; if ( ( s64 ) traf_duration > edts_e -> mediaTime ) traf_duration -= edts_e -> mediaTime ; else traf_duration = 0 ; edts_e -> segmentDuration = traf_duration ; edts_e -> segmentDuration *= trak -> moov -> mvhd -> timeScale ; edts_e -> segmentDuration /= trak -> Media -> mediaHeader -> timeScale ; } } } * cumulated_offset = data_offset + chunk_size ; if ( traf -> sampleGroups ) { GF_List * groups ; GF_List * groupDescs ; Bool is_identical_sgpd = GF_TRUE ; u32 * new_idx = NULL , new_idx_count = 0 ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroups ) trak -> Media -> information -> sampleTable -> sampleGroups = gf_list_new ( ) ; if ( ! trak -> Media -> information -> sampleTable -> sampleGroupsDescription ) trak -> Media -> information -> sampleTable -> sampleGroupsDescription = gf_list_new ( ) ; groupDescs = trak -> Media -> information -> sampleTable -> sampleGroupsDescription ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroupsDescription ) ; i ++ ) { GF_SampleGroupDescriptionBox * new_sgdesc = NULL ; GF_SampleGroupDescriptionBox * sgdesc = gf_list_get ( traf -> sampleGroupsDescription , i ) ; for ( j = 0 ; j < gf_list_count ( groupDescs ) ; j ++ ) { new_sgdesc = gf_list_get ( groupDescs , j ) ; if ( new_sgdesc -> grouping_type == sgdesc -> grouping_type ) break ; new_sgdesc = NULL ; } if ( ! new_sgdesc ) { gf_list_add ( groupDescs , sgdesc ) ; gf_list_add ( trak -> Media -> information -> sampleTable -> child_boxes , sgdesc ) ; gf_list_rem ( traf -> sampleGroupsDescription , i ) ; gf_list_del_item ( traf -> child_boxes , sgdesc ) ; i -- ; } else { u32 count ; is_identical_sgpd = gf_isom_is_identical_sgpd ( new_sgdesc , sgdesc , 0 ) ; if ( is_identical_sgpd ) continue ; new_idx_count = gf_list_count ( sgdesc -> group_descriptions ) ; new_idx = ( u32 * ) gf_malloc ( new_idx_count * sizeof ( u32 ) ) ; if ( ! new_idx ) return GF_OUT_OF_MEM ; count = 0 ; while ( gf_list_count ( sgdesc -> group_descriptions ) ) { void * sgpd_entry = gf_list_get ( sgdesc -> group_descriptions , 0 ) ; Bool new_entry = GF_TRUE ; for ( j = 0 ; j < gf_list_count ( new_sgdesc -> group_descriptions ) ; j ++ ) { void * ptr = gf_list_get ( new_sgdesc -> group_descriptions , j ) ; if ( gf_isom_is_identical_sgpd ( sgpd_entry , ptr , new_sgdesc -> grouping_type ) ) { new_idx [ count ] = j + 1 ; count ++ ; new_entry = GF_FALSE ; gf_free ( sgpd_entry ) ; break ; } } if ( new_entry ) { gf_list_add ( new_sgdesc -> group_descriptions , sgpd_entry ) ; new_idx [ count ] = gf_list_count ( new_sgdesc -> group_descriptions ) ; count ++ ; } gf_list_rem ( sgdesc -> group_descriptions , 0 ) ; } } } groups = trak -> Media -> information -> sampleTable -> sampleGroups ; for ( i = 0 ; i < gf_list_count ( traf -> sampleGroups ) ; i ++ ) { GF_SampleGroupBox * stbl_group = NULL ; GF_SampleGroupBox * frag_group = gf_list_get ( traf -> sampleGroups , i ) ; for ( j = 0 ; j < gf_list_count ( groups ) ; j ++ ) { stbl_group = gf_list_get ( groups , j ) ; if ( ( frag_group -> grouping_type == stbl_group -> grouping_type ) && ( frag_group -> grouping_type_parameter == stbl_group -> grouping_type_parameter ) ) break ; stbl_group = NULL ; } if ( ! stbl_group ) { stbl_group = ( GF_SampleGroupBox * ) gf_isom_box_new_parent ( & trak -> Media -> information -> sampleTable -> child_boxes , GF_ISOM_BOX_TYPE_SBGP ) ; if ( ! stbl_group ) return GF_OUT_OF_MEM ; stbl_group -> grouping_type = frag_group -> grouping_type ; stbl_group -> grouping_type_parameter = frag_group -> grouping_type_parameter ; stbl_group -> version = frag_group -> version ; gf_list_add ( groups , stbl_group ) ; } if ( is_identical_sgpd ) { for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) frag_group -> sample_entries [ j ] . group_description_index &= 0x0FFFF ; if ( frag_group -> entry_count && stbl_group -> entry_count && ( frag_group -> sample_entries [ 0 ] . group_description_index == stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . group_description_index ) ) { stbl_group -> sample_entries [ stbl_group -> entry_count - 1 ] . sample_count += frag_group -> sample_entries [ 0 ] . sample_count ; if ( frag_group -> entry_count > 1 ) { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count - 1 ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 1 ] , sizeof ( GF_SampleGroupEntry ) * ( frag_group -> entry_count - 1 ) ) ; stbl_group -> entry_count += frag_group -> entry_count - 1 ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } else { stbl_group -> sample_entries = gf_realloc ( stbl_group -> sample_entries , sizeof ( GF_SampleGroupEntry ) * ( stbl_group -> entry_count + frag_group -> entry_count ) ) ; for ( j = 0 ; j < frag_group -> entry_count ; j ++ ) { u32 sgidx = frag_group -> sample_entries [ j ] . group_description_index ; if ( sgidx > 0x10000 ) { sgidx -= 0x10001 ; if ( sgidx >= new_idx_count ) { GF_LOG ( GF_LOG_WARNING , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>corrupted<S2SV_blank>sample<S2SV_blank>group<S2SV_blank>index<S2SV_blank>in<S2SV_blank>fragment<S2SV_blank>%d<S2SV_blank>but<S2SV_blank>only<S2SV_blank>%d<S2SV_blank>group<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>fragment\\n"" , sgidx , new_idx_count ) ) ; } else { frag_group -> sample_entries [ j ] . group_description_index = new_idx [ sgidx ] ; } } } memcpy ( & stbl_group -> sample_entries [ stbl_group -> entry_count ] , & frag_group -> sample_entries [ 0 ] , sizeof ( GF_SampleGroupEntry ) * frag_group -> entry_count ) ; stbl_group -> entry_count += frag_group -> entry_count ; } } if ( new_idx ) gf_free ( new_idx ) ; } track_num = gf_isom_get_tracknum_from_id ( trak -> moov , trak -> Header -> trackID ) ; if ( gf_isom_is_cenc_media ( trak -> moov -> mov , track_num , DescIndex ) || traf -> sample_encryption ) { GF_SampleEncryptionBox * senc = NULL ; u32 scheme_type ; gf_isom_get_cenc_info ( trak -> moov -> mov , track_num , DescIndex , NULL , & scheme_type , NULL ) ; if ( traf -> sample_encryption ) { for ( i = 0 ; i < gf_list_count ( trak -> Media -> information -> sampleTable -> child_boxes ) ; i ++ ) { GF_Box * a = ( GF_Box * ) gf_list_get ( trak -> Media -> information -> sampleTable -> child_boxes , i ) ; if ( a -> type != traf -> sample_encryption -> type ) continue ; if ( ( a -> type == GF_ISOM_BOX_TYPE_UUID ) && ( ( ( GF_UUIDBox * ) a ) -> internal_4cc == GF_ISOM_BOX_UUID_PSEC ) ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } else if ( a -> type == GF_ISOM_BOX_TYPE_SENC ) { senc = ( GF_SampleEncryptionBox * ) a ; break ; } } if ( ! senc && trak -> sample_encryption ) senc = trak -> sample_encryption ; if ( ! senc ) { if ( traf -> sample_encryption -> piff_type == 1 ) { senc = ( GF_SampleEncryptionBox * ) gf_isom_create_piff_psec_box ( 1 , 0x2 , 0 , 0 , NULL ) ; } else { senc = gf_isom_create_samp_enc_box ( 1 , 0x2 ) ; } if ( ! trak -> Media -> information -> sampleTable -> child_boxes ) trak -> Media -> information -> sampleTable -> child_boxes = gf_list_new ( ) ; trak -> sample_encryption = senc ; if ( ! trak -> child_boxes ) trak -> child_boxes = gf_list_new ( ) ; gf_list_add ( trak -> child_boxes , senc ) ; } } if ( gf_isom_cenc_has_saiz_saio_traf ( traf , scheme_type ) ) { u32 nb_saio ; u32 aux_info_type ; u64 offset ; GF_Err e ; Bool is_encrypted ; GF_SampleAuxiliaryInfoOffsetBox * saio = NULL ; GF_SampleAuxiliaryInfoSizeBox * saiz = NULL ; offset = nb_saio = 0 ; for ( i = 0 ; i < gf_list_count ( traf -> sai_offsets ) ; i ++ ) { saio = ( GF_SampleAuxiliaryInfoOffsetBox * ) gf_list_get ( traf -> sai_offsets , i ) ; aux_info_type = saio -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_offsets ) == 1 ) ) { <S2SV_StartBug> offset = saio -> offsets [ 0 ] + moof_offset ; <S2SV_EndBug> nb_saio = saio -> entry_count ; break ; } } <S2SV_StartBug> for ( i = 0 ; i < gf_list_count ( traf -> sai_sizes ) ; i ++ ) { <S2SV_EndBug> saiz = ( GF_SampleAuxiliaryInfoSizeBox * ) gf_list_get ( traf -> sai_sizes , i ) ; aux_info_type = saiz -> aux_info_type ; if ( ! aux_info_type ) aux_info_type = scheme_type ; if ( ( aux_info_type == GF_ISOM_CENC_SCHEME ) || ( aux_info_type == GF_ISOM_CBC_SCHEME ) || ( aux_info_type == GF_ISOM_CENS_SCHEME ) || ( aux_info_type == GF_ISOM_CBCS_SCHEME ) || ( gf_list_count ( traf -> sai_sizes ) == 1 ) ) { break ; <S2SV_StartBug> } <S2SV_EndBug> } if ( saiz && saio && senc ) { for ( i = 0 ; i < saiz -> sample_count ; i ++ ) { GF_CENCSampleAuxInfo * sai ; const u8 * key_info = NULL ; u32 key_info_size ; u64 cur_position ; if ( nb_saio != 1 ) offset = saio -> offsets [ i ] + moof_offset ; size = saiz -> default_sample_info_size ? saiz -> default_sample_info_size : saiz -> sample_info_size [ i ] ; cur_position = gf_bs_get_position ( trak -> moov -> mov -> movieFileMap -> bs ) ; gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , offset ) ; GF_SAFEALLOC ( sai , GF_CENCSampleAuxInfo ) ; if ( ! sai ) return GF_OUT_OF_MEM ; e = gf_isom_get_sample_cenc_info_internal ( trak , traf , senc , i + 1 , & is_encrypted , NULL , NULL , & key_info , & key_info_size ) ; if ( e ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isobmf]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>cenc<S2SV_blank>info<S2SV_blank>for<S2SV_blank>sample<S2SV_blank>%d:<S2SV_blank>%s\\n"" , i + 1 , gf_error_to_string ( e ) ) ) ; return e ; } if ( is_encrypted ) { sai -> cenc_data_size = size ; sai -> cenc_data = gf_malloc ( sizeof ( u8 ) * size ) ; if ( ! sai -> cenc_data ) return GF_OUT_OF_MEM ; gf_bs_read_data ( trak -> moov -> mov -> movieFileMap -> bs , sai -> cenc_data , sai -> cenc_data_size ) ; } else { sai -> isNotProtected = 1 ; } if ( key_info ) { if ( ! key_info [ 0 ] ) { if ( size > key_info [ 3 ] ) senc -> flags = 0x00000002 ; } else { senc -> flags = 0x00000002 ; } } gf_bs_seek ( trak -> moov -> mov -> movieFileMap -> bs , cur_position ) ; gf_list_add ( senc -> samp_aux_info , sai ) ; e = gf_isom_cenc_merge_saiz_saio ( senc , trak -> Media -> information -> sampleTable , offset , size ) ; if ( e ) return e ; if ( nb_saio == 1 ) offset += size ; } } } else if ( traf -> sample_encryption ) { senc_Parse ( trak -> moov -> mov -> movieFileMap -> bs , trak , traf , traf -> sample_encryption ) ; trak -> sample_encryption -> AlgorithmID = traf -> sample_encryption -> AlgorithmID ; if ( ! trak -> sample_encryption -> IV_size ) trak -> sample_encryption -> IV_size = traf -> sample_encryption -> IV_size ; if ( ! trak -> sample_encryption -> samp_aux_info ) trak -> sample_encryption -> samp_aux_info = gf_list_new ( ) ; gf_list_transfer ( trak -> sample_encryption -> samp_aux_info , traf -> sample_encryption -> samp_aux_info ) ; if ( traf -> sample_encryption -> flags & 0x00000002 ) trak -> sample_encryption -> flags |= 0x00000002 ; } } return GF_OK ; }
","<S2SV_ModStart> ) ) { if ( saio -> offsets && saio -> entry_count ) { <S2SV_ModStart> ; } } saio = NULL ; } <S2SV_ModStart> break ; } saiz = NULL ;
",gpac@gpac/df8fffd839fe5ae9acd82d26fd48280a397411d9,CVE-2021-31260,https://github.com/gpac/gpac/commit/df8fffd839fe5ae9acd82d26fd48280a397411d9,2021-04-19T19:15Z
CWE-254,"CWE-254 int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { int i ; uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; switch ( zrtpPacket -> messageType ) { case MSGTYPE_HELLO : { bzrtpHelloMessage_t * messageData ; messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; messageContent += 16 ; memcpy ( messageData -> H3 , messageContent , 32 ) ; messageContent += 32 ; memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; messageContent += 1 ; messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } for ( i = 0 ; i < messageData -> hc ; i ++ ) { messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> cc ; i ++ ) { messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> ac ; i ++ ) { messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> kc ; i ++ ) { messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> sc ; i ++ ) { messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; } addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_HELLOACK : { if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } } break ; case MSGTYPE_COMMIT : { uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; uint16_t variableLength = 0 ; bzrtpCommitMessage_t * messageData ; messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; memcpy ( messageData -> H2 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; switch ( messageData -> keyAgreementAlgo ) { case ZRTP_KEYAGREEMENT_DH2k : case ZRTP_KEYAGREEMENT_EC25 : case ZRTP_KEYAGREEMENT_DH3k : case ZRTP_KEYAGREEMENT_EC38 : case ZRTP_KEYAGREEMENT_EC52 : variableLength = 32 ; break ; case ZRTP_KEYAGREEMENT_Prsh : variableLength = 24 ; break ; case ZRTP_KEYAGREEMENT_Mult : variableLength = 16 ; break ; default : free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { memcpy ( messageData -> nonce , messageContent , 16 ) ; messageContent += 16 ; if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { memcpy ( messageData -> keyID , messageContent , 8 ) ; messageContent += 8 ; } } else { memcpy ( messageData -> hvi , messageContent , 32 ) ; messageContent += 32 ; } memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_DHPART1 : case MSGTYPE_DHPART2 : { bzrtpDHPartMessage_t * messageData ; uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; if ( pvLength == 0 ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; memcpy ( messageData -> H1 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } <S2SV_StartBug> } else { <S2SV_EndBug> uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } memcpy ( messageData -> rs1ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> rs2ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pv , messageContent , pvLength ) ; messageContent += pvLength ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_CONFIRM1 : case MSGTYPE_CONFIRM2 : { uint8_t * confirmMessageKey = NULL ; uint8_t * confirmMessageMacKey = NULL ; bzrtpConfirmMessage_t * messageData ; uint16_t cipherTextLength ; uint8_t computedHmac [ 8 ] ; uint8_t * confirmPlainMessageBuffer ; uint8_t * confirmPlainMessage ; if ( zrtpChannelContext -> role == RESPONDER ) { if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; confirmMessageMacKey = zrtpChannelContext -> mackeyi ; } if ( zrtpChannelContext -> role == INITIATOR ) { if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; confirmMessageMacKey = zrtpChannelContext -> mackeyr ; } messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> CFBIV , messageContent , 16 ) ; messageContent += 16 ; cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; } confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; confirmPlainMessage = confirmPlainMessageBuffer ; memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; confirmPlainMessage += 33 ; if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { uint8_t checkH1 [ 32 ] ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } } else { uint8_t checkH1 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpDHPartMessage_t * peerDHPartMessageData ; if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; confirmPlainMessage += 2 ; messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; messageData -> D = ( * confirmPlainMessage ) & 0x01 ; confirmPlainMessage += 1 ; messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; confirmPlainMessage += 4 ; if ( messageData -> sig_len > 0 ) { memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; confirmPlainMessage += 4 ; messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; } else { messageData -> signatureBlock = NULL ; } free ( confirmPlainMessageBuffer ) ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; case MSGTYPE_CONF2ACK : break ; case MSGTYPE_PING : { bzrtpPingMessage_t * messageData ; messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> endpointHash , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; } return 0 ; }
","<S2SV_ModStart> BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } { uint8_t computedHvi [ 32 ] ; uint16_t HelloMessageLength = zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength ; uint16_t DHPartHelloMessageStringLength = zrtpPacket -> messageLength + HelloMessageLength ; uint8_t * DHPartHelloMessageString = ( uint8_t * ) malloc ( DHPartHelloMessageStringLength * sizeof ( uint8_t ) ) ; memcpy ( DHPartHelloMessageString , input + ZRTP_PACKET_HEADER_LENGTH , zrtpPacket -> messageLength ) ; memcpy ( DHPartHelloMessageString + zrtpPacket -> messageLength , zrtpChannelContext -> selfPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , HelloMessageLength ) ; zrtpChannelContext -> hashFunction ( DHPartHelloMessageString , DHPartHelloMessageStringLength , 32 , computedHvi ) ; free ( DHPartHelloMessageString ) ; if ( memcmp ( computedHvi , peerCommitMessageData -> hvi , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHVI ; } }
",BelledonneCommunications@bzrtp/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,CVE-2016-6271,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,2017-01-18T22:59Z
CWE-000,"CWE-000 static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numguard<S2SV_blank>=<S2SV_blank>%d;<S2SV_blank>numstepsizes<S2SV_blank>=<S2SV_blank>%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]<S2SV_blank>=<S2SV_blank>0x%04x;<S2SV_blank>mant[%d]<S2SV_blank>=<S2SV_blank>0x%04x;\\n"" , <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , <S2SV_EndBug> <S2SV_StartBug> i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; <S2SV_EndBug> } return 0 ; }
","<S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETEXPN ( qcd <S2SV_ModStart> i ] ) ) <S2SV_ModStart> , i , JAS_CAST ( unsigned , <S2SV_ModEnd> JPC_QCX_GETMANT ( qcd <S2SV_ModStart> ] ) ) )
",mdadams@jasper/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,CVE-2016-9391,https://github.com/mdadams/jasper/commit/1e84674d95353c64e5c4c0e7232ae86fd6ea813b,2017-03-23T18:59Z
CWE-400,"CWE-400 int do_mathemu ( struct pt_regs * regs , struct task_struct * fpt ) { int i ; int retcode = 0 ; unsigned long insn ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> # ifdef DEBUG_MATHEMU printk ( ""In<S2SV_blank>do_mathemu()...<S2SV_blank>pc<S2SV_blank>is<S2SV_blank>%08lx\\n"" , regs -> pc ) ; printk ( ""fpqdepth<S2SV_blank>is<S2SV_blank>%ld\\n"" , fpt -> thread . fpqdepth ) ; for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) printk ( ""%d:<S2SV_blank>%08lx<S2SV_blank>at<S2SV_blank>%08lx\\n"" , i , fpt -> thread . fpqueue [ i ] . insn , ( unsigned long ) fpt -> thread . fpqueue [ i ] . insn_addr ) ; # endif if ( fpt -> thread . fpqdepth == 0 ) { # ifdef DEBUG_MATHEMU printk ( ""precise<S2SV_blank>trap<S2SV_blank>at<S2SV_blank>%08lx\\n"" , regs -> pc ) ; # endif if ( ! get_user ( insn , ( u32 __user * ) regs -> pc ) ) { retcode = do_one_mathemu ( insn , & fpt -> thread . fsr , fpt -> thread . float_regs ) ; if ( retcode ) { regs -> pc = regs -> npc ; regs -> npc += 4 ; } } return retcode ; } for ( i = 0 ; i < fpt -> thread . fpqdepth ; i ++ ) { retcode = do_one_mathemu ( fpt -> thread . fpqueue [ i ] . insn , & ( fpt -> thread . fsr ) , fpt -> thread . float_regs ) ; if ( ! retcode ) break ; } if ( retcode ) fpt -> thread . fsr &= ~ ( 0x3000 | FSR_CEXC_MASK ) ; else fpt -> thread . fsr &= ~ 0x3000 ; fpt -> thread . fpqdepth = 0 ; return retcode ; }
","<S2SV_ModStart> PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-000,"CWE-000 static void ext4_end_io_dio ( struct kiocb * iocb , loff_t offset , ssize_t size , void * private ) { ext4_io_end_t * io_end = iocb -> private ; struct workqueue_struct * wq ; <S2SV_StartBug> if ( ! io_end || ! size ) <S2SV_EndBug> return ; ext_debug ( ""ext4_end_io_dio():<S2SV_blank>io_end<S2SV_blank>0x%p"" ""for<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>iocb<S2SV_blank>0x%p,<S2SV_blank>offset<S2SV_blank>%llu,<S2SV_blank>size<S2SV_blank>%llu\\n"" , iocb -> private , io_end -> inode -> i_ino , iocb , offset , size ) ; if ( io_end -> flag != EXT4_IO_UNWRITTEN ) { ext4_free_io_end ( io_end ) ; iocb -> private = NULL ; return ; } io_end -> offset = offset ; io_end -> size = size ; <S2SV_StartBug> wq = EXT4_SB ( io_end -> inode -> i_sb ) -> dio_unwritten_wq ; <S2SV_EndBug> queue_work ( wq , & io_end -> work ) ; <S2SV_StartBug> list_add_tail ( & io_end -> list , <S2SV_EndBug> <S2SV_StartBug> & EXT4_I ( io_end -> inode ) -> i_completed_io_list ) ; <S2SV_EndBug> iocb -> private = NULL ; }
","<S2SV_ModStart> * wq ; unsigned long flags ; struct ext4_inode_info * ei ; <S2SV_ModStart> = size ; io_end -> flag = EXT4_IO_UNWRITTEN ; <S2SV_ModStart> work ) ; ei = EXT4_I ( io_end -> inode ) ; spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> -> list , & ei -> i_completed_io_list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags <S2SV_ModEnd> ) ; iocb
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-399,"CWE-399 static int ovl_copy_up_locked ( struct dentry * workdir , struct dentry * upperdir , struct dentry * dentry , struct path * lowerpath , struct kstat * stat , struct iattr * attr , const char * link ) { struct inode * wdir = workdir -> d_inode ; struct inode * udir = upperdir -> d_inode ; struct dentry * newdentry = NULL ; struct dentry * upper = NULL ; umode_t mode = stat -> mode ; int err ; newdentry = ovl_lookup_temp ( workdir , dentry ) ; err = PTR_ERR ( newdentry ) ; if ( IS_ERR ( newdentry ) ) goto out ; upper = lookup_one_len ( dentry -> d_name . name , upperdir , dentry -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out1 ; stat -> mode &= S_IFMT ; err = ovl_create_real ( wdir , newdentry , stat , link , NULL , true ) ; stat -> mode = mode ; if ( err ) goto out2 ; if ( S_ISREG ( stat -> mode ) ) { struct path upperpath ; ovl_path_upper ( dentry , & upperpath ) ; BUG_ON ( upperpath . dentry != NULL ) ; upperpath . dentry = newdentry ; err = ovl_copy_up_data ( lowerpath , & upperpath , stat -> size ) ; if ( err ) goto out_cleanup ; } err = ovl_copy_xattr ( lowerpath -> dentry , newdentry ) ; if ( err ) goto out_cleanup ; mutex_lock ( & newdentry -> d_inode -> i_mutex ) ; err = ovl_set_attr ( newdentry , stat ) ; if ( ! err && attr ) err = notify_change ( newdentry , attr , NULL ) ; mutex_unlock ( & newdentry -> d_inode -> i_mutex ) ; if ( err ) goto out_cleanup ; err = ovl_do_rename ( wdir , newdentry , udir , upper , 0 ) ; if ( err ) goto out_cleanup ; ovl_dentry_update ( dentry , newdentry ) ; newdentry = NULL ; if ( ! S_ISDIR ( stat -> mode ) ) ovl_dentry_set_opaque ( dentry , true ) ; out2 : dput ( upper ) ; out1 : dput ( newdentry ) ; out : return err ; out_cleanup : ovl_cleanup ( wdir , newdentry ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ; goto out2 <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/ab79efab0a0ba01a74df782eb7fa44b044dae8b5,CVE-2015-8953,https://github.com/torvalds/linux/commit/ab79efab0a0ba01a74df782eb7fa44b044dae8b5,2016-10-16T21:59Z
CWE-22,"CWE-22 int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; <S2SV_StartBug> if ( snprintf ( spath , sizeof ( spath ) , var , iface ) >= sizeof ( spath ) ) <S2SV_EndBug> return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>for<S2SV_blank>%s:<S2SV_blank>%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
","<S2SV_ModStart> sizeof ( spath ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/'
",reubenhwk@radvd/92e22ca23e52066da2258df8c76a2dca8a428bcc,CVE-2011-3602,https://github.com/reubenhwk/radvd/commit/92e22ca23e52066da2258df8c76a2dca8a428bcc,2014-04-27T21:55Z
CWE-787,"CWE-787 MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; <S2SV_StartBug> uint32 num_properties = GETINT32 ( buf + idx ) ; <S2SV_EndBug> MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; <S2SV_StartBug> for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) <S2SV_EndBug> a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4byte ( a -> names [ i ] . len ) ; } } else { CHECKINT32 ( idx , len ) ; a -> name = GETINT32 ( buf + idx ) ; idx += 4 ; } } if ( a -> type & MULTI_VALUE_FLAG || a -> type == szMAPI_STRING || a -> type == szMAPI_UNICODE_STRING || a -> type == szMAPI_OBJECT || a -> type == szMAPI_BINARY ) { CHECKINT32 ( idx , len ) ; a -> num_values = GETINT32 ( buf + idx ) ; idx += 4 ; } else { a -> num_values = 1 ; } if ( a -> type & MULTI_VALUE_FLAG ) { a -> type -= MULTI_VALUE_FLAG ; } v = alloc_mapi_values ( a ) ; for ( j = 0 ; j < a -> num_values ; j ++ ) { switch ( a -> type ) { case szMAPI_SHORT : v -> len = 2 ; CHECKINT16 ( idx , len ) ; v -> data . bytes2 = GETINT16 ( buf + idx ) ; idx += 4 ; break ; case szMAPI_INT : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += 4 ; v ++ ; break ; case szMAPI_FLOAT : case szMAPI_BOOLEAN : v -> len = 4 ; CHECKINT32 ( idx , len ) ; v -> data . bytes4 = GETINT32 ( buf + idx ) ; idx += v -> len ; break ; case szMAPI_SYSTIME : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += 8 ; v ++ ; break ; case szMAPI_DOUBLE : case szMAPI_APPTIME : case szMAPI_CURRENCY : case szMAPI_INT8BYTE : v -> len = 8 ; CHECKINT32 ( idx , len ) ; v -> data . bytes8 [ 0 ] = GETINT32 ( buf + idx ) ; CHECKINT32 ( idx + 4 , len ) ; v -> data . bytes8 [ 1 ] = GETINT32 ( buf + idx + 4 ) ; idx += v -> len ; break ; case szMAPI_CLSID : v -> len = sizeof ( GUID ) ; copy_guid_from_buf ( & v -> data . guid , buf + idx , len ) ; idx += v -> len ; break ; case szMAPI_STRING : case szMAPI_UNICODE_STRING : case szMAPI_OBJECT : case szMAPI_BINARY : CHECKINT32 ( idx , len ) ; v -> len = GETINT32 ( buf + idx ) ; idx += 4 ; <S2SV_StartBug> if ( a -> type == szMAPI_UNICODE_STRING ) <S2SV_EndBug> { <S2SV_StartBug> v -> data . buf = ( unsigned char * ) unicode_to_utf8 ( v -> len , buf + idx ) ; <S2SV_EndBug> } else { v -> data . buf = CHECKED_XMALLOC ( unsigned char , v -> len ) ; memmove ( v -> data . buf , buf + idx , v -> len ) ; } idx += pad_to_4byte ( v -> len ) ; v ++ ; break ; case szMAPI_NULL : case szMAPI_ERROR : case szMAPI_UNSPECIFIED : fprintf ( stderr , ""Invalid<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; default : fprintf ( stderr , ""Undefined<S2SV_blank>attribute,<S2SV_blank>input<S2SV_blank>file<S2SV_blank>may<S2SV_blank>be<S2SV_blank>corrupted\\n"" ) ; if ( ! ENCODE_SKIP ) exit ( 1 ) ; return NULL ; } if ( DEBUG_ON ) mapi_attr_dump ( attrs [ i ] ) ; } } attrs [ i ] = NULL ; return attrs ; }
","<S2SV_ModStart> buf + idx ) ; assert ( ( num_properties + 1 ) != 0 <S2SV_ModStart> len ) ; assert ( ( idx + ( a -> names [ i ] . len * 2 ) ) <= len ) ; <S2SV_ModStart> += 4 ; assert ( v -> len + idx <= len ) ; <S2SV_ModStart> szMAPI_UNICODE_STRING ) { assert ( v -> len != 0 ) ;
",verdammelt@tnef/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,CVE-2017-6307,https://github.com/verdammelt/tnef/commit/1a17af1ed0c791aec44dbdc9eab91218cc1e335a,2017-02-24T04:59Z
CWE-362,"CWE-362 struct mapped_device * dm_get_from_kobject ( struct kobject * kobj ) { struct mapped_device * md ; md = container_of ( kobj , struct mapped_device , kobj_holder . kobj ) ; <S2SV_StartBug> if ( test_bit ( DMF_FREEING , & md -> flags ) || <S2SV_EndBug> <S2SV_StartBug> dm_deleting_md ( md ) ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> dm_get ( md ) ; <S2SV_EndBug> return md ; }
","<S2SV_ModStart> kobj ) ; spin_lock ( & _minor_lock ) ; <S2SV_ModStart> md ) ) { md = NULL ; goto out ; } <S2SV_ModEnd> dm_get ( md <S2SV_ModStart> dm_get ( md ) ; out : spin_unlock ( & _minor_lock
",torvalds@linux/b9a41d21dceadf8104812626ef85dc56ee8a60ed,CVE-2017-18203,https://github.com/torvalds/linux/commit/b9a41d21dceadf8104812626ef85dc56ee8a60ed,2018-02-27T20:29Z
CWE-17,"CWE-17 static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { ret = - ENOENT ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - EIO ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( READA , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; lfi = cfi . lengthFileIdent ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; } <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }
","<S2SV_ModStart> , nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if
",torvalds@linux/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,CVE-2014-9731,https://github.com/torvalds/linux/commit/0e5cc9a40ada6046e6bc3bdfcd0c0d7e4b706b14,2015-08-31T10:59Z
CWE-119,"CWE-119 static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }
","<S2SV_ModStart> * ctx ; if ( count > sizeof ( ei -> data ) - sizeof ( * elt ) - sizeof ( * app_hdr ) ) return - EINVAL ;
",torvalds@linux/c2c65cd2e14ada6de44cb527e7f1990bede24e15,CVE-2013-4513,https://github.com/torvalds/linux/commit/c2c65cd2e14ada6de44cb527e7f1990bede24e15,2013-11-12T14:35Z
CWE-20,"CWE-20 static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> -> x = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> y = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> z = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f , <S2SV_ModStart> -> w = MagickMin <S2SV_ModEnd> ( 1.0f , <S2SV_ModStart> ( 1.0f , MagickMax <S2SV_ModEnd> ( 0.0f ,
",ImageMagick@ImageMagick/d7325bac173492b358417a0ad49fabad44447d52,CVE-2014-9907,https://github.com/ImageMagick/ImageMagick/commit/d7325bac173492b358417a0ad49fabad44447d52,2017-04-19T14:59Z
CWE-264,"CWE-264 static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( ( pvc = add_pvc ( frad , dlci ) ) == NULL ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_add_pvc()\\n"" ) ; return - ENOBUFS ; } if ( * get_dev_p ( pvc , type ) ) return - EEXIST ; used = pvc_is_used ( pvc ) ; <S2SV_StartBug> if ( type == ARPHRD_ETHER ) <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; <S2SV_StartBug> else <S2SV_EndBug> dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memory<S2SV_blank>squeeze<S2SV_blank>on<S2SV_blank>fr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }
","<S2SV_ModStart> == ARPHRD_ETHER ) { <S2SV_ModStart> ether_setup ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; }
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-415,"CWE-415 void DDGifSlurp ( GifInfo * info , bool decode , bool exitAfterFrame ) { GifRecordType RecordType ; GifByteType * ExtData ; int ExtFunction ; GifFileType * gifFilePtr ; gifFilePtr = info -> gifFilePtr ; uint_fast32_t lastAllocatedGCBIndex = 0 ; do { if ( DGifGetRecordType ( gifFilePtr , & RecordType ) == GIF_ERROR ) { break ; } bool isInitialPass = ! decode && ! exitAfterFrame ; switch ( RecordType ) { case IMAGE_DESC_RECORD_TYPE : if ( DGifGetImageDesc ( gifFilePtr , isInitialPass ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( widthOverflow > 0 || heightOverflow > 0 ) { gifFilePtr -> SWidth += widthOverflow ; gifFilePtr -> SHeight += heightOverflow ; } SavedImage * sp = & gifFilePtr -> SavedImages [ gifFilePtr -> ImageCount - 1 ] ; int_fast32_t topOverflow = gifFilePtr -> Image . Top + gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( topOverflow > 0 ) { sp -> ImageDesc . Top -= topOverflow ; } int_fast32_t leftOverflow = gifFilePtr -> Image . Left + gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; if ( leftOverflow > 0 ) { sp -> ImageDesc . Left -= leftOverflow ; } if ( ! updateGCB ( info , & lastAllocatedGCBIndex ) ) { break ; } } if ( decode ) { <S2SV_StartBug> int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; <S2SV_EndBug> int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ; <S2SV_StartBug> const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; <S2SV_EndBug> if ( newRasterSize > info -> rasterSize || widthOverflow > 0 || heightOverflow > 0 ) { void * tmpRasterBits = reallocarray ( info -> rasterBits , newRasterSize , sizeof ( GifPixelType ) ) ; if ( tmpRasterBits == NULL ) { gifFilePtr -> Error = D_GIF_ERR_NOT_ENOUGH_MEM ; break ; } info -> rasterBits = tmpRasterBits ; info -> rasterSize = newRasterSize ; } if ( gifFilePtr -> Image . Interlace ) { uint_fast16_t i , j ; uint_fast8_t InterlacedOffset [ ] = { 0 , 4 , 2 , 1 } ; uint_fast8_t InterlacedJumps [ ] = { 8 , 8 , 4 , 2 } ; for ( i = 0 ; i < 4 ; i ++ ) for ( j = InterlacedOffset [ i ] ; j < gifFilePtr -> Image . Height ; j += InterlacedJumps [ i ] ) { if ( DGifGetLine ( gifFilePtr , info -> rasterBits + j * gifFilePtr -> Image . Width , gifFilePtr -> Image . Width ) == GIF_ERROR ) break ; } } else { if ( DGifGetLine ( gifFilePtr , info -> rasterBits , gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ) == GIF_ERROR ) { break ; } } if ( info -> sampleSize > 1 ) { unsigned char * dst = info -> rasterBits ; unsigned char * src = info -> rasterBits ; unsigned char * const srcEndImage = info -> rasterBits + gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; do { unsigned char * srcNextLineStart = src + gifFilePtr -> Image . Width * info -> sampleSize ; unsigned char * const srcEndLine = src + gifFilePtr -> Image . Width ; unsigned char * dstEndLine = dst + gifFilePtr -> Image . Width / info -> sampleSize ; do { * dst = * src ; dst ++ ; src += info -> sampleSize ; } while ( src < srcEndLine ) ; dst = dstEndLine ; src = srcNextLineStart ; } while ( src < srcEndImage ) ; } return ; } else { do { if ( DGifGetCodeNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) ; if ( exitAfterFrame ) { return ; } } break ; case EXTENSION_RECORD_TYPE : if ( DGifGetExtension ( gifFilePtr , & ExtFunction , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { updateGCB ( info , & lastAllocatedGCBIndex ) ; if ( readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } while ( ExtData != NULL ) { if ( DGifGetExtensionNext ( gifFilePtr , & ExtData ) == GIF_ERROR ) { break ; } if ( isInitialPass && readExtensions ( ExtFunction , ExtData , info ) == GIF_ERROR ) { break ; } } break ; case TERMINATE_RECORD_TYPE : break ; default : break ; } } while ( RecordType != TERMINATE_RECORD_TYPE ) ; info -> rewindFunction ( info ) ; }
","<S2SV_ModStart> decode ) { <S2SV_ModEnd> const uint_fast32_t newRasterSize <S2SV_ModStart> Image . Height ; if ( newRasterSize == 0 ) { free ( info -> rasterBits ) ; info -> rasterBits = NULL ; info -> rasterSize = newRasterSize ; return ; } const int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; const int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight
",koral--@android-gif-drawable/cc5b4f8e43463995a84efd594f89a21f906c2d20,CVE-2019-11932,https://github.com/koral--/android-gif-drawable/commit/cc5b4f8e43463995a84efd594f89a21f906c2d20,2019-10-03T22:15Z
CWE-617,"CWE-617 void pci_lintr_assert ( struct pci_vdev * dev ) { <S2SV_StartBug> assert ( dev -> lintr . pin > 0 ) ; <S2SV_EndBug> pthread_mutex_lock ( & dev -> lintr . lock ) ; if ( dev -> lintr . state == IDLE ) { if ( pci_lintr_permitted ( dev ) ) { dev -> lintr . state = ASSERTED ; pci_irq_assert ( dev ) ; } else dev -> lintr . state = PENDING ; } pthread_mutex_unlock ( & dev -> lintr . lock ) ; }
","<S2SV_ModStart> dev ) { if <S2SV_ModEnd> ( dev -> <S2SV_ModStart> lintr . pin <= 0 ) { pr_warn ( ""%s:<S2SV_blank>Invalid<S2SV_blank>intr<S2SV_blank>pin<S2SV_blank>on<S2SV_blank>dev<S2SV_blank>[%s]\\n"" , __func__ , dev -> name ) ; return ; } <S2SV_ModEnd> pthread_mutex_lock ( &
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-119,"CWE-119 static inline void header_put_be_short ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 2 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> x ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
","<S2SV_ModStart> t , const vpx_prob <S2SV_ModEnd> * context_tree , <S2SV_ModStart> * context_tree , int32_t <S2SV_ModEnd> extra , uint8_t
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || <S2SV_StartBug> ! DoReadFile ( infile , & ds64_chunk , chunk_header . ckSize , & bcount ) || <S2SV_EndBug> <S2SV_StartBug> bcount != chunk_header . ckSize ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && <S2SV_StartBug> ! WavpackAddWrapper ( wpc , & ds64_chunk , chunk_header . ckSize ) ) { <S2SV_EndBug> error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; char * buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }
","<S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> , & bcount <S2SV_ModStart> || bcount != sizeof ( DS64Chunk ) <S2SV_ModEnd> ) { error_line <S2SV_ModStart> & ds64_chunk , sizeof ( DS64Chunk ) <S2SV_ModEnd> ) ) {
",dbry@WavPack/d5bf76b5a88d044a1be1d5656698e3ba737167e5,CVE-2018-6767,https://github.com/dbry/WavPack/commit/d5bf76b5a88d044a1be1d5656698e3ba737167e5,2018-02-06T22:29Z
CWE-400,"CWE-400 static struct mnt_namespace * create_mnt_ns ( struct vfsmount * m ) { struct mnt_namespace * new_ns = alloc_mnt_ns ( & init_user_ns ) ; if ( ! IS_ERR ( new_ns ) ) { struct mount * mnt = real_mount ( m ) ; mnt -> mnt_ns = new_ns ; new_ns -> root = mnt ; <S2SV_StartBug> list_add ( & mnt -> mnt_list , & new_ns -> list ) ; <S2SV_EndBug> } else { mntput ( m ) ; } return new_ns ; }
","<S2SV_ModStart> = mnt ; new_ns -> mounts ++ ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
CWE-284,"CWE-284 int sock_recv_all ( int sock_fd , uint8_t * buf , int len ) { int r = len ; int ret = - 1 ; while ( r ) { <S2SV_StartBug> do ret = recv ( sock_fd , buf , r , MSG_WAITALL ) ; <S2SV_EndBug> while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>fd:%d<S2SV_blank>recv<S2SV_blank>errno:%d,<S2SV_blank>ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; r -= ret ; } return len ; }
","<S2SV_ModStart> do ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> r , MSG_WAITALL )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-476,"CWE-476 int fscrypt_get_encryption_info ( struct inode * inode ) { <S2SV_StartBug> struct fscrypt_info * ci = inode -> i_crypt_info ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ci || <S2SV_EndBug> ( ci -> ci_keyring_key && ( ci -> ci_keyring_key -> flags & ( ( 1 << KEY_FLAG_INVALIDATED ) | ( 1 << KEY_FLAG_REVOKED ) | ( 1 << KEY_FLAG_DEAD ) ) ) ) ) return fscrypt_get_crypt_info ( inode ) ; return 0 ; }
","<S2SV_ModStart> struct fscrypt_info * crypt_info ; struct fscrypt_context ctx ; struct crypto_skcipher * ctfm ; const char * cipher_str ; int keysize ; u8 * raw_key = NULL ; int res ; if ( <S2SV_ModEnd> inode -> i_crypt_info <S2SV_ModStart> inode -> i_crypt_info ) return 0 ; res = fscrypt_initialize ( inode -> i_sb -> s_cop -> flags ) ; if ( res ) return res <S2SV_ModStart> if ( ! inode -> i_sb -> s_cop -> get_context ) return - EOPNOTSUPP ; res = inode -> i_sb -> s_cop -> get_context ( inode , & ctx , sizeof ( ctx ) ) ; if ( res < 0 ) { if ( ! fscrypt_dummy_context_enabled ( inode ) || inode -> i_sb -> s_cop -> is_encrypted ( inode ) ) return res ; memset ( & ctx , 0 , sizeof ( ctx ) ) ; ctx . format = FS_ENCRYPTION_CONTEXT_FORMAT_V1 ; ctx . contents_encryption_mode = FS_ENCRYPTION_MODE_AES_256_XTS ; ctx . filenames_encryption_mode = FS_ENCRYPTION_MODE_AES_256_CTS ; memset ( ctx . master_key_descriptor , 0x42 , FS_KEY_DESCRIPTOR_SIZE ) ; } else if ( res != sizeof ( ctx ) ) { return - EINVAL ; } if ( ctx . format != FS_ENCRYPTION_CONTEXT_FORMAT_V1 ) return - EINVAL ; if ( ctx . flags & ~ FS_POLICY_FLAGS_VALID ) return - EINVAL ; crypt_info = kmem_cache_alloc ( fscrypt_info_cachep , GFP_NOFS ) ; if ( ! crypt_info ) return - ENOMEM ; crypt_info -> ci_flags = ctx . flags ; crypt_info -> ci_data_mode = ctx . contents_encryption_mode ; crypt_info -> ci_filename_mode = ctx . filenames_encryption_mode ; crypt_info -> ci_ctfm = NULL ; memcpy ( crypt_info -> ci_master_key , ctx . master_key_descriptor , sizeof ( crypt_info -> ci_master_key ) ) ; res = determine_cipher_type ( crypt_info , inode , & cipher_str , & keysize ) ; if ( res ) goto out ; res = - ENOMEM ; raw_key = kmalloc ( FS_MAX_KEY_SIZE , GFP_NOFS ) ; if ( ! raw_key ) goto out ; res = validate_user_key ( crypt_info , & ctx , raw_key , FS_KEY_DESC_PREFIX ) ; if ( res && inode -> i_sb -> s_cop -> key_prefix ) { int res2 = validate_user_key ( crypt_info , & ctx , raw_key , inode -> i_sb -> s_cop -> key_prefix ) ; if ( res2 ) { if ( res2 == - ENOKEY ) res = - ENOKEY ; goto out ; } } else if ( res ) { goto out ; } ctfm = crypto_alloc_skcipher ( cipher_str , 0 , 0 ) ; if ( ! ctfm || IS_ERR ( ctfm ) ) { res = ctfm ? PTR_ERR ( ctfm ) : - ENOMEM ; printk ( KERN_DEBUG ""%s:<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>(inode<S2SV_blank>%u)<S2SV_blank>allocating<S2SV_blank>crypto<S2SV_blank>tfm\\n"" , __func__ , res , ( unsigned ) inode -> i_ino ) ; goto out ; } crypt_info -> ci_ctfm = ctfm ; crypto_skcipher_clear_flags ( ctfm , ~ 0 ) ; crypto_skcipher_set_flags ( ctfm , CRYPTO_TFM_REQ_WEAK_KEY ) ; res = crypto_skcipher_setkey ( ctfm , raw_key , keysize ) ; if ( res ) goto out ; if ( cmpxchg ( & inode -> i_crypt_info , NULL , crypt_info ) == NULL ) crypt_info = NULL ; out : if ( res == - ENOKEY ) res = 0 ; put_crypt_info ( crypt_info ) ; kzfree ( raw_key ) ; return res <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,CVE-2017-7374,https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d,2017-03-31T20:59Z
CWE-399,"CWE-399 static void vhost_net_ubuf_put_and_wait ( struct vhost_net_ubuf_ref * ubufs ) { kref_put ( & ubufs -> kref , vhost_net_zerocopy_done_signal ) ; wait_event ( ubufs -> wait , ! atomic_read ( & ubufs -> kref . refcount ) ) ; <S2SV_StartBug> kfree ( ubufs ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,CVE-2013-4127,https://github.com/torvalds/linux/commit/dd7633ecd553a5e304d349aa6f8eb8a0417098c5,2013-07-29T13:59Z
CWE-119,"CWE-119 static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }
","<S2SV_ModStart> lock_ptr ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
CWE-415,"CWE-415 static OM_uint32 init_ctx_reselect ( OM_uint32 * minor_status , spnego_gss_ctx_id_t sc , OM_uint32 acc_negState , gss_OID supportedMech , gss_buffer_t * responseToken , gss_buffer_t * mechListMIC , OM_uint32 * negState , send_token_flag * tokflag ) { OM_uint32 tmpmin ; <S2SV_StartBug> size_t i ; <S2SV_EndBug> generic_gss_release_oid ( & tmpmin , & sc -> internal_mech ) ; gss_delete_sec_context ( & tmpmin , & sc -> ctx_handle , GSS_C_NO_BUFFER ) ; for ( i = 0 ; i < sc -> mech_set -> count ; i ++ ) { if ( g_OID_equal ( supportedMech , & sc -> mech_set -> elements [ i ] ) ) break ; } if ( i == sc -> mech_set -> count ) return GSS_S_DEFECTIVE_TOKEN ; sc -> internal_mech = & sc -> mech_set -> elements [ i ] ; if ( acc_negState != REQUEST_MIC ) return GSS_S_DEFECTIVE_TOKEN ; sc -> mech_complete = 0 ; sc -> mic_reqd = 1 ; * negState = REQUEST_MIC ; * tokflag = CONT_TOKEN_SEND ; return GSS_S_CONTINUE_NEEDED ; }
","<S2SV_ModStart> ; size_t i <S2SV_ModEnd> ; gss_delete_sec_context (
",krb5@krb5/f18ddf5d82de0ab7591a36e465bc24225776940f,CVE-2014-4343,https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f,2014-08-14T05:01Z
CWE-190,"CWE-190 gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++ ) { im -> open [ i ] = 1 ; im -> red [ i ] = 0 ; im -> green [ i ] = 0 ; im -> blue [ i ] = 0 ; } im -> trueColor = 0 ; im -> tpixels = 0 ; im -> cx1 = 0 ; im -> cy1 = 0 ; im -> cx2 = im -> sx - 1 ; im -> cy2 = im -> sy - 1 ; im -> interpolation = NULL ; im -> interpolation_id = GD_BILINEAR_FIXED ; return im ; }
","<S2SV_ModStart> NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sx ) ) { return NULL ; }
",php@php-src/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6,CVE-2016-5767,https://github.com/php/php-src/commit/c395c6e5d7e8df37a21265ff76e48fe75ceb5ae6?w=1,2016-08-07T10:59Z
CWE-119,"CWE-119 static int jpc_dec_tileinit ( jpc_dec_t * dec , jpc_dec_tile_t * tile ) { jpc_dec_tcomp_t * tcomp ; int compno ; int rlvlno ; jpc_dec_rlvl_t * rlvl ; jpc_dec_band_t * band ; jpc_dec_prc_t * prc ; int bndno ; jpc_tsfb_band_t * bnd ; int bandno ; jpc_dec_ccp_t * ccp ; int prccnt ; jpc_dec_cblk_t * cblk ; int cblkcnt ; uint_fast32_t tlprcxstart ; uint_fast32_t tlprcystart ; uint_fast32_t brprcxend ; uint_fast32_t brprcyend ; uint_fast32_t tlcbgxstart ; uint_fast32_t tlcbgystart ; uint_fast32_t brcbgxend ; uint_fast32_t brcbgyend ; uint_fast32_t cbgxstart ; uint_fast32_t cbgystart ; uint_fast32_t cbgxend ; uint_fast32_t cbgyend ; uint_fast32_t tlcblkxstart ; uint_fast32_t tlcblkystart ; uint_fast32_t brcblkxend ; uint_fast32_t brcblkyend ; uint_fast32_t cblkxstart ; uint_fast32_t cblkystart ; uint_fast32_t cblkxend ; uint_fast32_t cblkyend ; uint_fast32_t tmpxstart ; uint_fast32_t tmpystart ; uint_fast32_t tmpxend ; uint_fast32_t tmpyend ; jpc_dec_cp_t * cp ; <S2SV_StartBug> jpc_tsfb_band_t bnds [ 64 ] ; <S2SV_EndBug> jpc_pchg_t * pchg ; int pchgno ; jpc_dec_cmpt_t * cmpt ; cp = tile -> cp ; tile -> realmode = 0 ; if ( cp -> mctid == JPC_MCT_ICT ) { tile -> realmode = 1 ; } for ( compno = 0 , tcomp = tile -> tcomps , cmpt = dec -> cmpts ; compno < dec -> numcomps ; ++ compno , ++ tcomp , ++ cmpt ) { ccp = & tile -> cp -> ccps [ compno ] ; if ( ccp -> qmfbid == JPC_COX_INS ) { tile -> realmode = 1 ; } tcomp -> numrlvls = ccp -> numrlvls ; if ( ! ( tcomp -> rlvls = jas_alloc2 ( tcomp -> numrlvls , sizeof ( jpc_dec_rlvl_t ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> data = jas_seq2d_create ( JPC_CEILDIV ( tile -> xstart , cmpt -> hstep ) , JPC_CEILDIV ( tile -> ystart , cmpt -> vstep ) , JPC_CEILDIV ( tile -> xend , cmpt -> hstep ) , JPC_CEILDIV ( tile -> yend , cmpt -> vstep ) ) ) ) { return - 1 ; } if ( ! ( tcomp -> tsfb = jpc_cod_gettsfb ( ccp -> qmfbid , tcomp -> numrlvls - 1 ) ) ) { return - 1 ; } { jpc_tsfb_getbands ( tcomp -> tsfb , jas_seq2d_xstart ( tcomp -> data ) , jas_seq2d_ystart ( tcomp -> data ) , jas_seq2d_xend ( tcomp -> data ) , jas_seq2d_yend ( tcomp -> data ) , bnds ) ; } for ( rlvlno = 0 , rlvl = tcomp -> rlvls ; rlvlno < tcomp -> numrlvls ; ++ rlvlno , ++ rlvl ) { rlvl -> bands = 0 ; rlvl -> xstart = JPC_CEILDIVPOW2 ( tcomp -> xstart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> ystart = JPC_CEILDIVPOW2 ( tcomp -> ystart , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> xend = JPC_CEILDIVPOW2 ( tcomp -> xend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> yend = JPC_CEILDIVPOW2 ( tcomp -> yend , tcomp -> numrlvls - 1 - rlvlno ) ; rlvl -> prcwidthexpn = ccp -> prcwidthexpns [ rlvlno ] ; rlvl -> prcheightexpn = ccp -> prcheightexpns [ rlvlno ] ; tlprcxstart = JPC_FLOORDIVPOW2 ( rlvl -> xstart , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; tlprcystart = JPC_FLOORDIVPOW2 ( rlvl -> ystart , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; brprcxend = JPC_CEILDIVPOW2 ( rlvl -> xend , rlvl -> prcwidthexpn ) << rlvl -> prcwidthexpn ; brprcyend = JPC_CEILDIVPOW2 ( rlvl -> yend , rlvl -> prcheightexpn ) << rlvl -> prcheightexpn ; rlvl -> numhprcs = ( brprcxend - tlprcxstart ) >> rlvl -> prcwidthexpn ; rlvl -> numvprcs = ( brprcyend - tlprcystart ) >> rlvl -> prcheightexpn ; rlvl -> numprcs = rlvl -> numhprcs * rlvl -> numvprcs ; if ( rlvl -> xstart >= rlvl -> xend || rlvl -> ystart >= rlvl -> yend ) { rlvl -> bands = 0 ; rlvl -> numprcs = 0 ; rlvl -> numhprcs = 0 ; rlvl -> numvprcs = 0 ; continue ; } if ( ! rlvlno ) { tlcbgxstart = tlprcxstart ; tlcbgystart = tlprcystart ; brcbgxend = brprcxend ; brcbgyend = brprcyend ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn ; } else { tlcbgxstart = JPC_CEILDIVPOW2 ( tlprcxstart , 1 ) ; tlcbgystart = JPC_CEILDIVPOW2 ( tlprcystart , 1 ) ; brcbgxend = JPC_CEILDIVPOW2 ( brprcxend , 1 ) ; brcbgyend = JPC_CEILDIVPOW2 ( brprcyend , 1 ) ; rlvl -> cbgwidthexpn = rlvl -> prcwidthexpn - 1 ; rlvl -> cbgheightexpn = rlvl -> prcheightexpn - 1 ; } rlvl -> cblkwidthexpn = JAS_MIN ( ccp -> cblkwidthexpn , rlvl -> cbgwidthexpn ) ; rlvl -> cblkheightexpn = JAS_MIN ( ccp -> cblkheightexpn , rlvl -> cbgheightexpn ) ; rlvl -> numbands = ( ! rlvlno ) ? 1 : 3 ; if ( ! ( rlvl -> bands = jas_alloc2 ( rlvl -> numbands , sizeof ( jpc_dec_band_t ) ) ) ) { return - 1 ; } for ( bandno = 0 , band = rlvl -> bands ; bandno < rlvl -> numbands ; ++ bandno , ++ band ) { bndno = ( ! rlvlno ) ? 0 : ( 3 * ( rlvlno - 1 ) + bandno + 1 ) ; bnd = & bnds [ bndno ] ; band -> orient = bnd -> orient ; band -> stepsize = ccp -> stepsizes [ bndno ] ; band -> analgain = JPC_NOMINALGAIN ( ccp -> qmfbid , tcomp -> numrlvls - 1 , rlvlno , band -> orient ) ; band -> absstepsize = jpc_calcabsstepsize ( band -> stepsize , cmpt -> prec + band -> analgain ) ; band -> numbps = ccp -> numguardbits + JPC_QCX_GETEXPN ( band -> stepsize ) - 1 ; band -> roishift = ( ccp -> roishift + band -> numbps >= JPC_PREC ) ? ( JPC_PREC - 1 - band -> numbps ) : ccp -> roishift ; band -> data = 0 ; band -> prcs = 0 ; if ( bnd -> xstart == bnd -> xend || bnd -> ystart == bnd -> yend ) { continue ; } if ( ! ( band -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( band -> data , tcomp -> data , bnd -> locxstart , bnd -> locystart , bnd -> locxend , bnd -> locyend ) ; jas_seq2d_setshift ( band -> data , bnd -> xstart , bnd -> ystart ) ; assert ( rlvl -> numprcs ) ; if ( ! ( band -> prcs = jas_alloc2 ( rlvl -> numprcs , sizeof ( jpc_dec_prc_t ) ) ) ) { return - 1 ; } cbgxstart = tlcbgxstart ; cbgystart = tlcbgystart ; for ( prccnt = rlvl -> numprcs , prc = band -> prcs ; prccnt > 0 ; -- prccnt , ++ prc ) { cbgxend = cbgxstart + ( 1 << rlvl -> cbgwidthexpn ) ; cbgyend = cbgystart + ( 1 << rlvl -> cbgheightexpn ) ; prc -> xstart = JAS_MAX ( cbgxstart , JAS_CAST ( uint_fast32_t , jas_seq2d_xstart ( band -> data ) ) ) ; prc -> ystart = JAS_MAX ( cbgystart , JAS_CAST ( uint_fast32_t , jas_seq2d_ystart ( band -> data ) ) ) ; prc -> xend = JAS_MIN ( cbgxend , JAS_CAST ( uint_fast32_t , jas_seq2d_xend ( band -> data ) ) ) ; prc -> yend = JAS_MIN ( cbgyend , JAS_CAST ( uint_fast32_t , jas_seq2d_yend ( band -> data ) ) ) ; if ( prc -> xend > prc -> xstart && prc -> yend > prc -> ystart ) { tlcblkxstart = JPC_FLOORDIVPOW2 ( prc -> xstart , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; tlcblkystart = JPC_FLOORDIVPOW2 ( prc -> ystart , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; brcblkxend = JPC_CEILDIVPOW2 ( prc -> xend , rlvl -> cblkwidthexpn ) << rlvl -> cblkwidthexpn ; brcblkyend = JPC_CEILDIVPOW2 ( prc -> yend , rlvl -> cblkheightexpn ) << rlvl -> cblkheightexpn ; prc -> numhcblks = ( brcblkxend - tlcblkxstart ) >> rlvl -> cblkwidthexpn ; prc -> numvcblks = ( brcblkyend - tlcblkystart ) >> rlvl -> cblkheightexpn ; prc -> numcblks = prc -> numhcblks * prc -> numvcblks ; assert ( prc -> numcblks > 0 ) ; if ( ! ( prc -> incltagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> numimsbstagtree = jpc_tagtree_create ( prc -> numhcblks , prc -> numvcblks ) ) ) { return - 1 ; } if ( ! ( prc -> cblks = jas_alloc2 ( prc -> numcblks , sizeof ( jpc_dec_cblk_t ) ) ) ) { return - 1 ; } cblkxstart = cbgxstart ; cblkystart = cbgystart ; for ( cblkcnt = prc -> numcblks , cblk = prc -> cblks ; cblkcnt > 0 ; ) { cblkxend = cblkxstart + ( 1 << rlvl -> cblkwidthexpn ) ; cblkyend = cblkystart + ( 1 << rlvl -> cblkheightexpn ) ; tmpxstart = JAS_MAX ( cblkxstart , prc -> xstart ) ; tmpystart = JAS_MAX ( cblkystart , prc -> ystart ) ; tmpxend = JAS_MIN ( cblkxend , prc -> xend ) ; tmpyend = JAS_MIN ( cblkyend , prc -> yend ) ; if ( tmpxend > tmpxstart && tmpyend > tmpystart ) { cblk -> firstpassno = - 1 ; cblk -> mqdec = 0 ; cblk -> nulldec = 0 ; cblk -> flags = 0 ; cblk -> numpasses = 0 ; cblk -> segs . head = 0 ; cblk -> segs . tail = 0 ; cblk -> curseg = 0 ; cblk -> numimsbs = 0 ; cblk -> numlenbits = 3 ; cblk -> flags = 0 ; if ( ! ( cblk -> data = jas_seq2d_create ( 0 , 0 , 0 , 0 ) ) ) { return - 1 ; } jas_seq2d_bindsub ( cblk -> data , band -> data , tmpxstart , tmpystart , tmpxend , tmpyend ) ; ++ cblk ; -- cblkcnt ; } cblkxstart += 1 << rlvl -> cblkwidthexpn ; if ( cblkxstart >= cbgxend ) { cblkxstart = cbgxstart ; cblkystart += 1 << rlvl -> cblkheightexpn ; } } } else { prc -> cblks = 0 ; prc -> incltagtree = 0 ; prc -> numimsbstagtree = 0 ; } cbgxstart += 1 << rlvl -> cbgwidthexpn ; if ( cbgxstart >= brcbgxend ) { cbgxstart = tlcbgxstart ; cbgystart += 1 << rlvl -> cbgheightexpn ; } } } } } if ( ! ( tile -> pi = jpc_dec_pi_create ( dec , tile ) ) ) { return - 1 ; } for ( pchgno = 0 ; pchgno < jpc_pchglist_numpchgs ( tile -> cp -> pchglist ) ; ++ pchgno ) { pchg = jpc_pchg_copy ( jpc_pchglist_get ( tile -> cp -> pchglist , pchgno ) ) ; assert ( pchg ) ; jpc_pi_addpchg ( tile -> pi , pchg ) ; } jpc_pi_init ( tile -> pi ) ; return 0 ; }
","<S2SV_ModStart> jpc_tsfb_band_t bnds [ JPC_MAXBANDS <S2SV_ModEnd> ] ; jpc_pchg_t
",mdadams@jasper/1abc2e5a401a4bf1d5ca4df91358ce5df111f495,CVE-2016-9560,https://github.com/mdadams/jasper/commit/1abc2e5a401a4bf1d5ca4df91358ce5df111f495,2017-02-15T19:59Z
CWE-190,"CWE-190 MONGO_EXPORT int mongo_insert_batch ( mongo * conn , const char * ns , const bson * * bsons , int count , mongo_write_concern * custom_write_concern , int flags ) { mongo_message * mm ; mongo_write_concern * write_concern = NULL ; int i ; char * data ; <S2SV_StartBug> int overhead = 16 + 4 + strlen ( ns ) + 1 ; <S2SV_EndBug> <S2SV_StartBug> int size = overhead ; <S2SV_EndBug> if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ; for ( i = 0 ; i < count ; i ++ ) { size += bson_size ( bsons [ i ] ) ; if ( mongo_bson_valid ( conn , bsons [ i ] , 1 ) != MONGO_OK ) return MONGO_ERROR ; } if ( ( size - overhead ) > conn -> max_bson_size ) { conn -> err = MONGO_BSON_TOO_LARGE ; return MONGO_ERROR ; } if ( mongo_choose_write_concern ( conn , custom_write_concern , & write_concern ) == MONGO_ERROR ) { return MONGO_ERROR ; } mm = mongo_message_create ( size , 0 , 0 , MONGO_OP_INSERT ) ; data = & mm -> data ; if ( flags & MONGO_CONTINUE_ON_ERROR ) data = mongo_data_append32 ( data , & ONE ) ; else data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , ns , strlen ( ns ) + 1 ) ; for ( i = 0 ; i < count ; i ++ ) { data = mongo_data_append ( data , bsons [ i ] -> data , bson_size ( bsons [ i ] ) ) ; } if ( write_concern ) { if ( mongo_message_send ( conn , mm ) == MONGO_ERROR ) { return MONGO_ERROR ; } return mongo_check_last_error ( conn , ns , write_concern ) ; } else { return mongo_message_send ( conn , mm ) ; } }
","<S2SV_ModStart> * data ; size_t <S2SV_ModEnd> overhead = 16 <S2SV_ModStart> + 1 ; size_t <S2SV_ModEnd> size = overhead
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-284,"CWE-284 static int http_connect ( http_subtransport * t ) { int error ; char * proxy_url ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; if ( git_stream_supports_proxy ( t -> io ) && ! git_remote__get_http_proxy ( t -> owner -> owner , ! ! t -> connection_data . use_ssl , & proxy_url ) ) { error = git_stream_set_proxy ( t -> io , proxy_url ) ; git__free ( proxy_url ) ; if ( error < 0 ) return error ; } error = git_stream_connect ( t -> io ) ; # if defined ( GIT_OPENSSL ) || defined ( GIT_SECURE_TRANSPORT ) || defined ( GIT_CURL ) if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; <S2SV_StartBug> int is_valid ; <S2SV_EndBug> if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; <S2SV_StartBug> giterr_clear ( ) ; <S2SV_EndBug> is_valid = error != GIT_ECERTIFICATE ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""user<S2SV_blank>cancelled<S2SV_blank>certificate<S2SV_blank>check"" ) ; return error ; } } # endif if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
","<S2SV_ModStart> ; int is_valid = ( error == GIT_OK ) <S2SV_ModStart> giterr_clear ( ) <S2SV_ModEnd> ; error =
",libgit2@libgit2/b5c6a1b407b7f8b952bded2789593b68b1876211,CVE-2016-10130,https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211,2017-03-24T15:59Z
CWE-22,"CWE-22 static int pop_fetch_message ( struct Context * ctx , struct Message * msg , int msgno ) { void * uidl = NULL ; char buf [ LONG_STRING ] ; char path [ PATH_MAX ] ; struct Progress progressbar ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct PopCache * cache = NULL ; struct Header * h = ctx -> hdrs [ msgno ] ; unsigned short bcache = 1 ; <S2SV_StartBug> msg -> fp = mutt_bcache_get ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( msg -> fp ) return 0 ; cache = & pop_data -> cache [ h -> index % POP_CACHE_LEN ] ; if ( cache -> path ) { if ( cache -> index == h -> index ) { msg -> fp = fopen ( cache -> path , ""r"" ) ; if ( msg -> fp ) return 0 ; mutt_perror ( cache -> path ) ; return - 1 ; } else { unlink ( cache -> path ) ; FREE ( & cache -> path ) ; } } while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; if ( h -> refno < 0 ) { mutt_error ( _ ( ""The<S2SV_blank>message<S2SV_blank>index<S2SV_blank>is<S2SV_blank>incorrect.<S2SV_blank>Try<S2SV_blank>reopening<S2SV_blank>the<S2SV_blank>mailbox."" ) ) ; return - 1 ; } mutt_progress_init ( & progressbar , _ ( ""Fetching<S2SV_blank>message..."" ) , MUTT_PROGRESS_SIZE , NetInc , h -> content -> length + h -> content -> offset - 1 ) ; <S2SV_StartBug> msg -> fp = mutt_bcache_put ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> if ( ! msg -> fp ) { bcache = 0 ; mutt_mktemp ( path , sizeof ( path ) ) ; msg -> fp = mutt_file_fopen ( path , ""w+"" ) ; if ( ! msg -> fp ) { mutt_perror ( path ) ; return - 1 ; } } snprintf ( buf , sizeof ( buf ) , ""RETR<S2SV_blank>%d\\r\\n"" , h -> refno ) ; const int ret = pop_fetch_data ( pop_data , buf , & progressbar , fetch_message , msg -> fp ) ; if ( ret == 0 ) break ; mutt_file_fclose ( & msg -> fp ) ; if ( ! bcache ) unlink ( path ) ; if ( ret == - 2 ) { mutt_error ( ""%s"" , pop_data -> err_msg ) ; return - 1 ; } if ( ret == - 3 ) { mutt_error ( _ ( ""Can\'t<S2SV_blank>write<S2SV_blank>message<S2SV_blank>to<S2SV_blank>temporary<S2SV_blank>file!"" ) ) ; return - 1 ; } } if ( bcache ) <S2SV_StartBug> mutt_bcache_commit ( pop_data -> bcache , h -> data ) ; <S2SV_EndBug> else { cache -> index = h -> index ; cache -> path = mutt_str_strdup ( path ) ; } rewind ( msg -> fp ) ; uidl = h -> data ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_delete ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_remove ( ctx , h ) ; mutt_env_free ( & h -> env ) ; h -> env = mutt_rfc822_read_header ( msg -> fp , h , 0 , 0 ) ; if ( ctx -> subj_hash && h -> env -> real_subj ) mutt_hash_insert ( ctx -> subj_hash , h -> env -> real_subj , h ) ; mutt_label_hash_add ( ctx , h ) ; h -> data = uidl ; h -> lines = 0 ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; while ( ! feof ( msg -> fp ) ) { ctx -> hdrs [ msgno ] -> lines ++ ; fgets ( buf , sizeof ( buf ) , msg -> fp ) ; } h -> content -> length = ftello ( msg -> fp ) - h -> content -> offset ; if ( ! WithCrypto ) h -> security = crypt_query ( h -> content ) ; mutt_clear_error ( ) ; rewind ( msg -> fp ) ; return 0 ; }
","<S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data ) <S2SV_ModStart> -> bcache , cache_id ( <S2SV_ModStart> h -> data )
",neomutt@neomutt/9bfab35522301794483f8f9ed60820bdec9be59e,CVE-2018-14363,https://github.com/neomutt/neomutt/commit/9bfab35522301794483f8f9ed60820bdec9be59e,2018-07-17T17:29Z
CWE-119,"CWE-119 static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( ut32 ) ; if ( amount < n_got || amount > UT32_MAX ) { goto out_error ; } <S2SV_StartBug> struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; <S2SV_EndBug> if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_table ) { goto out_error ; } amount = n_reloc * sizeof ( ut32 ) ; if ( amount < n_reloc || amount > UT32_MAX ) { free ( reloc_table ) ; goto out_error ; } ut32 * reloc_pointer_table = calloc ( 1 , amount + 1 ) ; if ( ! reloc_pointer_table ) { free ( reloc_table ) ; goto out_error ; } if ( obj -> hdr -> reloc_start + amount > obj -> size || obj -> hdr -> reloc_start + amount < amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> reloc_start , ( ut8 * ) reloc_pointer_table , amount ) ; if ( len != amount ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } for ( i = 0 ; i < obj -> hdr -> reloc_count ; i ++ ) { ut32 reloc_offset = r_swap_ut32 ( reloc_pointer_table [ i ] ) + BFLT_HDR_SIZE ; if ( reloc_offset < obj -> hdr -> bss_end && reloc_offset < obj -> size ) { ut32 reloc_fixed , reloc_data_offset ; if ( reloc_offset + sizeof ( ut32 ) > obj -> size || reloc_offset + sizeof ( ut32 ) < reloc_offset ) { free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } len = r_buf_read_at ( obj -> b , reloc_offset , ( ut8 * ) & reloc_fixed , sizeof ( ut32 ) ) ; if ( len != sizeof ( ut32 ) ) { eprintf ( ""problem<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>relocation<S2SV_blank>entries\\n"" ) ; free ( reloc_table ) ; free ( reloc_pointer_table ) ; goto out_error ; } reloc_data_offset = r_swap_ut32 ( reloc_fixed ) + BFLT_HDR_SIZE ; reloc_table [ i ] . addr_to_patch = reloc_offset ; reloc_table [ i ] . data_offset = reloc_data_offset ; RBinReloc * reloc = R_NEW0 ( RBinReloc ) ; if ( reloc ) { reloc -> type = R_BIN_RELOC_32 ; reloc -> paddr = reloc_table [ i ] . addr_to_patch ; reloc -> vaddr = reloc -> paddr ; r_list_append ( list , reloc ) ; } } } free ( reloc_pointer_table ) ; obj -> reloc_table = reloc_table ; } return list ; out_error : r_list_free ( list ) ; return NULL ; }
","<S2SV_ModStart> * sizeof ( struct reloc_struct_t <S2SV_ModEnd> ) ) ;
",radare@radare2/72794dc3523bbd5bb370de3c5857cb736c387e18,CVE-2017-6194,https://github.com/radare/radare2/commit/72794dc3523bbd5bb370de3c5857cb736c387e18,2017-04-03T05:59Z
CWE-862,"CWE-862 static int rename_in_ns ( int pid , char * oldname , char * * newnamep ) { <S2SV_StartBug> int fd = - 1 , ofd = - 1 , ret , ifindex = - 1 ; <S2SV_EndBug> bool grab_newname = false ; ofd = lxc_preserve_ns ( getpid ( ) , ""net"" ) ; if ( ofd < 0 ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid ( ) ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } fd = lxc_preserve_ns ( pid , ""net"" ) ; if ( fd < 0 ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid ) ; <S2SV_EndBug> <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> if ( setns ( fd , 0 ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""setns<S2SV_blank>to<S2SV_blank>container<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; goto out_err ; } <S2SV_StartBug> close ( fd ) ; fd = - 1 ; <S2SV_EndBug> if ( ! * newnamep ) { grab_newname = true ; * newnamep = VETH_DEF_NAME ; <S2SV_StartBug> if ( ! ( ifindex = if_nametoindex ( oldname ) ) ) { <S2SV_EndBug> fprintf ( stderr , ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index\\n"" ) ; goto out_err ; } } <S2SV_StartBug> if ( ( ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container\\n"" , ret , oldname , * newnamep ) ; goto out_err ; } if ( grab_newname ) { <S2SV_StartBug> char ifname [ IFNAMSIZ ] , * namep = ifname ; <S2SV_EndBug> if ( ! if_indextoname ( ifindex , namep ) ) { <S2SV_StartBug> fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name\\n"" ) ; <S2SV_EndBug> goto out_err ; } * newnamep = strdup ( namep ) ; if ( ! * newnamep ) <S2SV_StartBug> goto out_err ; <S2SV_EndBug> } <S2SV_StartBug> if ( setns ( ofd , 0 ) < 0 ) { <S2SV_EndBug> fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>netns\\n"" ) ; close ( ofd ) ; <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } close ( ofd ) ; return 0 ; out_err : if ( ofd >= 0 ) close ( ofd ) ; if ( setns ( ofd , 0 ) < 0 ) fprintf ( stderr , ""Error<S2SV_blank>returning<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; if ( fd >= 0 ) close ( fd ) ; return - 1 ; }
","<S2SV_ModStart> newnamep ) { uid_t ruid , suid , euid ; int fret = - 1 ; int fd = - 1 , ifindex <S2SV_ModEnd> = - 1 <S2SV_ModStart> 1 , ret <S2SV_ModEnd> ; bool grab_newname <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , getpid <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } fd <S2SV_ModStart> 0 ) { usernic_error ( <S2SV_ModEnd> ""Failed<S2SV_blank>opening<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>path<S2SV_blank>for<S2SV_blank>\'%d\'."" , pid <S2SV_ModStart> pid ) ; goto do_partial_cleanup ; } ret = getresuid ( & ruid , & euid , & suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>real,<S2SV_blank>effective,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>"" ""user<S2SV_blank>IDs:<S2SV_blank>%s\\n"" , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = <S2SV_ModEnd> setns ( fd <S2SV_ModStart> ( fd , CLONE_NEWNET ) ; <S2SV_ModEnd> close ( fd <S2SV_ModStart> fd ) ; fd = - 1 ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>of<S2SV_blank>"" ""the<S2SV_blank>container<S2SV_blank>with<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , pid , strerror ( errno ) ) ; goto do_partial_cleanup ; } ret = setresuid ( ruid , ruid , 0 ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>and<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>0:<S2SV_blank>%s.\\n"" , ruid , strerror ( errno ) ) ; goto do_full_cleanup ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> = VETH_DEF_NAME ; ifindex = if_nametoindex ( oldname ) ; <S2SV_ModStart> if ( ! ifindex ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>netdev<S2SV_blank>index:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup ; } } ret = lxc_netdev_rename_by_name ( oldname , * newnamep ) ; if ( ret < 0 ) { usernic_error ( ""Error<S2SV_blank>%d<S2SV_blank>renaming<S2SV_blank>netdev<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>container.\\n"" , ret , <S2SV_ModEnd> oldname , * <S2SV_ModStart> * newnamep ) ; goto do_full_cleanup <S2SV_ModEnd> ; } if <S2SV_ModStart> [ IFNAMSIZ ] ; char <S2SV_ModEnd> * namep = <S2SV_ModStart> ) ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>new<S2SV_blank>netdev<S2SV_blank>name:<S2SV_blank>%s.\\n"" , strerror ( errno ) ) ; goto do_full_cleanup <S2SV_ModEnd> ; } * <S2SV_ModStart> newnamep ) goto do_full_cleanup ; } fret = 0 ; do_full_cleanup : ret = setresuid ( ruid , euid , suid ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>restore<S2SV_blank>privilege<S2SV_blank>by<S2SV_blank>setting<S2SV_blank>effective<S2SV_blank>"" ""user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>real<S2SV_blank>user<S2SV_blank>id<S2SV_blank>to<S2SV_blank>%d,<S2SV_blank>and<S2SV_blank>saved<S2SV_blank>user<S2SV_blank>"" ""ID<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ruid , euid , suid , strerror ( errno ) ) ; fret = - 1 ; } ret = <S2SV_ModEnd> setns ( ofd <S2SV_ModStart> ( ofd , CLONE_NEWNET ) ; if ( ret < 0 ) { usernic_error ( ""Failed<S2SV_blank>to<S2SV_blank>setns()<S2SV_blank>to<S2SV_blank>original<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>"" ""of<S2SV_blank>PID<S2SV_blank>%d:<S2SV_blank>%s.\\n"" , ofd , strerror ( errno ) ) ; fret = - 1 ; } do_partial_cleanup : if ( fd >= 0 ) close ( fd ) ; close ( <S2SV_ModEnd> ofd ) ; <S2SV_ModStart> ) ; return fret <S2SV_ModEnd> ; } <S2SV_null>
",lxc@lxc/16af238036a5464ae8f2420ed3af214f0de875f9,CVE-2017-5985,https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9,2017-03-14T17:59Z
CWE-20,"CWE-20 static int __ip6_append_data ( struct sock * sk , struct flowi6 * fl6 , struct sk_buff_head * queue , struct inet_cork * cork , struct inet6_cork * v6_cork , struct page_frag * pfrag , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , unsigned int flags , struct ipcm6_cookie * ipc6 , const struct sockcm_cookie * sockc ) { struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu , orig_mtu ; int exthdrlen = 0 ; int dst_exthdrlen = 0 ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; u32 tskey = 0 ; struct rt6_info * rt = ( struct rt6_info * ) cork -> dst ; struct ipv6_txoptions * opt = v6_cork -> opt ; int csummode = CHECKSUM_NONE ; unsigned int maxnonfragsize , headersize ; skb = skb_peek_tail ( queue ) ; if ( ! skb ) { exthdrlen = opt ? opt -> opt_flen : 0 ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } mtu = cork -> fragsize ; orig_mtu = mtu ; hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; headersize = sizeof ( struct ipv6hdr ) + ( opt ? opt -> opt_flen + opt -> opt_nflen : 0 ) + ( dst_allfrag ( & rt -> dst ) ? sizeof ( struct frag_hdr ) : 0 ) + rt -> rt6i_nfheader_len ; if ( cork -> length + length > mtu - headersize && ipc6 -> dontfrag && ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; goto emsgsize ; } if ( ip6_sk_ignore_df ( sk ) ) maxnonfragsize = sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ; else maxnonfragsize = mtu ; if ( cork -> length + length > maxnonfragsize - headersize ) { emsgsize : ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - headersize + sizeof ( struct ipv6hdr ) ) ; return - EMSGSIZE ; } if ( transhdrlen && sk -> sk_protocol == IPPROTO_UDP && headersize == sizeof ( struct ipv6hdr ) && length <= mtu - headersize && ! ( flags & MSG_MORE ) && rt -> dst . dev -> features & ( NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM ) ) csummode = CHECKSUM_PARTIAL ; if ( sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { sock_tx_timestamp ( sk , sockc -> tsflags , & tx_flags ) ; if ( tx_flags & SKBTX_ANY_SW_TSTAMP && sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) tskey = sk -> sk_tskey ++ ; } cork -> length += length ; if ( ( ( ( length + fragheaderlen ) > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) && ( rt -> dst . dev -> features & NETIF_F_UFO ) && ! dst_xfrm ( & rt -> dst ) && ( sk -> sk_type == SOCK_DGRAM ) && ! udp_get_no_check6_tx ( sk ) ) { err = ip6_ufo_append_data ( sk , queue , getfrag , from , length , hh_len , fragheaderlen , exthdrlen , transhdrlen , mtu , flags , fl6 ) ; if ( err ) goto error ; return 0 ; } if ( ! skb ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( ! skb || ! skb_prev ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , orig_mtu ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; <S2SV_StartBug> if ( transhdrlen ) { <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( ! skb ) ) err = - ENOBUFS ; } if ( ! skb ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; skb_shinfo ( skb ) -> tx_flags = tx_flags ; tx_flags = 0 ; skb_shinfo ( skb ) -> tskey = tskey ; tskey = 0 ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } <S2SV_StartBug> copy = datalen - transhdrlen - fraggap ; <S2SV_EndBug> if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; if ( ( flags & MSG_CONFIRM ) && ! skb_prev ) skb_set_dst_pending_confirm ( skb , 1 ) ; __skb_queue_tail ( queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> frag_hdr ) ; copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; goto error ; } <S2SV_ModStart> ) ; } if ( copy > 0 && getfrag ( from , data + transhdrlen <S2SV_ModEnd> , offset ,
",torvalds@linux/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,CVE-2017-9242,https://github.com/torvalds/linux/commit/232cd35d0804cc241eb887bb8d4d9b3b9881c64a,2017-05-27T01:29Z
CWE-20,"CWE-20 struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned int flags , int * peeked , int * off , int * err ) { struct sk_buff * skb ; long timeo ; int error = sock_error ( sk ) ; if ( error ) goto no_packet ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { unsigned long cpu_flags ; struct sk_buff_head * queue = & sk -> sk_receive_queue ; spin_lock_irqsave ( & queue -> lock , cpu_flags ) ; skb_queue_walk ( queue , skb ) { * peeked = skb -> peeked ; if ( flags & MSG_PEEK ) { <S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> * off -= skb -> len ; continue ; } skb -> peeked = 1 ; atomic_inc ( & skb -> users ) ; } else __skb_unlink ( skb , queue ) ; spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; return skb ; } spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; error = - EAGAIN ; if ( ! timeo ) goto no_packet ; } while ( ! wait_for_packet ( sk , err , & timeo ) ) ; return NULL ; no_packet : * err = error ; return NULL ; }
","<S2SV_ModStart> skb -> len && skb -> len
",torvalds@linux/77c1090f94d1b0b5186fb13a1b71b47b1343f87f,CVE-2013-0290,https://github.com/torvalds/linux/commit/77c1090f94d1b0b5186fb13a1b71b47b1343f87f,2013-02-19T19:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static void encode_sb_rt ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; BLOCK_SIZE subsize ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> const int idx_str = xd -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; subsize = mi_8x8 [ 0 ] -> mbmi . sb_type ; } else { ctx = 0 ; subsize = BLOCK_4X4 ; } partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_StartBug> switch ( partition ) { <S2SV_EndBug> case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , <S2SV_EndBug> subsize ) ; * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , <S2SV_EndBug> subsize ) ; * get_sb_index ( x , subsize ) = 3 ; encode_sb_rt ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
","<S2SV_ModStart> * cpi , ThreadData * td , <S2SV_ModStart> , BLOCK_SIZE bsize , PC_TREE * pc_tree <S2SV_ModStart> x = & td <S2SV_ModEnd> -> mb ; <S2SV_ModStart> int bsl = b_width_log2_lookup [ bsize ] <S2SV_ModEnd> , hbs = <S2SV_ModStart> BLOCK_8X8 ) { <S2SV_ModEnd> const int idx_str <S2SV_ModStart> subsize ] ; if ( output_enabled && bsize != BLOCK_4X4 ) td -> counts -> partition [ ctx ] [ partition ] ++ ; <S2SV_ModStart> case PARTITION_NONE : <S2SV_ModEnd> encode_b_rt ( cpi <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> none <S2SV_ModEnd> ) ; break <S2SV_ModStart> case PARTITION_VERT : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> vertical [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_cols && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , & pc_tree -> vertical [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> case PARTITION_HORZ : encode_b_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 0 ] <S2SV_ModEnd> ) ; if <S2SV_ModStart> cm -> mi_rows && bsize > BLOCK_8X8 ) { encode_b_rt ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , & pc_tree -> horizontal [ 1 ] <S2SV_ModEnd> ) ; } <S2SV_ModStart> PARTITION_SPLIT ) ; encode_sb_rt ( cpi , td , tile , tp , mi_row , mi_col , output_enabled , subsize , pc_tree -> split [ 0 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 1 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize , pc_tree -> split [ 2 ] ) <S2SV_ModEnd> ; encode_sb_rt ( <S2SV_ModStart> ( cpi , td , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize , pc_tree -> split [ 3 ] <S2SV_ModEnd> ) ; break <S2SV_ModStart> : assert ( 0 && ""Invalid<S2SV_blank>partition<S2SV_blank>type."" ) ; break <S2SV_ModEnd> ; } if
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> int16_t vp9_dc_quant ( int qindex , int delta ) { <S2SV_EndBug> return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> , int delta , vpx_bit_depth_t bit_depth ) { # if CONFIG_VP9_HIGHBITDEPTH switch ( bit_depth ) { case VPX_BITS_8 : <S2SV_ModEnd> return dc_qlookup [ <S2SV_ModStart> ) ] ; case VPX_BITS_10 : return dc_qlookup_10 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; case VPX_BITS_12 : return dc_qlookup_12 [ clamp ( qindex + delta , 0 , MAXQ ) ] ; default : assert ( 0 && ""bit_depth<S2SV_blank>should<S2SV_blank>be<S2SV_blank>VPX_BITS_8,<S2SV_blank>VPX_BITS_10<S2SV_blank>or<S2SV_blank>VPX_BITS_12"" ) ; return - 1 ; } # else ( void ) bit_depth ; return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ; # endif
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } if ( pqueue_insert ( queue -> q , item ) == NULL ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; <S2SV_StartBug> OPENSSL_free ( rdata ) ; <S2SV_EndBug> pitem_free ( item ) ; <S2SV_StartBug> return ( 0 ) ; <S2SV_EndBug> } return ( 1 ) ; }
","<S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ERR_R_INTERNAL_ERROR ) ; if ( rdata -> rbuf . buf != NULL ) <S2SV_ModStart> OPENSSL_free ( rdata -> rbuf . buf ) ; OPENSSL_free ( rdata <S2SV_ModStart> ; return ( - 1 <S2SV_ModEnd> ) ; }
",openssl@openssl/103b171d8fc282ef435f8de9afbf7782e312961f,CVE-2015-0206,https://github.com/openssl/openssl/commit/103b171d8fc282ef435f8de9afbf7782e312961f,2015-01-09T02:59Z
CWE-125,"CWE-125 static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }
","<S2SV_ModStart> case MAPI_ATTACH_LONG_FILENAME : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_DATA_OBJ : assert ( ( a -> type == szMAPI_BINARY ) || ( a -> type == szMAPI_OBJECT ) ) ; <S2SV_ModStart> case MAPI_ATTACH_MIME_TAG : assert ( a -> type == szMAPI_STRING ) ; <S2SV_ModStart> case MAPI_ATTACH_CONTENT_ID : assert ( a -> type == szMAPI_STRING ) ;
",verdammelt@tnef/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,CVE-2017-6310,https://github.com/verdammelt/tnef/commit/8dccf79857ceeb7a6d3e42c1e762e7b865d5344d,2017-02-24T04:59Z
CWE-119,"CWE-119 static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; <S2SV_EndBug> if ( frame != NULL ) { <S2SV_StartBug> YV12_BUFFER_CONFIG * fb ; <S2SV_EndBug> <S2SV_StartBug> vp9_get_reference_enc ( ctx -> cpi , frame -> idx , & fb ) ; <S2SV_EndBug> yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
","<S2SV_ModStart> * ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> { vp9_ref_frame_t * const <S2SV_ModStart> YV12_BUFFER_CONFIG * fb = get_ref_frame ( & <S2SV_ModEnd> ctx -> cpi <S2SV_ModStart> ctx -> cpi -> common <S2SV_ModStart> frame -> idx ) ; if ( fb == NULL ) return VPX_CODEC_ERROR <S2SV_ModEnd> ; yuvconfig2image (
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-310,"CWE-310 static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , ""11"" , & data , & str ) ; <S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty"" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , ""data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes"" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }
","<S2SV_ModStart> str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;
",ruby@openssl/8108e0a6db133f3375608303fdd2083eb5115062,CVE-2016-7798,https://github.com/ruby/openssl/commit/8108e0a6db133f3375608303fdd2083eb5115062,2017-01-30T22:59Z
CWE-401,"CWE-401 static int nl80211_get_ftm_responder_stats ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct wireless_dev * wdev = dev -> ieee80211_ptr ; struct cfg80211_ftm_responder_stats ftm_stats = { } ; struct sk_buff * msg ; void * hdr ; struct nlattr * ftm_stats_attr ; int err ; if ( wdev -> iftype != NL80211_IFTYPE_AP || ! wdev -> beacon_interval ) return - EOPNOTSUPP ; err = rdev_get_ftm_responder_stats ( rdev , dev , & ftm_stats ) ; if ( err ) return err ; if ( ! ftm_stats . filled ) return - ENODATA ; msg = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! msg ) return - ENOMEM ; hdr = nl80211hdr_put ( msg , info -> snd_portid , info -> snd_seq , 0 , NL80211_CMD_GET_FTM_RESPONDER_STATS ) ; if ( ! hdr ) <S2SV_StartBug> return - ENOBUFS ; <S2SV_EndBug> if ( nla_put_u32 ( msg , NL80211_ATTR_IFINDEX , dev -> ifindex ) ) goto nla_put_failure ; ftm_stats_attr = nla_nest_start_noflag ( msg , NL80211_ATTR_FTM_RESPONDER_STATS ) ; if ( ! ftm_stats_attr ) goto nla_put_failure ; # define SET_FTM ( field , name , type ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_ ## type ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field ) ) goto nla_put_failure ; } while ( 0 ) # define SET_FTM_U64 ( field , name ) do { if ( ( ftm_stats . filled & BIT ( NL80211_FTM_STATS_ ## name ) ) && nla_put_u64_64bit ( msg , NL80211_FTM_STATS_ ## name , ftm_stats . field , NL80211_FTM_STATS_PAD ) ) goto nla_put_failure ; } while ( 0 ) SET_FTM ( success_num , SUCCESS_NUM , u32 ) ; SET_FTM ( partial_num , PARTIAL_NUM , u32 ) ; SET_FTM ( failed_num , FAILED_NUM , u32 ) ; SET_FTM ( asap_num , ASAP_NUM , u32 ) ; SET_FTM ( non_asap_num , NON_ASAP_NUM , u32 ) ; SET_FTM_U64 ( total_duration_ms , TOTAL_DURATION_MSEC ) ; SET_FTM ( unknown_triggers_num , UNKNOWN_TRIGGERS_NUM , u32 ) ; SET_FTM ( reschedule_requests_num , RESCHEDULE_REQUESTS_NUM , u32 ) ; SET_FTM ( out_of_window_triggers_num , OUT_OF_WINDOW_TRIGGERS_NUM , u32 ) ; # undef SET_FTM nla_nest_end ( msg , ftm_stats_attr ) ; genlmsg_end ( msg , hdr ) ; return genlmsg_reply ( msg , info ) ; nla_put_failure : nlmsg_free ( msg ) ; return - ENOBUFS ; }
","<S2SV_ModStart> ! hdr ) goto nla_put_failure <S2SV_ModEnd> ; if (
",torvalds@linux/1399c59fa92984836db90538cf92397fe7caaa57,CVE-2019-19055,https://github.com/torvalds/linux/commit/1399c59fa92984836db90538cf92397fe7caaa57,2019-11-18T06:15Z
CWE-125,"CWE-125 static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , daoack -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u,status:%u]"" , dagid_str , daoack -> rpl_daoseq , daoack -> rpl_instanceid , daoack -> rpl_status ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|dao-length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
CWE-20,"CWE-20 static void keyring_describe ( const struct key * keyring , struct seq_file * m ) { if ( keyring -> description ) seq_puts ( m , keyring -> description ) ; else seq_puts ( m , ""[anon]"" ) ; <S2SV_StartBug> if ( key_is_instantiated ( keyring ) ) { <S2SV_EndBug> if ( keyring -> keys . nr_leaves_on_tree != 0 ) seq_printf ( m , "":<S2SV_blank>%lu"" , keyring -> keys . nr_leaves_on_tree ) ; else seq_puts ( m , "":<S2SV_blank>empty"" ) ; } }
","<S2SV_ModStart> ; if ( key_is_positive <S2SV_ModEnd> ( keyring )
",torvalds@linux/363b02dab09b3226f3bd1420dad9c72b79a42a76,CVE-2017-15951,https://github.com/torvalds/linux/commit/363b02dab09b3226f3bd1420dad9c72b79a42a76,2017-10-28T02:29Z
CWE-787,"CWE-787 <S2SV_StartBug> static MagickPixelPacket * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { MagickPixelPacket * * pixels ; register ssize_t i , j ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( MagickPixelPacket * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( MagickPixelPacket * * ) NULL ) return ( ( MagickPixelPacket * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { <S2SV_StartBug> pixels [ i ] = ( MagickPixelPacket * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( MagickPixelPacket * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> <S2SV_StartBug> GetMagickPixelPacket ( image , & pixels [ i ] [ j ] ) ; <S2SV_EndBug> } return ( pixels ) ; }
","<S2SV_ModStart> const Image * images ) { const Image * next ; <S2SV_ModEnd> MagickPixelPacket * * <S2SV_ModStart> j ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; for ( <S2SV_ModEnd> i = 0 <S2SV_ModStart> ) AcquireQuantumMemory ( <S2SV_ModEnd> columns , sizeof <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j <S2SV_ModStart> ) GetMagickPixelPacket ( images <S2SV_ModEnd> , & pixels
",ImageMagick@ImageMagick/5e409ae7a389cdf2ed17469303be3f3f21cec450,CVE-2019-13300,https://github.com/ImageMagick/ImageMagick/commit/5e409ae7a389cdf2ed17469303be3f3f21cec450,2019-07-05T01:15Z
CWE-284,"CWE-284 static void toggle_os_keylockstates ( int fd , int changedlockstates ) { BTIF_TRACE_EVENT ( ""%s:<S2SV_blank>fd<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>changedlockstates<S2SV_blank>=<S2SV_blank>0x%x"" , __FUNCTION__ , fd , changedlockstates ) ; UINT8 hidreport [ 9 ] ; int reportIndex ; memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; reportIndex = 4 ; if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_CAPSLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>CAPSLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_CAPSLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_NUMLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>NUMLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_NUMLOCK ; } if ( changedlockstates & BTIF_HH_KEYSTATE_MASK_SCROLLLOCK ) { BTIF_TRACE_DEBUG ( ""%s<S2SV_blank>Setting<S2SV_blank>SCROLLLOCK"" , __FUNCTION__ ) ; hidreport [ reportIndex ++ ] = ( UINT8 ) HID_REPORT_SCROLLLOCK ; } BTIF_TRACE_DEBUG ( ""Writing<S2SV_blank>hidreport<S2SV_blank>#1<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>"" ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; <S2SV_StartBug> usleep ( 200000 ) ; <S2SV_EndBug> memset ( hidreport , 0 , 9 ) ; hidreport [ 0 ] = 1 ; BTIF_TRACE_DEBUG ( ""Writing<S2SV_blank>hidreport<S2SV_blank>#2<S2SV_blank>to<S2SV_blank>os:<S2SV_blank>"" ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 0 ] , hidreport [ 1 ] , hidreport [ 2 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x"" , __FUNCTION__ , hidreport [ 3 ] , hidreport [ 4 ] , hidreport [ 5 ] ) ; BTIF_TRACE_DEBUG ( ""%s:<S2SV_blank><S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>"" , __FUNCTION__ , hidreport [ 6 ] , hidreport [ 7 ] , hidreport [ 8 ] ) ; bta_hh_co_write ( fd , hidreport , sizeof ( hidreport ) ) ; }
","<S2SV_ModStart> ) ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 200000 )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-399,"CWE-399 <S2SV_StartBug> void ptrace_triggered ( struct perf_event * bp , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct perf_event_attr attr ; attr = bp -> attr ; attr . disabled = true ; modify_user_hw_breakpoint ( bp , & attr ) ; }
","<S2SV_ModStart> perf_event * bp <S2SV_ModEnd> , struct perf_sample_data
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-416,"CWE-416 static Image * ReadMATImageV4 ( const ImageInfo * image_info , Image * image , ExceptionInfo * exception ) { typedef struct { unsigned char Type [ 4 ] ; unsigned int nRows ; unsigned int nCols ; unsigned int imagf ; unsigned int nameLen ; } MAT4_HDR ; long ldblk ; EndianType endian ; Image * rotated_image ; MagickBooleanType status ; MAT4_HDR HDR ; QuantumInfo * quantum_info ; QuantumFormatType format_type ; register ssize_t i ; ssize_t count , y ; unsigned char * pixels ; unsigned int depth ; quantum_info = ( QuantumInfo * ) NULL ; ( void ) SeekBlob ( image , 0 , SEEK_SET ) ; status = MagickTrue ; while ( EOFBlob ( image ) == MagickFalse ) { ldblk = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( ( ldblk > 9999 ) || ( ldblk < 0 ) ) <S2SV_EndBug> break ; HDR . Type [ 3 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 2 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 1 ] = ldblk % 10 ; ldblk /= 10 ; HDR . Type [ 0 ] = ldblk ; if ( HDR . Type [ 3 ] != 0 ) break ; if ( HDR . Type [ 2 ] != 0 ) break ; if ( HDR . Type [ 0 ] == 0 ) { HDR . nRows = ReadBlobLSBLong ( image ) ; HDR . nCols = ReadBlobLSBLong ( image ) ; HDR . imagf = ReadBlobLSBLong ( image ) ; HDR . nameLen = ReadBlobLSBLong ( image ) ; endian = LSBEndian ; } else { HDR . nRows = ReadBlobMSBLong ( image ) ; HDR . nCols = ReadBlobMSBLong ( image ) ; HDR . imagf = ReadBlobMSBLong ( image ) ; HDR . nameLen = ReadBlobMSBLong ( image ) ; endian = MSBEndian ; } if ( ( HDR . imagf != 0 ) && ( HDR . imagf != 1 ) ) break ; if ( HDR . nameLen > 0xFFFF ) return ( DestroyImageList ( image ) ) ; for ( i = 0 ; i < ( ssize_t ) HDR . nameLen ; i ++ ) { int byte ; byte = ReadBlobByte ( image ) ; if ( byte == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } image -> columns = ( size_t ) HDR . nRows ; image -> rows = ( size_t ) HDR . nCols ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( DestroyImageList ( image ) ) ; if ( image_info -> ping != MagickFalse ) { Swap ( image -> columns , image -> rows ) ; if ( HDR . imagf == 1 ) ldblk *= 2 ; SeekBlob ( image , HDR . nCols * ldblk , SEEK_CUR ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) return ( image -> previous == ( Image * ) NULL ? DestroyImageList ( image ) : image ) ; goto skip_reading_current ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; ( void ) SetImageBackgroundColor ( image , exception ) ; ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) return ( DestroyImageList ( image ) ) ; switch ( HDR . Type [ 1 ] ) { case 0 : format_type = FloatingPointQuantumFormat ; depth = 64 ; break ; case 1 : format_type = FloatingPointQuantumFormat ; depth = 32 ; break ; case 2 : format_type = UnsignedQuantumFormat ; depth = 16 ; break ; case 3 : format_type = SignedQuantumFormat ; depth = 16 ; break ; case 4 : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; default : format_type = UnsignedQuantumFormat ; depth = 8 ; break ; } image -> depth = depth ; if ( HDR . Type [ 0 ] != 0 ) SetQuantumEndian ( image , quantum_info , MSBEndian ) ; status = SetQuantumFormat ( image , quantum_info , format_type ) ; status = SetQuantumDepth ( image , quantum_info , depth ) ; status = SetQuantumEndian ( image , quantum_info , endian ) ; SetQuantumScale ( quantum_info , 1.0 ) ; pixels = ( unsigned char * ) GetQuantumPixels ( quantum_info ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register Quantum * magick_restrict q ; count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; q = QueueAuthenticPixels ( image , 0 , image -> rows - y - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , GrayQuantum , pixels , exception ) ; if ( ( HDR . Type [ 1 ] == 2 ) || ( HDR . Type [ 1 ] == 3 ) ) FixSignedValues ( image , q , ( int ) image -> columns ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( HDR . imagf == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , depth / 8 * image -> columns , ( char * ) pixels ) ; if ( count == - 1 ) break ; if ( HDR . Type [ 1 ] == 0 ) InsertComplexDoubleRow ( image , ( double * ) pixels , y , 0 , 0 , exception ) ; else InsertComplexFloatRow ( image , ( float * ) pixels , y , 0 , 0 , exception ) ; } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; rotated_image -> colors = image -> colors ; DestroyBlob ( rotated_image ) ; rotated_image -> blob = ReferenceBlob ( image -> blob ) ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; skip_reading_current : AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; break ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ; if ( EOFBlob ( image ) ) break ; if (
",ImageMagick@ImageMagick/f7206618d27c2e69d977abf40e3035a33e5f6be0,CVE-2019-15140,https://github.com/ImageMagick/ImageMagick/commit/f7206618d27c2e69d977abf40e3035a33e5f6be0,2019-08-18T19:15Z
CWE-119,"CWE-119 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> <S2SV_StartBug> int i ; <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><options><S2SV_blank>-o<S2SV_blank>dst_filename<S2SV_blank>src_filename<S2SV_blank>\\n"" , exec_name ) ; fprintf ( stderr , ""\\nOptions:\\n"" ) ; arg_show_usage ( stderr , main_args ) ; fprintf ( stderr , ""\\nEncoder<S2SV_blank>Global<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , global_args ) ; fprintf ( stderr , ""\\nRate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_args ) ; fprintf ( stderr , ""\\nTwopass<S2SV_blank>Rate<S2SV_blank>Control<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , rc_twopass_args ) ; fprintf ( stderr , ""\\nKeyframe<S2SV_blank>Placement<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , kf_args ) ; # if CONFIG_VP8_ENCODER fprintf ( stderr , ""\\nVP8<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp8_args ) ; # endif # if CONFIG_VP9_ENCODER fprintf ( stderr , ""\\nVP9<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp9_args ) ; # endif <S2SV_StartBug> fprintf ( stderr , ""\\nStream<S2SV_blank>timebase<S2SV_blank>(--timebase):\\n"" <S2SV_EndBug> ""<S2SV_blank><S2SV_blank>The<S2SV_blank>desired<S2SV_blank>precision<S2SV_blank>of<S2SV_blank>timestamps<S2SV_blank>in<S2SV_blank>the<S2SV_blank>output,<S2SV_blank>expressed\\n"" ""<S2SV_blank><S2SV_blank>in<S2SV_blank>fractional<S2SV_blank>seconds.<S2SV_blank>Default<S2SV_blank>is<S2SV_blank>1/1000.\\n"" ) ; fprintf ( stderr , ""\\nIncluded<S2SV_blank>encoders:\\n\\n"" ) ; <S2SV_StartBug> for ( i = 0 ; i < get_vpx_encoder_count ( ) ; ++ i ) { <S2SV_EndBug> const VpxInterface * const encoder = get_vpx_encoder_by_index ( i ) ; <S2SV_StartBug> fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s\\n"" , <S2SV_EndBug> <S2SV_StartBug> encoder -> name , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> exit ( EXIT_FAILURE ) ; }
","<S2SV_ModStart> void usage_exit ( void <S2SV_ModStart> { int i ; const int num_encoder = get_vpx_encoder_count ( ) <S2SV_ModStart> ; # endif # if CONFIG_VP10_ENCODER fprintf ( stderr , ""\\nVP10<S2SV_blank>Specific<S2SV_blank>Options:\\n"" ) ; arg_show_usage ( stderr , vp10_args ) ; # endif <S2SV_ModStart> ; i < num_encoder <S2SV_ModEnd> ; ++ i <S2SV_ModStart> i ) ; const char * defstr = ( i == ( num_encoder - 1 ) ) ? ""(default)"" : """" ; fprintf ( stderr , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%-6s<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>%s\\n"" <S2SV_ModEnd> , encoder -> <S2SV_ModStart> ( encoder -> codec_interface ( ) ) , defstr <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } fprintf ( stderr , ""\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; fprintf ( stderr , ""Use<S2SV_blank>--codec<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>a<S2SV_blank>non-default<S2SV_blank>encoder.\\n\\n"" ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static expr_ty ast_for_trailer ( struct compiling * c , const node * n , expr_ty left_expr ) { REQ ( n , trailer ) ; if ( TYPE ( CHILD ( n , 0 ) ) == LPAR ) { if ( NCH ( n ) == 2 ) return Call ( left_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return ast_for_call ( c , CHILD ( n , 1 ) , left_expr ) ; <S2SV_EndBug> } else if ( TYPE ( CHILD ( n , 0 ) ) == DOT ) { PyObject * attr_id = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! attr_id ) return NULL ; return Attribute ( left_expr , attr_id , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else { REQ ( CHILD ( n , 0 ) , LSQB ) ; REQ ( CHILD ( n , 2 ) , RSQB ) ; n = CHILD ( n , 1 ) ; if ( NCH ( n ) == 1 ) { slice_ty slc = ast_for_slice ( c , CHILD ( n , 0 ) ) ; if ( ! slc ) return NULL ; return Subscript ( left_expr , slc , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } else { int j ; slice_ty slc ; expr_ty e ; int simple = 1 ; asdl_seq * slices , * elts ; slices = _Ta3_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! slices ) return NULL ; for ( j = 0 ; j < NCH ( n ) ; j += 2 ) { slc = ast_for_slice ( c , CHILD ( n , j ) ) ; if ( ! slc ) return NULL ; if ( slc -> kind != Index_kind ) simple = 0 ; asdl_seq_SET ( slices , j / 2 , slc ) ; } if ( ! simple ) { return Subscript ( left_expr , ExtSlice ( slices , c -> c_arena ) , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } elts = _Ta3_asdl_seq_new ( asdl_seq_LEN ( slices ) , c -> c_arena ) ; if ( ! elts ) return NULL ; for ( j = 0 ; j < asdl_seq_LEN ( slices ) ; ++ j ) { slc = ( slice_ty ) asdl_seq_GET ( slices , j ) ; assert ( slc -> kind == Index_kind && slc -> v . Index . value ) ; asdl_seq_SET ( elts , j , slc -> v . Index . value ) ; } e = Tuple ( elts , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! e ) return NULL ; return Subscript ( left_expr , Index ( e , c -> c_arena ) , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } } }
","<S2SV_ModStart> ) , left_expr , true
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-125,"CWE-125 static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , <S2SV_StartBug> number_planes , <S2SV_EndBug> one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags & 0x04 ? BlendPixelTrait : UndefinedPixelTrait ; number_planes = ( size_t ) ReadBlobByte ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; number_colormaps = ( size_t ) ReadBlobByte ( image ) ; map_length = ( unsigned char ) ReadBlobByte ( image ) ; if ( map_length >= 64 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; one = 1 ; map_length = one << map_length ; if ( ( number_planes == 0 ) || ( number_planes == 2 ) || ( bits_per_pixel != 8 ) || ( image -> columns == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( flags & 0x02 ) { for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) background_color [ i ] = 0 ; ( void ) ReadBlobByte ( image ) ; } else { p = background_color ; for ( i = 0 ; i < ( ssize_t ) number_planes ; i ++ ) * p ++ = ( unsigned char ) ReadBlobByte ( image ) ; } if ( ( number_planes & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } colormap = ( unsigned char * ) NULL ; if ( number_colormaps != 0 ) { colormap = ( unsigned char * ) AcquireQuantumMemory ( number_colormaps , 3 * map_length * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; for ( i = 0 ; i < ( ssize_t ) number_colormaps ; i ++ ) for ( x = 0 ; x < ( ssize_t ) map_length ; x ++ ) * p ++ = ( unsigned char ) ScaleShortToQuantum ( ReadBlobLSBShort ( image ) ) ; } if ( ( flags & 0x08 ) != 0 ) { char * comment ; size_t length ; length = ReadBlobLSBShort ( image ) ; if ( length != 0 ) { comment = ( char * ) AcquireQuantumMemory ( length , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , length - 1 , ( unsigned char * ) comment ) ; comment [ length - 1 ] = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; if ( ( length & 0x01 ) == 0 ) ( void ) ReadBlobByte ( image ) ; } } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) number_planes ++ ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; <S2SV_StartBug> if ( ( number_pixels * number_planes ) != ( size_t ) ( number_pixels * number_planes ) ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> pixel_info_length = image -> columns * image -> rows * MagickMax ( number_planes , 4 ) ; <S2SV_EndBug> pixel_info = AcquireVirtualMemory ( pixel_info_length , sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( flags & 0x01 ) && ! ( flags & 0x02 ) ) { ssize_t j ; p = pixels ; for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( image -> alpha_trait == UndefinedPixelTrait ) for ( j = 0 ; j < ( ssize_t ) number_planes ; j ++ ) * p ++ = background_color [ j ] ; else { for ( j = 0 ; j < ( ssize_t ) ( number_planes - 1 ) ; j ++ ) * p ++ = background_color [ j ] ; * p ++ = 0 ; } } } plane = 0 ; x = 0 ; y = 0 ; opcode = ReadBlobByte ( image ) ; do { switch ( opcode & 0x3f ) { case SkipLinesOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x = 0 ; y += operand ; break ; } case SetColorOp : { operand = ReadBlobByte ( image ) ; plane = ( unsigned char ) operand ; if ( plane == 255 ) plane = ( unsigned char ) ( number_planes - 1 ) ; x = 0 ; break ; } case SkipPixelsOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; x += operand ; break ; } case ByteDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } if ( operand & 0x01 ) ( void ) ReadBlobByte ( image ) ; x += operand ; break ; } case RunDataOp : { operand = ReadBlobByte ( image ) ; if ( opcode & 0x40 ) operand = ( int ) ReadBlobLSBShort ( image ) ; pixel = ( unsigned char ) ReadBlobByte ( image ) ; ( void ) ReadBlobByte ( image ) ; offset = ( ( image -> rows - y - 1 ) * image -> columns * number_planes ) + x * number_planes + plane ; operand ++ ; if ( offset + ( ( size_t ) operand * number_planes ) > pixel_info_length ) { if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } p = pixels + offset ; for ( i = 0 ; i < ( ssize_t ) operand ; i ++ ) { if ( ( y < ( ssize_t ) image -> rows ) && ( ( x + i ) < ( ssize_t ) image -> columns ) ) * p = pixel ; p += number_planes ; } x += operand ; break ; } default : break ; } opcode = ReadBlobByte ( image ) ; } while ( ( ( opcode & 0x3f ) != EOFOp ) && ( opcode != EOF ) ) ; if ( number_colormaps != 0 ) { MagickStatusType mask ; mask = ( MagickStatusType ) ( map_length - 1 ) ; p = pixels ; x = ( ssize_t ) number_planes ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) { if ( IsValidColormapIndex ( image , * p & mask , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } else if ( ( number_planes >= 3 ) && ( number_colormaps >= 3 ) ) for ( i = 0 ; i < ( ssize_t ) number_pixels ; i ++ ) for ( x = 0 ; x < ( ssize_t ) number_planes ; x ++ ) { if ( IsValidColormapIndex ( image , ( size_t ) ( x * map_length + ( * p & mask ) ) , & index , exception ) == MagickFalse ) break ; * p = colormap [ ( ssize_t ) index ] ; p ++ ; } if ( ( i < ( ssize_t ) number_pixels ) || ( x < ( ssize_t ) number_planes ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; } } if ( number_planes >= 3 ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( number_colormaps == 0 ) map_length = 256 ; if ( AcquireImageColormap ( image , map_length , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = colormap ; if ( number_colormaps == 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( ( unsigned char ) i ) ; } else if ( number_colormaps > 1 ) for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length ) ) ; image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * ( p + map_length * 2 ) ) ; p ++ ; } p = pixels ; if ( image -> alpha_trait == UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } else { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . red ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . green ) , q ) ; if ( IsValidColormapIndex ( image , ( ssize_t ) * p ++ , & index , exception ) == MagickFalse ) break ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) index ] . blue ) , q ) ; SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } image -> colormap = ( PixelInfo * ) RelinquishMagickMemory ( image -> colormap ) ; image -> storage_class = DirectClass ; image -> colors = 0 ; } } if ( number_colormaps != 0 ) colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; ( void ) ReadBlobByte ( image ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( memcmp ( magick , ""\\122\\314"" , 2 ) == 0 ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> number_colormaps , number_planes , number_planes_filled <S2SV_ModStart> -> rows ; number_planes_filled = ( number_planes % 2 == 0 ) ? number_planes : number_planes + 1 ; <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) != ( <S2SV_ModStart> ( number_pixels * number_planes_filled <S2SV_ModEnd> ) ) ThrowReaderException <S2SV_ModStart> -> rows * number_planes_filled <S2SV_ModEnd> ; pixel_info =
",ImageMagick@ImageMagick/2ad6d33493750a28a5a655d319a8e0b16c392de1,CVE-2016-7515,https://github.com/ImageMagick/ImageMagick/commit/2ad6d33493750a28a5a655d319a8e0b16c392de1,2017-04-19T14:59Z
CWE-125,"CWE-125 static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>post<S2SV_blank>dattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } if ( dp ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_ACCESS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>attr:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( ! er ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; <S2SV_EndBug> return ; case NFSPROC_READLINK : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parselinkres ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_READ : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( EXTRACT_32BITS ( & dp [ 1 ] ) ) ND_PRINT ( ( ndo , ""<S2SV_blank>EOF"" ) ) ; } return ; } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , 0 ) != 0 ) return ; } break ; case NFSPROC_WRITE : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; if ( er ) return ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( dp [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%u<S2SV_blank>bytes"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { ND_TCHECK ( dp [ 1 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank><%s>"" , tok2str ( nfsv3_writemodes , NULL , EXTRACT_32BITS ( & dp [ 1 ] ) ) ) ) ; } return ; } } else { if ( parseattrstat ( ndo , dp , ndo -> ndo_vflag , v3 ) != 0 ) return ; } break ; case NFSPROC_CREATE : case NFSPROC_MKDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsediropres ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_SYMLINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_MKNOD : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsecreateopres ( ndo , dp , ndo -> ndo_vflag ) != NULL ) return ; break ; case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_RENAME : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>from:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>to:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; } return ; } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_LINK : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>file<S2SV_blank>POST:"" ) ) ; if ( ! ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>dir:"" ) ) ; if ( ! ( dp = parse_wcc_data ( ndo , dp , ndo -> ndo_vflag ) ) ) break ; return ; } } else { if ( parsestatus ( ndo , dp , & er ) != NULL ) return ; } break ; case NFSPROC_READDIR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parserddires ( ndo , dp ) != 0 ) return ; } break ; case NFSPROC_READDIRPLUS : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( parsev3rddirres ( ndo , dp , ndo -> ndo_vflag ) ) return ; break ; case NFSPROC_FSSTAT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsestatfs ( ndo , dp , v3 ) != 0 ) return ; break ; case NFSPROC_FSINFO : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsefsinfo ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_PATHCONF : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsepathconf ( ndo , dp ) != 0 ) return ; break ; case NFSPROC_COMMIT : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parsewccres ( ndo , dp , ndo -> ndo_vflag ) != 0 ) return ; break ; default : return ; } trunc : if ( ! nfserr ) ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }
","<S2SV_ModStart> ! er ) { ND_TCHECK ( <S2SV_ModEnd> dp [ 0 <S2SV_ModStart> 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>c<S2SV_blank>%04x"" , EXTRACT_32BITS ( & dp [ 0 ] ) ) ) ; } <S2SV_ModEnd> return ; case
",the-tcpdump-group@tcpdump/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,CVE-2017-12898,https://github.com/the-tcpdump-group/tcpdump/commit/19d25dd8781620cd41bf178a5e2e27fc1cf242d0,2017-09-14T06:29Z
CWE-416,"CWE-416 static void fanout_release ( struct sock * sk ) { struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f ; <S2SV_StartBug> f = po -> fanout ; <S2SV_EndBug> <S2SV_StartBug> if ( ! f ) <S2SV_EndBug> return ; mutex_lock ( & fanout_mutex ) ; po -> fanout = NULL ; if ( atomic_dec_and_test ( & f -> sk_ref ) ) { list_del ( & f -> list ) ; dev_remove_pack ( & f -> prot_hook ) ; fanout_release_data ( f ) ; kfree ( f ) ; } <S2SV_StartBug> mutex_unlock ( & fanout_mutex ) ; <S2SV_EndBug> if ( po -> rollover ) kfree_rcu ( po -> rollover , rcu ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> * f ; mutex_lock ( & fanout_mutex ) ; <S2SV_ModStart> ; if ( f ) { <S2SV_ModEnd> po -> fanout <S2SV_ModStart> ) ; } <S2SV_ModEnd> if ( po <S2SV_ModStart> ) ; } mutex_unlock ( & fanout_mutex ) ; }
",torvalds@linux/d199fab63c11998a602205f7ee7ff7c05c97164b,CVE-2017-6346,https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b,2017-03-01T20:59Z
CWE-119,"CWE-119 static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { <S2SV_StartBug> token ++ ; <S2SV_EndBug> } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
","<S2SV_ModStart> { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( ""Too<S2SV_blank>many<S2SV_blank>operands\\n"" ) ; return false
",radare@radare2/df167c7db545953bb7f71c72e98e7a3ca0c793bf,CVE-2018-20460,https://github.com/radare/radare2/commit/df167c7db545953bb7f71c72e98e7a3ca0c793bf,2018-12-25T19:29Z
CWE-119,"CWE-119 int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb , * skb_prev = NULL ; unsigned int maxfraglen , fragheaderlen , mtu ; int exthdrlen ; int dst_exthdrlen ; int hh_len ; int copy ; int err ; int offset = 0 ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kzalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; if ( rt -> dst . flags & DST_XFRM_TUNNEL ) mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( & rt -> dst ) ; else mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; exthdrlen = ( opt ? opt -> opt_flen : 0 ) ; length += exthdrlen ; transhdrlen += exthdrlen ; dst_exthdrlen = rt -> dst . header_len - rt -> rt6i_nfheader_len ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) sock_tx_timestamp ( sk , & tx_flags ) ; <S2SV_StartBug> cork -> length += length ; <S2SV_EndBug> <S2SV_StartBug> if ( length > mtu ) { <S2SV_EndBug> int proto = sk -> sk_protocol ; <S2SV_StartBug> if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { <S2SV_EndBug> ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } <S2SV_StartBug> if ( proto == IPPROTO_UDP && <S2SV_EndBug> ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , transhdrlen , mtu , flags , rt ) ; if ( err ) goto error ; return 0 ; } <S2SV_StartBug> } <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; alloc_new_skb : if ( skb ) fraggap = skb -> len - maxfraglen ; else fraggap = 0 ; if ( skb == NULL || skb_prev == NULL ) ip6_append_data_mtu ( & mtu , & maxfraglen , fragheaderlen , skb , rt , np -> pmtudisc == IPV6_PMTUDISC_PROBE ) ; skb_prev = skb ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen - rt -> dst . trailer_len ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; alloclen += dst_exthdrlen ; if ( datalen != length + fraggap ) { datalen += rt -> dst . trailer_len ; } alloclen += rt -> dst . trailer_len ; fraglen = datalen + fragheaderlen ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> protocol = htons ( ETH_P_IPV6 ) ; skb -> ip_summed = CHECKSUM_NONE ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) + dst_exthdrlen ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; dst_exthdrlen = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; struct page_frag * pfrag = sk_page_frag ( sk ) ; err = - ENOMEM ; if ( ! sk_page_frag_refill ( sk , pfrag ) ) goto error ; if ( ! skb_can_coalesce ( skb , i , pfrag -> page , pfrag -> offset ) ) { err = - EMSGSIZE ; if ( i == MAX_SKB_FRAGS ) goto error ; __skb_fill_page_desc ( skb , i , pfrag -> page , pfrag -> offset , 0 ) ; skb_shinfo ( skb ) -> nr_frags = ++ i ; get_page ( pfrag -> page ) ; } copy = min_t ( int , copy , pfrag -> size - pfrag -> offset ) ; if ( getfrag ( from , page_address ( pfrag -> page ) + pfrag -> offset , offset , copy , skb -> len , skb ) < 0 ) goto error_efault ; pfrag -> offset += copy ; skb_frag_size_add ( & skb_shinfo ( skb ) -> frags [ i - 1 ] , copy ) ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error_efault : err = - EFAULT ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }
","<S2SV_ModStart> tx_flags ) ; if ( <S2SV_ModEnd> ( length > <S2SV_ModStart> > mtu ) && <S2SV_ModEnd> dontfrag && ( <S2SV_ModStart> dontfrag && ( sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_UDP || <S2SV_ModStart> == IPPROTO_UDP || sk -> sk_protocol <S2SV_ModEnd> == IPPROTO_RAW ) <S2SV_ModStart> EMSGSIZE ; } skb = skb_peek_tail ( & sk -> sk_write_queue ) ; cork -> length += length ; if ( ( ( length > mtu ) || ( skb && skb_is_gso ( skb ) ) ) && ( sk -> sk_protocol == IPPROTO_UDP ) <S2SV_ModEnd> && ( rt <S2SV_ModStart> 0 ; } if ( ! skb <S2SV_ModEnd> ) goto alloc_new_skb
",torvalds@linux/2811ebac2521ceac84f2bdae402455baa6a7fb47,CVE-2013-4387,https://github.com/torvalds/linux/commit/2811ebac2521ceac84f2bdae402455baa6a7fb47,2013-10-10T10:55Z
CWE-119,"CWE-119 static void model_rd_for_sb ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , <S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> int i ; int64_t rate_sum = 0 ; int64_t dist_sum = 0 ; const int ref = xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] ; unsigned int sse ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { <S2SV_EndBug> struct macroblock_plane * const p = & x -> plane [ i ] ; struct macroblockd_plane * const pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; <S2SV_StartBug> ( void ) cpi -> fn_ptr [ bs ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> <S2SV_StartBug> pd -> dst . buf , pd -> dst . stride , & sse ) ; <S2SV_EndBug> <S2SV_StartBug> if ( i == 0 ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_sse [ ref ] = sse ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> speed > 4 ) { <S2SV_EndBug> int64_t rate ; <S2SV_StartBug> int64_t dist ; <S2SV_EndBug> <S2SV_StartBug> int64_t square_error = sse ; <S2SV_EndBug> <S2SV_StartBug> int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ; <S2SV_EndBug> if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ; else rate = 0 ; dist = ( square_error * quantizer ) >> 8 ; rate_sum += rate ; dist_sum += dist ; } else { <S2SV_StartBug> int rate ; <S2SV_EndBug> int64_t dist ; vp9_model_rd_from_var_lapndz ( sse , 1 << num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ; rate_sum += rate ; dist_sum += dist ; } } <S2SV_StartBug> * out_rate_sum = ( int ) rate_sum ; <S2SV_EndBug> * out_dist_sum = dist_sum << 4 ; }
","<S2SV_ModStart> int64_t * out_dist_sum , int * skip_txfm_sb , int64_t * skip_sse_sb <S2SV_ModStart> int sse ; unsigned int var = 0 ; unsigned int sum_sse = 0 ; int64_t total_sse = 0 ; int skip_flag = 1 ; const int shift = 6 ; int rate ; int64_t dist ; const int dequant_shift = # if CONFIG_VP9_HIGHBITDEPTH ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) ? xd -> bd - 5 : # endif 3 ; x -> pred_sse [ ref ] = 0 ; <S2SV_ModStart> pd ) ; const TX_SIZE max_tx_size = max_txsize_lookup <S2SV_ModEnd> [ bs ] <S2SV_ModStart> [ bs ] ; const BLOCK_SIZE unit_size = txsize_to_bsize [ max_tx_size ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> shift ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> shift ; const int64_t low_dc_thr = MIN ( 50 , dc_thr >> 2 ) ; const int64_t low_ac_thr = MIN ( 80 , ac_thr >> 2 ) ; int bw = 1 << ( b_width_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int bh = 1 << ( b_height_log2_lookup [ bs ] - b_width_log2_lookup [ unit_size ] ) ; int idx , idy ; int lw = b_width_log2_lookup [ unit_size ] + 2 ; int lh = b_height_log2_lookup [ unit_size ] + 2 ; sum_sse = 0 ; for ( idy = 0 ; idy < bh ; ++ idy ) { for ( idx = 0 ; idx < bw ; ++ idx ) { uint8_t * src = <S2SV_ModEnd> p -> src <S2SV_ModStart> src . buf + ( idy * <S2SV_ModEnd> p -> src <S2SV_ModStart> src . stride << lh ) + ( idx << lw ) ; uint8_t * dst = <S2SV_ModEnd> pd -> dst <S2SV_ModStart> dst . buf + ( idy * <S2SV_ModEnd> pd -> dst <S2SV_ModStart> dst . stride << lh ) + ( idx << lh ) ; int block_idx = ( idy << 1 ) + idx ; int low_err_skip = 0 ; var = cpi -> fn_ptr [ unit_size ] . vf ( src , p -> src . stride , dst , pd -> dst . stride <S2SV_ModStart> sse ) ; x -> bsse [ ( i << 2 ) + block_idx ] = sse ; sum_sse += sse ; x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_NONE ; if ( ! x -> select_tx_size ) { if ( var < ac_thr || var <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_ONLY ; if ( sse - var < dc_thr || sse == var ) { x -> skip_txfm [ ( i << 2 ) + block_idx ] = SKIP_TXFM_AC_DC ; if ( ! sse || ( var < low_ac_thr && sse - var < low_dc_thr ) ) low_err_skip = 1 ; } } } if ( skip_flag && ! low_err_skip ) skip_flag = 0 ; if ( i == 0 ) x -> <S2SV_ModEnd> pred_sse [ ref <S2SV_ModStart> [ ref ] += sse ; } } total_sse += sum_sse ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> ( cpi -> sf . simple_model_rd_from_var <S2SV_ModEnd> ) { int64_t <S2SV_ModStart> int64_t rate ; const <S2SV_ModEnd> int64_t square_error = <S2SV_ModStart> int64_t square_error = sum_sse <S2SV_ModEnd> ; int quantizer <S2SV_ModStart> 1 ] >> dequant_shift <S2SV_ModEnd> ) ; if <S2SV_ModStart> } else { vp9_model_rd_from_var_lapndz ( sum_sse , num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> dequant_shift , <S2SV_ModEnd> & rate , <S2SV_ModStart> } } * skip_txfm_sb = skip_flag ; * skip_sse_sb = total_sse << 4 ; *
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
","<S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 8 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> += 4 ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ; break ; } while ( context -> pass > 0 && context -> pass < 4 && context -> curY >= p -> height ) { switch ( ++ context -> pass ) { case 2 : context -> curY = i -> posY + 4 ; break ; case 3 : context -> curY = i -> posY + 2 ; break ; case 4 : context -> curY = i -> posY + 1 ; break ; }
",miniupnp@ngiflib/37d939a6f511d16d4c95678025c235fe62e6417a,CVE-2019-16347,https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a,2019-09-16T13:15Z
CWE-000,"CWE-000 static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; <S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> r = ati_remote2_urb_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , ""/input0"" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , ""ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II"" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> r = ati_remote2_input_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; <S2SV_StartBug> fail3 : <S2SV_EndBug> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }
","<S2SV_ModStart> = udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &
",torvalds@linux/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d,CVE-2016-2185,https://github.com/torvalds/linux/commit/950336ba3e4a1ffd2ca60d29f6ef386dd2c7351d,2016-05-02T10:59Z
CWE-119,"CWE-119 static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , ""error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>"" ""Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n"" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( ""Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n"" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( ""Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n"" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n"" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( ""Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n"" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( ""Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( ""Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( ""Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n"" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( ""Flags:<S2SV_blank>%d<S2SV_blank>%d\\n"" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( ""Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n"" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( ""Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n"" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( ""FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n"" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
","<S2SV_ModStart> ; int i <S2SV_ModEnd> , offset ; <S2SV_ModStart> ) ) { if ( udf_load_sparable_map ( sb , map , ( <S2SV_ModEnd> struct sparablePartitionMap * <S2SV_ModStart> struct sparablePartitionMap * ) gpm ) < 0 ) goto out_bh <S2SV_ModEnd> ; } else
",torvalds@linux/1df2ae31c724e57be9d7ac00d78db8a5dabdd050,CVE-2012-3400,https://github.com/torvalds/linux/commit/1df2ae31c724e57be9d7ac00d78db8a5dabdd050,2012-10-03T11:02Z
CWE-190,"CWE-190 static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; <S2SV_StartBug> case 'c' : return getnum ( L , fmt , 1 ) ; <S2SV_EndBug> case 'i' : case 'I' : { <S2SV_StartBug> int sz = getnum ( L , fmt , sizeof ( int ) ) ; <S2SV_EndBug> if ( sz > MAXINTSIZE ) luaL_error ( L , ""integral<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
","<S2SV_ModStart> return getnum ( <S2SV_ModEnd> fmt , 1 <S2SV_ModStart> = getnum ( <S2SV_ModEnd> fmt , sizeof
",antirez@redis/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,CVE-2018-11219,https://github.com/antirez/redis/commit/1eb08bcd4634ae42ec45e8284923ac048beaa4c3,2018-06-17T17:29Z
CWE-400,"CWE-400 static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
","<S2SV_ModStart> desc_ptr dt ; unsigned long cr4 ; <S2SV_ModStart> ; vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; cr4 = read_cr4 ( ) ; vmcs_writel ( HOST_CR4 , cr4 ) ; vmx -> host_state . vmcs_host_cr4 = cr4 <S2SV_ModEnd> ; vmcs_write16 (
",torvalds@linux/d974baa398f34393db76be45f7d4d04fbdbb4a0a,CVE-2014-3690,https://github.com/torvalds/linux/commit/d974baa398f34393db76be45f7d4d04fbdbb4a0a,2014-11-10T11:55Z
CWE-189,"CWE-189 static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , <S2SV_StartBug> size_t * acl_len ) <S2SV_EndBug> { <S2SV_StartBug> __be32 * savep ; <S2SV_EndBug> uint32_t attrlen , bitmap [ 3 ] = { 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; <S2SV_StartBug> * acl_len = 0 ; <S2SV_EndBug> if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; <S2SV_StartBug> hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; <S2SV_EndBug> recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { <S2SV_StartBug> dprintk ( ""NFS:<S2SV_blank>server<S2SV_blank>cheating<S2SV_blank>in<S2SV_blank>getattr"" <S2SV_EndBug> ""<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; <S2SV_StartBug> * acl_len = attrlen ; <S2SV_EndBug> } else status = - EOPNOTSUPP ; out : return status ; }
","<S2SV_ModStart> * req , struct nfs_getaclres * res <S2SV_ModEnd> ) { __be32 <S2SV_ModStart> __be32 * savep , * bm_p <S2SV_ModStart> int status ; res -> <S2SV_ModEnd> acl_len = 0 <S2SV_ModStart> ) goto out ; bm_p = xdr -> p <S2SV_ModStart> u32 recvd ; xdr -> p = bm_p ; res -> acl_data_offset = be32_to_cpup ( bm_p ) + 2 ; res -> acl_data_offset <<= 2 ; <S2SV_ModStart> iov -> iov_base ; attrlen += res -> acl_data_offset <S2SV_ModStart> recvd ) { if ( res -> acl_flags & NFS4_ACL_LEN_REQUEST ) { res -> acl_len = attrlen ; goto out ; } dprintk ( ""NFS:<S2SV_blank>acl<S2SV_blank>reply:<S2SV_blank>attrlen<S2SV_blank>%u<S2SV_blank>><S2SV_blank>recvd<S2SV_blank>%u\\n"" <S2SV_ModEnd> , attrlen , <S2SV_ModStart> attrlen ) ; res -> <S2SV_ModEnd> acl_len = attrlen
",torvalds@linux/bf118a342f10dafe44b14451a1392c3254629a1f,CVE-2011-4131,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,2012-05-17T11:00Z
CWE-125,"CWE-125 void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }
","<S2SV_ModStart> ] & 0x40 && i > 0
",LibreDWG@libredwg/95cc9300430d35feb05b06a9badf678419463dbe,CVE-2019-20915,https://github.com/LibreDWG/libredwg/commit/95cc9300430d35feb05b06a9badf678419463dbe,2020-07-16T18:15Z
CWE-20,"CWE-20 TEE_Result tee_mmu_check_access_rights ( const struct user_ta_ctx * utc , uint32_t flags , uaddr_t uaddr , size_t len ) { uaddr_t a ; <S2SV_StartBug> size_t addr_incr = MIN ( CORE_MMU_USER_CODE_SIZE , <S2SV_EndBug> CORE_MMU_USER_PARAM_SIZE ) ; <S2SV_StartBug> if ( ADD_OVERFLOW ( uaddr , len , & a ) ) <S2SV_EndBug> return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( flags & TEE_MEMORY_ACCESS_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ! ( flags & TEE_MEMORY_ACCESS_ANY_OWNER ) && ! tee_mmu_is_vbuf_inside_ta_private ( utc , ( void * ) uaddr , len ) ) return TEE_ERROR_ACCESS_DENIED ; <S2SV_StartBug> for ( a = uaddr ; a < ( uaddr + len ) ; a += addr_incr ) { <S2SV_EndBug> uint32_t attr ; TEE_Result res ; res = tee_mmu_user_va2pa_attr ( utc , ( void * ) a , NULL , & attr ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( flags & TEE_MEMORY_ACCESS_NONSECURE ) && ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_SECURE ) && ! ( attr & TEE_MATTR_SECURE ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_WRITE ) && ! ( attr & TEE_MATTR_UW ) ) return TEE_ERROR_ACCESS_DENIED ; if ( ( flags & TEE_MEMORY_ACCESS_READ ) && ! ( attr & TEE_MATTR_UR ) ) return TEE_ERROR_ACCESS_DENIED ; } return TEE_SUCCESS ; }
","<S2SV_ModStart> uaddr_t a ; uaddr_t end_addr = 0 ; <S2SV_ModStart> len , & end_addr <S2SV_ModEnd> ) ) return <S2SV_ModStart> ( a = ROUNDDOWN ( uaddr , addr_incr ) <S2SV_ModEnd> ; a < <S2SV_ModStart> ; a < end_addr <S2SV_ModEnd> ; a +=
",OP-TEE@optee_os/95f36d661f2b75887772ea28baaad904bde96970,CVE-2019-1010293,https://github.com/OP-TEE/optee_os/commit/95f36d661f2b75887772ea28baaad904bde96970,2019-07-15T18:15Z
CWE-20,"CWE-20 void dm9000WritePhyReg ( uint8_t address , uint16_t data ) { <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPAR , 0x40 | address ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRL , LSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPDRH , MSB ( data ) ) ; <S2SV_EndBug> <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS | EPCR_ERPRW ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( dm9000ReadReg ( DM9000_REG_EPCR ) & EPCR_ERRE ) != 0 ) <S2SV_EndBug> { } usleep ( 5 ) ; <S2SV_StartBug> dm9000WriteReg ( DM9000_REG_EPCR , EPCR_EPOS ) ; <S2SV_EndBug> }
","<S2SV_ModStart> { dm9000WriteReg ( DM9000_EPAR <S2SV_ModEnd> , 0x40 | <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPDRL <S2SV_ModEnd> , LSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPDRH <S2SV_ModEnd> , MSB ( <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS <S2SV_ModEnd> ) ; }
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-000,"CWE-000 static ssize_t ext4_ext_direct_IO ( int rw , struct kiocb * iocb , const struct iovec * iov , loff_t offset , unsigned long nr_segs ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; ssize_t ret ; size_t count = iov_length ( iov , nr_segs ) ; loff_t final_size = offset + count ; if ( rw == WRITE && final_size <= inode -> i_size ) { iocb -> private = NULL ; EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ! is_sync_kiocb ( iocb ) ) { <S2SV_StartBug> iocb -> private = ext4_init_io_end ( inode ) ; <S2SV_EndBug> if ( ! iocb -> private ) return - ENOMEM ; EXT4_I ( inode ) -> cur_aio_dio = iocb -> private ; } ret = blockdev_direct_IO ( rw , iocb , inode , inode -> i_sb -> s_bdev , iov , offset , nr_segs , ext4_get_block_write , ext4_end_io_dio ) ; if ( iocb -> private ) EXT4_I ( inode ) -> cur_aio_dio = NULL ; if ( ret != - EIOCBQUEUED && ret <= 0 && iocb -> private ) { ext4_free_io_end ( iocb -> private ) ; iocb -> private = NULL ; } else if ( ret > 0 && ext4_test_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ) { int err ; err = ext4_convert_unwritten_extents ( inode , offset , ret ) ; if ( err < 0 ) ret = err ; ext4_clear_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; } return ret ; } return ext4_ind_direct_IO ( rw , iocb , iov , offset , nr_segs ) ; }
","<S2SV_ModStart> ext4_init_io_end ( inode , GFP_NOFS
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-352,"CWE-352 static void doGet ( HttpRequest req , HttpResponse res ) { set_content_type ( res , ""text/html"" ) ; if ( ACTION ( HOME ) ) { LOCK ( Run . mutex ) do_home ( res ) ; END_LOCK ; <S2SV_StartBug> } else if ( ACTION ( RUN ) ) { <S2SV_EndBug> <S2SV_StartBug> handle_run ( req , res ) ; <S2SV_EndBug> } else if ( ACTION ( TEST ) ) { <S2SV_StartBug> is_monit_running ( res ) ; <S2SV_EndBug> } else if ( ACTION ( VIEWLOG ) ) { do_viewlog ( req , res ) ; } else if ( ACTION ( ABOUT ) ) { do_about ( res ) ; } else if ( ACTION ( FAVICON ) ) { printFavicon ( res ) ; } else if ( ACTION ( PING ) ) { do_ping ( res ) ; } else if ( ACTION ( GETID ) ) { do_getid ( res ) ; <S2SV_StartBug> } else if ( ACTION ( STATUS ) ) { <S2SV_EndBug> print_status ( req , res , 1 ) ; } else if ( ACTION ( STATUS2 ) ) { print_status ( req , res , 2 ) ; } else if ( ACTION ( SUMMARY ) ) { print_summary ( req , res ) ; } else if ( ACTION ( REPORT ) ) { _printReport ( req , res ) ; } else if ( ACTION ( DOACTION ) ) { handle_do_action ( req , res ) ; } else { handle_action ( req , res ) ; } }
","<S2SV_ModStart> ( ACTION ( RUNTIME <S2SV_ModEnd> ) ) { <S2SV_ModStart> ) ) { handle_runtime <S2SV_ModEnd> ( req , <S2SV_ModStart> { is_monit_running ( <S2SV_ModEnd> res ) ; <S2SV_ModStart> ; } else { handle_service <S2SV_ModEnd> ( req ,
",tildeslash@monit/c6ec3820e627f85417053e6336de2987f2d863e3,CVE-2016-7067,https://bitbucket.org/tildeslash/monit/commit/c6ec3820e627f85417053e6336de2987f2d863e3,2018-09-10T14:29Z
CWE-264,"CWE-264 static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> ) ) ; if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( kvm_vcpu_apicv_active ( vcpu ) ) vmcs_set_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; else vmcs_clear_bits ( SECONDARY_VM_EXEC_CONTROL , SECONDARY_EXEC_APIC_REGISTER_VIRT | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ) ; } if ( cpu_has_vmx_msr_bitmap ( ) ) vmx_set_msr_bitmap ( vcpu ) ;
",torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
CWE-119,"CWE-119 void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( ""dbfilename"" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , ""dbfilename<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>a<S2SV_blank>path,<S2SV_blank>just<S2SV_blank>a<S2SV_blank>filename"" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( ""requirepass"" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""masterauth"" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""cluster-announce-ip"" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""maxclients"" ) { int orig_value = server . maxclients ; if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ; server . maxclients = ll ; if ( ll > orig_value ) { adjustOpenFilesLimit ( ) ; if ( server . maxclients != ll ) { addReplyErrorFormat ( c , ""The<S2SV_blank>operating<S2SV_blank>system<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients,<S2SV_blank>try<S2SV_blank>with<S2SV_blank>%d"" , server . maxclients ) ; server . maxclients = orig_value ; return ; } if ( ( unsigned int ) aeGetSetSize ( server . el ) < server . maxclients + CONFIG_FDSET_INCR ) { if ( aeResizeSetSize ( server . el , server . maxclients + CONFIG_FDSET_INCR ) == AE_ERR ) { addReplyError ( c , ""The<S2SV_blank>event<S2SV_blank>loop<S2SV_blank>API<S2SV_blank>used<S2SV_blank>by<S2SV_blank>Redis<S2SV_blank>is<S2SV_blank>not<S2SV_blank>able<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>number<S2SV_blank>of<S2SV_blank>clients"" ) ; server . maxclients = orig_value ; return ; } } } } config_set_special_field ( ""appendonly"" ) { int enable = yesnotoi ( o -> ptr ) ; if ( enable == - 1 ) goto badfmt ; if ( enable == 0 && server . aof_state != AOF_OFF ) { stopAppendOnly ( ) ; } else if ( enable && server . aof_state == AOF_OFF ) { if ( startAppendOnly ( ) == C_ERR ) { addReplyError ( c , ""Unable<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>AOF.<S2SV_blank>Check<S2SV_blank>server<S2SV_blank>logs."" ) ; return ; } } } config_set_special_field ( ""save"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ; if ( vlen & 1 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { char * eptr ; long val ; val = strtoll ( v [ j ] , & eptr , 10 ) ; if ( eptr [ 0 ] != '\\0' || ( ( j & 1 ) == 0 && val < 1 ) || ( ( j & 1 ) == 1 && val < 0 ) ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } resetServerSaveParams ( ) ; for ( j = 0 ; j < vlen ; j += 2 ) { time_t seconds ; int changes ; seconds = strtoll ( v [ j ] , NULL , 10 ) ; changes = strtoll ( v [ j + 1 ] , NULL , 10 ) ; appendServerSaveParams ( seconds , changes ) ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""dir"" ) { if ( chdir ( ( char * ) o -> ptr ) == - 1 ) { addReplyErrorFormat ( c , ""Changing<S2SV_blank>directory:<S2SV_blank>%s"" , strerror ( errno ) ) ; return ; } } config_set_special_field ( ""client-output-buffer-limit"" ) { int vlen , j ; sds * v = sdssplitlen ( o -> ptr , sdslen ( o -> ptr ) , ""<S2SV_blank>"" , 1 , & vlen ) ; if ( vlen % 4 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } for ( j = 0 ; j < vlen ; j ++ ) { long val ; if ( ( j % 4 ) == 0 ) { <S2SV_StartBug> if ( getClientTypeByName ( v [ j ] ) == - 1 ) { <S2SV_EndBug> sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } else { val = memtoll ( v [ j ] , & err ) ; if ( err || val < 0 ) { sdsfreesplitres ( v , vlen ) ; goto badfmt ; } } } for ( j = 0 ; j < vlen ; j += 4 ) { int class ; unsigned long long hard , soft ; int soft_seconds ; class = getClientTypeByName ( v [ j ] ) ; hard = strtoll ( v [ j + 1 ] , NULL , 10 ) ; soft = strtoll ( v [ j + 2 ] , NULL , 10 ) ; soft_seconds = strtoll ( v [ j + 3 ] , NULL , 10 ) ; server . client_obuf_limits [ class ] . hard_limit_bytes = hard ; server . client_obuf_limits [ class ] . soft_limit_bytes = soft ; server . client_obuf_limits [ class ] . soft_limit_seconds = soft_seconds ; } sdsfreesplitres ( v , vlen ) ; } config_set_special_field ( ""notify-keyspace-events"" ) { int flags = keyspaceEventsStringToFlags ( o -> ptr ) ; if ( flags == - 1 ) goto badfmt ; server . notify_keyspace_events = flags ; } config_set_special_field ( ""slave-announce-ip"" ) { zfree ( server . slave_announce_ip ) ; server . slave_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_bool_field ( ""rdbcompression"" , server . rdb_compression ) { } config_set_bool_field ( ""repl-disable-tcp-nodelay"" , server . repl_disable_tcp_nodelay ) { } config_set_bool_field ( ""repl-diskless-sync"" , server . repl_diskless_sync ) { } config_set_bool_field ( ""cluster-require-full-coverage"" , server . cluster_require_full_coverage ) { } config_set_bool_field ( ""aof-rewrite-incremental-fsync"" , server . aof_rewrite_incremental_fsync ) { } config_set_bool_field ( ""aof-load-truncated"" , server . aof_load_truncated ) { } config_set_bool_field ( ""aof-use-rdb-preamble"" , server . aof_use_rdb_preamble ) { } config_set_bool_field ( ""slave-serve-stale-data"" , server . repl_serve_stale_data ) { } config_set_bool_field ( ""slave-read-only"" , server . repl_slave_ro ) { } config_set_bool_field ( ""activerehashing"" , server . activerehashing ) { } config_set_bool_field ( ""protected-mode"" , server . protected_mode ) { } config_set_bool_field ( ""stop-writes-on-bgsave-error"" , server . stop_writes_on_bgsave_err ) { } config_set_bool_field ( ""lazyfree-lazy-eviction"" , server . lazyfree_lazy_eviction ) { } config_set_bool_field ( ""lazyfree-lazy-expire"" , server . lazyfree_lazy_expire ) { } config_set_bool_field ( ""lazyfree-lazy-server-del"" , server . lazyfree_lazy_server_del ) { } config_set_bool_field ( ""slave-lazy-flush"" , server . repl_slave_lazy_flush ) { } config_set_bool_field ( ""no-appendfsync-on-rewrite"" , server . aof_no_fsync_on_rewrite ) { } config_set_numerical_field ( ""tcp-keepalive"" , server . tcpkeepalive , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""maxmemory-samples"" , server . maxmemory_samples , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-log-factor"" , server . lfu_log_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lfu-decay-time"" , server . lfu_decay_time , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""timeout"" , server . maxidletime , 0 , LONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-percentage"" , server . aof_rewrite_perc , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""auto-aof-rewrite-min-size"" , server . aof_rewrite_min_size , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-entries"" , server . hash_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hash-max-ziplist-value"" , server . hash_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""list-max-ziplist-size"" , server . list_max_ziplist_size , INT_MIN , INT_MAX ) { } config_set_numerical_field ( ""list-compress-depth"" , server . list_compress_depth , 0 , INT_MAX ) { } config_set_numerical_field ( ""set-max-intset-entries"" , server . set_max_intset_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-entries"" , server . zset_max_ziplist_entries , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""zset-max-ziplist-value"" , server . zset_max_ziplist_value , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hll-sparse-max-bytes"" , server . hll_sparse_max_bytes , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""lua-time-limit"" , server . lua_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-log-slower-than"" , server . slowlog_log_slower_than , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slowlog-max-len"" , ll , 0 , LLONG_MAX ) { server . slowlog_max_len = ( unsigned ) ll ; } config_set_numerical_field ( ""latency-monitor-threshold"" , server . latency_monitor_threshold , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-ping-slave-period"" , server . repl_ping_slave_period , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-timeout"" , server . repl_timeout , 1 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-backlog-ttl"" , server . repl_backlog_time_limit , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""repl-diskless-sync-delay"" , server . repl_diskless_sync_delay , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-priority"" , server . slave_priority , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""slave-announce-port"" , server . slave_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""min-slaves-to-write"" , server . repl_min_slaves_to_write , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""min-slaves-max-lag"" , server . repl_min_slaves_max_lag , 0 , LLONG_MAX ) { refreshGoodSlavesCount ( ) ; } config_set_numerical_field ( ""cluster-node-timeout"" , server . cluster_node_timeout , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-announce-port"" , server . cluster_announce_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-announce-bus-port"" , server . cluster_announce_bus_port , 0 , 65535 ) { } config_set_numerical_field ( ""cluster-migration-barrier"" , server . cluster_migration_barrier , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""cluster-slave-validity-factor"" , server . cluster_slave_validity_factor , 0 , LLONG_MAX ) { } config_set_numerical_field ( ""hz"" , server . hz , 0 , LLONG_MAX ) { if ( server . hz < CONFIG_MIN_HZ ) server . hz = CONFIG_MIN_HZ ; if ( server . hz > CONFIG_MAX_HZ ) server . hz = CONFIG_MAX_HZ ; } config_set_numerical_field ( ""watchdog-period"" , ll , 0 , LLONG_MAX ) { if ( ll ) enableWatchdog ( ll ) ; else disableWatchdog ( ) ; } config_set_memory_field ( ""maxmemory"" , server . maxmemory ) { if ( server . maxmemory ) { if ( server . maxmemory < zmalloc_used_memory ( ) ) { serverLog ( LL_WARNING , ""WARNING:<S2SV_blank>the<S2SV_blank>new<S2SV_blank>maxmemory<S2SV_blank>value<S2SV_blank>set<S2SV_blank>via<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>is<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>the<S2SV_blank>current<S2SV_blank>memory<S2SV_blank>usage.<S2SV_blank>This<S2SV_blank>will<S2SV_blank>result<S2SV_blank>in<S2SV_blank>keys<S2SV_blank>eviction<S2SV_blank>and/or<S2SV_blank>inability<S2SV_blank>to<S2SV_blank>accept<S2SV_blank>new<S2SV_blank>write<S2SV_blank>commands<S2SV_blank>depending<S2SV_blank>on<S2SV_blank>the<S2SV_blank>maxmemory-policy."" ) ; } freeMemoryIfNeeded ( ) ; } } config_set_memory_field ( ""repl-backlog-size"" , ll ) { resizeReplicationBacklog ( ll ) ; } config_set_enum_field ( ""loglevel"" , server . verbosity , loglevel_enum ) { } config_set_enum_field ( ""maxmemory-policy"" , server . maxmemory_policy , maxmemory_policy_enum ) { } config_set_enum_field ( ""appendfsync"" , server . aof_fsync , aof_fsync_enum ) { } config_set_else { addReplyErrorFormat ( c , ""Unsupported<S2SV_blank>CONFIG<S2SV_blank>parameter:<S2SV_blank>%s"" , ( char * ) c -> argv [ 2 ] -> ptr ) ; return ; } addReply ( c , shared . ok ) ; return ; badfmt : addReplyErrorFormat ( c , ""Invalid<S2SV_blank>argument<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>CONFIG<S2SV_blank>SET<S2SV_blank>\'%s\'"" , ( char * ) o -> ptr , ( char * ) c -> argv [ 2 ] -> ptr ) ; }
","<S2SV_ModStart> 0 ) { int class = <S2SV_ModEnd> getClientTypeByName ( v <S2SV_ModStart> j ] ) ; if ( class <S2SV_ModStart> == - 1 || class == CLIENT_TYPE_MASTER
",antirez@redis/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,CVE-2016-8339,https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977,2016-10-28T14:59Z
CWE-119,"CWE-119 static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register PixelPacket * q ; register unsigned char * p ; register ssize_t i , x ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; while ( ( c != '\\n' ) && ( c != '\\0' ) ) { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) ; image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'Y' : case 'y' : { if ( strcmp ( keyword , ""Y"" ) == 0 ) { int height , width ; ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( q , 0 ) ; SetPixelGreen ( q , 0 ) ; SetPixelBlue ( q , 0 ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) ) ; SetPixelGreen ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) ) ; SetPixelBlue ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-416,"CWE-416 struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; <S2SV_StartBug> } <S2SV_EndBug> return opt2 ; }
","<S2SV_ModStart> += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ;
",torvalds@linux/45f6fad84cc305103b28d73482b344d7f5b76f39,CVE-2016-3841,https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39,2016-08-06T20:59Z
CWE-200,"CWE-200 int x25_negotiate_facilities ( struct sk_buff * skb , struct sock * sk , struct x25_facilities * new , struct x25_dte_facilities * dte ) { struct x25_sock * x25 = x25_sk ( sk ) ; struct x25_facilities * ours = & x25 -> facilities ; struct x25_facilities theirs ; int len ; memset ( & theirs , 0 , sizeof ( theirs ) ) ; <S2SV_StartBug> memcpy ( new , ours , sizeof ( * new ) ) ; <S2SV_EndBug> len = x25_parse_facilities ( skb , & theirs , dte , & x25 -> vc_facil_mask ) ; if ( len < 0 ) return len ; if ( ( theirs . reverse & 0x01 ) && ( ours -> reverse & 0x01 ) ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>rejecting<S2SV_blank>reverse<S2SV_blank>charging<S2SV_blank>request\\n"" ) ; return - 1 ; } new -> reverse = theirs . reverse ; if ( theirs . throughput ) { int theirs_in = theirs . throughput & 0x0f ; int theirs_out = theirs . throughput & 0xf0 ; int ours_in = ours -> throughput & 0x0f ; int ours_out = ours -> throughput & 0xf0 ; if ( ! ours_in || theirs_in < ours_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>inbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0xf0 ) | theirs_in ; } if ( ! ours_out || theirs_out < ours_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>outbound<S2SV_blank>throughput<S2SV_blank>negotiated\\n"" ) ; new -> throughput = ( new -> throughput & 0x0f ) | theirs_out ; } } if ( theirs . pacsize_in && theirs . pacsize_out ) { if ( theirs . pacsize_in < ours -> pacsize_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> pacsize_in = theirs . pacsize_in ; } if ( theirs . pacsize_out < ours -> pacsize_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>packet<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> pacsize_out = theirs . pacsize_out ; } } if ( theirs . winsize_in && theirs . winsize_out ) { if ( theirs . winsize_in < ours -> winsize_in ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>inwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> winsize_in = theirs . winsize_in ; } if ( theirs . winsize_out < ours -> winsize_out ) { SOCK_DEBUG ( sk , ""X.25:<S2SV_blank>window<S2SV_blank>size<S2SV_blank>outwards<S2SV_blank>negotiated<S2SV_blank>down\\n"" ) ; new -> winsize_out = theirs . winsize_out ; } } return len ; }
","<S2SV_ModStart> ( * new ) ) ; memset ( dte , 0 , sizeof ( * dte
",torvalds@linux/79e48650320e6fba48369fccf13fd045315b19b8,CVE-2016-4580,https://github.com/torvalds/linux/commit/79e48650320e6fba48369fccf13fd045315b19b8,2016-05-23T10:59Z
CWE-416,"CWE-416 void ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; list_del ( & pch -> list ) ; spin_unlock_bh ( & pn -> all_channels_lock ) ; <S2SV_StartBug> pch -> file . dead = 1 ; <S2SV_EndBug> wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
","<S2SV_ModStart> all_channels_lock ) ; put_net ( pch -> chan_net ) ; pch -> chan_net = NULL ;
",torvalds@linux/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,CVE-2016-4805,https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89,2016-05-23T10:59Z
CWE-200,"CWE-200 __be32 ipv6_proxy_select_ident ( struct net * net , struct sk_buff * skb ) { <S2SV_StartBug> static u32 ip6_proxy_idents_hashrnd __read_mostly ; <S2SV_EndBug> struct in6_addr buf [ 2 ] ; struct in6_addr * addrs ; u32 id ; addrs = skb_header_pointer ( skb , skb_network_offset ( skb ) + offsetof ( struct ipv6hdr , saddr ) , sizeof ( buf ) , buf ) ; if ( ! addrs ) return 0 ; <S2SV_StartBug> net_get_random_once ( & ip6_proxy_idents_hashrnd , <S2SV_EndBug> sizeof ( ip6_proxy_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_proxy_idents_hashrnd , <S2SV_EndBug> & addrs [ 1 ] , & addrs [ 0 ] ) ; return htonl ( id ) ; }
","<S2SV_ModStart> skb ) { <S2SV_ModEnd> struct in6_addr buf <S2SV_ModStart> return 0 ; <S2SV_ModEnd> id = __ipv6_select_ident <S2SV_ModStart> ( net , <S2SV_ModEnd> & addrs [
",torvalds@linux/df453700e8d81b1bdafdf684365ee2b9431fb702,CVE-2019-10638,https://github.com/torvalds/linux/commit/df453700e8d81b1bdafdf684365ee2b9431fb702,2019-07-05T23:15Z
CWE-000,"CWE-000 static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }
","<S2SV_ModStart> ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-787,"CWE-787 opj_image_t * tgatoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f ; opj_image_t * image ; unsigned int image_width , image_height , pixel_bit_depth ; unsigned int x , y ; int flip_image = 0 ; opj_image_cmptparm_t cmptparm [ 4 ] ; int numcomps ; OPJ_COLOR_SPACE color_space ; OPJ_BOOL mono ; OPJ_BOOL save_alpha ; int subsampling_dx , subsampling_dy ; int i ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading<S2SV_blank>!!\\n"" , filename ) ; return 0 ; } if ( ! tga_readheader ( f , & pixel_bit_depth , & image_width , & image_height , & flip_image ) ) { fclose ( f ) ; return NULL ; } if ( ! ( ( pixel_bit_depth == 24 ) || ( pixel_bit_depth == 32 ) ) ) { fclose ( f ) ; return NULL ; } memset ( & cmptparm [ 0 ] , 0 , 4 * sizeof ( opj_image_cmptparm_t ) ) ; mono = ( pixel_bit_depth == 8 ) || ( pixel_bit_depth == 16 ) ; save_alpha = ( pixel_bit_depth == 16 ) || ( pixel_bit_depth == 32 ) ; if ( mono ) { color_space = OPJ_CLRSPC_GRAY ; numcomps = save_alpha ? 2 : 1 ; } else { numcomps = save_alpha ? 4 : 3 ; color_space = OPJ_CLRSPC_SRGB ; } <S2SV_StartBug> subsampling_dx = parameters -> subsampling_dx ; <S2SV_EndBug> subsampling_dy = parameters -> subsampling_dy ; for ( i = 0 ; i < numcomps ; i ++ ) { cmptparm [ i ] . prec = 8 ; cmptparm [ i ] . bpp = 8 ; cmptparm [ i ] . sgnd = 0 ; cmptparm [ i ] . dx = ( OPJ_UINT32 ) subsampling_dx ; cmptparm [ i ] . dy = ( OPJ_UINT32 ) subsampling_dy ; cmptparm [ i ] . w = image_width ; cmptparm [ i ] . h = image_height ; } image = opj_image_create ( ( OPJ_UINT32 ) numcomps , & cmptparm [ 0 ] , color_space ) ; if ( ! image ) { fclose ( f ) ; return NULL ; } image -> x0 = ( OPJ_UINT32 ) parameters -> image_offset_x0 ; image -> y0 = ( OPJ_UINT32 ) parameters -> image_offset_y0 ; image -> x1 = ! image -> x0 ? ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 : image -> x0 + ( OPJ_UINT32 ) ( image_width - 1 ) * ( OPJ_UINT32 ) subsampling_dx + 1 ; image -> y1 = ! image -> y0 ? ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 : image -> y0 + ( OPJ_UINT32 ) ( image_height - 1 ) * ( OPJ_UINT32 ) subsampling_dy + 1 ; for ( y = 0 ; y < image_height ; y ++ ) { int index ; if ( flip_image ) { index = ( int ) ( ( image_height - y - 1 ) * image_width ) ; } else { index = ( int ) ( y * image_width ) ; } if ( numcomps == 3 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; index ++ ; } } else if ( numcomps == 4 ) { for ( x = 0 ; x < image_width ; x ++ ) { unsigned char r , g , b , a ; if ( ! fread ( & b , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & g , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & r , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } if ( ! fread ( & a , 1 , 1 , f ) ) { fprintf ( stderr , ""\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n"" ) ; opj_image_destroy ( image ) ; fclose ( f ) ; return NULL ; } image -> comps [ 0 ] . data [ index ] = r ; image -> comps [ 1 ] . data [ index ] = g ; image -> comps [ 2 ] . data [ index ] = b ; image -> comps [ 3 ] . data [ index ] = a ; index ++ ; } } else { fprintf ( stderr , ""Currently<S2SV_blank>unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>:<S2SV_blank>%s\\n"" , filename ) ; } } fclose ( f ) ; return image ; }
","<S2SV_ModStart> OPJ_CLRSPC_SRGB ; } if ( image_height != 0 && image_width > 10000000 / image_height / numcomps ) { char ch ; OPJ_UINT64 expected_file_size = ( OPJ_UINT64 ) image_width * image_height * numcomps ; long curpos = ftell ( f ) ; if ( expected_file_size > ( OPJ_UINT64 ) INT_MAX ) { expected_file_size = ( OPJ_UINT64 ) INT_MAX ; } fseek ( f , ( long ) expected_file_size - 1 , SEEK_SET ) ; if ( fread ( & ch , 1 , 1 , f ) != 1 ) { fclose ( f ) ; return NULL ; } fseek ( f , curpos , SEEK_SET ) ; }
",uclouvain@openjpeg/2cd30c2b06ce332dede81cccad8b334cde997281,CVE-2017-14040,https://github.com/uclouvain/openjpeg/commit/2cd30c2b06ce332dede81cccad8b334cde997281,2017-08-30T22:29Z
CWE-125,"CWE-125 <S2SV_StartBug> void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) <S2SV_EndBug> { BYTE flags ; UINT16 length ; UINT32 failureCode ; <S2SV_StartBug> WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; <S2SV_EndBug> Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:<S2SV_blank>SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:<S2SV_blank>INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:<S2SV_blank>HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:<S2SV_blank>Unknown<S2SV_blank>protocol<S2SV_blank>security<S2SV_blank>error<S2SV_blank>%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> BOOL <S2SV_ModEnd> nego_process_negotiation_failure ( rdpNego <S2SV_ModStart> , ""RDP_NEG_FAILURE"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) return FALSE <S2SV_ModStart> = NEGO_STATE_FAIL ; return TRUE ;
",FreeRDP@FreeRDP/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,CVE-2020-11089,https://github.com/FreeRDP/FreeRDP/commit/6b485b146a1b9d6ce72dfd7b5f36456c166e7a16,2020-05-29T20:15Z
CWE-119,"CWE-119 static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; <S2SV_StartBug> v_fn_ptr . vf = vp8_mse16x16 ; <S2SV_EndBug> xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param + n , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } } } }
","<S2SV_ModStart> . vf = vpx_mse16x16 <S2SV_ModEnd> ; xd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; int retsize ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>%"" PRIu32 ""<S2SV_blank>cmdSize<S2SV_blank>%"" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) <S2SV_StartBug> || pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData:<S2SV_blank>%p"" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || <S2SV_StartBug> pReplyData == NULL || <S2SV_EndBug> * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%"" PRId32 "",<S2SV_blank>replySize<S2SV_blank>%"" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData<S2SV_blank>%p"" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) <S2SV_StartBug> || pReplyData == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { <S2SV_EndBug> return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_ENABLE : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( ""EFFECT_CMD_ENABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : <S2SV_StartBug> if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { <S2SV_EndBug> return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( ""EFFECT_CMD_DISABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08"" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>"" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%"" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( ""Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%"" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }
","<S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> ) || pReplyData == NULL || replySize <S2SV_ModStart> ) || pReplyData == NULL || replySize <S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> == NULL || replySize == NULL || <S2SV_ModStart> if ( pReplyData == NULL || replySize
",frameworks@av/aeea52da00d210587fb3ed895de3d5f2e0264c88,CVE-2015-3842,https://android.googlesource.com/platform/frameworks/av/+/aeea52da00d210587fb3ed895de3d5f2e0264c88,2015-10-01T00:59Z
CWE-284,"CWE-284 static int tcp_v6_rcv ( struct sk_buff * skb ) { const struct tcphdr * th ; const struct ipv6hdr * hdr ; bool refcounted ; struct sock * sk ; int ret ; struct net * net = dev_net ( skb -> dev ) ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , ip6_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb ) ; lookup : sk = __inet6_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , inet6_iif ( skb ) , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; tcp_v6_restore_cb ( skb ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v6_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( hdr -> hop_limit < inet6_sk ( sk ) -> min_hopcount ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm6_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_v6_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v6_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v6_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ? - 1 : 0 ; no_tcp_socket : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v6_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm6_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } tcp_v6_fill_cb ( skb , hdr , th ) ; if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 ; sk2 = inet6_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , & ipv6_hdr ( skb ) -> saddr , th -> source , & ipv6_hdr ( skb ) -> daddr , ntohs ( th -> dest ) , tcp_v6_iif ( skb ) ) ; if ( sk2 ) { struct inet_timewait_sock * tw = inet_twsk ( sk ) ; inet_twsk_deschedule_put ( tw ) ; sk = sk2 ; tcp_v6_restore_cb ( skb ) ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v6_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v6_restore_cb ( skb ) ; tcp_v6_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }
","<S2SV_ModStart> ; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; hdr = ipv6_hdr ( skb )
",torvalds@linux/ac6e780070e30e4c35bd395acfe9191e6268bdd3,CVE-2016-8645,https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3,2016-11-28T03:59Z
CWE-119,"CWE-119 int squidclamav_check_preview_handler ( char * preview_data , int preview_data_len , ci_request_t * req ) { ci_headers_list_t * req_header ; struct http_info httpinf ; av_req_data_t * data = ci_service_data ( req ) ; char * clientip ; struct hostent * clientname ; unsigned long ip ; char * username ; char * content_type ; ci_off_t content_length ; char * chain_ret = NULL ; char * ret = NULL ; int chkipdone = 0 ; ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>processing<S2SV_blank>preview<S2SV_blank>header.\\n"" ) ; if ( preview_data_len ) ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>preview<S2SV_blank>data<S2SV_blank>size<S2SV_blank>is<S2SV_blank>%d\\n"" , preview_data_len ) ; if ( ( req_header = ci_http_request_headers ( req ) ) == NULL ) { ci_debug_printf ( 0 , ""ERROR<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>bad<S2SV_blank>http<S2SV_blank>header,<S2SV_blank>aborting.\\n"" ) ; return CI_ERROR ; } if ( ( username = ci_headers_value ( req -> request_header , ""X-Authenticated-User"" ) ) != NULL ) { ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>X-Authenticated-User:<S2SV_blank>%s\\n"" , username ) ; if ( simple_pattern_compare ( username , TRUSTUSER ) == 1 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>squidguard<S2SV_blank>and<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(TRUSTUSER<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>user:<S2SV_blank>%s\\n"" , username ) ; return CI_MOD_ALLOW204 ; } } else { username = ( char * ) malloc ( sizeof ( char ) * 2 ) ; strcpy ( username , ""-"" ) ; } if ( ( clientip = ci_headers_value ( req -> request_header , ""X-Client-IP"" ) ) != NULL ) { ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>X-Client-IP:<S2SV_blank>%s\\n"" , clientip ) ; ip = inet_addr ( clientip ) ; chkipdone = 0 ; if ( dnslookup == 1 ) { if ( ( clientname = gethostbyaddr ( ( char * ) & ip , sizeof ( ip ) , AF_INET ) ) != NULL ) { if ( clientname -> h_name != NULL ) { if ( client_pattern_compare ( clientip , clientname -> h_name ) > 0 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>squidguard<S2SV_blank>and<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(TRUSTCLIENT<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>client:<S2SV_blank>%s(%s)\\n"" , clientname -> h_name , clientip ) ; return CI_MOD_ALLOW204 ; } chkipdone = 1 ; } } } if ( chkipdone == 0 ) { if ( client_pattern_compare ( clientip , NULL ) > 0 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>squidguard<S2SV_blank>and<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(TRUSTCLIENT<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>client:<S2SV_blank>%s\\n"" , clientip ) ; return CI_MOD_ALLOW204 ; } } } else { clientip = ( char * ) malloc ( sizeof ( char ) * 2 ) ; strcpy ( clientip , ""-"" ) ; } if ( ! extract_http_info ( req , req_header , & httpinf ) ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>bad<S2SV_blank>http<S2SV_blank>header,<S2SV_blank>aborting.\\n"" ) ; return CI_MOD_ALLOW204 ; } ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>URL<S2SV_blank>requested:<S2SV_blank>%s\\n"" , httpinf . url ) ; if ( simple_pattern_compare ( httpinf . url , WHITELIST ) == 1 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>squidguard<S2SV_blank>and<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(WHITELIST<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>url:<S2SV_blank>%s\\n"" , httpinf . url ) ; return CI_MOD_ALLOW204 ; } if ( usepipe == 1 ) { <S2SV_StartBug> ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Sending<S2SV_blank>request<S2SV_blank>to<S2SV_blank>chained<S2SV_blank>program:<S2SV_blank>%s\\n"" , squidguard ) ; <S2SV_EndBug> ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Request:<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , httpinf . url , clientip , username , httpinf . method ) ; <S2SV_StartBug> fprintf ( sgfpw , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , httpinf . url , clientip , username , httpinf . method ) ; <S2SV_EndBug> <S2SV_StartBug> fflush ( sgfpw ) ; <S2SV_EndBug> chain_ret = ( char * ) malloc ( sizeof ( char ) * MAX_URL_SIZE ) ; if ( chain_ret != NULL ) { ret = fgets ( chain_ret , MAX_URL_SIZE , sgfpr ) ; if ( ( ret != NULL ) && ( strlen ( chain_ret ) > 1 ) ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Chained<S2SV_blank>program<S2SV_blank>redirection<S2SV_blank>received:<S2SV_blank>%s\\n"" , chain_ret ) ; if ( logredir ) ci_debug_printf ( 0 , ""INFO<S2SV_blank>Chained<S2SV_blank>program<S2SV_blank>redirection<S2SV_blank>received:<S2SV_blank>%s\\n"" , chain_ret ) ; data -> blocked = 1 ; generate_redirect_page ( strtok ( chain_ret , ""<S2SV_blank>"" ) , req , data ) ; xfree ( chain_ret ) ; chain_ret = NULL ; return CI_MOD_CONTINUE ; } xfree ( chain_ret ) ; chain_ret = NULL ; } } if ( strcmp ( httpinf . method , ""CONNECT"" ) == 0 ) { ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>method<S2SV_blank>%s<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>scanned.\\n"" , httpinf . method ) ; return CI_MOD_ALLOW204 ; } if ( simple_pattern_compare ( httpinf . url , ABORT ) == 1 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(ABORT<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>url:<S2SV_blank>%s\\n"" , httpinf . url ) ; return CI_MOD_ALLOW204 ; } content_length = ci_http_content_length ( req ) ; ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Content-Length:<S2SV_blank>%d\\n"" , ( int ) content_length ) ; if ( ( content_length > 0 ) && ( maxsize > 0 ) && ( content_length >= maxsize ) ) { ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>antivir<S2SV_blank>check,<S2SV_blank>content-length<S2SV_blank>upper<S2SV_blank>than<S2SV_blank>maxsize<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%d)\\n"" , content_length , ( int ) maxsize ) ; return CI_MOD_ALLOW204 ; } if ( ( content_type = http_content_type ( req ) ) != NULL ) { ci_debug_printf ( 2 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>Content-Type:<S2SV_blank>%s\\n"" , content_type ) ; if ( simple_pattern_compare ( content_type , ABORTCONTENT ) ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>antivir<S2SV_blank>check<S2SV_blank>(ABORTCONTENT<S2SV_blank>match)<S2SV_blank>for<S2SV_blank>content-type:<S2SV_blank>%s\\n"" , content_type ) ; return CI_MOD_ALLOW204 ; } } if ( ! data || ! ci_req_hasbody ( req ) ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>No<S2SV_blank>body<S2SV_blank>data,<S2SV_blank>allow<S2SV_blank>204\\n"" ) ; return CI_MOD_ALLOW204 ; } if ( preview_data_len == 0 ) { ci_debug_printf ( 1 , ""DEBUG<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>can<S2SV_blank>not<S2SV_blank>begin<S2SV_blank>to<S2SV_blank>scan<S2SV_blank>url:<S2SV_blank>No<S2SV_blank>preview<S2SV_blank>data.\\n"" ) ; return CI_MOD_ALLOW204 ; } data -> url = ci_buffer_alloc ( strlen ( httpinf . url ) + 1 ) ; strcpy ( data -> url , httpinf . url ) ; if ( username != NULL ) { data -> user = ci_buffer_alloc ( strlen ( username ) + 1 ) ; strcpy ( data -> user , username ) ; } else { data -> user = NULL ; } if ( clientip != NULL ) { data -> clientip = ci_buffer_alloc ( strlen ( clientip ) + 1 ) ; strcpy ( data -> clientip , clientip ) ; } else { ci_debug_printf ( 0 , ""ERROR<S2SV_blank>squidclamav_check_preview_handler:<S2SV_blank>clientip<S2SV_blank>is<S2SV_blank>null,<S2SV_blank>you<S2SV_blank>must<S2SV_blank>set<S2SV_blank>\'icap_send_client_ip<S2SV_blank>on\'<S2SV_blank>into<S2SV_blank>squid.conf\\n"" ) ; data -> clientip = NULL ; } data -> body = ci_simple_file_new ( 0 ) ; if ( ( SEND_PERCENT_BYTES >= 0 ) && ( START_SEND_AFTER == 0 ) ) { ci_req_unlock_data ( req ) ; ci_simple_file_lock_all ( data -> body ) ; } if ( ! data -> body ) return CI_ERROR ; if ( preview_data_len ) { if ( ci_simple_file_write ( data -> body , preview_data , preview_data_len , ci_req_hasalldata ( req ) ) == CI_ERROR ) return CI_ERROR ; } return CI_MOD_CONTINUE ; }
","<S2SV_ModStart> 1 ) { char * rbuff = NULL ; <S2SV_ModStart> method ) ; rbuff = replace ( httpinf . url , ""%"" , ""%25"" ) ; <S2SV_ModStart> , ""%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , rbuff <S2SV_ModEnd> , clientip , <S2SV_ModStart> fflush ( sgfpw ) ; xfree ( rbuff
",darold@squidclamav/80f74451f628264d1d9a1f1c0bbcebc932ba5e00,CVE-2012-3501,https://github.com/darold/squidclamav/commit/80f74451f628264d1d9a1f1c0bbcebc932ba5e00,2012-08-25T10:29Z
CWE-119,"CWE-119 static void test_modules ( ) { assert_true_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_false_rule ( <S2SV_StartBug> ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , <S2SV_EndBug> NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_error ( ""import<S2SV_blank>\\""\\\\x00\\"""" , ERROR_INVALID_MODULE_NAME ) ; assert_error ( ""import<S2SV_blank>\\""\\"""" , ERROR_INVALID_MODULE_NAME ) ; }
","<S2SV_ModStart> { assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.one<S2SV_blank>+<S2SV_blank>1<S2SV_blank>==<S2SV_blank>tests.constants.two<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.foo<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.constants.empty<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.empty()<S2SV_blank>==<S2SV_blank>\\""\\""<S2SV_blank><S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[1].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>or<S2SV_blank>true<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[0]<S2SV_blank>==<S2SV_blank>0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[1]<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.integer_array[256]<S2SV_blank>==<S2SV_blank>256<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[0]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_array[2]<S2SV_blank>==<S2SV_blank>\\""baz\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""foo\\""]<S2SV_blank>==<S2SV_blank>\\""foo\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.string_dict[\\""bar\\""]<S2SV_blank>==<S2SV_blank>\\""bar\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.isum(1,2,3)<S2SV_blank>==<S2SV_blank>6<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,2.0,3.0)<S2SV_blank>==<S2SV_blank>6.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>==<S2SV_blank>tests.foobar(1)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.foobar(1)<S2SV_blank>!=<S2SV_blank>tests.foobar(2)<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>tests.length(\\""dummy\\"")<S2SV_blank>==<S2SV_blank>5<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.struct_array[0].i<S2SV_blank>==<S2SV_blank>1<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.isum(1,1)<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL ) <S2SV_ModStart> ; assert_false_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.fsum(1.0,1.0)<S2SV_blank>==<S2SV_blank>3.0<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""foo\\"")<S2SV_blank>==<S2SV_blank>3<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo/,\\""bar\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/i,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>-1\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" , NULL ) ; assert_true_rule ( ""import<S2SV_blank>\\""tests\\""<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>condition:<S2SV_blank>tests.match(/foo.bar/is,\\""FOO\\\\nBAR\\"")<S2SV_blank>==<S2SV_blank>7\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" <S2SV_ModEnd> , NULL )
",VirusTotal@yara/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,CVE-2017-11328,https://github.com/VirusTotal/yara/commit/4a342f01e5439b9bb901aff1c6c23c536baeeb3f,2017-07-17T13:18Z
CWE-125,"CWE-125 <S2SV_StartBug> int ntlm_read_message_fields ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( Stream_GetRemainingLength ( s ) < 8 ) return - 1 ; Stream_Read_UINT16 ( s , fields -> Len ) ; Stream_Read_UINT16 ( s , fields -> MaxLen ) ; Stream_Read_UINT32 ( s , fields -> BufferOffset ) ; return 1 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> static
",FreeRDP@FreeRDP/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,CVE-2018-8789,https://github.com/FreeRDP/FreeRDP/commit/2ee663f39dc8dac3d9988e847db19b2d7e3ac8c6,2018-11-29T18:29Z
CWE-000,"CWE-000 static int ext4_writepage ( struct page * page , struct writeback_control * wbc ) { int ret = 0 ; loff_t size ; unsigned int len ; <S2SV_StartBug> struct buffer_head * page_bufs ; <S2SV_EndBug> struct inode * inode = page -> mapping -> host ; trace_ext4_writepage ( inode , page ) ; size = i_size_read ( inode ) ; if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { ret = block_prepare_write ( page , 0 , len , noalloc_get_block_write ) ; if ( ! ret ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } block_commit_write ( page , 0 , len ) ; } if ( PageChecked ( page ) && ext4_should_journal_data ( inode ) ) { ClearPageChecked ( page ) ; return __ext4_journalled_writepage ( page , len ) ; } if ( test_opt ( inode -> i_sb , NOBH ) && ext4_should_writeback_data ( inode ) ) ret = nobh_writepage ( page , noalloc_get_block_write , wbc ) ; <S2SV_StartBug> else <S2SV_EndBug> ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ; return ret ; }
","<S2SV_ModStart> buffer_head * page_bufs = NULL <S2SV_ModStart> ) ; else if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-78,"CWE-78 static char * __filterShell ( const char * arg ) { r_return_val_if_fail ( arg , NULL ) ; char * a = malloc ( strlen ( arg ) + 1 ) ; if ( ! a ) { return NULL ; } char * b = a ; while ( * arg ) { <S2SV_StartBug> switch ( * arg ) { <S2SV_EndBug> case '@' : case '`' : case '|' : case ';' : <S2SV_StartBug> case '\\n' : <S2SV_EndBug> break ; default : <S2SV_StartBug> * b ++ = * arg ; <S2SV_EndBug> break ; } arg ++ ; } * b = 0 ; return a ; }
","<S2SV_ModStart> arg ) { char ch = * arg ; switch ( ch <S2SV_ModEnd> ) { case <S2SV_ModStart> ';' : case '=' : case <S2SV_ModStart> b ++ = ch <S2SV_ModEnd> ; break ;
",radareorg@radare2/5411543a310a470b1257fb93273cdd6e8dfcb3af,CVE-2019-16718,https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af,2019-09-23T14:15Z
CWE-119,"CWE-119 static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MaxTextExtent ] ; CINInfo cin ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register PixelPacket * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . file_size = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . file . version ) , ( unsigned char * ) cin . file . version ) ; ( void ) CopyMagickString ( property , cin . file . version , sizeof ( cin . file . version ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.version"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . filename ) , ( unsigned char * ) cin . file . filename ) ; ( void ) CopyMagickString ( property , cin . file . filename , sizeof ( cin . file . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_date ) , ( unsigned char * ) cin . file . create_date ) ; ( void ) CopyMagickString ( property , cin . file . create_date , sizeof ( cin . file . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . create_time ) , ( unsigned char * ) cin . file . create_time ) ; ( void ) CopyMagickString ( property , cin . file . create_time , sizeof ( cin . file . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:file.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . file . reserve ) , ( unsigned char * ) cin . file . reserve ) ; cin . image . orientation = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; if ( cin . image . orientation != ( unsigned char ) ( ~ 0 ) ) ( void ) FormatImageProperty ( image , ""dpx:image.orientation"" , ""%d"" , cin . image . orientation ) ; switch ( cin . image . orientation ) { default : case 0 : image -> orientation = TopLeftOrientation ; break ; case 1 : image -> orientation = TopRightOrientation ; break ; case 2 : image -> orientation = BottomLeftOrientation ; break ; case 3 : image -> orientation = BottomRightOrientation ; break ; case 4 : image -> orientation = LeftTopOrientation ; break ; case 5 : image -> orientation = RightTopOrientation ; break ; case 6 : image -> orientation = LeftBottomOrientation ; break ; case 7 : image -> orientation = RightBottomOrientation ; break ; } cin . image . number_channels = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; offset += ReadBlob ( image , sizeof ( cin . image . reserve1 ) , ( unsigned char * ) cin . image . reserve1 ) ; for ( i = 0 ; i < 8 ; i ++ ) { cin . image . channel [ i ] . designator [ 0 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . designator [ 1 ] = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . bits_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . reserve = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . image . channel [ i ] . pixels_per_line = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . lines_per_image = ReadBlobLong ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . min_quantity = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_data = ReadBlobFloat ( image ) ; offset += 4 ; cin . image . channel [ i ] . max_quantity = ReadBlobFloat ( image ) ; offset += 4 ; } cin . image . white_point [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 0 ] ) != MagickFalse ) image -> chromaticity . white_point . x = cin . image . white_point [ 0 ] ; cin . image . white_point [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . white_point [ 1 ] ) != MagickFalse ) image -> chromaticity . white_point . y = cin . image . white_point [ 1 ] ; cin . image . red_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . red_primary_chromaticity [ 0 ] ; cin . image . red_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . red_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . red_primary . y = cin . image . red_primary_chromaticity [ 1 ] ; cin . image . green_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . red_primary . x = cin . image . green_primary_chromaticity [ 0 ] ; cin . image . green_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . green_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . green_primary . y = cin . image . green_primary_chromaticity [ 1 ] ; cin . image . blue_primary_chromaticity [ 0 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 0 ] ) != MagickFalse ) image -> chromaticity . blue_primary . x = cin . image . blue_primary_chromaticity [ 0 ] ; cin . image . blue_primary_chromaticity [ 1 ] = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . image . blue_primary_chromaticity [ 1 ] ) != MagickFalse ) image -> chromaticity . blue_primary . y = cin . image . blue_primary_chromaticity [ 1 ] ; offset += ReadBlob ( image , sizeof ( cin . image . label ) , ( unsigned char * ) cin . image . label ) ; ( void ) CopyMagickString ( property , cin . image . label , sizeof ( cin . image . label ) ) ; ( void ) SetImageProperty ( image , ""dpx:image.label"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . image . reserve ) , ( unsigned char * ) cin . image . reserve ) ; cin . data_format . interleave = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . packing = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sign = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . sense = ( unsigned char ) ReadBlobByte ( image ) ; offset ++ ; cin . data_format . line_pad = ReadBlobLong ( image ) ; offset += 4 ; cin . data_format . channel_pad = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . data_format . reserve ) , ( unsigned char * ) cin . data_format . reserve ) ; cin . origination . x_offset = ( int ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . x_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.x_offset"" , ""%.20g"" , ( double ) cin . origination . x_offset ) ; cin . origination . y_offset = ( ssize_t ) ReadBlobLong ( image ) ; offset += 4 ; if ( ( size_t ) cin . origination . y_offset != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:origination.y_offset"" , ""%.20g"" , ( double ) cin . origination . y_offset ) ; offset += ReadBlob ( image , sizeof ( cin . origination . filename ) , ( unsigned char * ) cin . origination . filename ) ; ( void ) CopyMagickString ( property , cin . origination . filename , sizeof ( cin . origination . filename ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.filename"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_date ) , ( unsigned char * ) cin . origination . create_date ) ; ( void ) CopyMagickString ( property , cin . origination . create_date , sizeof ( cin . origination . create_date ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_date"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . create_time ) , ( unsigned char * ) cin . origination . create_time ) ; ( void ) CopyMagickString ( property , cin . origination . create_time , sizeof ( cin . origination . create_time ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.create_time"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . device ) , ( unsigned char * ) cin . origination . device ) ; ( void ) CopyMagickString ( property , cin . origination . device , sizeof ( cin . origination . device ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.device"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . origination . model ) , ( unsigned char * ) cin . origination . model ) ; ( void ) CopyMagickString ( property , cin . origination . model , sizeof ( cin . origination . model ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.model"" , property ) ; ( void ) ResetMagickMemory ( cin . origination . serial , 0 , sizeof ( cin . origination . serial ) ) ; offset += ReadBlob ( image , sizeof ( cin . origination . serial ) , ( unsigned char * ) cin . origination . serial ) ; ( void ) CopyMagickString ( property , cin . origination . serial , sizeof ( cin . origination . serial ) ) ; ( void ) SetImageProperty ( image , ""dpx:origination.serial"" , property ) ; cin . origination . x_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . y_pitch = ReadBlobFloat ( image ) ; offset += 4 ; cin . origination . gamma = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . origination . gamma ) != MagickFalse ) image -> gamma = cin . origination . gamma ; offset += ReadBlob ( image , sizeof ( cin . origination . reserve ) , ( unsigned char * ) cin . origination . reserve ) ; if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { int c ; cin . film . id = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . id ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.id"" , ""%d"" , cin . film . id ) ; cin . film . type = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . type ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.type"" , ""%d"" , cin . film . type ) ; cin . film . offset = ReadBlobByte ( image ) ; offset ++ ; c = cin . film . offset ; if ( c != ~ 0 ) ( void ) FormatImageProperty ( image , ""dpx:film.offset"" , ""%d"" , cin . film . offset ) ; cin . film . reserve1 = ReadBlobByte ( image ) ; offset ++ ; cin . film . prefix = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . prefix != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.prefix"" , ""%.20g"" , ( double ) cin . film . prefix ) ; cin . film . count = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( cin . film . format ) , ( unsigned char * ) cin . film . format ) ; ( void ) CopyMagickString ( property , cin . film . format , sizeof ( cin . film . format ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.format"" , property ) ; cin . film . frame_position = ReadBlobLong ( image ) ; offset += 4 ; if ( cin . film . frame_position != ~ 0UL ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_position"" , ""%.20g"" , ( double ) cin . film . frame_position ) ; cin . film . frame_rate = ReadBlobFloat ( image ) ; offset += 4 ; if ( IsFloatDefined ( cin . film . frame_rate ) != MagickFalse ) ( void ) FormatImageProperty ( image , ""dpx:film.frame_rate"" , ""%g"" , cin . film . frame_rate ) ; offset += ReadBlob ( image , sizeof ( cin . film . frame_id ) , ( unsigned char * ) cin . film . frame_id ) ; ( void ) CopyMagickString ( property , cin . film . frame_id , sizeof ( cin . film . frame_id ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.frame_id"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . slate_info ) , ( unsigned char * ) cin . film . slate_info ) ; ( void ) CopyMagickString ( property , cin . film . slate_info , sizeof ( cin . film . slate_info ) ) ; ( void ) SetImageProperty ( image , ""dpx:film.slate_info"" , property ) ; offset += ReadBlob ( image , sizeof ( cin . film . reserve ) , ( unsigned char * ) cin . film . reserve ) ; } if ( ( cin . file . image_offset > 2048 ) && ( cin . file . user_length != 0 ) ) { StringInfo * profile ; profile = BlobToStringInfo ( ( const void * ) NULL , cin . file . user_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; offset += ReadBlob ( image , GetStringInfoLength ( profile ) , GetStringInfoDatum ( profile ) ) ; ( void ) SetImageProfile ( image , ""dpx:user.data"" , profile ) ; profile = DestroyStringInfo ( profile ) ; } for ( ; offset < ( MagickOffsetType ) cin . file . image_offset ; offset ++ ) ( void ) ReadBlobByte ( image ) ; image -> depth = cin . image . channel [ 0 ] . bits_per_pixel ; image -> columns = cin . image . channel [ 0 ] . pixels_per_line ; image -> rows = cin . image . channel [ 0 ] . lines_per_image ; <S2SV_StartBug> if ( image_info -> ping ) <S2SV_EndBug> { ( void ) CloseBlob ( image ) ; <S2SV_StartBug> return ( image ) ; <S2SV_EndBug> } quantum_info = AcquireQuantumInfo ( image_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_info -> quantum = 32 ; quantum_info -> pack = MagickFalse ; quantum_type = RGBQuantum ; pixels = GetQuantumPixels ( quantum_info ) ; length = GetQuantumExtent ( image , quantum_info , quantum_type ) ; length = GetBytesPerRow ( image -> columns , 3 , image -> depth , MagickTrue ) ; if ( cin . image . number_channels == 1 ) { quantum_type = GrayQuantum ; length = GetBytesPerRow ( image -> columns , 1 , image -> depth , MagickTrue ) ; } for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) break ; ( void ) ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } SetQuantumImageType ( image , quantum_type ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; SetImageColorspace ( image , LogColorspace ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> image_info -> ping != MagickFalse <S2SV_ModStart> return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image )
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-269,"CWE-269 static int __poke_user ( struct task_struct * child , addr_t addr , addr_t data ) { struct user * dummy = NULL ; addr_t offset ; if ( addr < ( addr_t ) & dummy -> regs . acrs ) { if ( addr == ( addr_t ) & dummy -> regs . psw . mask ) { unsigned long mask = PSW_MASK_USER ; mask |= is_ri_task ( child ) ? PSW_MASK_RI : 0 ; <S2SV_StartBug> if ( ( data & ~ mask ) != PSW_USER_BITS ) <S2SV_EndBug> return - EINVAL ; if ( ( data & PSW_MASK_EA ) && ! ( data & PSW_MASK_BA ) ) return - EINVAL ; } * ( addr_t * ) ( ( addr_t ) & task_pt_regs ( child ) -> psw + addr ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . orig_gpr2 ) ) { offset = addr - ( addr_t ) & dummy -> regs . acrs ; # ifdef CONFIG_64BIT if ( addr == ( addr_t ) & dummy -> regs . acrs [ 15 ] ) child -> thread . acrs [ 15 ] = ( unsigned int ) ( data >> 32 ) ; else # endif * ( addr_t * ) ( ( addr_t ) & child -> thread . acrs + offset ) = data ; } else if ( addr == ( addr_t ) & dummy -> regs . orig_gpr2 ) { task_pt_regs ( child ) -> orig_gpr2 = data ; } else if ( addr < ( addr_t ) & dummy -> regs . fp_regs ) { return 0 ; } else if ( addr < ( addr_t ) ( & dummy -> regs . fp_regs + 1 ) ) { if ( addr == ( addr_t ) & dummy -> regs . fp_regs . fpc ) if ( ( unsigned int ) data != 0 || test_fp_ctl ( data >> ( BITS_PER_LONG - 32 ) ) ) return - EINVAL ; offset = addr - ( addr_t ) & dummy -> regs . fp_regs ; * ( addr_t * ) ( ( addr_t ) & child -> thread . fp_regs + offset ) = data ; } else if ( addr < ( addr_t ) ( & dummy -> regs . per_info + 1 ) ) { addr -= ( addr_t ) & dummy -> regs . per_info ; __poke_user_per ( child , addr , data ) ; } return 0 ; }
","<S2SV_ModStart> ( ( data ^ PSW_USER_BITS ) <S2SV_ModStart> ~ mask ) return - EINVAL ; if ( ( data & PSW_MASK_ASC ) == PSW_ASC_HOME <S2SV_ModEnd> ) return -
",torvalds@linux/dab6cf55f81a6e16b8147aed9a843e1691dcd318,CVE-2014-3534,https://github.com/torvalds/linux/commit/dab6cf55f81a6e16b8147aed9a843e1691dcd318,2014-08-01T11:13Z
CWE-119,"CWE-119 void vp8_default_bmode_probs ( vp8_prob p [ VP8_BINTRAMODES - 1 ] ) { <S2SV_StartBug> vpx_memcpy ( p , vp8_bmode_prob , sizeof ( vp8_bmode_prob ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> ] ) { memcpy <S2SV_ModEnd> ( p ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-416,"CWE-416 static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; <S2SV_StartBug> pipe_buf_get ( ipipe , ibuf ) ; <S2SV_EndBug> obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
","<S2SV_ModStart> 1 ) ; if ( ! <S2SV_ModStart> , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } <S2SV_ModEnd> obuf = opipe
",torvalds@linux/6b3a707736301c2128ca85ce85fb13f60b5e350a,CVE-2019-11487,https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a,2019-04-23T22:29Z
CWE-119,"CWE-119 int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }
","<S2SV_ModStart> u_int32_t * vendor , unsigned char * type <S2SV_ModStart> size_t * len , const void * raw , size_t raw_len <S2SV_ModStart> * attr ; if ( raw_len < sizeof ( struct vendor_attribute ) ) { return - 1 ; } <S2SV_ModStart> vendor_attribute * ) raw <S2SV_ModEnd> ; * vendor <S2SV_ModStart> -> vendor_value ) ; * type = attr -> attrib_type <S2SV_ModStart> - 2 ; if ( ( attr -> attrib_len + 4 ) > raw_len ) { return - 1 ; }
",LawnGnome@php-radius/13c149b051f82b709e8d7cc32111e84b49d57234,CVE-2013-2220,https://github.com/LawnGnome/php-radius/commit/13c149b051f82b709e8d7cc32111e84b49d57234,2013-07-31T13:20Z
CWE-362,"CWE-362 int inet_sk_rebuild_header ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; __be32 daddr ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( rt ) return 0 ; <S2SV_StartBug> daddr = inet -> inet_daddr ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt && inet -> opt -> srr ) <S2SV_EndBug> daddr = inet -> opt -> faddr ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! IS_ERR ( rt ) ) { err = 0 ; sk_setup_caps ( sk , & rt -> dst ) ; } else { err = PTR_ERR ( rt ) ; sk -> sk_route_caps = 0 ; if ( ! sysctl_ip_dynaddr || sk -> sk_state != TCP_SYN_SENT || ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) sk -> sk_err_soft = - err ; } return err ; }
","<S2SV_ModStart> __be32 daddr ; struct ip_options_rcu * inet_opt ; <S2SV_ModStart> return 0 ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; <S2SV_ModStart> ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) <S2SV_ModEnd> ; rt =
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-415,"CWE-415 SPL_METHOD ( SplDoublyLinkedList , offsetSet ) { zval * zindex , * value ; spl_dllist_object * intern ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""zz"" , & zindex , & value ) == FAILURE ) { return ; } intern = Z_SPLDLLIST_P ( getThis ( ) ) ; if ( Z_TYPE_P ( zindex ) == IS_NULL ) { spl_ptr_llist_push ( intern -> llist , value ) ; } else { zend_long index ; spl_ptr_llist_element * element ; index = spl_offset_convert_to_long ( zindex ) ; if ( index < 0 || index >= intern -> llist -> count ) { <S2SV_StartBug> zval_ptr_dtor ( value ) ; <S2SV_EndBug> zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" , 0 ) ; return ; } element = spl_ptr_llist_offset ( intern -> llist , index , intern -> flags & SPL_DLLIST_IT_LIFO ) ; if ( element != NULL ) { if ( intern -> llist -> dtor ) { intern -> llist -> dtor ( element ) ; } zval_ptr_dtor ( & element -> data ) ; ZVAL_COPY_VALUE ( & element -> data , value ) ; if ( intern -> llist -> ctor ) { intern -> llist -> ctor ( element ) ; } } else { zval_ptr_dtor ( value ) ; zend_throw_exception ( spl_ce_OutOfRangeException , ""Offset<S2SV_blank>invalid"" , 0 ) ; return ; } } }
","<S2SV_ModStart> count ) { <S2SV_ModEnd> zend_throw_exception ( spl_ce_OutOfRangeException
",php@php-src/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5,CVE-2016-3132,https://github.com/php/php-src/commit/28a6ed9f9a36b9c517e4a8a429baf4dd382fc5d5,2016-08-07T10:59Z
CWE-310,"CWE-310 int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err : <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }
","<S2SV_ModStart> * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }
",openssl@openssl/684400ce192dac51df3d3e92b61830a6ef90be3e,CVE-2014-8275,https://github.com/openssl/openssl/commit/684400ce192dac51df3d3e92b61830a6ef90be3e,2015-01-09T02:59Z
CWE-264,"CWE-264 int regset_tls_set ( struct task_struct * target , const struct user_regset * regset , unsigned int pos , unsigned int count , const void * kbuf , const void __user * ubuf ) { struct user_desc infobuf [ GDT_ENTRY_TLS_ENTRIES ] ; const struct user_desc * info ; <S2SV_StartBug> if ( pos >= GDT_ENTRY_TLS_ENTRIES * sizeof ( struct user_desc ) || <S2SV_EndBug> ( pos % sizeof ( struct user_desc ) ) != 0 || ( count % sizeof ( struct user_desc ) ) != 0 ) return - EINVAL ; if ( kbuf ) info = kbuf ; else if ( __copy_from_user ( infobuf , ubuf , count ) ) return - EFAULT ; else info = infobuf ; <S2SV_StartBug> set_tls_desc ( target , <S2SV_EndBug> GDT_ENTRY_TLS_MIN + ( pos / sizeof ( struct user_desc ) ) , info , count / sizeof ( struct user_desc ) ) ; return 0 ; }
","<S2SV_ModStart> * info ; int i ; <S2SV_ModStart> = infobuf ; for ( i = 0 ; i < count / sizeof ( struct user_desc ) ; i ++ ) if ( ! tls_desc_okay ( info + i ) ) return - EINVAL ;
",torvalds@linux/41bdc78544b8a93a9c6814b8bbbfef966272abbe,CVE-2014-8133,https://github.com/torvalds/linux/commit/41bdc78544b8a93a9c6814b8bbbfef966272abbe,2014-12-17T11:59Z
CWE-20,"CWE-20 static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min ; <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> if ( put_user ( len , optlen ) ) return - EFAULT ; SCTP_DEBUG_PRINTK ( ""sctp_getsockopt_assoc_stat(%d):<S2SV_blank>%d\\n"" , len , sas . sas_assoc_id ) ; if ( copy_to_user ( optval , & sas , len ) ) return - EFAULT ; return 0 ; }
","<S2SV_ModStart> - EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart> -> rto_min ; <S2SV_ModEnd> if ( put_user
",torvalds@linux/726bc6b092da4c093eb74d13c07184b18c1af0f1,CVE-2013-1828,https://github.com/torvalds/linux/commit/726bc6b092da4c093eb74d13c07184b18c1af0f1,2013-03-22T11:59Z
CWE-119,"CWE-119 static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }
","<S2SV_ModStart> key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
CWE-000,"CWE-000 krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm"" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER ""%s))"" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( ""operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>"" ""entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\""%s\\""<S2SV_blank>found"" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( ""krbtgt"" ) && strncmp ( entry -> princ -> data [ 0 ] . data , ""krbtgt"" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( ""\'%s\'<S2SV_blank>not<S2SV_blank>found"" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , ""krbprincipalname=%s,%s"" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree"" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { ""krbticketpolicyreference"" , ""krbprincipalname"" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , ""krbticketpolicyreference"" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , ""krbprincipalname"" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>"" ""kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>"" ""object"" ) ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastSuccessfulAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastFailedAuth"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , ""krbLoginFailedCount"" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxticketlife"" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbmaxrenewableage"" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , ""krbticketflags"" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalname"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbprincipalexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , ""Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null"" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpwdpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbprincipalkey"" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbpasswordexpiration"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastPwdChange"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , ""krbExtraData"" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbLastAdminUnlock"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , ""objectclass"" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( ""ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>"" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbticketpolicyreference"" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""krbObjectReferences"" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = ""krbprincipal"" ; strval [ 1 ] = ""krbprincipalaux"" ; strval [ 2 ] = ""krbTicketPolicyAux"" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>"" ""entry):<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { ""krbprincipalaux"" , ""krbTicketPolicyAux"" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , ""objectclass"" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , ""objectclass"" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( ""User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s"" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , ""%s"" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }
","<S2SV_ModStart> ; if ( bersecretkey == NULL ) { st = ENOMEM ; goto cleanup ; } if ( bersecretkey [ 0 ] != NULL || ! create_standalone_prinicipal ) { <S2SV_ModEnd> st = krb5_add_ber_mem_ldap_mod <S2SV_ModStart> , bersecretkey ) ; if ( st != 0 ) goto cleanup ; } <S2SV_ModEnd> if ( !
",krb5@krb5/04038bf3633c4b909b5ded3072dc88c8c419bf16,CVE-2014-5354,https://github.com/krb5/krb5/commit/04038bf3633c4b909b5ded3072dc88c8c419bf16,2014-12-16T23:59Z
CWE-20,"CWE-20 static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; PixelTrait alpha_trait ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { alpha_trait = BlendPixelTrait ; decoder = ReadUncompressedRGBA ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { alpha_trait = UndefinedPixelTrait ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { alpha_trait = BlendPixelTrait ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { alpha_trait = BlendPixelTrait ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> alpha_trait = alpha_trait ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> != MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;
",ImageMagick@ImageMagick/0c5b1e430a83ef793a7334bbbee408cf3c628699,CVE-2017-9141,https://github.com/ImageMagick/ImageMagick/commit/0c5b1e430a83ef793a7334bbbee408cf3c628699,2017-05-22T14:29Z
CWE-264,"CWE-264 static ssize_t get_node_path_locked ( struct node * node , char * buf , size_t bufsize ) { const char * name ; size_t namelen ; if ( node -> graft_path ) { name = node -> graft_path ; namelen = node -> graft_pathlen ; } else if ( node -> actual_name ) { name = node -> actual_name ; namelen = node -> namelen ; } else { name = node -> name ; namelen = node -> namelen ; } if ( bufsize < namelen + 1 ) { return - 1 ; } ssize_t pathlen = 0 ; if ( node -> parent && node -> graft_path == NULL ) { <S2SV_StartBug> pathlen = get_node_path_locked ( node -> parent , buf , bufsize - namelen - 2 ) ; <S2SV_EndBug> if ( pathlen < 0 ) { return - 1 ; } buf [ pathlen ++ ] = '/' ; } memcpy ( buf + pathlen , name , namelen + 1 ) ; return pathlen + namelen ; }
","<S2SV_ModStart> - namelen - 1 <S2SV_ModEnd> ) ; if
",system@core/864e2e22fcd0cba3f5e67680ccabd0302dfda45d,CVE-2016-2494,https://android.googlesource.com/platform/system/core/+/864e2e22fcd0cba3f5e67680ccabd0302dfda45d,2016-06-13T01:59Z
CWE-399,"CWE-399 static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } <S2SV_StartBug> while ( offset < end_offset ) <S2SV_EndBug> offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; <S2SV_StartBug> return offset ; <S2SV_EndBug> }
","<S2SV_ModStart> while ( offset > 0 && offset <S2SV_ModStart> < end_offset ) { <S2SV_ModStart> hf_keybuffer ) ; }
",wireshark@wireshark/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,CVE-2016-5350,https://github.com/wireshark/wireshark/commit/b4d16b4495b732888e12baf5b8a7e9bf2665e22b,2016-08-07T16:59Z
CWE-120,"CWE-120 enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( ""Authenticating<S2SV_blank>(CRAM-MD5)..."" ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , ""AUTHENTICATE<S2SV_blank>CRAM-MD5"" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , ""Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n"" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , ""Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n"" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , ""CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n"" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , ""%s<S2SV_blank>"" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , ""CRAM<S2SV_blank>response:<S2SV_blank>%s\\n"" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , ""\\r\\n"" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , ""Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n"" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( ""CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }
","<S2SV_ModStart> buf + 2 , sizeof ( obuf )
",neomutt@neomutt/6f163e07ae68654d7ac5268cbb7565f6df79ad85,CVE-2018-14359,https://github.com/neomutt/neomutt/commit/6f163e07ae68654d7ac5268cbb7565f6df79ad85,2018-07-17T17:29Z
CWE-401,"CWE-401 static struct fc_host_statistics * bfad_im_get_stats ( struct Scsi_Host * shost ) { struct bfad_im_port_s * im_port = ( struct bfad_im_port_s * ) shost -> hostdata [ 0 ] ; struct bfad_s * bfad = im_port -> bfad ; struct bfad_hal_comp fcomp ; union bfa_port_stats_u * fcstats ; struct fc_host_statistics * hstats ; bfa_status_t rc ; unsigned long flags ; fcstats = kzalloc ( sizeof ( union bfa_port_stats_u ) , GFP_KERNEL ) ; if ( fcstats == NULL ) return NULL ; hstats = & bfad -> link_stats ; init_completion ( & fcomp . comp ) ; spin_lock_irqsave ( & bfad -> bfad_lock , flags ) ; memset ( hstats , 0 , sizeof ( struct fc_host_statistics ) ) ; rc = bfa_port_get_stats ( BFA_FCPORT ( & bfad -> bfa ) , fcstats , bfad_hcb_comp , & fcomp ) ; spin_unlock_irqrestore ( & bfad -> bfad_lock , flags ) ; <S2SV_StartBug> if ( rc != BFA_STATUS_OK ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> wait_for_completion ( & fcomp . comp ) ; <S2SV_EndBug> hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ; hstats -> tx_frames = fcstats -> fc . tx_frames ; hstats -> tx_words = fcstats -> fc . tx_words ; hstats -> rx_frames = fcstats -> fc . rx_frames ; hstats -> rx_words = fcstats -> fc . rx_words ; hstats -> lip_count = fcstats -> fc . lip_count ; hstats -> nos_count = fcstats -> fc . nos_count ; hstats -> error_frames = fcstats -> fc . error_frames ; hstats -> dumped_frames = fcstats -> fc . dropped_frames ; hstats -> link_failure_count = fcstats -> fc . link_failures ; hstats -> loss_of_sync_count = fcstats -> fc . loss_of_syncs ; hstats -> loss_of_signal_count = fcstats -> fc . loss_of_signals ; hstats -> prim_seq_protocol_err_count = fcstats -> fc . primseq_errs ; hstats -> invalid_crc_count = fcstats -> fc . invalid_crcs ; kfree ( fcstats ) ; return hstats ; }
","<S2SV_ModStart> != BFA_STATUS_OK ) { kfree ( fcstats ) ; <S2SV_ModStart> return NULL ; }
",torvalds@linux/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,CVE-2019-19066,https://github.com/torvalds/linux/commit/0e62395da2bd5166d7c9e14cbc7503b256a34cb0,2019-11-18T06:15Z
CWE-000,"CWE-000 static void veth_setup ( struct net_device * dev ) { <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> dev -> netdev_ops = & veth_netdev_ops ; dev -> ethtool_ops = & veth_ethtool_ops ; dev -> features |= NETIF_F_LLTX ; dev -> destructor = veth_dev_free ; dev -> hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM ; }
","<S2SV_ModStart> ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-000,"CWE-000 SYSCALL_DEFINE4 ( epoll_ctl , int , epfd , int , op , int , fd , struct epoll_event __user * , event ) { int error ; int did_lock_epmutex = 0 ; struct file * file , * tfile ; struct eventpoll * ep ; struct epitem * epi ; struct epoll_event epds ; error = - EFAULT ; if ( ep_op_has_event ( op ) && copy_from_user ( & epds , event , sizeof ( struct epoll_event ) ) ) goto error_return ; error = - EBADF ; file = fget ( epfd ) ; if ( ! file ) goto error_return ; tfile = fget ( fd ) ; if ( ! tfile ) goto error_fput ; error = - EPERM ; if ( ! tfile -> f_op || ! tfile -> f_op -> poll ) goto error_tgt_fput ; error = - EINVAL ; if ( file == tfile || ! is_file_epoll ( file ) ) goto error_tgt_fput ; ep = file -> private_data ; if ( op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL ) { mutex_lock ( & epmutex ) ; did_lock_epmutex = 1 ; } if ( op == EPOLL_CTL_ADD ) { if ( is_file_epoll ( tfile ) ) { error = - ELOOP ; <S2SV_StartBug> if ( ep_loop_check ( ep , tfile ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> goto error_tgt_fput ; <S2SV_EndBug> } else list_add ( & tfile -> f_tfile_llink , & tfile_check_list ) ; } mutex_lock_nested ( & ep -> mtx , 0 ) ; epi = ep_find ( ep , tfile , fd ) ; error = - EINVAL ; switch ( op ) { case EPOLL_CTL_ADD : if ( ! epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_insert ( ep , & epds , tfile , fd ) ; } else error = - EEXIST ; clear_tfile_check_list ( ) ; break ; case EPOLL_CTL_DEL : if ( epi ) error = ep_remove ( ep , epi ) ; else error = - ENOENT ; break ; case EPOLL_CTL_MOD : if ( epi ) { epds . events |= POLLERR | POLLHUP ; error = ep_modify ( ep , epi , & epds ) ; } else error = - ENOENT ; break ; } mutex_unlock ( & ep -> mtx ) ; error_tgt_fput : if ( did_lock_epmutex ) mutex_unlock ( & epmutex ) ; fput ( tfile ) ; error_fput : fput ( file ) ; error_return : return error ; }
","<S2SV_ModStart> != 0 ) { clear_tfile_check_list ( ) ; <S2SV_ModStart> goto error_tgt_fput ; }
",torvalds@linux/13d518074a952d33d47c428419693f63389547e9,CVE-2012-3375,https://github.com/torvalds/linux/commit/13d518074a952d33d47c428419693f63389547e9,2012-10-03T11:02Z
CWE-000,"CWE-000 static int ext4_write_begin ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned flags , struct page * * pagep , void * * fsdata ) { struct inode * inode = mapping -> host ; int ret , needed_blocks ; handle_t * handle ; int retries = 0 ; struct page * page ; pgoff_t index ; unsigned from , to ; trace_ext4_write_begin ( inode , pos , len , flags ) ; needed_blocks = ext4_writepage_trans_blocks ( inode ) + 1 ; index = pos >> PAGE_CACHE_SHIFT ; from = pos & ( PAGE_CACHE_SIZE - 1 ) ; to = from + len ; retry : handle = ext4_journal_start ( inode , needed_blocks ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; goto out ; } flags |= AOP_FLAG_NOFS ; page = grab_cache_page_write_begin ( mapping , index , flags ) ; if ( ! page ) { ext4_journal_stop ( handle ) ; ret = - ENOMEM ; goto out ; } * pagep = page ; <S2SV_StartBug> ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata , <S2SV_EndBug> <S2SV_StartBug> ext4_get_block ) ; <S2SV_EndBug> if ( ! ret && ext4_should_journal_data ( inode ) ) { ret = walk_page_buffers ( handle , page_buffers ( page ) , from , to , NULL , do_journal_get_write_access ) ; } if ( ret ) { unlock_page ( page ) ; page_cache_release ( page ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; ext4_journal_stop ( handle ) ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } } if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry ; out : return ret ; }
","<S2SV_ModStart> = page ; if ( ext4_should_dioread_nolock ( inode ) ) <S2SV_ModStart> , fsdata , ext4_get_block_write ) ; else ret = block_write_begin ( file , mapping , pos , len , flags , pagep , fsdata ,
",torvalds@linux/744692dc059845b2a3022119871846e74d4f6e11,CVE-2015-8324,https://github.com/torvalds/linux/commit/744692dc059845b2a3022119871846e74d4f6e11,2016-05-02T10:59Z
CWE-000,"CWE-000 <S2SV_StartBug> static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , int open_flags ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( state -> inode ) ; struct nfs_delegation * deleg_cur ; int ret = 0 ; <S2SV_StartBug> open_flags &= ( FMODE_READ | FMODE_WRITE ) ; <S2SV_EndBug> rcu_read_lock ( ) ; deleg_cur = rcu_dereference ( nfsi -> delegation ) ; if ( deleg_cur == NULL ) goto no_delegation ; spin_lock ( & deleg_cur -> lock ) ; if ( nfsi -> delegation != deleg_cur || <S2SV_StartBug> ( deleg_cur -> type & open_flags ) != open_flags ) <S2SV_EndBug> goto no_delegation_unlock ; if ( delegation == NULL ) delegation = & deleg_cur -> stateid ; else if ( memcmp ( deleg_cur -> stateid . data , delegation -> data , NFS4_STATEID_SIZE ) != 0 ) goto no_delegation_unlock ; nfs_mark_delegation_referenced ( deleg_cur ) ; <S2SV_StartBug> __update_open_stateid ( state , open_stateid , & deleg_cur -> stateid , open_flags ) ; <S2SV_EndBug> ret = 1 ; no_delegation_unlock : spin_unlock ( & deleg_cur -> lock ) ; no_delegation : rcu_read_unlock ( ) ; if ( ! ret && open_stateid != NULL ) { <S2SV_StartBug> __update_open_stateid ( state , open_stateid , NULL , open_flags ) ; <S2SV_EndBug> ret = 1 ; } return ret ; }
","<S2SV_ModStart> * delegation , fmode_t fmode <S2SV_ModEnd> ) { struct <S2SV_ModStart> = 0 ; fmode <S2SV_ModEnd> &= ( FMODE_READ <S2SV_ModStart> -> type & fmode ) != fmode <S2SV_ModEnd> ) goto no_delegation_unlock <S2SV_ModStart> -> stateid , fmode <S2SV_ModEnd> ) ; ret <S2SV_ModStart> , NULL , fmode <S2SV_ModEnd> ) ; ret
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-119,"CWE-119 void vp9_copy_and_extend_frame ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) { const int et_y = 16 ; const int el_y = 16 ; <S2SV_StartBug> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <S2SV_EndBug> 16 ) ; const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , 16 ) ; const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; const int et_uv = et_y >> uv_height_subsampling ; const int el_uv = el_y >> uv_width_subsampling ; const int eb_uv = eb_y >> uv_height_subsampling ; const int er_uv = er_y >> uv_width_subsampling ; <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ; const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ; const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ; const int er_a = el_a + dst -> alpha_width - src -> alpha_width ; copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ; # endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , <S2SV_StartBug> src -> y_width , src -> y_height , <S2SV_EndBug> et_y , el_y , eb_y , er_y ) ; copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> et_uv , el_uv , eb_uv , er_uv ) ; copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> et_uv , el_uv , eb_uv , er_uv ) ; }
","<S2SV_ModStart> ; const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> = MAX ( src -> y_height + 16 , <S2SV_ModStart> ( src -> y_height <S2SV_ModEnd> , 6 ) <S2SV_ModStart> , 6 ) ) <S2SV_ModStart> - src -> y_crop_height <S2SV_ModEnd> ; const int <S2SV_ModStart> ; # if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> # endif copy_and_extend_plane <S2SV_ModStart> , src -> y_crop_width , src -> y_crop_height <S2SV_ModEnd> , et_y , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 static void finish_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * name , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( ""missing<S2SV_blank>blob<S2SV_blank>object<S2SV_blank>\'%s\'"" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }
","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char *
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-125,"CWE-125 int obj2ast_arg ( PyObject * obj , arg_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; identifier arg ; expr_ty annotation ; <S2SV_StartBug> int lineno ; <S2SV_EndBug> int col_offset ; int end_lineno ; int end_col_offset ; if ( _PyObject_LookupAttrId ( obj , & PyId_arg , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""arg\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_identifier ( tmp , & arg , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_annotation , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; annotation = NULL ; } else { int res ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & annotation , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""lineno\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL ) { PyErr_SetString ( PyExc_TypeError , ""required<S2SV_blank>field<S2SV_blank>\\""col_offset\\""<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>arg"" ) ; return 1 ; } else { int res ; res = obj2ast_int ( tmp , & col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_lineno , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_lineno = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_lineno , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_end_col_offset , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; end_col_offset = 0 ; } else { int res ; res = obj2ast_int ( tmp , & end_col_offset , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } <S2SV_StartBug> * out = arg ( arg , annotation , lineno , col_offset , end_lineno , end_col_offset , <S2SV_EndBug> arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
","<S2SV_ModStart> expr_ty annotation ; string type_comment ; <S2SV_ModStart> , & annotation , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } if ( _PyObject_LookupAttrId ( obj , & PyId_type_comment , & tmp ) < 0 ) { return 1 ; } if ( tmp == NULL || tmp == Py_None ) { Py_CLEAR ( tmp ) ; type_comment = NULL ; } else { int res ; res = obj2ast_string ( tmp , & type_comment <S2SV_ModStart> , annotation , type_comment ,
",python@typed_ast/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,CVE-2019-19275,https://github.com/python/typed_ast/commit/dcfcd146f8e6fc5c2fc16a4c192a0c5f5ca8c53c,2019-11-26T15:15Z
CWE-119,"CWE-119 <S2SV_StartBug> static int conditional_skipintra ( MB_PREDICTION_MODE mode , <S2SV_EndBug> MB_PREDICTION_MODE best_intra_mode ) { if ( mode == D117_PRED && best_intra_mode != V_PRED && best_intra_mode != D135_PRED ) return 1 ; if ( mode == D63_PRED && best_intra_mode != V_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D207_PRED && best_intra_mode != H_PRED && best_intra_mode != D45_PRED ) return 1 ; if ( mode == D153_PRED && best_intra_mode != H_PRED && best_intra_mode != D135_PRED ) return 1 ; return 0 ; }
","<S2SV_ModStart> int conditional_skipintra ( PREDICTION_MODE mode , PREDICTION_MODE <S2SV_ModEnd> best_intra_mode ) {
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 void wb_print ( netdissect_options * ndo , register const void * hdr , register u_int len ) { register const struct pkt_hdr * ph ; ph = ( const struct pkt_hdr * ) hdr ; if ( len < sizeof ( * ph ) || ! ND_TTEST ( * ph ) ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } len -= sizeof ( * ph ) ; if ( ph -> ph_flags ) ND_PRINT ( ( ndo , ""*"" ) ) ; switch ( ph -> ph_type ) { case PT_KILL : ND_PRINT ( ( ndo , ""<S2SV_blank>wb-kill"" ) ) ; return ; case PT_ID : if ( wb_id ( ndo , ( const struct pkt_id * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREQ : if ( wb_rreq ( ndo , ( const struct pkt_rreq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_RREP : if ( wb_rrep ( ndo , ( const struct pkt_rrep * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_DRAWOP : if ( wb_drawop ( ndo , ( const struct pkt_dop * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREQ : if ( wb_preq ( ndo , ( const struct pkt_preq * ) ( ph + 1 ) , len ) >= 0 ) return ; <S2SV_StartBug> break ; <S2SV_EndBug> case PT_PREP : if ( wb_prep ( ndo , ( const struct pkt_prep * ) ( ph + 1 ) , len ) >= 0 ) <S2SV_StartBug> return ; <S2SV_EndBug> break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>wb-%d!"" , ph -> ph_type ) ) ; return ; } }
","<S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; <S2SV_ModStart> 0 ) return ; ND_PRINT ( ( ndo , ""%s"" , tstr ) )
",the-tcpdump-group@tcpdump/cc356512f512e7fa423b3674db4bb31dbe40ffec,CVE-2017-13014,https://github.com/the-tcpdump-group/tcpdump/commit/cc356512f512e7fa423b3674db4bb31dbe40ffec,2017-09-14T06:29Z
CWE-476,"CWE-476 static MagickBooleanType ReadPSDChannel ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , LayerInfo * layer_info , const size_t channel , const PSDCompressionType compression , ExceptionInfo * exception ) { Image * channel_image , * mask ; MagickOffsetType offset ; MagickBooleanType status ; channel_image = image ; mask = ( Image * ) NULL ; if ( layer_info -> channel_info [ channel ] . type < - 1 ) { const char * option ; option = GetImageOption ( image_info , ""psd:preserve-opacity-mask"" ) ; if ( ( layer_info -> channel_info [ channel ] . type != - 2 ) || ( layer_info -> mask . flags > 2 ) || ( ( layer_info -> mask . flags & 0x02 ) && ( IsStringTrue ( option ) == MagickFalse ) ) ) { SeekBlob ( image , layer_info -> channel_info [ channel ] . size - 2 , SEEK_CUR ) ; return ( MagickTrue ) ; } mask = CloneImage ( image , layer_info -> mask . page . width , layer_info -> mask . page . height , MagickFalse , exception ) ; <S2SV_StartBug> mask -> matte = MagickFalse ; <S2SV_EndBug> <S2SV_StartBug> channel_image = mask ; <S2SV_EndBug> } offset = TellBlob ( image ) ; status = MagickTrue ; switch ( compression ) { case Raw : status = ReadPSDChannelRaw ( channel_image , psd_info -> channels , layer_info -> channel_info [ channel ] . type , exception ) ; break ; case RLE : { MagickOffsetType * sizes ; sizes = ReadPSDRLESizes ( channel_image , psd_info , channel_image -> rows ) ; if ( sizes == ( MagickOffsetType * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; status = ReadPSDChannelRLE ( channel_image , psd_info , layer_info -> channel_info [ channel ] . type , sizes , exception ) ; sizes = ( MagickOffsetType * ) RelinquishMagickMemory ( sizes ) ; } break ; case ZipWithPrediction : case ZipWithoutPrediction : # ifdef MAGICKCORE_ZLIB_DELEGATE status = ReadPSDChannelZip ( channel_image , layer_info -> channels , layer_info -> channel_info [ channel ] . type , compression , layer_info -> channel_info [ channel ] . size - 2 , exception ) ; # else ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , MissingDelegateWarning , ""DelegateLibrarySupportNotBuiltIn"" , ""\'%s\'<S2SV_blank>(ZLIB)"" , image -> filename ) ; # endif break ; default : ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , TypeWarning , ""CompressionNotSupported"" , ""\'%.20g\'"" , ( double ) compression ) ; break ; } SeekBlob ( image , offset + layer_info -> channel_info [ channel ] . size - 2 , SEEK_SET ) ; if ( status == MagickFalse ) { if ( mask != ( Image * ) NULL ) DestroyImage ( mask ) ; ThrowBinaryException ( CoderError , ""UnableToDecompressImage"" , image -> filename ) ; } layer_info -> mask . image = mask ; return ( status ) ; }
","<S2SV_ModStart> exception ) ; if ( mask != ( Image * ) NULL ) { <S2SV_ModStart> = mask ; }
",ImageMagick@ImageMagick/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,CVE-2017-6497,https://github.com/ImageMagick/ImageMagick/commit/7f2dc7a1afc067d0c89f12c82bcdec0445fb1b94,2017-03-06T02:59Z
CWE-254,"CWE-254 int main ( int argc , char * argv [ ] ) { int i , fails_count = 0 ; CU_pSuite cryptoUtilsTestSuite , parserTestSuite ; CU_pSuite * suites [ ] = { & cryptoUtilsTestSuite , & parserTestSuite , NULL } ; if ( argc > 1 ) { if ( argv [ 1 ] [ 0 ] == '-' ) { if ( strcmp ( argv [ 1 ] , ""-verbose"" ) == 0 ) { verbose = 1 ; } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } # ifdef HAVE_LIBXML2 xmlInitParser ( ) ; # endif if ( CUE_SUCCESS != CU_initialize_registry ( ) ) { return CU_get_error ( ) ; } cryptoUtilsTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>Crypto<S2SV_blank>Utils"" , NULL , NULL ) ; CU_add_test ( cryptoUtilsTestSuite , ""zrtpKDF"" , test_zrtpKDF ) ; CU_add_test ( cryptoUtilsTestSuite , ""CRC32"" , test_CRC32 ) ; CU_add_test ( cryptoUtilsTestSuite , ""algo<S2SV_blank>agreement"" , test_algoAgreement ) ; CU_add_test ( cryptoUtilsTestSuite , ""context<S2SV_blank>algo<S2SV_blank>setter<S2SV_blank>and<S2SV_blank>getter"" , test_algoSetterGetter ) ; CU_add_test ( cryptoUtilsTestSuite , ""adding<S2SV_blank>mandatory<S2SV_blank>crypto<S2SV_blank>algorithms<S2SV_blank>if<S2SV_blank>needed"" , test_addMandatoryCryptoTypesIfNeeded ) ; parserTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>ZRTP<S2SV_blank>Packet<S2SV_blank>Parser"" , NULL , NULL ) ; CU_add_test ( parserTestSuite , ""Parse"" , test_parser ) ; <S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ; for ( i = 0 ; suites [ i ] ; i ++ ) { CU_basic_run_suite ( * suites [ i ] ) ; fails_count += CU_get_number_of_tests_failed ( ) ; } CU_cleanup_registry ( ) ; # ifdef HAVE_LIBXML2 xmlCleanupParser ( ) ; # endif return ( fails_count == 0 ? 0 : 1 ) ; }
","<S2SV_ModStart> ( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,
",BelledonneCommunications@bzrtp/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,CVE-2016-6271,https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b,2017-01-18T22:59Z
CWE-287,"CWE-287 CMD_FUNC ( m_authenticate ) { aClient * agent_p = NULL ; if ( ! SASL_SERVER || ! MyConnect ( sptr ) || BadPtr ( parv [ 1 ] ) || ! CHECKPROTO ( sptr , PROTO_SASL ) ) return 0 ; if ( sptr -> local -> sasl_complete ) { sendto_one ( sptr , err_str ( ERR_SASLALREADY ) , me . name , BadPtr ( sptr -> name ) ? ""*"" : sptr -> name ) ; return 0 ; } <S2SV_StartBug> if ( strlen ( parv [ 1 ] ) > 400 ) <S2SV_EndBug> { sendto_one ( sptr , err_str ( ERR_SASLTOOLONG ) , me . name , BadPtr ( sptr -> name ) ? ""*"" : sptr -> name ) ; return 0 ; } if ( * sptr -> local -> sasl_agent ) agent_p = find_client ( sptr -> local -> sasl_agent , NULL ) ; if ( agent_p == NULL ) { char * addr = BadPtr ( sptr -> ip ) ? ""0"" : sptr -> ip ; char * certfp = moddata_client_get ( sptr , ""certfp"" ) ; sendto_server ( NULL , 0 , 0 , "":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>H<S2SV_blank>%s<S2SV_blank>%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , addr , addr ) ; if ( certfp ) sendto_server ( NULL , 0 , 0 , "":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s<S2SV_blank>%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] , certfp ) ; else sendto_server ( NULL , 0 , 0 , "":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>S<S2SV_blank>%s"" , me . name , SASL_SERVER , encode_puid ( sptr ) , parv [ 1 ] ) ; } else sendto_server ( NULL , 0 , 0 , "":%s<S2SV_blank>SASL<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>C<S2SV_blank>%s"" , me . name , AGENT_SID ( agent_p ) , encode_puid ( sptr ) , parv [ 1 ] ) ; sptr -> local -> sasl_out ++ ; return 0 ; }
","<S2SV_ModStart> } if ( ( parv [ 1 ] [ 0 ] == ':' ) || strchr ( parv [ 1 ] , '<S2SV_blank>' ) ) { sendto_one ( sptr , err_str ( ERR_CANNOTDOCOMMAND ) , me . name , ""*"" , ""AUTHENTICATE"" , ""Invalid<S2SV_blank>parameter"" ) ; return 0 ; } if (
",unrealircd@unrealircd/f473e355e1dc422c4f019dbf86bc50ba1a34a766,CVE-2016-7144,https://github.com/unrealircd/unrealircd/commit/f473e355e1dc422c4f019dbf86bc50ba1a34a766,2017-01-18T17:59Z
CWE-119,"CWE-119 static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> if ( info -> flags & REV_LIST_QUIET ) return ; <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> ( obj , name <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> , obj , name <S2SV_ModEnd> ) ; }
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2315,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-399,"CWE-399 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-119,"CWE-119 static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
","<S2SV_ModStart> ( isspace ( ( unsigned char )
",kohler@t1utils/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,CVE-2015-3905,https://github.com/kohler/t1utils/commit/6b9d1aafcb61a3663c883663eb19ccdbfcde8d33,2015-06-08T14:59Z
CWE-125,"CWE-125 static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>len"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",<S2SV_blank>subject=DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>subject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]"" ) ) ; break ; } needcomma = 0 ; <S2SV_StartBug> ni6 = ( const struct icmp6_nodeinfo * ) dp ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; <S2SV_StartBug> cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; <S2SV_EndBug> if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; }
","<S2SV_ModStart> = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; <S2SV_ModStart> ) + 4 ; ND_TCHECK ( cp [ 0 ] )
",the-tcpdump-group@tcpdump/f4b9e24c7384d882a7f434cc7413925bf871d63e,CVE-2017-13041,https://github.com/the-tcpdump-group/tcpdump/commit/f4b9e24c7384d882a7f434cc7413925bf871d63e,2017-09-14T06:29Z
CWE-787,"CWE-787 static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { EXRContext * s = avctx -> priv_data ; ThreadFrame frame = { . f = data } ; AVFrame * picture = data ; uint8_t * ptr ; int i , y , ret , ymax ; int planes ; int out_line_size ; int nb_blocks ; uint64_t start_offset_table ; uint64_t start_next_scanline ; PutByteContext offset_table_writer ; bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ; if ( ( ret = decode_header ( s , picture ) ) < 0 ) return ret ; switch ( s -> pixel_type ) { case EXR_FLOAT : case EXR_HALF : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GBRAPF32 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_GBRPF32 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAYF32 ; } } break ; case EXR_UINT : if ( s -> channel_offsets [ 3 ] >= 0 ) { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGBA64 ; } else { avctx -> pix_fmt = AV_PIX_FMT_YA16 ; } } else { if ( ! s -> is_luma ) { avctx -> pix_fmt = AV_PIX_FMT_RGB48 ; } else { avctx -> pix_fmt = AV_PIX_FMT_GRAY16 ; } } break ; default : av_log ( avctx , AV_LOG_ERROR , ""Missing<S2SV_blank>channel<S2SV_blank>list.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( s -> apply_trc_type != AVCOL_TRC_UNSPECIFIED ) avctx -> color_trc = s -> apply_trc_type ; switch ( s -> compression ) { case EXR_RAW : case EXR_RLE : case EXR_ZIP1 : s -> scan_lines_per_block = 1 ; break ; case EXR_PXR24 : case EXR_ZIP16 : s -> scan_lines_per_block = 16 ; break ; case EXR_PIZ : case EXR_B44 : case EXR_B44A : s -> scan_lines_per_block = 32 ; break ; default : avpriv_report_missing_feature ( avctx , ""Compression<S2SV_blank>%d"" , s -> compression ) ; return AVERROR_PATCHWELCOME ; } if ( s -> xmin > s -> xmax || s -> ymin > s -> ymax || s -> ydelta == 0xFFFFFFFF || s -> xdelta == 0xFFFFFFFF ) { av_log ( avctx , AV_LOG_ERROR , ""Wrong<S2SV_blank>or<S2SV_blank>missing<S2SV_blank>size<S2SV_blank>information.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = ff_set_dimensions ( avctx , s -> w , s -> h ) ) < 0 ) return ret ; s -> desc = av_pix_fmt_desc_get ( avctx -> pix_fmt ) ; if ( ! s -> desc ) return AVERROR_INVALIDDATA ; if ( s -> desc -> flags & AV_PIX_FMT_FLAG_FLOAT ) { planes = s -> desc -> nb_components ; out_line_size = avctx -> width * 4 ; } else { planes = 1 ; out_line_size = avctx -> width * 2 * s -> desc -> nb_components ; } if ( s -> is_tile ) { nb_blocks = ( ( s -> xdelta + s -> tile_attr . xSize - 1 ) / s -> tile_attr . xSize ) * ( ( s -> ydelta + s -> tile_attr . ySize - 1 ) / s -> tile_attr . ySize ) ; } else { nb_blocks = ( s -> ydelta + s -> scan_lines_per_block - 1 ) / s -> scan_lines_per_block ; } if ( ( ret = ff_thread_get_buffer ( avctx , & frame , 0 ) ) < 0 ) return ret ; if ( bytestream2_get_bytes_left ( & s -> gb ) / 8 < nb_blocks ) return AVERROR_INVALIDDATA ; if ( ! s -> is_tile && bytestream2_peek_le64 ( & s -> gb ) == 0 ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""recreating<S2SV_blank>invalid<S2SV_blank>scanline<S2SV_blank>offset<S2SV_blank>table\\n"" ) ; start_offset_table = bytestream2_tell ( & s -> gb ) ; start_next_scanline = start_offset_table + nb_blocks * 8 ; bytestream2_init_writer ( & offset_table_writer , & avpkt -> data [ start_offset_table ] , nb_blocks * 8 ) ; for ( y = 0 ; y < nb_blocks ; y ++ ) { bytestream2_put_le64 ( & offset_table_writer , start_next_scanline ) ; bytestream2_seek ( & s -> gb , start_next_scanline + 4 , SEEK_SET ) ; start_next_scanline += ( bytestream2_get_le32 ( & s -> gb ) + 8 ) ; } bytestream2_seek ( & s -> gb , start_offset_table , SEEK_SET ) ; } s -> buf = avpkt -> data ; s -> buf_size = avpkt -> size ; for ( i = 0 ; i < planes ; i ++ ) { ptr = picture -> data [ i ] ; for ( y = 0 ; y < FFMIN ( s -> ymin , s -> h ) ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } s -> picture = picture ; avctx -> execute2 ( avctx , decode_block , s -> thread_data , NULL , nb_blocks ) ; ymax = FFMAX ( 0 , s -> ymax + 1 ) ; <S2SV_StartBug> for ( i = 0 ; i < planes ; i ++ ) { <S2SV_EndBug> ptr = picture -> data [ i ] + ( ymax * picture -> linesize [ i ] ) ; for ( y = ymax ; y < avctx -> height ; y ++ ) { memset ( ptr , 0 , out_line_size ) ; ptr += picture -> linesize [ i ] ; } } picture -> pict_type = AV_PICTURE_TYPE_I ; * got_frame = 1 ; return avpkt -> size ; }
","<S2SV_ModStart> 1 ) ; if ( ymax < avctx -> height )
",FFmpeg@FFmpeg/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,CVE-2020-35965,https://github.com/FFmpeg/FFmpeg/commit/b0a8b40294ea212c1938348ff112ef1b9bf16bb3,2021-01-04T02:15Z
CWE-416,"CWE-416 void usb_sg_cancel ( struct usb_sg_request * io ) { unsigned long flags ; int i , retval ; spin_lock_irqsave ( & io -> lock , flags ) ; <S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; return ; } io -> status = - ECONNRESET ; <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> for ( i = io -> entries - 1 ; i >= 0 ; -- i ) { usb_block_urb ( io -> urbs [ i ] ) ; retval = usb_unlink_urb ( io -> urbs [ i ] ) ; if ( retval != - EINPROGRESS && retval != - ENODEV && retval != - EBUSY && retval != - EIDRM ) dev_warn ( & io -> dev -> dev , ""%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n"" , __func__ , retval ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> io -> status || io -> count == 0 <S2SV_ModStart> - ECONNRESET ; io -> count ++ ; <S2SV_ModStart> ) ; } spin_lock_irqsave ( & io -> lock , flags ) ; io -> count -- ; if ( ! io -> count ) complete ( & io -> complete ) ; spin_unlock_irqrestore ( & io -> lock , flags ) ;
",torvalds@linux/056ad39ee9253873522f6469c3364964a322912b,CVE-2020-12464,https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b,2020-04-29T18:15Z
CWE-264,"CWE-264 static inline unsigned long zap_pmd_range ( struct mmu_gather * tlb , struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , struct zap_details * details ) { pmd_t * pmd ; unsigned long next ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( next - addr != HPAGE_PMD_SIZE ) { VM_BUG_ON ( ! rwsem_is_locked ( & tlb -> mm -> mmap_sem ) ) ; split_huge_page_pmd ( vma -> vm_mm , pmd ) ; } else if ( zap_huge_pmd ( tlb , vma , pmd , addr ) ) <S2SV_StartBug> continue ; <S2SV_EndBug> } <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> <S2SV_StartBug> continue ; <S2SV_EndBug> <S2SV_StartBug> next = zap_pte_range ( tlb , vma , pmd , addr , next , details ) ; <S2SV_EndBug> cond_resched ( ) ; } while ( pmd ++ , addr = next , addr != end ) ; return addr ; }
","<S2SV_ModStart> addr ) ) goto next <S2SV_ModEnd> ; } if <S2SV_ModStart> } if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd ) <S2SV_ModStart> pmd ) ) goto next <S2SV_ModEnd> ; next = <S2SV_ModStart> details ) ; next :
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-358,"CWE-358 int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
","<S2SV_ModStart> ( sk ) ; bool checksum_valid = false <S2SV_ModStart> partial_cov ) { checksum_valid = ! <S2SV_ModEnd> udp_lib_checksum_complete ( skb <S2SV_ModStart> ( skb ) ; if ( ! checksum_valid <S2SV_ModStart> } if ( checksum_valid ||
",torvalds@linux/197c949e7798fbf28cfadc69d9ca0c2abbf93191,CVE-2016-10229,https://github.com/torvalds/linux/commit/197c949e7798fbf28cfadc69d9ca0c2abbf93191,2017-04-04T05:59Z
CWE-119,"CWE-119 php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirection<S2SV_blank>limit<S2SV_blank>reached,<S2SV_blank>aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == FAILURE || Z_TYPE_PP ( tmpzval ) != IS_STRING || Z_STRLEN_PP ( tmpzval ) <= 0 ) { php_url_free ( resource ) ; return php_stream_open_wrapper_ex ( path , mode , REPORT_ERRORS , NULL , context ) ; } request_fulluri = 1 ; use_ssl = 0 ; use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { if ( strpbrk ( mode , ""awx+"" ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>wrapper<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>writeable<S2SV_blank>connections"" ) ; php_url_free ( resource ) ; return NULL ; } use_ssl = resource -> scheme && ( strlen ( resource -> scheme ) > 4 ) && resource -> scheme [ 4 ] == 's' ; if ( use_ssl && resource -> port == 0 ) resource -> port = 443 ; else if ( resource -> port == 0 ) resource -> port = 80 ; if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""proxy"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { use_proxy = 1 ; transport_len = Z_STRLEN_PP ( tmpzval ) ; transport_string = estrndup ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { transport_len = spprintf ( & transport_string , 0 , ""%s://%s:%d"" , use_ssl ? ""ssl"" : ""tcp"" , resource -> host , resource -> port ) ; } } if ( context && php_stream_context_get_option ( context , wrapper -> wops -> label , ""timeout"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; timeout . tv_sec = ( time_t ) Z_DVAL_PP ( tmpzval ) ; timeout . tv_usec = ( size_t ) ( ( Z_DVAL_PP ( tmpzval ) - timeout . tv_sec ) * 1000000 ) ; } else { timeout . tv_sec = FG ( default_socket_timeout ) ; timeout . tv_usec = 0 ; } stream = php_stream_xport_create ( transport_string , transport_len , options , STREAM_XPORT_CLIENT | STREAM_XPORT_CONNECT , NULL , & timeout , context , & errstr , NULL ) ; if ( stream ) { php_stream_set_option ( stream , PHP_STREAM_OPTION_READ_TIMEOUT , 0 , & timeout ) ; } if ( errstr ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""%s"" , errstr ) ; efree ( errstr ) ; errstr = NULL ; } efree ( transport_string ) ; if ( stream && use_proxy && use_ssl ) { smart_str header = { 0 } ; if ( ! context || php_stream_context_get_option ( context , ""ssl"" , ""peer_name"" , & tmpzval ) == FAILURE ) { MAKE_STD_ZVAL ( ssl_proxy_peer_name ) ; ZVAL_STRING ( ssl_proxy_peer_name , resource -> host , 1 ) ; php_stream_context_set_option ( stream -> context , ""ssl"" , ""peer_name"" , ssl_proxy_peer_name ) ; } smart_str_appendl ( & header , ""CONNECT<S2SV_blank>"" , sizeof ( ""CONNECT<S2SV_blank>"" ) - 1 ) ; smart_str_appends ( & header , resource -> host ) ; smart_str_appendc ( & header , ':' ) ; smart_str_append_unsigned ( & header , resource -> port ) ; smart_str_appendl ( & header , ""<S2SV_blank>HTTP/1.0\\r\\n"" , sizeof ( ""<S2SV_blank>HTTP/1.0\\r\\n"" ) - 1 ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { char * s , * p ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { s = Z_STRVAL_PP ( tmpheader ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } } else if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { s = Z_STRVAL_PP ( tmpzval ) ; do { while ( * s == '<S2SV_blank>' || * s == '\\t' ) s ++ ; p = s ; while ( * p != 0 && * p != ':' && * p != '\\r' && * p != '\\n' ) p ++ ; if ( * p == ':' ) { p ++ ; if ( p - s == sizeof ( ""Proxy-Authorization:"" ) - 1 && zend_binary_strcasecmp ( s , sizeof ( ""Proxy-Authorization:"" ) - 1 , ""Proxy-Authorization:"" , sizeof ( ""Proxy-Authorization:"" ) - 1 ) == 0 ) { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; smart_str_appendl ( & header , s , p - s ) ; smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; goto finish ; } else { while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; } } s = p ; while ( * s == '\\r' || * s == '\\n' ) s ++ ; } while ( * s != 0 ) ; } } finish : smart_str_appendl ( & header , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; if ( php_stream_write ( stream , header . c , header . len ) != header . len ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } smart_str_free ( & header ) ; if ( stream ) { char header_line [ HTTP_HEADER_BLOCK_SIZE ] ; while ( php_stream_gets ( stream , header_line , HTTP_HEADER_BLOCK_SIZE - 1 ) != NULL ) { if ( header_line [ 0 ] == '\\n' || header_line [ 0 ] == '\\r' || header_line [ 0 ] == '\\0' ) { break ; } } } if ( stream ) { if ( php_stream_xport_crypto_setup ( stream , STREAM_CRYPTO_METHOD_SSLv23_CLIENT , NULL TSRMLS_CC ) < 0 || php_stream_xport_crypto_enable ( stream , 1 TSRMLS_CC ) < 0 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>HTTPS<S2SV_blank>server<S2SV_blank>through<S2SV_blank>proxy"" ) ; php_stream_close ( stream ) ; stream = NULL ; } } } if ( stream == NULL ) goto out ; if ( options & STREAM_WILL_CAST ) chunk_size = php_stream_set_chunk_size ( stream , 1 ) ; eol_detect = stream -> flags & ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; stream -> flags &= ~ ( PHP_STREAM_FLAG_DETECT_EOL | PHP_STREAM_FLAG_EOL_MAC ) ; php_stream_context_set ( stream , context ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_CONNECT , NULL , 0 ) ; if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""max_redirects"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; redirect_max = Z_LVAL_PP ( tmpzval ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""method"" , & tmpzval ) == SUCCESS ) { if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! redirected || ( Z_STRLEN_PP ( tmpzval ) == 3 && memcmp ( ""GET"" , Z_STRVAL_PP ( tmpzval ) , 3 ) == 0 ) || ( Z_STRLEN_PP ( tmpzval ) == 4 && memcmp ( ""HEAD"" , Z_STRVAL_PP ( tmpzval ) , 4 ) == 0 ) ) { scratch_len = strlen ( path ) + 29 + Z_STRLEN_PP ( tmpzval ) ; scratch = emalloc ( scratch_len ) ; strlcpy ( scratch , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) + 1 ) ; strncat ( scratch , ""<S2SV_blank>"" , 1 ) ; } } } if ( context && php_stream_context_get_option ( context , ""http"" , ""protocol_version"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_double_ex ( tmpzval ) ; protocol_version_len = spprintf ( & protocol_version , 0 , ""%.1F"" , Z_DVAL_PP ( tmpzval ) ) ; } if ( ! scratch ) { scratch_len = strlen ( path ) + 29 + protocol_version_len ; scratch = emalloc ( scratch_len ) ; strncpy ( scratch , ""GET<S2SV_blank>"" , scratch_len ) ; } if ( ! request_fulluri && context && php_stream_context_get_option ( context , ""http"" , ""request_fulluri"" , & tmpzval ) == SUCCESS ) { zval ztmp = * * tmpzval ; zval_copy_ctor ( & ztmp ) ; convert_to_boolean ( & ztmp ) ; request_fulluri = Z_BVAL ( ztmp ) ? 1 : 0 ; zval_dtor ( & ztmp ) ; } if ( request_fulluri ) { strcat ( scratch , path ) ; } else { if ( resource -> path && * resource -> path ) { strlcat ( scratch , resource -> path , scratch_len ) ; } else { strlcat ( scratch , ""/"" , scratch_len ) ; } if ( resource -> query ) { strlcat ( scratch , ""?"" , scratch_len ) ; strlcat ( scratch , resource -> query , scratch_len ) ; } } if ( protocol_version ) { strlcat ( scratch , ""<S2SV_blank>HTTP/"" , scratch_len ) ; strlcat ( scratch , protocol_version , scratch_len ) ; strlcat ( scratch , ""\\r\\n"" , scratch_len ) ; } else { strlcat ( scratch , ""<S2SV_blank>HTTP/1.0\\r\\n"" , scratch_len ) ; } php_stream_write ( stream , scratch , strlen ( scratch ) ) ; if ( context && php_stream_context_get_option ( context , ""http"" , ""header"" , & tmpzval ) == SUCCESS ) { tmp = NULL ; if ( Z_TYPE_PP ( tmpzval ) == IS_ARRAY ) { HashPosition pos ; zval * * tmpheader = NULL ; smart_str tmpstr = { 0 } ; for ( zend_hash_internal_pointer_reset_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ; SUCCESS == zend_hash_get_current_data_ex ( Z_ARRVAL_PP ( tmpzval ) , ( void * ) & tmpheader , & pos ) ; zend_hash_move_forward_ex ( Z_ARRVAL_PP ( tmpzval ) , & pos ) ) { if ( Z_TYPE_PP ( tmpheader ) == IS_STRING ) { smart_str_appendl ( & tmpstr , Z_STRVAL_PP ( tmpheader ) , Z_STRLEN_PP ( tmpheader ) ) ; smart_str_appendl ( & tmpstr , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } } smart_str_0 ( & tmpstr ) ; if ( tmpstr . c ) { tmp = php_trim ( tmpstr . c , strlen ( tmpstr . c ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; smart_str_free ( & tmpstr ) ; } } if ( Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) ) { tmp = php_trim ( Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) , NULL , 0 , NULL , 3 TSRMLS_CC ) ; } if ( tmp && strlen ( tmp ) > 0 ) { char * s ; user_headers = estrdup ( tmp ) ; php_strtolower ( tmp , strlen ( tmp ) ) ; if ( ! header_init ) { strip_header ( user_headers , tmp , ""content-length:"" ) ; strip_header ( user_headers , tmp , ""content-type:"" ) ; } if ( ( s = strstr ( tmp , ""user-agent:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_USER_AGENT ; } if ( ( s = strstr ( tmp , ""host:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_HOST ; } if ( ( s = strstr ( tmp , ""from:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_FROM ; } if ( ( s = strstr ( tmp , ""authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_AUTH ; } if ( ( s = strstr ( tmp , ""content-length:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONTENT_LENGTH ; } if ( ( s = strstr ( tmp , ""content-type:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_TYPE ; } if ( ( s = strstr ( tmp , ""connection:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { have_header |= HTTP_HEADER_CONNECTION ; } if ( use_proxy && use_ssl && ( s = strstr ( tmp , ""proxy-authorization:"" ) ) && ( s == tmp || * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' || * ( s - 1 ) == '\\t' || * ( s - 1 ) == '<S2SV_blank>' ) ) { char * p = s + sizeof ( ""proxy-authorization:"" ) - 1 ; while ( s > tmp && ( * ( s - 1 ) == '<S2SV_blank>' || * ( s - 1 ) == '\\t' ) ) s -- ; while ( * p != 0 && * p != '\\r' && * p != '\\n' ) p ++ ; while ( * p == '\\r' || * p == '\\n' ) p ++ ; if ( * p == 0 ) { if ( s == tmp ) { efree ( user_headers ) ; user_headers = NULL ; } else { while ( s > tmp && ( * ( s - 1 ) == '\\r' || * ( s - 1 ) == '\\n' ) ) s -- ; user_headers [ s - tmp ] = 0 ; } } else { memmove ( user_headers + ( s - tmp ) , user_headers + ( p - tmp ) , strlen ( p ) + 1 ) ; } } } if ( tmp ) { efree ( tmp ) ; } } if ( ( ( have_header & HTTP_HEADER_AUTH ) == 0 ) && resource -> user ) { php_url_decode ( resource -> user , strlen ( resource -> user ) ) ; strcpy ( scratch , resource -> user ) ; strcat ( scratch , "":"" ) ; if ( resource -> pass ) { php_url_decode ( resource -> pass , strlen ( resource -> pass ) ) ; strcat ( scratch , resource -> pass ) ; } tmp = ( char * ) php_base64_encode ( ( unsigned char * ) scratch , strlen ( scratch ) , NULL ) ; if ( snprintf ( scratch , scratch_len , ""Authorization:<S2SV_blank>Basic<S2SV_blank>%s\\r\\n"" , tmp ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; php_stream_notify_info ( context , PHP_STREAM_NOTIFY_AUTH_REQUIRED , NULL , 0 ) ; } efree ( tmp ) ; tmp = NULL ; } if ( ( ( have_header & HTTP_HEADER_FROM ) == 0 ) && FG ( from_address ) ) { if ( snprintf ( scratch , scratch_len , ""From:<S2SV_blank>%s\\r\\n"" , FG ( from_address ) ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } if ( ( have_header & HTTP_HEADER_HOST ) == 0 ) { if ( ( use_ssl && resource -> port != 443 && resource -> port != 0 ) || ( ! use_ssl && resource -> port != 80 && resource -> port != 0 ) ) { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s:%i\\r\\n"" , resource -> host , resource -> port ) > 0 ) php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } else { if ( snprintf ( scratch , scratch_len , ""Host:<S2SV_blank>%s\\r\\n"" , resource -> host ) > 0 ) { php_stream_write ( stream , scratch , strlen ( scratch ) ) ; } } } if ( ( have_header & HTTP_HEADER_CONNECTION ) == 0 ) { php_stream_write_string ( stream , ""Connection:<S2SV_blank>close\\r\\n"" ) ; } if ( context && php_stream_context_get_option ( context , ""http"" , ""user_agent"" , & ua_zval ) == SUCCESS && Z_TYPE_PP ( ua_zval ) == IS_STRING ) { ua_str = Z_STRVAL_PP ( ua_zval ) ; } else if ( FG ( user_agent ) ) { ua_str = FG ( user_agent ) ; } if ( ( ( have_header & HTTP_HEADER_USER_AGENT ) == 0 ) && ua_str ) { # define _UA_HEADER ""User-Agent:<S2SV_blank>%s\\r\\n"" char * ua ; size_t ua_len ; ua_len = sizeof ( _UA_HEADER ) + strlen ( ua_str ) ; if ( ua_len > sizeof ( _UA_HEADER ) ) { ua = emalloc ( ua_len + 1 ) ; if ( ( ua_len = slprintf ( ua , ua_len , _UA_HEADER , ua_str ) ) > 0 ) { ua [ ua_len ] = 0 ; php_stream_write ( stream , ua , ua_len ) ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Cannot<S2SV_blank>construct<S2SV_blank>User-agent<S2SV_blank>header"" ) ; } if ( ua ) { efree ( ua ) ; } } } if ( user_headers ) { if ( header_init && context && ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; have_header |= HTTP_HEADER_CONTENT_LENGTH ; } php_stream_write ( stream , user_headers , strlen ( user_headers ) ) ; php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; efree ( user_headers ) ; } if ( header_init && context && php_stream_context_get_option ( context , ""http"" , ""content"" , & tmpzval ) == SUCCESS && Z_TYPE_PP ( tmpzval ) == IS_STRING && Z_STRLEN_PP ( tmpzval ) > 0 ) { if ( ! ( have_header & HTTP_HEADER_CONTENT_LENGTH ) ) { scratch_len = slprintf ( scratch , scratch_len , ""Content-Length:<S2SV_blank>%d\\r\\n"" , Z_STRLEN_PP ( tmpzval ) ) ; php_stream_write ( stream , scratch , scratch_len ) ; } if ( ! ( have_header & HTTP_HEADER_TYPE ) ) { php_stream_write ( stream , ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" , sizeof ( ""Content-Type:<S2SV_blank>application/x-www-form-urlencoded\\r\\n"" ) - 1 ) ; php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Content-type<S2SV_blank>not<S2SV_blank>specified<S2SV_blank>assuming<S2SV_blank>application/x-www-form-urlencoded"" ) ; } php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; php_stream_write ( stream , Z_STRVAL_PP ( tmpzval ) , Z_STRLEN_PP ( tmpzval ) ) ; } else { php_stream_write ( stream , ""\\r\\n"" , sizeof ( ""\\r\\n"" ) - 1 ) ; } location [ 0 ] = '\\0' ; if ( ! EG ( active_symbol_table ) ) { zend_rebuild_symbol_table ( TSRMLS_C ) ; } if ( header_init ) { zval * ztmp ; MAKE_STD_ZVAL ( ztmp ) ; array_init ( ztmp ) ; ZEND_SET_SYMBOL ( EG ( active_symbol_table ) , ""http_response_header"" , ztmp ) ; } { zval * * rh ; if ( zend_hash_find ( EG ( active_symbol_table ) , ""http_response_header"" , sizeof ( ""http_response_header"" ) , ( void * * ) & rh ) != SUCCESS || Z_TYPE_PP ( rh ) != IS_ARRAY ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>http_response_header<S2SV_blank>overwritten"" ) ; goto out ; } response_header = * rh ; Z_ADDREF_P ( response_header ) ; } if ( ! php_stream_eof ( stream ) ) { size_t tmp_line_len ; if ( php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL ) { zval * http_response ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } if ( context && SUCCESS == php_stream_context_get_option ( context , ""http"" , ""ignore_errors"" , & tmpzval ) ) { ignore_errors = zend_is_true ( * tmpzval ) ; } if ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) { reqok = 1 ; } if ( response_code >= 100 && response_code < 200 ) { while ( ! php_stream_eof ( stream ) && php_stream_get_line ( stream , tmp_line , sizeof ( tmp_line ) - 1 , & tmp_line_len ) != NULL && ( tmp_line_len < sizeof ( ""HTTP/1"" ) - 1 || strncasecmp ( tmp_line , ""HTTP/1"" , sizeof ( ""HTTP/1"" ) - 1 ) ) ) ; if ( tmp_line_len > 9 ) { response_code = atoi ( tmp_line + 9 ) ; } else { response_code = 0 ; } } if ( response_code >= 200 && response_code < 400 ) { reqok = 1 ; } else { switch ( response_code ) { case 403 : php_stream_notify_error ( context , PHP_STREAM_NOTIFY_AUTH_RESULT , tmp_line , response_code ) ; break ; default : if ( ! tmp_line_len ) { tmp_line [ 0 ] = '\\0' ; } php_stream_notify_error ( context , PHP_STREAM_NOTIFY_FAILURE , tmp_line , response_code ) ; } } <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\n' ) { <S2SV_EndBug> -- tmp_line_len ; <S2SV_StartBug> if ( tmp_line [ tmp_line_len - 1 ] == '\\r' ) { <S2SV_EndBug> -- tmp_line_len ; } } MAKE_STD_ZVAL ( http_response ) ; ZVAL_STRINGL ( http_response , tmp_line , tmp_line_len , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_response , sizeof ( zval * ) , NULL ) ; } } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed,<S2SV_blank>unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>socket!"" ) ; goto out ; } http_header_line = emalloc ( HTTP_HEADER_BLOCK_SIZE ) ; while ( ! body && ! php_stream_eof ( stream ) ) { size_t http_header_line_length ; if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) && * http_header_line != '\\n' && * http_header_line != '\\r' ) { char * e = http_header_line + http_header_line_length - 1 ; if ( * e != '\\n' ) { do { if ( php_stream_get_line ( stream , http_header_line , HTTP_HEADER_BLOCK_SIZE , & http_header_line_length ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>HTTP<S2SV_blank>headers"" ) ; goto out ; } e = http_header_line + http_header_line_length - 1 ; } while ( * e != '\\n' ) ; continue ; } while ( * e == '\\n' || * e == '\\r' ) { e -- ; } http_header_line_length = e - http_header_line + 1 ; http_header_line [ http_header_line_length ] = '\\0' ; if ( ! strncasecmp ( http_header_line , ""Location:<S2SV_blank>"" , 10 ) ) { if ( context && php_stream_context_get_option ( context , ""http"" , ""follow_location"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_long_ex ( tmpzval ) ; follow_location = Z_LVAL_PP ( tmpzval ) ; } else if ( ! ( response_code >= 300 && response_code < 304 || 307 == response_code || 308 == response_code ) ) { follow_location = 0 ; } strlcpy ( location , http_header_line + 10 , sizeof ( location ) ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Type:<S2SV_blank>"" , 14 ) ) { php_stream_notify_info ( context , PHP_STREAM_NOTIFY_MIME_TYPE_IS , http_header_line + 14 , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Content-Length:<S2SV_blank>"" , 16 ) ) { file_size = atoi ( http_header_line + 16 ) ; php_stream_notify_file_size ( context , file_size , http_header_line , 0 ) ; } else if ( ! strncasecmp ( http_header_line , ""Transfer-Encoding:<S2SV_blank>chunked"" , sizeof ( ""Transfer-Encoding:<S2SV_blank>chunked"" ) ) ) { if ( ! ( options & STREAM_ONLY_GET_HEADERS ) ) { long decode = 1 ; if ( context && php_stream_context_get_option ( context , ""http"" , ""auto_decode"" , & tmpzval ) == SUCCESS ) { SEPARATE_ZVAL ( tmpzval ) ; convert_to_boolean ( * tmpzval ) ; decode = Z_LVAL_PP ( tmpzval ) ; } if ( decode ) { transfer_encoding = php_stream_filter_create ( ""dechunk"" , NULL , php_stream_is_persistent ( stream ) TSRMLS_CC ) ; if ( transfer_encoding ) { continue ; } } } } if ( http_header_line [ 0 ] == '\\0' ) { body = 1 ; } else { zval * http_header ; MAKE_STD_ZVAL ( http_header ) ; ZVAL_STRINGL ( http_header , http_header_line , http_header_line_length , 1 ) ; zend_hash_next_index_insert ( Z_ARRVAL_P ( response_header ) , & http_header , sizeof ( zval * ) , NULL ) ; } } else { break ; } } if ( ! reqok || ( location [ 0 ] != '\\0' && follow_location ) ) { if ( ! follow_location || ( ( ( options & STREAM_ONLY_GET_HEADERS ) || ignore_errors ) && redirect_max <= 1 ) ) { goto out ; } if ( location [ 0 ] != '\\0' ) php_stream_notify_info ( context , PHP_STREAM_NOTIFY_REDIRECTED , location , 0 ) ; php_stream_close ( stream ) ; stream = NULL ; if ( location [ 0 ] != '\\0' ) { char new_path [ HTTP_HEADER_BLOCK_SIZE ] ; char loc_path [ HTTP_HEADER_BLOCK_SIZE ] ; * new_path = '\\0' ; if ( strlen ( location ) < 8 || ( strncasecmp ( location , ""http://"" , sizeof ( ""http://"" ) - 1 ) && strncasecmp ( location , ""https://"" , sizeof ( ""https://"" ) - 1 ) && strncasecmp ( location , ""ftp://"" , sizeof ( ""ftp://"" ) - 1 ) && strncasecmp ( location , ""ftps://"" , sizeof ( ""ftps://"" ) - 1 ) ) ) { if ( * location != '/' ) { if ( * ( location + 1 ) != '\\0' && resource -> path ) { char * s = strrchr ( resource -> path , '/' ) ; if ( ! s ) { s = resource -> path ; if ( ! s [ 0 ] ) { efree ( s ) ; s = resource -> path = estrdup ( ""/"" ) ; } else { * s = '/' ; } } s [ 1 ] = '\\0' ; if ( resource -> path && * ( resource -> path ) == '/' && * ( resource -> path + 1 ) == '\\0' ) { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s%s"" , resource -> path , location ) ; } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""%s/%s"" , resource -> path , location ) ; } } else { snprintf ( loc_path , sizeof ( loc_path ) - 1 , ""/%s"" , location ) ; } } else { strlcpy ( loc_path , location , sizeof ( loc_path ) ) ; } if ( ( use_ssl && resource -> port != 443 ) || ( ! use_ssl && resource -> port != 80 ) ) { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s:%d%s"" , resource -> scheme , resource -> host , resource -> port , loc_path ) ; } else { snprintf ( new_path , sizeof ( new_path ) - 1 , ""%s://%s%s"" , resource -> scheme , resource -> host , loc_path ) ; } } else { strlcpy ( new_path , location , sizeof ( new_path ) ) ; } php_url_free ( resource ) ; if ( ( resource = php_url_parse ( new_path ) ) == NULL ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } <S2SV_StartBug> # define CHECK_FOR_CNTRL_CHARS ( val ) { if ( val ) { unsigned char * s , * e ; int l ; l = php_url_decode ( val , strlen ( val ) ) ; s = ( unsigned char * ) val ; e = s + l ; while ( s < e ) { if ( iscntrl ( * s ) ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Invalid<S2SV_blank>redirect<S2SV_blank>URL!<S2SV_blank>%s"" , new_path ) ; goto out ; } s ++ ; } } } <S2SV_EndBug> if ( strncasecmp ( new_path , ""http://"" , sizeof ( ""http://"" ) - 1 ) || strncasecmp ( new_path , ""https://"" , sizeof ( ""https://"" ) - 1 ) ) { CHECK_FOR_CNTRL_CHARS ( resource -> user ) CHECK_FOR_CNTRL_CHARS ( resource -> pass ) CHECK_FOR_CNTRL_CHARS ( resource -> path ) } stream = php_stream_url_wrap_http_ex ( wrapper , new_path , mode , options , opened_path , context , -- redirect_max , HTTP_WRAPPER_REDIRECTED STREAMS_CC TSRMLS_CC ) ; } else { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""HTTP<S2SV_blank>request<S2SV_blank>failed!<S2SV_blank>%s"" , tmp_line ) ; } } out : if ( protocol_version ) { efree ( protocol_version ) ; } if ( http_header_line ) { efree ( http_header_line ) ; } if ( scratch ) { efree ( scratch ) ; } if ( resource ) { php_url_free ( resource ) ; } if ( stream ) { if ( header_init ) { stream -> wrapperdata = response_header ; } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } } php_stream_notify_progress_init ( context , 0 , file_size ) ; if ( options & STREAM_WILL_CAST ) php_stream_set_chunk_size ( stream , chunk_size ) ; stream -> flags |= eol_detect ; stream -> position = 0 ; strlcpy ( stream -> mode , mode , sizeof ( stream -> mode ) ) ; if ( transfer_encoding ) { php_stream_filter_append ( & stream -> readfilters , transfer_encoding ) ; } } else { if ( response_header ) { Z_DELREF_P ( response_header ) ; } if ( transfer_encoding ) { php_stream_filter_free ( transfer_encoding TSRMLS_CC ) ; } } return stream ; }
","<S2SV_ModStart> } if ( tmp_line_len >= 1 && <S2SV_ModStart> ; if ( tmp_line_len >= 1 && <S2SV_ModStart> ; } } \\\n} <S2SV_ModEnd> if ( strncasecmp
",php@php-src/523f230c831d7b33353203fa34aee4e92ac12bba,CVE-2018-7584,https://github.com/php/php-src/commit/523f230c831d7b33353203fa34aee4e92ac12bba,2018-03-01T19:29Z
CWE-787,"CWE-787 static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }
","<S2SV_ModStart> / 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }
",vadz@libtiff/83a4b92815ea04969d494416eaae3d4c6b338e4a,CVE-2016-9533,https://github.com/vadz/libtiff/commit/83a4b92815ea04969d494416eaae3d4c6b338e4a#diff-bdc795f6afeb9558c1012b3cfae729ef,2016-11-22T19:59Z
CWE-674,"CWE-674 static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
","<S2SV_ModStart> text ; int result ; int <S2SV_ModStart> ; } } result = <S2SV_ModEnd> js_regexec ( re <S2SV_ModStart> , opts ) ; if ( result < 0 ) js_error ( J , ""regexec<S2SV_blank>failed"" ) ; if ( result == 0
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
CWE-20,"CWE-20 void BezierCircle ( double r , char * action ) <S2SV_StartBug> { <S2SV_EndBug> outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c\\n"" , r * BzK , r , r , r * BzK , r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>%12.3f<S2SV_blank>c\\n"" , r , - r * BzK , r * BzK , - r , - r ) ; outpos += sprintf ( outpos , ""<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>0<S2SV_blank>c<S2SV_blank>%s\\n"" , - r * BzK , - r , - r , - r * BzK , - r , action ) ; <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> action ) { char * outpos = outputbuffer ; <S2SV_ModStart> action ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-125,"CWE-125 static void dhcp6opt_print ( netdissect_options * ndo , const u_char * cp , const u_char * ep ) { const struct dhcp6opt * dh6o ; const u_char * tp ; size_t i ; uint16_t opttype ; size_t optlen ; uint8_t auth_proto ; u_int authinfolen , authrealmlen ; int remain_len ; int label_len ; uint16_t subopt_code ; uint16_t subopt_len ; if ( cp == ep ) return ; while ( cp < ep ) { if ( ep < cp + sizeof ( * dh6o ) ) goto trunc ; dh6o = ( const struct dhcp6opt * ) cp ; ND_TCHECK ( * dh6o ) ; optlen = EXTRACT_16BITS ( & dh6o -> dh6opt_len ) ; if ( ep < cp + sizeof ( * dh6o ) + optlen ) goto trunc ; opttype = EXTRACT_16BITS ( & dh6o -> dh6opt_type ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s"" , tok2str ( dh6opt_str , ""opt_%u"" , opttype ) ) ) ; ND_TCHECK2 ( * ( cp + sizeof ( * dh6o ) ) , optlen ) ; switch ( opttype ) { case DH6OPT_CLIENTID : case DH6OPT_SERVERID : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( EXTRACT_16BITS ( tp ) ) { case 1 : if ( optlen >= 2 + 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr/time<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>time<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; for ( i = 8 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 2 : if ( optlen >= 2 + 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>vid<S2SV_blank>"" ) ) ; for ( i = 2 ; i < 2 + 8 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 3 : if ( optlen >= 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) ) ) ; for ( i = 4 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; } break ; case DH6OPT_IA_ADDR : if ( optlen < 24 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 16 ] ) , EXTRACT_32BITS ( & tp [ 20 ] ) ) ) ; if ( optlen > 24 ) { dhcp6opt_print ( ndo , tp + 24 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_ORO : case DH6OPT_ERO : if ( optlen % 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( dh6opt_str , ""opt_%u"" , EXTRACT_16BITS ( & tp [ i ] ) ) ) ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_PREFERENCE : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , * tp ) ) ; break ; case DH6OPT_ELAPSED_TIME : if ( optlen != 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; case DH6OPT_RELAY_MSG : ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; tp = ( const u_char * ) ( dh6o + 1 ) ; dhcp6_print ( ndo , tp , optlen ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AUTH : if ( optlen < 11 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; auth_proto = * tp ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>delayed"" ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>reconfigure"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>%d"" , auth_proto ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHALG_HMACMD5 : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHRDM_MONOCOUNTER : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>mono"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>RD:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 2 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , EXTRACT_16BITS ( tp ) ) ) ; authinfolen = optlen - 11 ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : if ( authinfolen == 0 ) break ; if ( authinfolen < 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } authrealmlen = authinfolen - 20 ; if ( authrealmlen > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>realm:<S2SV_blank>"" ) ) ; } for ( i = 0 ; i < authrealmlen ; i ++ , tp ++ ) ND_PRINT ( ( ndo , ""%02x"" , * tp ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>key<S2SV_blank>ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; tp += 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>HMAC-MD5:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : if ( authinfolen != 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } switch ( * tp ++ ) { case DH6OPT_AUTHRECONFIG_KEY : ND_PRINT ( ( ndo , ""<S2SV_blank>reconfig-key"" ) ) ; break ; case DH6OPT_AUTHRECONFIG_HMACMD5 : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>value:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_RAPID_COMMIT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_INTERFACE_ID : case DH6OPT_SUBSCRIBER_ID : tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; for ( i = 0 ; i < optlen && i < 10 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; <S2SV_StartBug> case DH6OPT_RECONF_MSG : <S2SV_EndBug> tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case DH6_RENEW : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>renew)"" ) ) ; break ; case DH6_INFORM_REQ : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>inf-req)"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>?\\?\\?(%02x))"" , * tp ) ) ; break ; } break ; case DH6OPT_RECONF_ACCEPT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_A : case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : case DH6OPT_NIS_SERVERS : case DH6OPT_NISP_SERVERS : case DH6OPT_BCMCS_SERVER_A : case DH6OPT_PANA_AGENT : case DH6OPT_LQ_CLIENT_LINK : if ( optlen % 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ i ] ) ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_D : case DH6OPT_DOMAIN_LIST : tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , cp + sizeof ( * dh6o ) + optlen ) ) == NULL ) goto trunc ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_STATUS_CODE : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s)"" , dhcp6stcode ( EXTRACT_16BITS ( & tp [ 0 ] ) ) ) ) ; break ; case DH6OPT_IA_NA : case DH6OPT_IA_PD : if ( optlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u<S2SV_blank>T1:%u<S2SV_blank>T2:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) , EXTRACT_32BITS ( & tp [ 8 ] ) ) ) ; if ( optlen > 12 ) { dhcp6opt_print ( ndo , tp + 12 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_TA : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u"" , EXTRACT_32BITS ( tp ) ) ) ; if ( optlen > 4 ) { dhcp6opt_print ( ndo , tp + 4 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_PD_PREFIX : if ( optlen < 25 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%d"" , ip6addr_string ( ndo , & tp [ 9 ] ) , tp [ 8 ] ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; if ( optlen > 25 ) { dhcp6opt_print ( ndo , tp + 25 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LIFETIME : case DH6OPT_CLT_TIME : if ( optlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_REMOTE_ID : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d<S2SV_blank>"" , EXTRACT_32BITS ( tp ) ) ) ; for ( i = 4 ; i < optlen && i < 14 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_LQ_QUERY : if ( optlen < 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-address"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-clientID"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type_%d"" , ( int ) * tp ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 1 ] ) ) ) ; if ( optlen > 17 ) { dhcp6opt_print ( ndo , tp + 17 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_CLIENT_DATA : tp = ( const u_char * ) ( dh6o + 1 ) ; if ( optlen > 0 ) { dhcp6opt_print ( ndo , tp , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LQ_RELAY_DATA : if ( optlen < 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; for ( i = 16 ; i < optlen && i < 26 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_NTP_SERVER : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen - 4 ) { subopt_code = EXTRACT_16BITS ( tp ) ; tp += 2 ; subopt_len = EXTRACT_16BITS ( tp ) ; tp += 2 ; if ( tp + subopt_len > cp + sizeof ( * dh6o ) + optlen ) goto trunc ; ND_PRINT ( ( ndo , ""<S2SV_blank>subopt:%d"" , subopt_code ) ) ; switch ( subopt_code ) { case DH6OPT_NTP_SUBOPTION_SRV_ADDR : case DH6OPT_NTP_SUBOPTION_MC_ADDR : if ( subopt_len != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; break ; case DH6OPT_NTP_SUBOPTION_SRV_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ns_nprint ( ndo , tp , tp + subopt_len ) == NULL ) goto trunc ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } tp += subopt_len ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AFTR_NAME : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; remain_len = optlen ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; while ( remain_len && * tp ) { label_len = * tp ++ ; if ( label_len < remain_len - 1 ) { ( void ) fn_printn ( ndo , tp , label_len , NULL ) ; tp += label_len ; remain_len -= ( label_len + 1 ) ; if ( * tp ) ND_PRINT ( ( ndo , ""."" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_NEW_POSIX_TIMEZONE : case DH6OPT_NEW_TZDB_TIMEZONE : case DH6OPT_MUDURL : if ( optlen < 5 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""="" ) ) ; ( void ) fn_printn ( ndo , tp , ( u_int ) optlen , NULL ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : ND_PRINT ( ( ndo , "")"" ) ) ; break ; } cp += sizeof ( * dh6o ) + optlen ; } return ; trunc : ND_PRINT ( ( ndo , ""[|dhcp6ext]"" ) ) ; }
","<S2SV_ModStart> case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; }
",the-tcpdump-group@tcpdump/11b426ee05eb62ed103218526f1fa616851c43ce,CVE-2017-13017,https://github.com/the-tcpdump-group/tcpdump/commit/11b426ee05eb62ed103218526f1fa616851c43ce,2017-09-14T06:29Z
CWE-125,"CWE-125 static void rpl_dao_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dao * dao = ( const struct nd_rpl_dao * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK ( * dao ) ; if ( length < ND_RPL_DAO_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAO_MIN_LEN ; length -= ND_RPL_DAO_MIN_LEN ; if ( RPL_DAO_D ( dao -> rpl_flags ) ) { ND_TCHECK2 ( dao -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , dao -> rpl_dagid ) ; bp += DAGID_LEN ; length -= DAGID_LEN ; } ND_PRINT ( ( ndo , ""<S2SV_blank>[dagid:%s,seq:%u,instance:%u%s%s,%02x]"" , dagid_str , dao -> rpl_daoseq , dao -> rpl_instanceid , RPL_DAO_K ( dao -> rpl_flags ) ? "",acK"" : """" , RPL_DAO_D ( dao -> rpl_flags ) ? "",Dagid"" : """" , dao -> rpl_flags ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>[|truncated]"" ) ) ; <S2SV_EndBug> return ; tooshort : ND_PRINT ( ( ndo , ""<S2SV_blank>[|length<S2SV_blank>too<S2SV_blank>short]"" ) ) ; return ; }
","<S2SV_ModStart> ( ndo , ""%s"" , rpl_tstr <S2SV_ModEnd> ) ) ;
",the-tcpdump-group@tcpdump/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,CVE-2018-14882,https://github.com/the-tcpdump-group/tcpdump/commit/d7505276842e85bfd067fa21cdb32b8a2dc3c5e4,2019-10-03T16:15Z
CWE-20,"CWE-20 static int ssl_scan_serverhello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int length , type , size ; int tlsext_servername = 0 ; int renegotiate_seen = 0 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif s -> tlsext_ticket_expected = 0 ; OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> s -> s3 -> flags &= ~ TLS1_FLAGS_RECEIVED_EXTMS ; if ( ! PACKET_get_net_2 ( pkt , & length ) ) goto ri_check ; if ( PACKET_remaining ( pkt ) != length ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( ! tls1_check_duplicate_extensions ( pkt ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } while ( PACKET_get_net_2 ( pkt , & type ) && PACKET_get_net_2 ( pkt , & size ) ) { const unsigned char * data ; PACKET spkt ; if ( ! PACKET_get_sub_packet ( pkt , & spkt , size ) || ! PACKET_peek_bytes ( & spkt , & data , size ) ) goto ri_check ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 1 , type , data , size , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_serverhello_renegotiate_ext ( s , & spkt , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { if ( s -> tlsext_hostname == NULL || size > 0 ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } tlsext_servername = 1 ; } # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { unsigned int ecpointformatlist_length ; if ( ! PACKET_get_1 ( & spkt , & ecpointformatlist_length ) || ecpointformatlist_length != size - 1 ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit ) { s -> session -> tlsext_ecpointformatlist_length = 0 ; OPENSSL_free ( s -> session -> tlsext_ecpointformatlist ) ; if ( ( s -> session -> tlsext_ecpointformatlist = OPENSSL_malloc ( ecpointformatlist_length ) ) == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> session -> tlsext_ecpointformatlist_length = ecpointformatlist_length ; if ( ! PACKET_copy_bytes ( & spkt , s -> session -> tlsext_ecpointformatlist , ecpointformatlist_length ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , data , size , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ! tls_use_ticket ( s ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_ticket_expected = 1 ; } else if ( type == TLSEXT_TYPE_status_request ) { if ( ( s -> tlsext_status_type == - 1 ) || ( size > 0 ) ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } s -> tlsext_status_expected = 1 ; } # ifndef OPENSSL_NO_CT else if ( type == TLSEXT_TYPE_signed_certificate_timestamp && s -> ct_validation_callback != NULL ) { if ( s -> tlsext_scts != NULL ) { OPENSSL_free ( s -> tlsext_scts ) ; s -> tlsext_scts = NULL ; } s -> tlsext_scts_len = size ; if ( size > 0 ) { s -> tlsext_scts = OPENSSL_malloc ( size ) ; if ( s -> tlsext_scts == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> tlsext_scts , data , size ) ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { unsigned char * selected ; unsigned char selected_len ; if ( s -> ctx -> next_proto_select_cb == NULL ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! ssl_next_proto_validate ( & spkt ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } if ( s -> ctx -> next_proto_select_cb ( s , & selected , & selected_len , data , size , s -> ctx -> next_proto_select_cb_arg ) != SSL_TLSEXT_ERR_OK ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } OPENSSL_free ( s -> next_proto_negotiated ) ; s -> next_proto_negotiated = OPENSSL_malloc ( selected_len ) ; if ( s -> next_proto_negotiated == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } memcpy ( s -> next_proto_negotiated , selected , selected_len ) ; s -> next_proto_negotiated_len = selected_len ; s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation ) { unsigned len ; if ( ! s -> s3 -> alpn_sent ) { * al = TLS1_AD_UNSUPPORTED_EXTENSION ; return 0 ; } if ( ! PACKET_get_net_2 ( & spkt , & len ) || PACKET_remaining ( & spkt ) != len || ! PACKET_get_1 ( & spkt , & len ) || PACKET_remaining ( & spkt ) != len ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = OPENSSL_malloc ( len ) ; if ( s -> s3 -> alpn_selected == NULL ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } if ( ! PACKET_copy_bytes ( & spkt , s -> s3 -> alpn_selected , len ) ) { * al = TLS1_AD_DECODE_ERROR ; return 0 ; } s -> s3 -> alpn_selected_len = len ; } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & spkt , & hbtype ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_serverhello_use_srtp_ext ( s , & spkt , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) { if ( s -> s3 -> tmp . new_cipher -> algorithm_mac != SSL_AEAD && s -> s3 -> tmp . new_cipher -> algorithm_enc != SSL_RC4 ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> } else if ( type == TLSEXT_TYPE_extended_master_secret ) { s -> s3 -> flags |= TLS1_FLAGS_RECEIVED_EXTMS ; if ( ! s -> hit ) s -> session -> flags |= SSL_SESS_FLAG_EXTMS ; } else if ( custom_ext_parse ( s , 0 , type , data , size , al ) <= 0 ) return 0 ; } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } if ( ! s -> hit && tlsext_servername == 1 ) { if ( s -> tlsext_hostname ) { if ( s -> session -> tlsext_hostname == NULL ) { s -> session -> tlsext_hostname = OPENSSL_strdup ( s -> tlsext_hostname ) ; if ( ! s -> session -> tlsext_hostname ) { * al = SSL_AD_UNRECOGNIZED_NAME ; return 0 ; } } else { * al = SSL_AD_DECODE_ERROR ; return 0 ; } } } ri_check : if ( ! renegotiate_seen && ! ( s -> options & SSL_OP_LEGACY_SERVER_CONNECT ) && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } if ( s -> hit ) { if ( ! ( s -> s3 -> flags & TLS1_FLAGS_RECEIVED_EXTMS ) != ! ( s -> session -> flags & SSL_SESS_FLAG_EXTMS ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT , SSL_R_INCONSISTENT_EXTMS ) ; return 0 ; } } return 1 ; }
","<S2SV_ModStart> endif s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; s -> <S2SV_ModStart> ) s -> tlsext_use_etm = 1 <S2SV_ModEnd> ; } else
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z
CWE-119,"CWE-119 static void show_object ( struct object * obj , <S2SV_StartBug> struct strbuf * path , const char * component , <S2SV_EndBug> void * cb_data ) { struct rev_list_info * info = cb_data ; <S2SV_StartBug> finish_object ( obj , path , component , cb_data ) ; <S2SV_EndBug> if ( info -> flags & REV_LIST_QUIET ) return ; <S2SV_StartBug> show_object_with_name ( stdout , obj , path , component ) ; <S2SV_EndBug> }
","<S2SV_ModStart> * obj , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> ( obj , name <S2SV_ModEnd> , cb_data ) <S2SV_ModStart> , obj , name <S2SV_ModEnd> ) ; }
",git@git/de1e67d0703894cb6ea782e36abb63976ab07e60,CVE-2016-2324,https://github.com/git/git/commit/de1e67d0703894cb6ea782e36abb63976ab07e60,2016-04-08T14:59Z
CWE-125,"CWE-125 void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }
","<S2SV_ModStart> ; if ( skb_is_err_queue ( skb ) &&
",torvalds@linux/8605330aac5a5785630aec8f64378a54891937cc,CVE-2017-7277,https://github.com/torvalds/linux/commit/8605330aac5a5785630aec8f64378a54891937cc,2017-03-28T06:59Z
CWE-59,"CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; <S2SV_StartBug> dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; <S2SV_EndBug> char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } # if 0 { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } } # endif dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> , fsuid , <S2SV_ModEnd> NULL ) ;
",abrt@abrt/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,CVE-2015-3315,https://github.com/abrt/abrt/commit/4f2c1ddd3e3b81d2d5146b883115371f1cada9f9,2017-06-26T15:29Z
CWE-908,"CWE-908 int im_vips2dz ( IMAGE * in , const char * filename ) { char * p , * q ; char name [ FILENAME_MAX ] ; char mode [ FILENAME_MAX ] ; char buf [ FILENAME_MAX ] ; int i ; VipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ ; char * suffix = "".jpeg"" ; int overlap = 0 ; int tile_size = 256 ; VipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL ; gboolean centre = FALSE ; VipsAngle angle = VIPS_ANGLE_D0 ; im_strncpy ( name , filename , FILENAME_MAX ) ; if ( ( p = strchr ( name , ':' ) ) ) { * p = '\\0' ; im_strncpy ( mode , p + 1 , FILENAME_MAX ) ; } <S2SV_StartBug> strcpy ( buf , mode ) ; <S2SV_EndBug> p = & buf [ 0 ] ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_LAYOUT , q ) ) < 0 ) return ( - 1 ) ; layout = i ; } if ( ( q = im_getnextoption ( & p ) ) ) suffix = g_strdup ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) overlap = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) tile_size = atoi ( q ) ; if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_FOREIGN_DZ_DEPTH , q ) ) < 0 ) return ( - 1 ) ; depth = i ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( im_isprefix ( ""cen"" , q ) ) centre = TRUE ; } if ( ( q = im_getnextoption ( & p ) ) ) { if ( ( i = vips_enum_from_nick ( ""im_vips2dz"" , VIPS_TYPE_ANGLE , q ) ) < 0 ) return ( - 1 ) ; angle = i ; } if ( vips_dzsave ( in , name , ""layout"" , layout , ""suffix"" , suffix , ""overlap"" , overlap , ""tile_size"" , tile_size , ""depth"" , depth , ""centre"" , centre , ""angle"" , angle , NULL ) ) return ( - 1 ) ; return ( 0 ) ; }
","<S2SV_ModStart> ) ; } else strcpy ( mode , """" ) ;
",libvips@libvips/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,CVE-2020-20739,https://github.com/libvips/libvips/commit/2ab5aa7bf515135c2b02d42e9a72e4c98e17031a,2020-11-20T19:15Z
CWE-20,"CWE-20 int ssl3_get_record ( SSL * s ) { int ssl_major , ssl_minor , al ; int enc_err , n , i , ret = - 1 ; SSL3_RECORD * rr ; SSL3_BUFFER * rbuf ; SSL_SESSION * sess ; unsigned char * p ; unsigned char md [ EVP_MAX_MD_SIZE ] ; short version ; unsigned mac_size ; unsigned int num_recs = 0 ; unsigned int max_recs ; unsigned int j ; rr = RECORD_LAYER_get_rrec ( & s -> rlayer ) ; rbuf = RECORD_LAYER_get_rbuf ( & s -> rlayer ) ; max_recs = s -> max_pipelines ; if ( max_recs == 0 ) max_recs = 1 ; sess = s -> session ; do { if ( ( RECORD_LAYER_get_rstate ( & s -> rlayer ) != SSL_ST_READ_BODY ) || ( RECORD_LAYER_get_packet_length ( & s -> rlayer ) < SSL3_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , SSL3_RT_HEADER_LENGTH , SSL3_BUFFER_get_len ( rbuf ) , 0 , num_recs == 0 ? 1 : 0 ) ; if ( n <= 0 ) return ( n ) ; RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_BODY ) ; p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; if ( s -> server && RECORD_LAYER_is_first_record ( & s -> rlayer ) && ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) { rr [ num_recs ] . type = SSL3_RT_HANDSHAKE ; rr [ num_recs ] . rec_version = SSL2_VERSION ; rr [ num_recs ] . length = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ; if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL2_RT_HEADER_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; goto f_err ; } if ( rr [ num_recs ] . length < MIN_SSL2_RECORD_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } } else { if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , 5 , s , s -> msg_callback_arg ) ; rr [ num_recs ] . type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; rr [ num_recs ] . rec_version = version ; n2s ( p , rr [ num_recs ] . length ) ; if ( ! s -> first_packet && version != s -> version ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; if ( ( s -> version & 0xFF00 ) == ( version & 0xFF00 ) && ! s -> enc_write_ctx && ! s -> write_hash ) { if ( rr -> type == SSL3_RT_ALERT ) { goto err ; } s -> version = ( unsigned short ) version ; } al = SSL_AD_PROTOCOL_VERSION ; goto f_err ; } if ( ( version >> 8 ) != SSL3_VERSION_MAJOR ) { if ( RECORD_LAYER_is_first_record ( & s -> rlayer ) ) { p = RECORD_LAYER_get_packet ( & s -> rlayer ) ; if ( strncmp ( ( char * ) p , ""GET<S2SV_blank>"" , 4 ) == 0 || strncmp ( ( char * ) p , ""POST<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""HEAD<S2SV_blank>"" , 5 ) == 0 || strncmp ( ( char * ) p , ""PUT<S2SV_blank>"" , 4 ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTP_REQUEST ) ; goto err ; } else if ( strncmp ( ( char * ) p , ""CONNE"" , 5 ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_HTTPS_PROXY_REQUEST ) ; goto err ; } SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; goto err ; } else { SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_WRONG_VERSION_NUMBER ) ; al = SSL_AD_PROTOCOL_VERSION ; goto f_err ; } } if ( rr [ num_recs ] . length > SSL3_BUFFER_get_len ( rbuf ) - SSL3_RT_HEADER_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_PACKET_LENGTH_TOO_LONG ) ; goto f_err ; } } } if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { i = rr [ num_recs ] . length + SSL2_RT_HEADER_LENGTH - SSL3_RT_HEADER_LENGTH ; } else { i = rr [ num_recs ] . length ; } if ( i > 0 ) { n = ssl3_read_n ( s , i , i , 1 , 0 ) ; if ( n <= 0 ) return ( n ) ; } RECORD_LAYER_set_rstate ( & s -> rlayer , SSL_ST_READ_HEADER ) ; if ( rr [ num_recs ] . rec_version == SSL2_VERSION ) { rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL2_RT_HEADER_LENGTH ] ) ; } else { rr [ num_recs ] . input = & ( RECORD_LAYER_get_packet ( & s -> rlayer ) [ SSL3_RT_HEADER_LENGTH ] ) ; } if ( rr [ num_recs ] . length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; goto f_err ; } rr [ num_recs ] . data = rr [ num_recs ] . input ; rr [ num_recs ] . orig_len = rr [ num_recs ] . length ; rr [ num_recs ] . read = 0 ; num_recs ++ ; RECORD_LAYER_reset_packet_length ( & s -> rlayer ) ; RECORD_LAYER_clear_first_record ( & s -> rlayer ) ; } while ( num_recs < max_recs && rr [ num_recs - 1 ] . type == SSL3_RT_APPLICATION_DATA && SSL_USE_EXPLICIT_IV ( s ) && s -> enc_read_ctx != NULL && ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_read_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) && ssl3_record_app_data_waiting ( s ) ) ; <S2SV_StartBug> if ( SSL_USE_ETM ( s ) && s -> read_hash ) { <S2SV_EndBug> unsigned char * mac ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; for ( j = 0 ; j < num_recs ; j ++ ) { if ( rr [ j ] . length < mac_size ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rr [ j ] . length -= mac_size ; mac = rr [ j ] . data + rr [ j ] . length ; i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; if ( i < 0 || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) { al = SSL_AD_BAD_RECORD_MAC ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; goto f_err ; } } } enc_err = s -> method -> ssl3_enc -> enc ( s , rr , num_recs , 0 ) ; if ( enc_err == 0 ) { al = SSL_AD_DECRYPTION_FAILED ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BLOCK_CIPHER_PAD_IS_WRONG ) ; goto f_err ; } # ifdef SSL_DEBUG printf ( ""dec<S2SV_blank>%d\\n"" , rr -> length ) ; { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( ""%02X%c"" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( ""\\n"" ) ; # endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && <S2SV_StartBug> ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) && ! SSL_USE_ETM ( s ) ) { <S2SV_EndBug> unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; for ( j = 0 ; j < num_recs ; j ++ ) { if ( rr [ j ] . orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr [ j ] . orig_len < mac_size + 1 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { mac = mac_tmp ; ssl3_cbc_copy_mac ( mac_tmp , & rr [ j ] , mac_size ) ; rr [ j ] . length -= mac_size ; } else { rr [ j ] . length -= mac_size ; mac = & rr [ j ] . data [ rr [ j ] . length ] ; } i = s -> method -> ssl3_enc -> mac ( s , & rr [ j ] , md , 0 ) ; if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ; if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ; } } if ( enc_err < 0 ) { al = SSL_AD_BAD_RECORD_MAC ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC ) ; goto f_err ; } for ( j = 0 ; j < num_recs ; j ++ ) { if ( s -> expand != NULL ) { if ( rr [ j ] . length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; goto f_err ; } if ( ! ssl3_do_uncompress ( s , & rr [ j ] ) ) { al = SSL_AD_DECOMPRESSION_FAILURE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_BAD_DECOMPRESSION ) ; goto f_err ; } } if ( rr [ j ] . length > SSL3_RT_MAX_PLAIN_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } rr [ j ] . off = 0 ; if ( rr [ j ] . length == 0 ) { RECORD_LAYER_inc_empty_record_count ( & s -> rlayer ) ; if ( RECORD_LAYER_get_empty_record_count ( & s -> rlayer ) > MAX_EMPTY_RECORDS ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_RECORD , SSL_R_RECORD_TOO_SMALL ) ; goto f_err ; } } else { RECORD_LAYER_reset_empty_record_count ( & s -> rlayer ) ; } } RECORD_LAYER_set_numrpipes ( & s -> rlayer , num_recs ) ; return 1 ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ret ; }
","<S2SV_ModStart> ; if ( SSL_READ_ETM <S2SV_ModEnd> ( s ) <S2SV_ModStart> ) && ( ! SSL_READ_ETM ( s ) && <S2SV_ModStart> ) != NULL <S2SV_ModEnd> ) ) {
",openssl@openssl/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,CVE-2017-3733,https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2,2017-05-04T19:29Z
CWE-119,"CWE-119 int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ; <S2SV_StartBug> int i , target_bits_per_mb ; <S2SV_EndBug> const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do { <S2SV_StartBug> const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , <S2SV_EndBug> <S2SV_StartBug> correction_factor ) ; <S2SV_EndBug> if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ; <S2SV_StartBug> return q ; <S2SV_EndBug> }
","<S2SV_ModStart> i , target_bits_per_mb , bits_per_mb_at_this_q <S2SV_ModStart> ; do { if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled && cpi -> svc . temporal_layer_id == 0 && cpi -> svc . spatial_layer_id == 0 ) { bits_per_mb_at_this_q = ( int ) vp9_cyclic_refresh_rc_bits_per_mb ( cpi , i , correction_factor ) ; } else { <S2SV_ModEnd> bits_per_mb_at_this_q = ( <S2SV_ModStart> i , correction_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> if ( bits_per_mb_at_this_q <S2SV_ModStart> active_worst_quality ) ; if ( cpi -> oxcf . rc_mode == VPX_CBR && ( cpi -> rc . rc_1_frame * cpi -> rc . rc_2_frame == - 1 ) && cpi -> rc . q_1_frame != cpi -> rc . q_2_frame ) { q = clamp ( q , MIN ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) , MAX ( cpi -> rc . q_1_frame , cpi -> rc . q_2_frame ) ) ; }
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""<S2SV_blank>with<S2SV_blank>policy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , ""initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u"" ""<S2SV_blank>but<S2SV_blank>\\""%s\\""<S2SV_blank>forbids<S2SV_blank>connection"" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( ""local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation"" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( ""found<S2SV_blank>connection:<S2SV_blank>%s\\n"" , c ? c -> name : ""<none>"" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( ""received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it"" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( ""dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet"" , blob ) ; DBG_dump ( ""dcookie<S2SV_blank>computed"" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( ""mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one"" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( ""dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one"" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie"" ) ; DBG_log ( ""send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state"" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( ""will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie"" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , ""ikev2_inI1outR1<S2SV_blank>KE"" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , ""system<S2SV_blank>too<S2SV_blank>busy"" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }
","<S2SV_ModStart> * ke ; <S2SV_ModEnd> char fromname [ <S2SV_ModStart> ADDRTOT_BUF ) ; if ( ! md -> chain [ ISAKMP_NEXT_v2KE ] ) { if ( md -> chain [ ISAKMP_NEXT_v2N ] ) { libreswan_log ( ""Received<S2SV_blank>Notify(%d):<S2SV_blank>%s"" , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type , enum_name ( & ikev2_notify_names , md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type ) ) ; } libreswan_log ( ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>no<S2SV_blank>KE<S2SV_blank>payload<S2SV_blank>present"" , fromname , md -> sender_port ) ; return STF_FAIL + v2N_INVALID_KE_PAYLOAD ; } ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { libreswan_log ( <S2SV_ModEnd> ""rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u"" , fromname <S2SV_ModStart> ) ; return STF_FAIL +
",libreswan@libreswan/2899351224fe2940aec37d7656e1e392c0fe07f0,CVE-2013-7294,https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0,2014-01-16T05:05Z
CWE-310,"CWE-310 void bn_sqr_comba4 ( BN_ULONG * r , const BN_ULONG * a ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; r [ 7 ] = c2 ; }
","<S2SV_ModStart> ) { BN_ULONG <S2SV_ModEnd> c1 , c2
",openssl@openssl/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,CVE-2014-3570,https://github.com/openssl/openssl/commit/a7a44ba55cb4f884c6bc9ceac90072dea38e66d0,2015-01-09T02:59Z
CWE-362,"CWE-362 static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; <S2SV_StartBug> struct free_nid * i ; <S2SV_EndBug> struct nat_entry * ne ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( unlikely ( nid == 0 ) ) return false ; <S2SV_StartBug> if ( build ) { <S2SV_EndBug> ne = __lookup_nat_cache ( nm_i , nid ) ; if ( ne && ( ! get_nat_flag ( ne , IS_CHECKPOINTED ) || nat_get_blkaddr ( ne ) != NULL_ADDR ) ) <S2SV_StartBug> return false ; <S2SV_EndBug> } i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }
","<S2SV_ModStart> free_nid * i , * e <S2SV_ModStart> ; int err = - EINVAL ; bool ret = false <S2SV_ModStart> return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; <S2SV_ModStart> NULL_ADDR ) ) goto err_out ; e = __lookup_free_nid_list ( nm_i , nid ) ; if ( e ) { if ( e -> state == NID_NEW ) ret = true ; goto err_out ; } } ret = true ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; err_out : spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; err : if ( err ) kmem_cache_free ( free_nid_slab , i ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,CVE-2017-18249,https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3,2018-03-26T20:29Z
CWE-000,"CWE-000 static int em_syscall ( struct x86_emulate_ctxt * ctxt ) { struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; <S2SV_StartBug> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; <S2SV_EndBug> <S2SV_StartBug> setup_syscalls_segments ( ctxt , & cs , & ss ) ; <S2SV_EndBug> ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; msr_data >>= 32 ; cs_sel = ( u16 ) ( msr_data & 0xfffc ) ; ss_sel = ( u16 ) ( msr_data + 8 ) ; if ( efer & EFER_LMA ) { cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ctxt -> regs [ VCPU_REGS_RCX ] = ctxt -> _eip ; if ( efer & EFER_LMA ) { # ifdef CONFIG_X86_64 ctxt -> regs [ VCPU_REGS_R11 ] = ctxt -> eflags & ~ EFLG_RF ; ops -> get_msr ( ctxt , ctxt -> mode == X86EMUL_MODE_PROT64 ? MSR_LSTAR : MSR_CSTAR , & msr_data ) ; ctxt -> _eip = msr_data ; ops -> get_msr ( ctxt , MSR_SYSCALL_MASK , & msr_data ) ; ctxt -> eflags &= ~ ( msr_data | EFLG_RF ) ; # endif } else { ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; ctxt -> _eip = ( u32 ) msr_data ; ctxt -> eflags &= ~ ( EFLG_VM | EFLG_IF | EFLG_RF ) ; } return X86EMUL_CONTINUE ; }
","<S2SV_ModStart> ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; <S2SV_ModStart> , & ss ) ; if ( ! ( efer & EFER_SCE ) ) return emulate_ud ( ctxt
",torvalds@linux/c2226fc9e87ba3da060e47333657cd6616652b84,CVE-2012-0045,https://github.com/torvalds/linux/commit/c2226fc9e87ba3da060e47333657cd6616652b84,2012-07-03T16:40Z
CWE-399,"CWE-399 void xsltGenerateIdFunction ( xmlXPathParserContextPtr ctxt , int nargs ) { <S2SV_StartBug> xmlNodePtr cur = NULL ; <S2SV_EndBug> long val ; xmlChar str [ 30 ] ; xmlDocPtr doc ; if ( nargs == 0 ) { cur = ctxt -> context -> node ; } else if ( nargs == 1 ) { <S2SV_StartBug> xmlXPathObjectPtr obj ; <S2SV_EndBug> xmlNodeSetPtr nodelist ; int i , ret ; if ( ( ctxt -> value == NULL ) || ( ctxt -> value -> type != XPATH_NODESET ) ) { ctxt -> error = XPATH_INVALID_TYPE ; xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>arg<S2SV_blank>expecting<S2SV_blank>a<S2SV_blank>node-set\\n"" ) ; return ; } obj = valuePop ( ctxt ) ; nodelist = obj -> nodesetval ; if ( ( nodelist == NULL ) || ( nodelist -> nodeNr <= 0 ) ) { xmlXPathFreeObject ( obj ) ; valuePush ( ctxt , xmlXPathNewCString ( """" ) ) ; return ; } cur = nodelist -> nodeTab [ 0 ] ; for ( i = 1 ; i < nodelist -> nodeNr ; i ++ ) { ret = xmlXPathCmpNodes ( cur , nodelist -> nodeTab [ i ] ) ; if ( ret == - 1 ) cur = nodelist -> nodeTab [ i ] ; } <S2SV_StartBug> xmlXPathFreeObject ( obj ) ; <S2SV_EndBug> } else { xsltTransformError ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL , ""generate-id()<S2SV_blank>:<S2SV_blank>invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>args<S2SV_blank>%d\\n"" , nargs ) ; ctxt -> error = XPATH_INVALID_ARITY ; return ; } if ( cur -> type != XML_NAMESPACE_DECL ) doc = cur -> doc ; else { xmlNsPtr ns = ( xmlNsPtr ) cur ; if ( ns -> context != NULL ) doc = ns -> context ; else doc = ctxt -> context -> doc ; } <S2SV_StartBug> val = ( long ) ( ( char * ) cur - ( char * ) doc ) ; <S2SV_EndBug> if ( val >= 0 ) { sprintf ( ( char * ) str , ""idp%ld"" , val ) ; } else { sprintf ( ( char * ) str , ""idm%ld"" , - val ) ; } valuePush ( ctxt , xmlXPathNewString ( str ) ) ; }
","<S2SV_ModStart> { xmlNodePtr cur = NULL ; xmlXPathObjectPtr obj <S2SV_ModStart> 1 ) { <S2SV_ModEnd> xmlNodeSetPtr nodelist ; <S2SV_ModStart> ] ; } <S2SV_ModEnd> } else { <S2SV_ModStart> doc ; } if ( obj ) xmlXPathFreeObject ( obj ) ;
",chromium@chromium/e741149a6b7872a2bf1f2b6cc0a56e836592fb77,CVE-2012-2870,https://github.com/chromium/chromium/commit/e741149a6b7872a2bf1f2b6cc0a56e836592fb77,2012-08-31T19:55Z
CWE-200,"CWE-200 int dse_bind ( Slapi_PBlock * pb ) { ber_tag_t method ; struct berval * cred ; Slapi_Value * * bvals ; struct dse * pdse ; Slapi_Attr * attr ; Slapi_DN * sdn = NULL ; Slapi_Entry * ec = NULL ; if ( slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & pdse ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_TARGET_SDN , & sdn ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) < 0 || slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) < 0 ) { slapi_send_ldap_result ( pb , LDAP_OPERATIONS_ERROR , NULL , NULL , 0 , NULL ) ; return SLAPI_BIND_FAIL ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { slapi_send_ldap_result ( pb , LDAP_SUCCESS , NULL , NULL , 0 , NULL ) ; return ( SLAPI_BIND_FAIL ) ; } ec = dse_get_entry_copy ( pdse , sdn , DSE_USE_LOCK ) ; if ( ec == NULL ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_NO_SUCH_OBJECT , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> return ( SLAPI_BIND_FAIL ) ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( ec , ""userpassword"" , & attr ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ; <S2SV_EndBug> slapi_entry_free ( ec ) ; value_done ( & cv ) ; return SLAPI_BIND_FAIL ; } value_done ( & cv ) ; } break ; default : slapi_send_ldap_result ( pb , LDAP_STRONG_AUTH_NOT_SUPPORTED , NULL , ""auth<S2SV_blank>method<S2SV_blank>not<S2SV_blank>supported"" , 0 , NULL ) ; slapi_entry_free ( ec ) ; return SLAPI_BIND_FAIL ; } slapi_entry_free ( ec ) ; return SLAPI_BIND_SUCCESS ; }
","<S2SV_ModStart> NULL ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS <S2SV_ModEnd> , NULL , <S2SV_ModStart> 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Invalid<S2SV_blank>credentials"" ) ;
",389ds@389-ds-base/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32,CVE-2020-35518,https://github.com/389ds/389-ds-base/commit/b6aae4d8e7c8a6ddd21646f94fef1bf7f22c3f32,2021-03-26T17:15Z
CWE-416,"CWE-416 static void regulator_ena_gpio_free ( struct regulator_dev * rdev ) { struct regulator_enable_gpio * pin , * n ; if ( ! rdev -> ena_pin ) return ; list_for_each_entry_safe ( pin , n , & regulator_ena_gpio_list , list ) { if ( pin -> gpiod == rdev -> ena_pin -> gpiod ) { if ( pin -> request_count <= 1 ) { pin -> request_count = 0 ; gpiod_put ( pin -> gpiod ) ; list_del ( & pin -> list ) ; kfree ( pin ) ; <S2SV_StartBug> } else { <S2SV_EndBug> pin -> request_count -- ; } } } }
","<S2SV_ModStart> pin ) ; rdev -> ena_pin = NULL ; return ;
",torvalds@linux/60a2362f769cf549dc466134efe71c8bf9fbaaba,CVE-2014-9940,https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba,2017-05-02T21:59Z
CWE-476,"CWE-476 av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }
","<S2SV_ModStart> { if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
",FFmpeg@FFmpeg/b3332a182f8ba33a34542e4a0370f38b914ccf7d,CVE-2018-12460,https://github.com/FFmpeg/FFmpeg/commit/b3332a182f8ba33a34542e4a0370f38b914ccf7d,2018-06-15T15:29Z
CWE-190,"CWE-190 <S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) { <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = send
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-310,"CWE-310 static void prefetch_enc ( void ) { <S2SV_StartBug> prefetch_table ( ( const void * ) encT , sizeof ( encT ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> void ) { enc_tables . counter_head ++ ; enc_tables . counter_tail ++ ; <S2SV_ModStart> void * ) & enc_tables <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( enc_tables <S2SV_ModEnd> ) ) ;
",gpg@libgcrypt/daedbbb5541cd8ecda1459d3b843ea4d92788762,CVE-2019-12904,https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762,2019-06-20T00:15Z
CWE-264,"CWE-264 static void vmx_set_msr_bitmap ( struct kvm_vcpu * vcpu ) { unsigned long * msr_bitmap ; if ( is_guest_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_nested ; <S2SV_StartBug> else if ( vcpu -> arch . apic_base & X2APIC_ENABLE ) { <S2SV_EndBug> if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ; else msr_bitmap = vmx_msr_bitmap_legacy_x2apic ; } else { if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode ; else msr_bitmap = vmx_msr_bitmap_legacy ; } vmcs_write64 ( MSR_BITMAP , __pa ( msr_bitmap ) ) ; }
","<S2SV_ModStart> else if ( cpu_has_secondary_exec_ctrls ( ) && ( vmcs_read32 ( SECONDARY_VM_EXEC_CONTROL ) & SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE ) <S2SV_ModEnd> ) { if
",torvalds@linux/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,CVE-2016-4440,https://github.com/torvalds/linux/commit/3ce424e45411cf5a13105e0386b6ecf6eeb4f66f,2016-06-27T10:59Z
CWE-190,"CWE-190 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
","<S2SV_ModStart> val ) { jas_ulonglong <S2SV_ModEnd> tmp ; if
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-190,"CWE-190 SQLITE_PRIVATE ExprList * sqlite3ExprListAppend ( Parse * pParse , ExprList * pList , Expr * pExpr ) { struct ExprList_item * pItem ; sqlite3 * db = pParse -> db ; assert ( db != 0 ) ; if ( pList == 0 ) { pList = sqlite3DbMallocRawNN ( db , sizeof ( ExprList ) ) ; if ( pList == 0 ) { goto no_mem ; } pList -> nExpr = 0 ; } else if ( ( pList -> nExpr & ( pList -> nExpr - 1 ) ) == 0 ) { ExprList * pNew ; pNew = sqlite3DbRealloc ( db , pList , <S2SV_StartBug> sizeof ( * pList ) + ( 2 * pList -> nExpr - 1 ) * sizeof ( pList -> a [ 0 ] ) ) ; <S2SV_EndBug> if ( pNew == 0 ) { goto no_mem ; } pList = pNew ; } pItem = & pList -> a [ pList -> nExpr ++ ] ; assert ( offsetof ( struct ExprList_item , zName ) == sizeof ( pItem -> pExpr ) ) ; assert ( offsetof ( struct ExprList_item , pExpr ) == 0 ) ; memset ( & pItem -> zName , 0 , sizeof ( * pItem ) - offsetof ( struct ExprList_item , zName ) ) ; pItem -> pExpr = pExpr ; return pList ; no_mem : sqlite3ExprDelete ( db , pExpr ) ; sqlite3ExprListDelete ( db , pList ) ; return 0 ; }
","<S2SV_ModStart> ( 2 * ( sqlite3_int64 )
",chromium@chromium/517ac71c9ee27f856f9becde8abea7d1604af9d4,CVE-2019-5827,https://github.com/chromium/chromium/commit/517ac71c9ee27f856f9becde8abea7d1604af9d4,2019-06-27T17:15Z
CWE-285,"CWE-285 static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }
","<S2SV_ModStart> { ret = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( ret ) return ret <S2SV_ModEnd> ; } ret
",torvalds@linux/073931017b49d9458aa351605b43a7e34598caef,CVE-2016-7097,https://github.com/torvalds/linux/commit/073931017b49d9458aa351605b43a7e34598caef,2016-10-16T21:59Z
CWE-125,"CWE-125 static int ext4_fill_super ( struct super_block * sb , void * data , int silent ) { char * orig_data = kstrdup ( data , GFP_KERNEL ) ; struct buffer_head * bh ; struct ext4_super_block * es = NULL ; struct ext4_sb_info * sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; ext4_fsblk_t block ; ext4_fsblk_t sb_block = get_sb_block ( & data ) ; ext4_fsblk_t logical_sb_block ; unsigned long offset = 0 ; unsigned long journal_devnum = 0 ; unsigned long def_mount_opts ; struct inode * root ; const char * descr ; int ret = - ENOMEM ; int blocksize , clustersize ; unsigned int db_count ; unsigned int i ; int needs_recovery , has_huge_files , has_bigalloc ; __u64 blocks_count ; int err = 0 ; unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO ; ext4_group_t first_not_zeroed ; if ( ( data && ! orig_data ) || ! sbi ) goto out_free_base ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) goto out_free_base ; sb -> s_fs_info = sbi ; sbi -> s_sb = sb ; sbi -> s_inode_readahead_blks = EXT4_DEF_INODE_READAHEAD_BLKS ; sbi -> s_sb_block = sb_block ; if ( sb -> s_bdev -> bd_part ) sbi -> s_sectors_written_start = part_stat_read ( sb -> s_bdev -> bd_part , sectors [ 1 ] ) ; strreplace ( sb -> s_id , '/' , '!' ) ; ret = - EINVAL ; blocksize = sb_min_blocksize ( sb , EXT4_MIN_BLOCK_SIZE ) ; if ( ! blocksize ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>blocksize"" ) ; goto out_fail ; } if ( blocksize != EXT4_MIN_BLOCK_SIZE ) { logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; } else { logical_sb_block = sb_block ; } if ( ! ( bh = sb_bread_unmovable ( sb , logical_sb_block ) ) ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>superblock"" ) ; goto out_fail ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es -> s_magic ) ; if ( sb -> s_magic != EXT4_SUPER_MAGIC ) goto cantfind_ext4 ; sbi -> s_kbytes_written = le64_to_cpu ( es -> s_kbytes_written ) ; if ( ext4_has_feature_metadata_csum ( sb ) && ext4_has_feature_gdt_csum ( sb ) ) ext4_warning ( sb , ""metadata_csum<S2SV_blank>and<S2SV_blank>uninit_bg<S2SV_blank>are<S2SV_blank>"" ""redundant<S2SV_blank>flags;<S2SV_blank>please<S2SV_blank>run<S2SV_blank>fsck."" ) ; if ( ! ext4_verify_csum_type ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>"" ""unknown<S2SV_blank>checksum<S2SV_blank>algorithm."" ) ; silent = 1 ; goto cantfind_ext4 ; } if ( ext4_has_feature_metadata_csum ( sb ) ) { sbi -> s_chksum_driver = crypto_alloc_shash ( ""crc32c"" , 0 , 0 ) ; if ( IS_ERR ( sbi -> s_chksum_driver ) ) { ext4_msg ( sb , KERN_ERR , ""Cannot<S2SV_blank>load<S2SV_blank>crc32c<S2SV_blank>driver."" ) ; ret = PTR_ERR ( sbi -> s_chksum_driver ) ; sbi -> s_chksum_driver = NULL ; goto failed_mount ; } } if ( ! ext4_superblock_csum_verify ( sb , es ) ) { ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Found<S2SV_blank>ext4<S2SV_blank>filesystem<S2SV_blank>with<S2SV_blank>"" ""invalid<S2SV_blank>superblock<S2SV_blank>checksum.<S2SV_blank><S2SV_blank>Run<S2SV_blank>e2fsck?"" ) ; silent = 1 ; ret = - EFSBADCRC ; goto cantfind_ext4 ; } if ( ext4_has_feature_csum_seed ( sb ) ) sbi -> s_csum_seed = le32_to_cpu ( es -> s_checksum_seed ) ; else if ( ext4_has_metadata_csum ( sb ) ) sbi -> s_csum_seed = ext4_chksum ( sbi , ~ 0 , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; def_mount_opts = le32_to_cpu ( es -> s_default_mount_opts ) ; set_opt ( sb , INIT_INODE_TABLE ) ; if ( def_mount_opts & EXT4_DEFM_DEBUG ) set_opt ( sb , DEBUG ) ; if ( def_mount_opts & EXT4_DEFM_BSDGROUPS ) set_opt ( sb , GRPID ) ; if ( def_mount_opts & EXT4_DEFM_UID16 ) set_opt ( sb , NO_UID32 ) ; set_opt ( sb , XATTR_USER ) ; # ifdef CONFIG_EXT4_FS_POSIX_ACL set_opt ( sb , POSIX_ACL ) ; # endif if ( ext4_has_metadata_csum ( sb ) ) set_opt ( sb , JOURNAL_CHECKSUM ) ; if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_DATA ) set_opt ( sb , JOURNAL_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_ORDERED ) set_opt ( sb , ORDERED_DATA ) ; else if ( ( def_mount_opts & EXT4_DEFM_JMODE ) == EXT4_DEFM_JMODE_WBACK ) set_opt ( sb , WRITEBACK_DATA ) ; if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_PANIC ) set_opt ( sb , ERRORS_PANIC ) ; else if ( le16_to_cpu ( sbi -> s_es -> s_errors ) == EXT4_ERRORS_CONTINUE ) set_opt ( sb , ERRORS_CONT ) ; else set_opt ( sb , ERRORS_RO ) ; set_opt ( sb , BLOCK_VALIDITY ) ; if ( def_mount_opts & EXT4_DEFM_DISCARD ) set_opt ( sb , DISCARD ) ; sbi -> s_resuid = make_kuid ( & init_user_ns , le16_to_cpu ( es -> s_def_resuid ) ) ; sbi -> s_resgid = make_kgid ( & init_user_ns , le16_to_cpu ( es -> s_def_resgid ) ) ; sbi -> s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ; sbi -> s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME ; sbi -> s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME ; if ( ( def_mount_opts & EXT4_DEFM_NOBARRIER ) == 0 ) set_opt ( sb , BARRIER ) ; if ( ! IS_EXT3_SB ( sb ) && ! IS_EXT2_SB ( sb ) && ( ( def_mount_opts & EXT4_DEFM_NODELALLOC ) == 0 ) ) set_opt ( sb , DELALLOC ) ; sbi -> s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT ; if ( sbi -> s_es -> s_mount_opts [ 0 ] ) { char * s_mount_opts = kstrndup ( sbi -> s_es -> s_mount_opts , sizeof ( sbi -> s_es -> s_mount_opts ) , GFP_KERNEL ) ; if ( ! s_mount_opts ) goto failed_mount ; if ( ! parse_options ( s_mount_opts , sb , & journal_devnum , & journal_ioprio , 0 ) ) { ext4_msg ( sb , KERN_WARNING , ""failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>options<S2SV_blank>in<S2SV_blank>superblock:<S2SV_blank>%s"" , s_mount_opts ) ; } kfree ( s_mount_opts ) ; } sbi -> s_def_mount_opt = sbi -> s_mount_opt ; if ( ! parse_options ( ( char * ) data , sb , & journal_devnum , & journal_ioprio , 0 ) ) goto failed_mount ; if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) { printk_once ( KERN_WARNING ""EXT4-fs:<S2SV_blank>Warning:<S2SV_blank>mounting<S2SV_blank>"" ""with<S2SV_blank>data=journal<S2SV_blank>disables<S2SV_blank>delayed<S2SV_blank>"" ""allocation<S2SV_blank>and<S2SV_blank>O_DIRECT<S2SV_blank>support!\\n"" ) ; if ( test_opt2 ( sb , EXPLICIT_DELALLOC ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>delalloc"" ) ; goto failed_mount ; } if ( test_opt ( sb , DIOREAD_NOLOCK ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dioread_nolock"" ) ; goto failed_mount ; } if ( test_opt ( sb , DAX ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""both<S2SV_blank>data=journal<S2SV_blank>and<S2SV_blank>dax"" ) ; goto failed_mount ; } if ( test_opt ( sb , DELALLOC ) ) clear_opt ( sb , DELALLOC ) ; } else { sb -> s_iflags |= SB_I_CGROUPWB ; } sb -> s_flags = ( sb -> s_flags & ~ MS_POSIXACL ) | ( test_opt ( sb , POSIX_ACL ) ? MS_POSIXACL : 0 ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV && ( ext4_has_compat_features ( sb ) || ext4_has_ro_compat_features ( sb ) || ext4_has_incompat_features ( sb ) ) ) ext4_msg ( sb , KERN_WARNING , ""feature<S2SV_blank>flags<S2SV_blank>set<S2SV_blank>on<S2SV_blank>rev<S2SV_blank>0<S2SV_blank>fs,<S2SV_blank>"" ""running<S2SV_blank>e2fsck<S2SV_blank>is<S2SV_blank>recommended"" ) ; if ( es -> s_creator_os == cpu_to_le32 ( EXT4_OS_HURD ) ) { set_opt2 ( sb , HURD_COMPAT ) ; if ( ext4_has_feature_64bit ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""The<S2SV_blank>Hurd<S2SV_blank>can\'t<S2SV_blank>support<S2SV_blank>64-bit<S2SV_blank>file<S2SV_blank>systems"" ) ; goto failed_mount ; } } if ( IS_EXT2_SB ( sb ) ) { if ( ext2_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mounting<S2SV_blank>ext2<S2SV_blank>file<S2SV_blank>system<S2SV_blank>"" ""using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext2<S2SV_blank>due<S2SV_blank>"" ""to<S2SV_blank>feature<S2SV_blank>incompatibilities"" ) ; goto failed_mount ; } } if ( IS_EXT3_SB ( sb ) ) { if ( ext3_feature_set_ok ( sb ) ) ext4_msg ( sb , KERN_INFO , ""mounting<S2SV_blank>ext3<S2SV_blank>file<S2SV_blank>system<S2SV_blank>"" ""using<S2SV_blank>the<S2SV_blank>ext4<S2SV_blank>subsystem"" ) ; else { ext4_msg ( sb , KERN_ERR , ""couldn\'t<S2SV_blank>mount<S2SV_blank>as<S2SV_blank>ext3<S2SV_blank>due<S2SV_blank>"" ""to<S2SV_blank>feature<S2SV_blank>incompatibilities"" ) ; goto failed_mount ; } } if ( ! ext4_feature_set_ok ( sb , ( sb -> s_flags & MS_RDONLY ) ) ) goto failed_mount ; blocksize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_block_size ) ; if ( blocksize < EXT4_MIN_BLOCK_SIZE || blocksize > EXT4_MAX_BLOCK_SIZE ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>filesystem<S2SV_blank>blocksize<S2SV_blank>%d<S2SV_blank>(%d<S2SV_blank>log_block_size)"" , blocksize , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_block_size ) > ( EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Invalid<S2SV_blank>log<S2SV_blank>block<S2SV_blank>size:<S2SV_blank>%u"" , le32_to_cpu ( es -> s_log_block_size ) ) ; goto failed_mount ; } if ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) > ( blocksize / 4 ) ) { ext4_msg ( sb , KERN_ERR , ""Number<S2SV_blank>of<S2SV_blank>reserved<S2SV_blank>GDT<S2SV_blank>blocks<S2SV_blank>insanely<S2SV_blank>large:<S2SV_blank>%d"" , le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) ) ; goto failed_mount ; } if ( sbi -> s_mount_opt & EXT4_MOUNT_DAX ) { err = bdev_dax_supported ( sb , blocksize ) ; if ( err ) goto failed_mount ; } if ( ext4_has_feature_encrypt ( sb ) && es -> s_encryption_level ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>encryption<S2SV_blank>level<S2SV_blank>%d"" , es -> s_encryption_level ) ; goto failed_mount ; } if ( sb -> s_blocksize != blocksize ) { if ( ! sb_set_blocksize ( sb , blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""bad<S2SV_blank>block<S2SV_blank>size<S2SV_blank>%d"" , blocksize ) ; goto failed_mount ; } brelse ( bh ) ; logical_sb_block = sb_block * EXT4_MIN_BLOCK_SIZE ; offset = do_div ( logical_sb_block , blocksize ) ; bh = sb_bread_unmovable ( sb , logical_sb_block ) ; if ( ! bh ) { ext4_msg ( sb , KERN_ERR , ""Can\'t<S2SV_blank>read<S2SV_blank>superblock<S2SV_blank>on<S2SV_blank>2nd<S2SV_blank>try"" ) ; goto failed_mount ; } es = ( struct ext4_super_block * ) ( bh -> b_data + offset ) ; sbi -> s_es = es ; if ( es -> s_magic != cpu_to_le16 ( EXT4_SUPER_MAGIC ) ) { ext4_msg ( sb , KERN_ERR , ""Magic<S2SV_blank>mismatch,<S2SV_blank>very<S2SV_blank>weird!"" ) ; goto failed_mount ; } } has_huge_files = ext4_has_feature_huge_file ( sb ) ; sbi -> s_bitmap_maxbytes = ext4_max_bitmap_size ( sb -> s_blocksize_bits , has_huge_files ) ; sb -> s_maxbytes = ext4_max_size ( sb -> s_blocksize_bits , has_huge_files ) ; if ( le32_to_cpu ( es -> s_rev_level ) == EXT4_GOOD_OLD_REV ) { sbi -> s_inode_size = EXT4_GOOD_OLD_INODE_SIZE ; sbi -> s_first_ino = EXT4_GOOD_OLD_FIRST_INO ; } else { sbi -> s_inode_size = le16_to_cpu ( es -> s_inode_size ) ; sbi -> s_first_ino = le32_to_cpu ( es -> s_first_ino ) ; if ( ( sbi -> s_inode_size < EXT4_GOOD_OLD_INODE_SIZE ) || ( ! is_power_of_2 ( sbi -> s_inode_size ) ) || ( sbi -> s_inode_size > blocksize ) ) { ext4_msg ( sb , KERN_ERR , ""unsupported<S2SV_blank>inode<S2SV_blank>size:<S2SV_blank>%d"" , sbi -> s_inode_size ) ; goto failed_mount ; } if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) sb -> s_time_gran = 1 << ( EXT4_EPOCH_BITS - 2 ) ; } sbi -> s_desc_size = le16_to_cpu ( es -> s_desc_size ) ; if ( ext4_has_feature_64bit ( sb ) ) { if ( sbi -> s_desc_size < EXT4_MIN_DESC_SIZE_64BIT || sbi -> s_desc_size > EXT4_MAX_DESC_SIZE || ! is_power_of_2 ( sbi -> s_desc_size ) ) { ext4_msg ( sb , KERN_ERR , ""unsupported<S2SV_blank>descriptor<S2SV_blank>size<S2SV_blank>%lu"" , sbi -> s_desc_size ) ; goto failed_mount ; } } else sbi -> s_desc_size = EXT4_MIN_DESC_SIZE ; sbi -> s_blocks_per_group = le32_to_cpu ( es -> s_blocks_per_group ) ; sbi -> s_inodes_per_group = le32_to_cpu ( es -> s_inodes_per_group ) ; sbi -> s_inodes_per_block = blocksize / EXT4_INODE_SIZE ( sb ) ; if ( sbi -> s_inodes_per_block == 0 ) goto cantfind_ext4 ; if ( sbi -> s_inodes_per_group < sbi -> s_inodes_per_block || sbi -> s_inodes_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""invalid<S2SV_blank>inodes<S2SV_blank>per<S2SV_blank>group:<S2SV_blank>%lu\\n"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_itb_per_group = sbi -> s_inodes_per_group / sbi -> s_inodes_per_block ; sbi -> s_desc_per_block = blocksize / EXT4_DESC_SIZE ( sb ) ; sbi -> s_sbh = bh ; sbi -> s_mount_state = le16_to_cpu ( es -> s_state ) ; sbi -> s_addr_per_block_bits = ilog2 ( EXT4_ADDR_PER_BLOCK ( sb ) ) ; sbi -> s_desc_per_block_bits = ilog2 ( EXT4_DESC_PER_BLOCK ( sb ) ) ; for ( i = 0 ; i < 4 ; i ++ ) sbi -> s_hash_seed [ i ] = le32_to_cpu ( es -> s_hash_seed [ i ] ) ; sbi -> s_def_hash_version = es -> s_def_hash_version ; if ( ext4_has_feature_dir_index ( sb ) ) { i = le32_to_cpu ( es -> s_flags ) ; if ( i & EXT2_FLAGS_UNSIGNED_HASH ) sbi -> s_hash_unsigned = 3 ; else if ( ( i & EXT2_FLAGS_SIGNED_HASH ) == 0 ) { # ifdef __CHAR_UNSIGNED__ if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_UNSIGNED_HASH ) ; sbi -> s_hash_unsigned = 3 ; # else if ( ! ( sb -> s_flags & MS_RDONLY ) ) es -> s_flags |= cpu_to_le32 ( EXT2_FLAGS_SIGNED_HASH ) ; # endif } } clustersize = BLOCK_SIZE << le32_to_cpu ( es -> s_log_cluster_size ) ; has_bigalloc = ext4_has_feature_bigalloc ( sb ) ; if ( has_bigalloc ) { if ( clustersize < blocksize ) { ext4_msg ( sb , KERN_ERR , ""cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>smaller<S2SV_blank>than<S2SV_blank>"" ""block<S2SV_blank>size<S2SV_blank>(%d)"" , clustersize , blocksize ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_log_cluster_size ) > ( EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Invalid<S2SV_blank>log<S2SV_blank>cluster<S2SV_blank>size:<S2SV_blank>%u"" , le32_to_cpu ( es -> s_log_cluster_size ) ) ; goto failed_mount ; } sbi -> s_cluster_bits = le32_to_cpu ( es -> s_log_cluster_size ) - le32_to_cpu ( es -> s_log_block_size ) ; sbi -> s_clusters_per_group = le32_to_cpu ( es -> s_clusters_per_group ) ; if ( sbi -> s_clusters_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_clusters_per_group ) ; goto failed_mount ; } if ( sbi -> s_blocks_per_group != ( sbi -> s_clusters_per_group * ( clustersize / blocksize ) ) ) { ext4_msg ( sb , KERN_ERR , ""blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>and<S2SV_blank>"" ""clusters<S2SV_blank>per<S2SV_blank>group<S2SV_blank>(%lu)<S2SV_blank>inconsistent"" , sbi -> s_blocks_per_group , sbi -> s_clusters_per_group ) ; goto failed_mount ; } } else { if ( clustersize != blocksize ) { ext4_warning ( sb , ""fragment/cluster<S2SV_blank>size<S2SV_blank>(%d)<S2SV_blank>!=<S2SV_blank>"" ""block<S2SV_blank>size<S2SV_blank>(%d)"" , clustersize , blocksize ) ; clustersize = blocksize ; } if ( sbi -> s_blocks_per_group > blocksize * 8 ) { ext4_msg ( sb , KERN_ERR , ""#blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%lu"" , sbi -> s_blocks_per_group ) ; goto failed_mount ; } sbi -> s_clusters_per_group = sbi -> s_blocks_per_group ; sbi -> s_cluster_bits = 0 ; } sbi -> s_cluster_ratio = clustersize / blocksize ; if ( sbi -> s_blocks_per_group == clustersize << 3 ) set_opt2 ( sb , STD_GROUP_SIZE ) ; err = generic_check_addressable ( sb -> s_blocksize_bits , ext4_blocks_count ( es ) ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""filesystem"" ""<S2SV_blank>too<S2SV_blank>large<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>safely<S2SV_blank>on<S2SV_blank>this<S2SV_blank>system"" ) ; if ( sizeof ( sector_t ) < 8 ) ext4_msg ( sb , KERN_WARNING , ""CONFIG_LBDAF<S2SV_blank>not<S2SV_blank>enabled"" ) ; goto failed_mount ; } if ( EXT4_BLOCKS_PER_GROUP ( sb ) == 0 ) goto cantfind_ext4 ; blocks_count = sb -> s_bdev -> bd_inode -> i_size >> sb -> s_blocksize_bits ; if ( blocks_count && ext4_blocks_count ( es ) > blocks_count ) { ext4_msg ( sb , KERN_WARNING , ""bad<S2SV_blank>geometry:<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%llu<S2SV_blank>"" ""exceeds<S2SV_blank>size<S2SV_blank>of<S2SV_blank>device<S2SV_blank>(%llu<S2SV_blank>blocks)"" , ext4_blocks_count ( es ) , blocks_count ) ; goto failed_mount ; } if ( le32_to_cpu ( es -> s_first_data_block ) >= ext4_blocks_count ( es ) ) { ext4_msg ( sb , KERN_WARNING , ""bad<S2SV_blank>geometry:<S2SV_blank>first<S2SV_blank>data<S2SV_blank>"" ""block<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>beyond<S2SV_blank>end<S2SV_blank>of<S2SV_blank>filesystem<S2SV_blank>(%llu)"" , le32_to_cpu ( es -> s_first_data_block ) , ext4_blocks_count ( es ) ) ; goto failed_mount ; } blocks_count = ( ext4_blocks_count ( es ) - le32_to_cpu ( es -> s_first_data_block ) + EXT4_BLOCKS_PER_GROUP ( sb ) - 1 ) ; do_div ( blocks_count , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; if ( blocks_count > ( ( uint64_t ) 1 << 32 ) - EXT4_DESC_PER_BLOCK ( sb ) ) { ext4_msg ( sb , KERN_WARNING , ""groups<S2SV_blank>count<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(block<S2SV_blank>count<S2SV_blank>%llu,<S2SV_blank>first<S2SV_blank>data<S2SV_blank>block<S2SV_blank>%u,<S2SV_blank>"" ""blocks<S2SV_blank>per<S2SV_blank>group<S2SV_blank>%lu)"" , sbi -> s_groups_count , ext4_blocks_count ( es ) , le32_to_cpu ( es -> s_first_data_block ) , EXT4_BLOCKS_PER_GROUP ( sb ) ) ; goto failed_mount ; } sbi -> s_groups_count = blocks_count ; sbi -> s_blockfile_groups = min_t ( ext4_group_t , sbi -> s_groups_count , ( EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP ( sb ) ) ) ; db_count = ( sbi -> s_groups_count + EXT4_DESC_PER_BLOCK ( sb ) - 1 ) / <S2SV_StartBug> EXT4_DESC_PER_BLOCK ( sb ) ; <S2SV_EndBug> sbi -> s_group_desc = ext4_kvmalloc ( db_count * sizeof ( struct buffer_head * ) , GFP_KERNEL ) ; if ( sbi -> s_group_desc == NULL ) { ext4_msg ( sb , KERN_ERR , ""not<S2SV_blank>enough<S2SV_blank>memory"" ) ; ret = - ENOMEM ; goto failed_mount ; } bgl_lock_init ( sbi -> s_blockgroup_lock ) ; for ( i = 0 ; i < db_count ; i ++ ) { block = descriptor_loc ( sb , logical_sb_block , i ) ; sbi -> s_group_desc [ i ] = sb_bread_unmovable ( sb , block ) ; if ( ! sbi -> s_group_desc [ i ] ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>read<S2SV_blank>group<S2SV_blank>descriptor<S2SV_blank>%d"" , i ) ; db_count = i ; goto failed_mount2 ; } } if ( ! ext4_check_descriptors ( sb , logical_sb_block , & first_not_zeroed ) ) { ext4_msg ( sb , KERN_ERR , ""group<S2SV_blank>descriptors<S2SV_blank>corrupted!"" ) ; ret = - EFSCORRUPTED ; goto failed_mount2 ; } sbi -> s_gdb_count = db_count ; get_random_bytes ( & sbi -> s_next_generation , sizeof ( u32 ) ) ; spin_lock_init ( & sbi -> s_next_gen_lock ) ; setup_timer ( & sbi -> s_err_report , print_daily_error_info , ( unsigned long ) sb ) ; if ( ext4_es_register_shrinker ( sbi ) ) goto failed_mount3 ; sbi -> s_stripe = ext4_get_stripe_size ( sbi ) ; sbi -> s_extent_max_zeroout_kb = 32 ; sb -> s_op = & ext4_sops ; sb -> s_export_op = & ext4_export_ops ; sb -> s_xattr = ext4_xattr_handlers ; sb -> s_cop = & ext4_cryptops ; # ifdef CONFIG_QUOTA sb -> dq_op = & ext4_quota_operations ; if ( ext4_has_feature_quota ( sb ) ) sb -> s_qcop = & dquot_quotactl_sysfile_ops ; else sb -> s_qcop = & ext4_qctl_operations ; sb -> s_quota_types = QTYPE_MASK_USR | QTYPE_MASK_GRP | QTYPE_MASK_PRJ ; # endif memcpy ( sb -> s_uuid , es -> s_uuid , sizeof ( es -> s_uuid ) ) ; INIT_LIST_HEAD ( & sbi -> s_orphan ) ; mutex_init ( & sbi -> s_orphan_lock ) ; sb -> s_root = NULL ; needs_recovery = ( es -> s_last_orphan != 0 || ext4_has_feature_journal_needs_recovery ( sb ) ) ; if ( ext4_has_feature_mmp ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) if ( ext4_multi_mount_protect ( sb , le64_to_cpu ( es -> s_mmp_block ) ) ) goto failed_mount3a ; if ( ! test_opt ( sb , NOLOAD ) && ext4_has_feature_journal ( sb ) ) { if ( ext4_load_journal ( sb , es , journal_devnum ) ) goto failed_mount3a ; } else if ( test_opt ( sb , NOLOAD ) && ! ( sb -> s_flags & MS_RDONLY ) && ext4_has_feature_journal_needs_recovery ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""required<S2SV_blank>journal<S2SV_blank>recovery<S2SV_blank>"" ""suppressed<S2SV_blank>and<S2SV_blank>not<S2SV_blank>mounted<S2SV_blank>read-only"" ) ; goto failed_mount_wq ; } else { if ( test_opt2 ( sb , EXPLICIT_JOURNAL_CHECKSUM ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""journal_checksum,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } if ( test_opt ( sb , JOURNAL_ASYNC_COMMIT ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""journal_async_commit,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } if ( sbi -> s_commit_interval != JBD2_DEFAULT_MAX_COMMIT_AGE * HZ ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""commit=%lu,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" , sbi -> s_commit_interval / HZ ) ; goto failed_mount_wq ; } if ( EXT4_MOUNT_DATA_FLAGS & ( sbi -> s_mount_opt ^ sbi -> s_def_mount_opt ) ) { ext4_msg ( sb , KERN_ERR , ""can\'t<S2SV_blank>mount<S2SV_blank>with<S2SV_blank>"" ""data=,<S2SV_blank>fs<S2SV_blank>mounted<S2SV_blank>w/o<S2SV_blank>journal"" ) ; goto failed_mount_wq ; } sbi -> s_def_mount_opt &= EXT4_MOUNT_JOURNAL_CHECKSUM ; clear_opt ( sb , JOURNAL_CHECKSUM ) ; clear_opt ( sb , DATA_FLAGS ) ; sbi -> s_journal = NULL ; needs_recovery = 0 ; goto no_journal ; } if ( ext4_has_feature_64bit ( sb ) && ! jbd2_journal_set_features ( EXT4_SB ( sb ) -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_64BIT ) ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>64-bit<S2SV_blank>journal<S2SV_blank>feature"" ) ; goto failed_mount_wq ; } if ( ! set_journal_csum_feature_set ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>journal<S2SV_blank>checksum<S2SV_blank>"" ""feature<S2SV_blank>set"" ) ; goto failed_mount_wq ; } switch ( test_opt ( sb , DATA_FLAGS ) ) { case 0 : if ( jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) set_opt ( sb , ORDERED_DATA ) ; else set_opt ( sb , JOURNAL_DATA ) ; break ; case EXT4_MOUNT_ORDERED_DATA : case EXT4_MOUNT_WRITEBACK_DATA : if ( ! jbd2_journal_check_available_features ( sbi -> s_journal , 0 , 0 , JBD2_FEATURE_INCOMPAT_REVOKE ) ) { ext4_msg ( sb , KERN_ERR , ""Journal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>"" ""requested<S2SV_blank>data<S2SV_blank>journaling<S2SV_blank>mode"" ) ; goto failed_mount_wq ; } default : break ; } set_task_ioprio ( sbi -> s_journal -> j_task , journal_ioprio ) ; sbi -> s_journal -> j_commit_callback = ext4_journal_commit_callback ; no_journal : sbi -> s_mb_cache = ext4_xattr_create_cache ( ) ; if ( ! sbi -> s_mb_cache ) { ext4_msg ( sb , KERN_ERR , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>an<S2SV_blank>mb_cache"" ) ; goto failed_mount_wq ; } if ( ( DUMMY_ENCRYPTION_ENABLED ( sbi ) || ext4_has_feature_encrypt ( sb ) ) && ( blocksize != PAGE_SIZE ) ) { ext4_msg ( sb , KERN_ERR , ""Unsupported<S2SV_blank>blocksize<S2SV_blank>for<S2SV_blank>fs<S2SV_blank>encryption"" ) ; goto failed_mount_wq ; } if ( DUMMY_ENCRYPTION_ENABLED ( sbi ) && ! ( sb -> s_flags & MS_RDONLY ) && ! ext4_has_feature_encrypt ( sb ) ) { ext4_set_feature_encrypt ( sb ) ; ext4_commit_super ( sb , 1 ) ; } if ( es -> s_overhead_clusters ) sbi -> s_overhead = le32_to_cpu ( es -> s_overhead_clusters ) ; else { err = ext4_calculate_overhead ( sb ) ; if ( err ) goto failed_mount_wq ; } EXT4_SB ( sb ) -> rsv_conversion_wq = alloc_workqueue ( ""ext4-rsv-conversion"" , WQ_MEM_RECLAIM | WQ_UNBOUND , 1 ) ; if ( ! EXT4_SB ( sb ) -> rsv_conversion_wq ) { printk ( KERN_ERR ""EXT4-fs:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>workqueue\\n"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } root = ext4_iget ( sb , EXT4_ROOT_INO ) ; if ( IS_ERR ( root ) ) { ext4_msg ( sb , KERN_ERR , ""get<S2SV_blank>root<S2SV_blank>inode<S2SV_blank>failed"" ) ; ret = PTR_ERR ( root ) ; root = NULL ; goto failed_mount4 ; } if ( ! S_ISDIR ( root -> i_mode ) || ! root -> i_blocks || ! root -> i_size ) { ext4_msg ( sb , KERN_ERR , ""corrupt<S2SV_blank>root<S2SV_blank>inode,<S2SV_blank>run<S2SV_blank>e2fsck"" ) ; iput ( root ) ; goto failed_mount4 ; } sb -> s_root = d_make_root ( root ) ; if ( ! sb -> s_root ) { ext4_msg ( sb , KERN_ERR , ""get<S2SV_blank>root<S2SV_blank>dentry<S2SV_blank>failed"" ) ; ret = - ENOMEM ; goto failed_mount4 ; } if ( ext4_setup_super ( sb , es , sb -> s_flags & MS_RDONLY ) ) sb -> s_flags |= MS_RDONLY ; if ( sbi -> s_inode_size > EXT4_GOOD_OLD_INODE_SIZE ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; if ( ext4_has_feature_extra_isize ( sb ) ) { if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_want_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_want_extra_isize ) ; if ( sbi -> s_want_extra_isize < le16_to_cpu ( es -> s_min_extra_isize ) ) sbi -> s_want_extra_isize = le16_to_cpu ( es -> s_min_extra_isize ) ; } } if ( EXT4_GOOD_OLD_INODE_SIZE + sbi -> s_want_extra_isize > sbi -> s_inode_size ) { sbi -> s_want_extra_isize = sizeof ( struct ext4_inode ) - EXT4_GOOD_OLD_INODE_SIZE ; ext4_msg ( sb , KERN_INFO , ""required<S2SV_blank>extra<S2SV_blank>inode<S2SV_blank>space<S2SV_blank>not"" ""available"" ) ; } ext4_set_resv_clusters ( sb ) ; err = ext4_setup_system_zone ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>system<S2SV_blank>"" ""zone<S2SV_blank>(%d)"" , err ) ; goto failed_mount4a ; } ext4_ext_init ( sb ) ; err = ext4_mb_init ( sb ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>mballoc<S2SV_blank>(%d)"" , err ) ; goto failed_mount5 ; } block = ext4_count_free_clusters ( sb ) ; ext4_free_blocks_count_set ( sbi -> s_es , EXT4_C2B ( sbi , block ) ) ; err = percpu_counter_init ( & sbi -> s_freeclusters_counter , block , GFP_KERNEL ) ; if ( ! err ) { unsigned long freei = ext4_count_free_inodes ( sb ) ; sbi -> s_es -> s_free_inodes_count = cpu_to_le32 ( freei ) ; err = percpu_counter_init ( & sbi -> s_freeinodes_counter , freei , GFP_KERNEL ) ; } if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirs_counter , ext4_count_dirs ( sb ) , GFP_KERNEL ) ; if ( ! err ) err = percpu_counter_init ( & sbi -> s_dirtyclusters_counter , 0 , GFP_KERNEL ) ; if ( ! err ) err = percpu_init_rwsem ( & sbi -> s_journal_flag_rwsem ) ; if ( err ) { ext4_msg ( sb , KERN_ERR , ""insufficient<S2SV_blank>memory"" ) ; goto failed_mount6 ; } if ( ext4_has_feature_flex_bg ( sb ) ) if ( ! ext4_fill_flex_info ( sb ) ) { ext4_msg ( sb , KERN_ERR , ""unable<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>"" ""flex_bg<S2SV_blank>meta<S2SV_blank>info!"" ) ; goto failed_mount6 ; } err = ext4_register_li_request ( sb , first_not_zeroed ) ; if ( err ) goto failed_mount6 ; err = ext4_register_sysfs ( sb ) ; if ( err ) goto failed_mount7 ; # ifdef CONFIG_QUOTA if ( ext4_has_feature_quota ( sb ) && ! ( sb -> s_flags & MS_RDONLY ) ) { err = ext4_enable_quotas ( sb ) ; if ( err ) goto failed_mount8 ; } # endif EXT4_SB ( sb ) -> s_mount_state |= EXT4_ORPHAN_FS ; ext4_orphan_cleanup ( sb , es ) ; EXT4_SB ( sb ) -> s_mount_state &= ~ EXT4_ORPHAN_FS ; if ( needs_recovery ) { ext4_msg ( sb , KERN_INFO , ""recovery<S2SV_blank>complete"" ) ; ext4_mark_recovery_complete ( sb , es ) ; } if ( EXT4_SB ( sb ) -> s_journal ) { if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_JOURNAL_DATA ) descr = ""<S2SV_blank>journalled<S2SV_blank>data<S2SV_blank>mode"" ; else if ( test_opt ( sb , DATA_FLAGS ) == EXT4_MOUNT_ORDERED_DATA ) descr = ""<S2SV_blank>ordered<S2SV_blank>data<S2SV_blank>mode"" ; else descr = ""<S2SV_blank>writeback<S2SV_blank>data<S2SV_blank>mode"" ; } else descr = ""out<S2SV_blank>journal"" ; if ( test_opt ( sb , DISCARD ) ) { struct request_queue * q = bdev_get_queue ( sb -> s_bdev ) ; if ( ! blk_queue_discard ( q ) ) ext4_msg ( sb , KERN_WARNING , ""mounting<S2SV_blank>with<S2SV_blank>\\""discard\\""<S2SV_blank>option,<S2SV_blank>but<S2SV_blank>"" ""the<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>discard"" ) ; } if ( ___ratelimit ( & ext4_mount_msg_ratelimit , ""EXT4-fs<S2SV_blank>mount"" ) ) ext4_msg ( sb , KERN_INFO , ""mounted<S2SV_blank>filesystem<S2SV_blank>with%s.<S2SV_blank>"" ""Opts:<S2SV_blank>%.*s%s%s"" , descr , ( int ) sizeof ( sbi -> s_es -> s_mount_opts ) , sbi -> s_es -> s_mount_opts , * sbi -> s_es -> s_mount_opts ? "";<S2SV_blank>"" : """" , orig_data ) ; if ( es -> s_error_count ) mod_timer ( & sbi -> s_err_report , jiffies + 300 * HZ ) ; ratelimit_state_init ( & sbi -> s_err_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_warning_ratelimit_state , 5 * HZ , 10 ) ; ratelimit_state_init ( & sbi -> s_msg_ratelimit_state , 5 * HZ , 10 ) ; kfree ( orig_data ) ; # ifdef CONFIG_EXT4_FS_ENCRYPTION memcpy ( sbi -> key_prefix , EXT4_KEY_DESC_PREFIX , EXT4_KEY_DESC_PREFIX_SIZE ) ; sbi -> key_prefix_size = EXT4_KEY_DESC_PREFIX_SIZE ; # endif return 0 ; cantfind_ext4 : if ( ! silent ) ext4_msg ( sb , KERN_ERR , ""VFS:<S2SV_blank>Can\'t<S2SV_blank>find<S2SV_blank>ext4<S2SV_blank>filesystem"" ) ; goto failed_mount ; # ifdef CONFIG_QUOTA failed_mount8 : ext4_unregister_sysfs ( sb ) ; # endif failed_mount7 : ext4_unregister_li_request ( sb ) ; failed_mount6 : ext4_mb_release ( sb ) ; if ( sbi -> s_flex_groups ) kvfree ( sbi -> s_flex_groups ) ; percpu_counter_destroy ( & sbi -> s_freeclusters_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; percpu_counter_destroy ( & sbi -> s_dirtyclusters_counter ) ; failed_mount5 : ext4_ext_release ( sb ) ; ext4_release_system_zone ( sb ) ; failed_mount4a : dput ( sb -> s_root ) ; sb -> s_root = NULL ; failed_mount4 : ext4_msg ( sb , KERN_ERR , ""mount<S2SV_blank>failed"" ) ; if ( EXT4_SB ( sb ) -> rsv_conversion_wq ) destroy_workqueue ( EXT4_SB ( sb ) -> rsv_conversion_wq ) ; failed_mount_wq : if ( sbi -> s_mb_cache ) { ext4_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( sbi -> s_journal ) { jbd2_journal_destroy ( sbi -> s_journal ) ; sbi -> s_journal = NULL ; } failed_mount3a : ext4_es_unregister_shrinker ( sbi ) ; failed_mount3 : del_timer_sync ( & sbi -> s_err_report ) ; if ( sbi -> s_mmp_tsk ) kthread_stop ( sbi -> s_mmp_tsk ) ; failed_mount2 : for ( i = 0 ; i < db_count ; i ++ ) brelse ( sbi -> s_group_desc [ i ] ) ; kvfree ( sbi -> s_group_desc ) ; failed_mount : if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < EXT4_MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif ext4_blkdev_remove ( sbi ) ; brelse ( bh ) ; out_fail : sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; out_free_base : kfree ( sbi ) ; kfree ( orig_data ) ; return err ? err : ret ; }
","<S2SV_ModStart> sb ) ; if ( ext4_has_feature_meta_bg ( sb ) ) { if ( le32_to_cpu ( es -> s_first_meta_bg ) >= db_count ) { ext4_msg ( sb , KERN_WARNING , ""first<S2SV_blank>meta<S2SV_blank>block<S2SV_blank>group<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%u<S2SV_blank>"" ""(group<S2SV_blank>descriptor<S2SV_blank>block<S2SV_blank>count<S2SV_blank>%u)"" , le32_to_cpu ( es -> s_first_meta_bg ) , db_count ) ; goto failed_mount ; } }
",torvalds@linux/3a4b77cd47bb837b8557595ec7425f281f2ca1fe,CVE-2016-10208,https://github.com/torvalds/linux/commit/3a4b77cd47bb837b8557595ec7425f281f2ca1fe,2017-02-06T06:59Z
CWE-362,"CWE-362 static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
","<S2SV_ModStart> -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock
",torvalds@linux/04f5866e41fb70690e28397487d8bd8eea7d712a,CVE-2019-11599,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,2019-04-29T18:29Z
CWE-119,"CWE-119 vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) { <S2SV_StartBug> SvcInternal * const si = get_svc_internal ( svc_ctx ) ; <S2SV_EndBug> if ( svc_ctx == NULL || options == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } strncpy ( si -> options , options , sizeof ( si -> options ) ) ; si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> options ) { SvcInternal_t <S2SV_ModEnd> * const si
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 error_t getHostByName ( NetInterface * interface , const char_t * name , IpAddr * ipAddr , uint_t flags ) { error_t error ; HostType type ; HostnameResolver protocol ; # if ( IPV4_SUPPORT == ENABLED ) type = HOST_TYPE_IPV4 ; # elif ( IPV6_SUPPORT == ENABLED ) type = HOST_TYPE_IPV6 ; # else type = HOST_TYPE_ANY ; # endif # if ( DNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_DNS ; # elif ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # elif ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # elif ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # else protocol = HOST_NAME_RESOLVER_ANY ; # endif if ( name == NULL || ipAddr == NULL ) return ERROR_INVALID_PARAMETER ; if ( interface == NULL ) interface = netGetDefaultInterface ( ) ; error = ipStringToAddr ( name , ipAddr ) ; if ( error ) { if ( flags & HOST_TYPE_IPV4 ) type = HOST_TYPE_IPV4 ; else if ( flags & HOST_TYPE_IPV6 ) type = HOST_TYPE_IPV6 ; if ( flags & HOST_NAME_RESOLVER_DNS ) { protocol = HOST_NAME_RESOLVER_DNS ; } else if ( flags & HOST_NAME_RESOLVER_MDNS ) { protocol = HOST_NAME_RESOLVER_MDNS ; } else if ( flags & HOST_NAME_RESOLVER_NBNS ) { protocol = HOST_NAME_RESOLVER_NBNS ; } else if ( flags & HOST_NAME_RESOLVER_LLMNR ) { protocol = HOST_NAME_RESOLVER_LLMNR ; } else { size_t n = osStrlen ( name ) ; if ( n >= 6 && ! osStrcasecmp ( name + n - 6 , "".local"" ) ) { # if ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # endif } <S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> { # if ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # endif } <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> { # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # endif } } # if ( DNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_DNS ) { error = dnsResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( MDNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_MDNS ) { error = mdnsClientResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_NBNS ) { error = nbnsResolve ( interface , name , ipAddr ) ; } else # endif # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_LLMNR ) { error = llmnrResolve ( interface , name , type , ipAddr ) ; } else # endif { error = ERROR_INVALID_PARAMETER ; } } return error ; }
","<S2SV_ModStart> 15 && ! osStrchr <S2SV_ModEnd> ( name , <S2SV_ModStart> if ( ! osStrchr <S2SV_ModEnd> ( name ,
",Oryx-Embedded@CycloneTCP/de5336016edbe1e90327d0ed1cba5c4e49114366,CVE-2021-26788,https://github.com/Oryx-Embedded/CycloneTCP/commit/de5336016edbe1e90327d0ed1cba5c4e49114366,2021-03-08T13:15Z
CWE-134,"CWE-134 static rsRetVal createSocket ( instanceConf_t * info , void * * sock ) { int rv ; sublist * sub ; * sock = zsocket_new ( s_context , info -> type ) ; if ( ! sock ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zsocket_new<S2SV_blank>failed:<S2SV_blank>%s,<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%d"" , zmq_strerror ( errno ) , info -> type ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>socket<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>created<S2SV_blank>successfully\\n"" , info -> type ) if ( info -> identity ) zsocket_set_identity ( * sock , info -> identity ) ; if ( info -> sndBuf > - 1 ) zsocket_set_sndbuf ( * sock , info -> sndBuf ) ; if ( info -> rcvBuf > - 1 ) zsocket_set_rcvbuf ( * sock , info -> rcvBuf ) ; if ( info -> linger > - 1 ) zsocket_set_linger ( * sock , info -> linger ) ; if ( info -> backlog > - 1 ) zsocket_set_backlog ( * sock , info -> backlog ) ; if ( info -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( * sock , info -> sndTimeout ) ; if ( info -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( * sock , info -> rcvTimeout ) ; if ( info -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( * sock , info -> maxMsgSize ) ; if ( info -> rate > - 1 ) zsocket_set_rate ( * sock , info -> rate ) ; if ( info -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( * sock , info -> recoveryIVL ) ; if ( info -> multicastHops > - 1 ) zsocket_set_multicast_hops ( * sock , info -> multicastHops ) ; if ( info -> reconnectIVL > - 1 ) zsocket_set_reconnect_ivl ( * sock , info -> reconnectIVL ) ; if ( info -> reconnectIVLMax > - 1 ) zsocket_set_reconnect_ivl_max ( * sock , info -> reconnectIVLMax ) ; if ( info -> ipv4Only > - 1 ) zsocket_set_ipv4only ( * sock , info -> ipv4Only ) ; if ( info -> affinity > - 1 ) zsocket_set_affinity ( * sock , info -> affinity ) ; if ( info -> sndHWM > - 1 ) zsocket_set_sndhwm ( * sock , info -> sndHWM ) ; if ( info -> rcvHWM > - 1 ) zsocket_set_rcvhwm ( * sock , info -> rcvHWM ) ; if ( info -> type == ZMQ_SUB ) { for ( sub = info -> subscriptions ; sub != NULL ; sub = sub -> next ) { zsocket_set_subscribe ( * sock , sub -> subscribe ) ; } } if ( info -> action == ACTION_CONNECT ) { <S2SV_StartBug> rv = zsocket_connect ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_connect<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>connect<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } else { <S2SV_StartBug> rv = zsocket_bind ( * sock , info -> description ) ; <S2SV_EndBug> if ( rv == - 1 ) { errmsg . LogError ( 0 , RS_RET_INVALID_PARAMS , ""zmq_bind<S2SV_blank>using<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%s"" , info -> description , zmq_strerror ( errno ) ) ; return RS_RET_INVALID_PARAMS ; } DBGPRINTF ( ""imzmq3:<S2SV_blank>bind<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>successful\\n"" , info -> description ) ; } return RS_RET_OK ; }
","<S2SV_ModStart> * sock , ""%s"" , <S2SV_ModStart> * sock , ""%s"" ,
",rsyslog@rsyslog/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,CVE-2017-12588,https://github.com/rsyslog/rsyslog/commit/062d0c671a29f7c6f7dff4a2f1f35df375bbb30b,2017-08-06T14:29Z
CWE-190,"CWE-190 static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; <S2SV_StartBug> uint16 strip , nstrips = TIFFNumberOfStrips ( in ) ; <S2SV_EndBug> uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }
","<S2SV_ModStart> = 0 ; uint32 <S2SV_ModEnd> strip , nstrips
",vadz@libtiff/43c0b81a818640429317c80fea1e66771e85024b,CVE-2016-9538,https://github.com/vadz/libtiff/commit/43c0b81a818640429317c80fea1e66771e85024b,2016-11-22T19:59Z
CWE-399,"CWE-399 long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( ""EINVAL:<S2SV_blank>io_submit:<S2SV_blank>invalid<S2SV_blank>context<S2SV_blank>id\\n"" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ; <S2SV_StartBug> kiocb_batch_free ( & batch ) ; <S2SV_EndBug> put_ioctx ( ctx ) ; return i ? i : ret ; }
","<S2SV_ModStart> ; kiocb_batch_free ( ctx ,
",torvalds@linux/802f43594d6e4d2ac61086d239153c17873a0428,CVE-2012-0058,https://github.com/torvalds/linux/commit/802f43594d6e4d2ac61086d239153c17873a0428,2012-05-17T11:00Z
CWE-476,"CWE-476 static long btrfs_ioctl_dev_info ( struct btrfs_fs_info * fs_info , void __user * arg ) { struct btrfs_ioctl_dev_info_args * di_args ; struct btrfs_device * dev ; int ret = 0 ; char * s_uuid = NULL ; di_args = memdup_user ( arg , sizeof ( * di_args ) ) ; if ( IS_ERR ( di_args ) ) return PTR_ERR ( di_args ) ; if ( ! btrfs_is_empty_uuid ( di_args -> uuid ) ) s_uuid = di_args -> uuid ; rcu_read_lock ( ) ; dev = btrfs_find_device ( fs_info -> fs_devices , di_args -> devid , s_uuid , <S2SV_StartBug> NULL ) ; <S2SV_EndBug> if ( ! dev ) { ret = - ENODEV ; goto out ; } di_args -> devid = dev -> devid ; di_args -> bytes_used = btrfs_device_get_bytes_used ( dev ) ; di_args -> total_bytes = btrfs_device_get_total_bytes ( dev ) ; memcpy ( di_args -> uuid , dev -> uuid , sizeof ( di_args -> uuid ) ) ; if ( dev -> name ) { strncpy ( di_args -> path , rcu_str_deref ( dev -> name ) , sizeof ( di_args -> path ) - 1 ) ; di_args -> path [ sizeof ( di_args -> path ) - 1 ] = 0 ; } else { di_args -> path [ 0 ] = '\\0' ; } out : rcu_read_unlock ( ) ; if ( ret == 0 && copy_to_user ( arg , di_args , sizeof ( * di_args ) ) ) ret = - EFAULT ; kfree ( di_args ) ; return ret ; }
","<S2SV_ModStart> s_uuid , NULL , true
",torvalds@linux/09ba3bc9dd150457c506e4661380a6183af651c1,CVE-2019-18885,https://github.com/torvalds/linux/commit/09ba3bc9dd150457c506e4661380a6183af651c1,2019-11-14T14:15Z
CWE-17,"CWE-17 static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; <S2SV_StartBug> flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT | <S2SV_EndBug> EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ; <S2SV_StartBug> if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_EndBug> flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; <S2SV_StartBug> mutex_lock ( & inode -> i_mutex ) ; <S2SV_EndBug> if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; if ( partial_end ) max_blocks += 1 ; } <S2SV_StartBug> if ( max_blocks > 0 ) { <S2SV_EndBug> truncate_pagecache_range ( inode , start , end - 1 ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , flags , mode ) ; if ( ret ) goto out_dio ; ret = ext4_es_remove_extent ( inode , 0 , EXT_MAX_BLOCKS ) ; if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }
","<S2SV_ModStart> -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! <S2SV_ModEnd> ( mode & <S2SV_ModStart> & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) <S2SV_ModStart> |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex <S2SV_ModEnd> ; } if <S2SV_ModStart> 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ;
",torvalds@linux/0f2af21aae11972fa924374ddcf52e88347cf5a8,CVE-2015-0275,https://github.com/torvalds/linux/commit/0f2af21aae11972fa924374ddcf52e88347cf5a8,2015-10-19T10:59Z
CWE-264,"CWE-264 void vlan_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags |= IFF_802_1Q_VLAN ; <S2SV_StartBug> dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> dev -> tx_queue_len = 0 ; dev -> netdev_ops = & vlan_netdev_ops ; dev -> destructor = free_netdev ; dev -> ethtool_ops = & vlan_ethtool_ops ; memset ( dev -> broadcast , 0 , ETH_ALEN ) ; }
","<S2SV_ModStart> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; dev ->
",torvalds@linux/550fd08c2cebad61c548def135f67aba284c6162,CVE-2011-4112,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,2012-05-17T11:00Z
CWE-399,"CWE-399 int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; <S2SV_StartBug> if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""remove<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>from<S2SV_blank>orphan<S2SV_blank>list\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%u\\n"" , i_prev -> i_ino , ino_next ) ; err = ext4_reserve_inode_write ( handle , i_prev , & iloc2 ) ; if ( err ) goto out_brelse ; NEXT_ORPHAN ( i_prev ) = ino_next ; err = ext4_mark_iloc_dirty ( handle , i_prev , & iloc2 ) ; } if ( err ) goto out_brelse ; NEXT_ORPHAN ( inode ) = 0 ; err = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; out_err : ext4_std_error ( inode -> i_sb , err ) ; out : mutex_unlock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; return err ; out_brelse : brelse ( iloc . bh ) ; goto out_err ; }
","<S2SV_ModStart> ; if ( ( <S2SV_ModStart> ) -> s_journal ) && ! ( EXT4_SB ( inode -> i_sb ) -> s_mount_state & EXT4_ORPHAN_FS )
",torvalds@linux/0e9a9a1ad619e7e987815d20262d36a2f95717ca,CVE-2013-2015,https://github.com/torvalds/linux/commit/0e9a9a1ad619e7e987815d20262d36a2f95717ca,2013-04-29T14:55Z
CWE-200,"CWE-200 static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; <S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }
","<S2SV_ModStart> goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
",torvalds@linux/ba3021b2c79b2fa9114f92790a99deb27a65b728,CVE-2017-1000380,https://github.com/torvalds/linux/commit/ba3021b2c79b2fa9114f92790a99deb27a65b728,2017-06-17T18:29Z
CWE-20,"CWE-20 void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) { <S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } }
","<S2SV_ModStart> 0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
",monkey@monkey/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,CVE-2014-5336,https://github.com/monkey/monkey/commit/b2d0e6f92310bb14a15aa2f8e96e1fb5379776dd,2014-08-26T14:55Z
CWE-200,"CWE-200 void * vips_tracked_malloc ( size_t size ) { void * buf ; vips_tracked_init ( ) ; size += 16 ; <S2SV_StartBug> if ( ! ( buf = g_try_malloc ( size ) ) ) { <S2SV_EndBug> # ifdef DEBUG g_assert_not_reached ( ) ; # endif vips_error ( ""vips_tracked"" , _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; g_warning ( _ ( ""out<S2SV_blank>of<S2SV_blank>memory<S2SV_blank>---<S2SV_blank>size<S2SV_blank>==<S2SV_blank>%dMB"" ) , ( int ) ( size / ( 1024.0 * 1024.0 ) ) ) ; return ( NULL ) ; } g_mutex_lock ( vips_tracked_mutex ) ; * ( ( size_t * ) buf ) = size ; buf = ( void * ) ( ( char * ) buf + 16 ) ; vips_tracked_mem += size ; if ( vips_tracked_mem > vips_tracked_mem_highwater ) vips_tracked_mem_highwater = vips_tracked_mem ; vips_tracked_allocs += 1 ; # ifdef DEBUG_VERBOSE printf ( ""vips_tracked_malloc:<S2SV_blank>%p,<S2SV_blank>%zd<S2SV_blank>bytes\\n"" , buf , size ) ; # endif g_mutex_unlock ( vips_tracked_mutex ) ; VIPS_GATE_MALLOC ( size ) ; return ( buf ) ; }
","<S2SV_ModStart> ( buf = g_try_malloc0 <S2SV_ModEnd> ( size )
",libvips@libvips/00622428bda8d7521db8d74260b519fa41d69d0a,CVE-2019-6976,https://github.com/libvips/libvips/commit/00622428bda8d7521db8d74260b519fa41d69d0a,2019-01-26T23:29Z
CWE-20,"CWE-20 static int snd_timer_start_slave ( struct snd_timer_instance * timeri ) { unsigned long flags ; spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags |= SNDRV_TIMER_IFLG_RUNNING ; <S2SV_StartBug> if ( timeri -> master ) <S2SV_EndBug> list_add_tail ( & timeri -> active_list , & timeri -> master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irqrestore ( & slave_active_lock , flags ) ; <S2SV_EndBug> return 1 ; }
","<S2SV_ModStart> timeri -> master && timeri -> timer ) { spin_lock ( & timeri -> timer -> lock ) ; <S2SV_ModEnd> list_add_tail ( & <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & timeri -> timer -> lock ) ; }
",torvalds@linux/b5a663aa426f4884c71cd8580adae73f33570f0d,CVE-2016-2548,https://github.com/torvalds/linux/commit/b5a663aa426f4884c71cd8580adae73f33570f0d,2016-04-27T17:59Z
CWE-362,"CWE-362 static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
","<S2SV_ModStart> ; newinet -> inet_opt <S2SV_ModEnd> = NULL ;
",torvalds@linux/f6d8bd051c391c1c0458a30b2a7abcd939329259,CVE-2012-3552,https://github.com/torvalds/linux/commit/f6d8bd051c391c1c0458a30b2a7abcd939329259,2012-10-03T11:02Z
CWE-189,"CWE-189 void * chk_malloc ( size_t bytes ) { <S2SV_StartBug> char * buffer = ( char * ) dlmalloc ( bytes + CHK_OVERHEAD_SIZE ) ; <S2SV_EndBug> if ( buffer ) { memset ( buffer , CHK_SENTINEL_VALUE , bytes + CHK_OVERHEAD_SIZE ) ; size_t offset = dlmalloc_usable_size ( buffer ) - sizeof ( size_t ) ; * ( size_t * ) ( buffer + offset ) = bytes ; buffer += CHK_SENTINEL_HEAD_SIZE ; } return buffer ; }
","<S2SV_ModStart> bytes ) { size_t size = bytes + CHK_OVERHEAD_SIZE ; if ( size < bytes ) { return NULL ; } uint8_t <S2SV_ModEnd> * buffer = <S2SV_ModStart> buffer = ( uint8_t <S2SV_ModEnd> * ) dlmalloc <S2SV_ModStart> ) dlmalloc ( size <S2SV_ModEnd> ) ; if
",android@platform_bionic/7f5aa4f35e23fd37425b3a5041737cdf58f87385,CVE-2012-2674,https://github.com/android/platform_bionic/commit/7f5aa4f35e23fd37425b3a5041737cdf58f87385,2012-07-25T19:55Z
CWE-59,"CWE-59 int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } <S2SV_StartBug> { <S2SV_EndBug> char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } <S2SV_StartBug> } <S2SV_EndBug> dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
","<S2SV_ModStart> ) ; } # if 0 <S2SV_ModStart> ; } } # endif
",abrt@abrt/17cb66b13997b0159b4253b3f5722db79f476d68,CVE-2015-3315,https://github.com/abrt/abrt/commit/17cb66b13997b0159b4253b3f5722db79f476d68,2017-06-26T15:29Z
CWE-190,"CWE-190 void * <S2SV_StartBug> checked_xmalloc ( size_t size ) <S2SV_EndBug> { <S2SV_StartBug> alloc_limit_assert ( ""checked_xmalloc"" , size ) ; <S2SV_EndBug> <S2SV_StartBug> return xmalloc ( size ) ; <S2SV_EndBug> }
","<S2SV_ModStart> checked_xmalloc ( size_t num , size_t <S2SV_ModStart> size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; <S2SV_ModStart> ( ""checked_xmalloc"" , res <S2SV_ModEnd> ) ; return <S2SV_ModStart> return xmalloc ( num ,
",verdammelt@tnef/c5044689e50039635e7700fe2472fd632ac77176,CVE-2017-6308,https://github.com/verdammelt/tnef/commit/c5044689e50039635e7700fe2472fd632ac77176,2017-02-24T04:59Z
CWE-295,"CWE-295 <S2SV_StartBug> int bind_ports ( void ) { <S2SV_EndBug> SERVICE_OPTIONS * opt ; int listening_section ; # ifdef USE_LIBWRAP libwrap_init ( ) ; # endif s_poll_init ( fds , 1 ) ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { unsigned i ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) opt -> local_fd [ i ] = INVALID_SOCKET ; } listening_section = 0 ; for ( opt = service_options . next ; opt ; opt = opt -> next ) { opt -> bound_ports = 0 ; if ( opt -> local_addr . num ) { unsigned i ; s_log ( LOG_DEBUG , ""Binding<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) { SOCKET fd ; fd = bind_port ( opt , listening_section , i ) ; opt -> local_fd [ i ] = fd ; if ( fd != INVALID_SOCKET ) { s_poll_add ( fds , fd , 1 , 0 ) ; ++ opt -> bound_ports ; } } if ( ! opt -> bound_ports ) { s_log ( LOG_ERR , ""Binding<S2SV_blank>service<S2SV_blank>[%s]<S2SV_blank>failed"" , opt -> servname ) ; return 1 ; } ++ listening_section ; } else if ( opt -> exec_name && opt -> connect_addr . names ) { s_log ( LOG_DEBUG , ""Skipped<S2SV_blank>exec+connect<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; # ifndef OPENSSL_NO_TLSEXT } else if ( ! opt -> option . client && opt -> sni ) { s_log ( LOG_DEBUG , ""Skipped<S2SV_blank>SNI<S2SV_blank>slave<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; # endif } else { s_log ( LOG_ERR , ""Invalid<S2SV_blank>service<S2SV_blank>[%s]"" , opt -> servname ) ; return 1 ; } } if ( listening_section < systemd_fds ) { s_log ( LOG_ERR , ""Too<S2SV_blank>many<S2SV_blank>listening<S2SV_blank>file<S2SV_blank>descriptors<S2SV_blank>received<S2SV_blank>from<S2SV_blank>systemd,<S2SV_blank>got<S2SV_blank>%d"" , systemd_fds ) ; return 1 ; } return 0 ; }
","<S2SV_ModStart> <S2SV_null> <S2SV_null> <S2SV_null> NOEXPORT
",mtrojnar@stunnel/ebad9ddc4efb2635f37174c9d800d06206f1edf9,CVE-2021-20230,https://github.com/mtrojnar/stunnel/commit/ebad9ddc4efb2635f37174c9d800d06206f1edf9,2021-02-23T17:15Z
CWE-120,"CWE-120 static int complete_emulated_mmio ( struct kvm_vcpu * vcpu ) { struct kvm_run * run = vcpu -> run ; struct kvm_mmio_fragment * frag ; unsigned len ; BUG_ON ( ! vcpu -> mmio_needed ) ; frag = & vcpu -> mmio_fragments [ vcpu -> mmio_cur_fragment ] ; len = min ( 8u , frag -> len ) ; if ( ! vcpu -> mmio_is_write ) memcpy ( frag -> data , run -> mmio . data , len ) ; if ( frag -> len <= 8 ) { frag ++ ; vcpu -> mmio_cur_fragment ++ ; } else { frag -> data += len ; frag -> gpa += len ; frag -> len -= len ; } <S2SV_StartBug> if ( vcpu -> mmio_cur_fragment == vcpu -> mmio_nr_fragments ) { <S2SV_EndBug> vcpu -> mmio_needed = 0 ; if ( vcpu -> mmio_is_write ) return 1 ; vcpu -> mmio_read_completed = 1 ; return complete_emulated_io ( vcpu ) ; } run -> exit_reason = KVM_EXIT_MMIO ; run -> mmio . phys_addr = frag -> gpa ; if ( vcpu -> mmio_is_write ) memcpy ( run -> mmio . data , frag -> data , min ( 8u , frag -> len ) ) ; run -> mmio . len = min ( 8u , frag -> len ) ; run -> mmio . is_write = vcpu -> mmio_is_write ; vcpu -> arch . complete_userspace_io = complete_emulated_mmio ; return 0 ; }
","<S2SV_ModStart> vcpu -> mmio_cur_fragment >= <S2SV_ModEnd> vcpu -> mmio_nr_fragments
",torvalds@linux/a08d3b3b99efd509133946056531cdf8f3a0c09b,CVE-2014-0049,https://github.com/torvalds/linux/commit/a08d3b3b99efd509133946056531cdf8f3a0c09b,2014-03-11T13:01Z
CWE-772,"CWE-772 gprincs_ret * get_princs_2_svc ( gprincs_arg * arg , struct svc_req * rqstp ) { static gprincs_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprincs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> exp ; if ( prime_arg == NULL ) prime_arg = ""*"" ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_LIST , NULL , NULL ) ) { ret . code = KADM5_AUTH_LIST ; log_unauth ( ""kadm5_get_principals"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principals ( ( void * ) handle , arg -> exp , & ret . princs , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_principals"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-000,"CWE-000 static int nested_vmx_check_permission ( struct kvm_vcpu * vcpu ) <S2SV_StartBug> { <S2SV_EndBug> if ( ! to_vmx ( vcpu ) -> nested . vmxon ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; } return 1 ; }
","<S2SV_ModStart> vcpu ) { if ( vmx_get_cpl ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 0 ; }
",torvalds@linux/727ba748e110b4de50d142edca9d6a9b7e6111d8,CVE-2018-12904,https://github.com/torvalds/linux/commit/727ba748e110b4de50d142edca9d6a9b7e6111d8,2018-06-27T11:29Z
CWE-400,"CWE-400 static int add_ballooned_pages ( int nr_pages ) { enum bp_state st ; if ( xen_hotplug_unpopulated ) { st = reserve_additional_memory ( ) ; if ( st != BP_ECANCELED ) { mutex_unlock ( & balloon_mutex ) ; wait_event ( balloon_wq , ! list_empty ( & ballooned_pages ) ) ; mutex_lock ( & balloon_mutex ) ; return 0 ; } } <S2SV_StartBug> st = decrease_reservation ( nr_pages , GFP_USER ) ; <S2SV_EndBug> if ( st != BP_DONE ) return - ENOMEM ; return 0 ; }
","<S2SV_ModStart> ; } } if ( si_mem_available ( ) < nr_pages ) return - ENOMEM ;
",torvalds@linux/6ef36ab967c71690ebe7e5ef997a8be4da3bc844,CVE-2019-17351,https://github.com/torvalds/linux/commit/6ef36ab967c71690ebe7e5ef997a8be4da3bc844,2019-10-08T00:15Z
CWE-119,"CWE-119 static void update_reference_frames ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; YV12_BUFFER_CONFIG * yv12_fb = cm -> yv12_fb ; if ( cm -> frame_type == KEY_FRAME ) { yv12_fb [ cm -> new_fb_idx ] . flags |= VP8_GOLD_FRAME | VP8_ALTR_FRAME ; yv12_fb [ cm -> gld_fb_idx ] . flags &= ~ VP8_GOLD_FRAME ; yv12_fb [ cm -> alt_fb_idx ] . flags &= ~ VP8_ALTR_FRAME ; cm -> alt_fb_idx = cm -> gld_fb_idx = cm -> new_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ; cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ; <S2SV_StartBug> # endif <S2SV_EndBug> } else { if ( cm -> refresh_alt_ref_frame ) { assert ( ! cm -> copy_buffer_to_arf ) ; cm -> yv12_fb [ cm -> new_fb_idx ] . flags |= VP8_ALTR_FRAME ; cm -> yv12_fb [ cm -> alt_fb_idx ] . flags &= ~ VP8_ALTR_FRAME ; cm -> alt_fb_idx = cm -> new_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ ALTREF_FRAME ] = cm -> current_video_frame ; <S2SV_StartBug> # endif <S2SV_EndBug> } else if ( cm -> copy_buffer_to_arf ) { assert ( ! ( cm -> copy_buffer_to_arf & ~ 0x3 ) ) ; if ( cm -> copy_buffer_to_arf == 1 ) { if ( cm -> alt_fb_idx != cm -> lst_fb_idx ) { yv12_fb [ cm -> lst_fb_idx ] . flags |= VP8_ALTR_FRAME ; yv12_fb [ cm -> alt_fb_idx ] . flags &= ~ VP8_ALTR_FRAME ; cm -> alt_fb_idx = cm -> lst_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ; <S2SV_StartBug> # endif <S2SV_EndBug> } } else { if ( cm -> alt_fb_idx != cm -> gld_fb_idx ) { yv12_fb [ cm -> gld_fb_idx ] . flags |= VP8_ALTR_FRAME ; yv12_fb [ cm -> alt_fb_idx ] . flags &= ~ VP8_ALTR_FRAME ; cm -> alt_fb_idx = cm -> gld_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ ALTREF_FRAME ] = cpi -> current_ref_frames [ GOLDEN_FRAME ] ; <S2SV_StartBug> # endif <S2SV_EndBug> } } } if ( cm -> refresh_golden_frame ) { assert ( ! cm -> copy_buffer_to_gf ) ; cm -> yv12_fb [ cm -> new_fb_idx ] . flags |= VP8_GOLD_FRAME ; cm -> yv12_fb [ cm -> gld_fb_idx ] . flags &= ~ VP8_GOLD_FRAME ; cm -> gld_fb_idx = cm -> new_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cm -> current_video_frame ; <S2SV_StartBug> # endif <S2SV_EndBug> } else if ( cm -> copy_buffer_to_gf ) { assert ( ! ( cm -> copy_buffer_to_arf & ~ 0x3 ) ) ; if ( cm -> copy_buffer_to_gf == 1 ) { if ( cm -> gld_fb_idx != cm -> lst_fb_idx ) { yv12_fb [ cm -> lst_fb_idx ] . flags |= VP8_GOLD_FRAME ; yv12_fb [ cm -> gld_fb_idx ] . flags &= ~ VP8_GOLD_FRAME ; cm -> gld_fb_idx = cm -> lst_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ LAST_FRAME ] ; <S2SV_StartBug> # endif <S2SV_EndBug> } } else { if ( cm -> alt_fb_idx != cm -> gld_fb_idx ) { yv12_fb [ cm -> alt_fb_idx ] . flags |= VP8_GOLD_FRAME ; yv12_fb [ cm -> gld_fb_idx ] . flags &= ~ VP8_GOLD_FRAME ; cm -> gld_fb_idx = cm -> alt_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ GOLDEN_FRAME ] = cpi -> current_ref_frames [ ALTREF_FRAME ] ; <S2SV_StartBug> # endif <S2SV_EndBug> } } } } if ( cm -> refresh_last_frame ) { cm -> yv12_fb [ cm -> new_fb_idx ] . flags |= VP8_LAST_FRAME ; cm -> yv12_fb [ cm -> lst_fb_idx ] . flags &= ~ VP8_LAST_FRAME ; cm -> lst_fb_idx = cm -> new_fb_idx ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> cpi -> current_ref_frames [ LAST_FRAME ] = cm -> current_video_frame ; <S2SV_StartBug> # endif <S2SV_EndBug> } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { if ( cm -> frame_type == KEY_FRAME ) { int i ; <S2SV_StartBug> vp8_yv12_copy_frame ( <S2SV_EndBug> cpi -> Source , & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ; vp8_yv12_extend_frame_borders ( & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ; <S2SV_StartBug> for ( i = 2 ; i < MAX_REF_FRAMES - 1 ; i ++ ) <S2SV_EndBug> vp8_yv12_copy_frame ( <S2SV_StartBug> & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] , <S2SV_EndBug> & cpi -> denoiser . yv12_running_avg [ i ] ) ; } else { vp8_yv12_extend_frame_borders ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; if ( cm -> refresh_alt_ref_frame || cm -> copy_buffer_to_arf ) { vp8_yv12_copy_frame ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , & cpi -> denoiser . yv12_running_avg [ ALTREF_FRAME ] ) ; } if ( cm -> refresh_golden_frame || cm -> copy_buffer_to_gf ) { vp8_yv12_copy_frame ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , & cpi -> denoiser . yv12_running_avg [ GOLDEN_FRAME ] ) ; } if ( cm -> refresh_last_frame ) { vp8_yv12_copy_frame ( & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , & cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] ) ; } } <S2SV_StartBug> } <S2SV_EndBug> # endif }
","<S2SV_ModStart> -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_video_frame ; <S2SV_ModEnd> } else { <S2SV_ModStart> -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_video_frame ; <S2SV_ModEnd> } else if <S2SV_ModStart> -> lst_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> LAST_FRAME ] ; <S2SV_ModEnd> } } else <S2SV_ModStart> -> gld_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> GOLDEN_FRAME ] ; <S2SV_ModEnd> } } } <S2SV_ModStart> -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_video_frame ; <S2SV_ModEnd> } else if <S2SV_ModStart> -> lst_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> LAST_FRAME ] ; <S2SV_ModEnd> } } else <S2SV_ModStart> -> alt_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> ALTREF_FRAME ] ; <S2SV_ModEnd> } } } <S2SV_ModStart> -> new_fb_idx ; <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_video_frame ; <S2SV_ModEnd> } # if <S2SV_ModStart> int i ; for ( i = LAST_FRAME <S2SV_ModEnd> ; i < <S2SV_ModStart> i < MAX_REF_FRAMES ; ++ i <S2SV_ModEnd> ) vp8_yv12_copy_frame ( <S2SV_ModStart> ) vp8_yv12_copy_frame ( cpi -> Source <S2SV_ModEnd> , & cpi <S2SV_ModStart> ; } } if ( cpi -> oxcf . noise_sensitivity == 4 ) vp8_yv12_copy_frame ( cpi -> Source , & cpi -> denoiser . yv12_last_source ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; <S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> srose -> srose_family = AF_ROSE ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
","<S2SV_ModStart> ( sk ) <S2SV_ModEnd> ; size_t copied <S2SV_ModStart> ; if ( msg -> msg_name ) { struct sockaddr_rose * srose ; memset ( msg -> msg_name <S2SV_ModEnd> , 0 , <S2SV_ModStart> , 0 , sizeof ( struct full_sockaddr_rose ) ) ; srose = msg -> msg_name <S2SV_ModEnd> ; srose ->
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 static void videobuf_vm_open ( struct vm_area_struct * vma ) { struct videobuf_mapping * map = vma -> vm_private_data ; <S2SV_StartBug> dprintk ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%d,vma=%08lx-%08lx]\\n"" , map , <S2SV_EndBug> map -> count , vma -> vm_start , vma -> vm_end ) ; map -> count ++ ; }
","<S2SV_ModStart> ( 2 , ""vm_open<S2SV_blank>%p<S2SV_blank>[count=%u,vma=%08lx-%08lx]\\n"" <S2SV_ModEnd> , map ,
",torvalds@linux/0b29669c065f60501e7289e1950fa2a618962358,CVE-2007-6761,https://github.com/torvalds/linux/commit/0b29669c065f60501e7289e1950fa2a618962358,2017-04-24T06:59Z
CWE-119,"CWE-119 <S2SV_StartBug> int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs ) <S2SV_EndBug> { u16 * op ; int size ; unicode_t u ; op = pwcs ; <S2SV_StartBug> while ( * s && len > 0 ) { <S2SV_EndBug> if ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; <S2SV_StartBug> if ( u >= PLANE_SIZE ) { <S2SV_EndBug> <S2SV_StartBug> u -= PLANE_SIZE ; <S2SV_EndBug> <S2SV_StartBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | <S2SV_EndBug> <S2SV_StartBug> ( ( u >> 10 ) & SURROGATE_BITS ) ) ; <S2SV_EndBug> * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | <S2SV_StartBug> ( u & SURROGATE_BITS ) ) ; <S2SV_EndBug> } else { <S2SV_StartBug> * op ++ = ( wchar_t ) u ; <S2SV_EndBug> } s += size ; len -= size ; } else { <S2SV_StartBug> * op ++ = * s ++ ; <S2SV_EndBug> len -- ; } } return op - pwcs ; }
","<S2SV_ModStart> int len , enum utf16_endian endian , <S2SV_ModStart> wchar_t * pwcs , int maxlen <S2SV_ModStart> ; while ( <S2SV_ModEnd> len > 0 <S2SV_ModStart> len > 0 && maxlen > 0 && * s <S2SV_ModStart> - EINVAL ; s += size ; len -= size ; <S2SV_ModStart> PLANE_SIZE ) { if ( maxlen < 2 ) break ; <S2SV_ModStart> -= PLANE_SIZE ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | ( <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; put_utf16 ( op ++ , <S2SV_ModEnd> SURROGATE_PAIR | SURROGATE_LOW <S2SV_ModStart> & SURROGATE_BITS ) , endian ) ; maxlen -= 2 <S2SV_ModEnd> ; } else <S2SV_ModStart> } else { put_utf16 ( op ++ , u , endian ) ; maxlen -- ; } <S2SV_ModEnd> } else { <S2SV_ModStart> } else { put_utf16 ( op ++ , * s ++ , endian ) ; len -- ; maxlen <S2SV_ModEnd> -- ; }
",torvalds@linux/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,CVE-2013-1773,https://github.com/torvalds/linux/commit/0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd,2013-02-28T19:55Z
CWE-269,"CWE-269 static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) { <S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( ret , hb2 , & key2 , & pi_state , NULL ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { wake_futex ( this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { atomic_inc ( & pi_state -> refcount ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task , 1 ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; free_pi_state ( pi_state ) ; goto out_unlock ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } out_unlock : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : if ( pi_state != NULL ) free_pi_state ( pi_state ) ; return ret ? ret : task_count ; }
","<S2SV_ModStart> { if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }
",torvalds@linux/e9c243a5a6de0be8e584c604d353412584b592f8,CVE-2014-3153,https://github.com/torvalds/linux/commit/e9c243a5a6de0be8e584c604d353412584b592f8,2014-06-07T14:55Z
CWE-78,"CWE-78 static int compile_search ( struct Context * ctx , const struct Pattern * pat , struct Buffer * buf ) { if ( do_search ( pat , 0 ) == 0 ) return 0 ; if ( pat -> not ) mutt_buffer_addstr ( buf , ""NOT<S2SV_blank>"" ) ; if ( pat -> child ) { int clauses ; clauses = do_search ( pat -> child , 1 ) ; if ( clauses > 0 ) { const struct Pattern * clause = pat -> child ; mutt_buffer_addch ( buf , '(' ) ; while ( clauses ) { if ( do_search ( clause , 0 ) ) { if ( pat -> op == MUTT_OR && clauses > 1 ) mutt_buffer_addstr ( buf , ""OR<S2SV_blank>"" ) ; clauses -- ; if ( compile_search ( ctx , clause , buf ) < 0 ) return - 1 ; if ( clauses ) mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; } clause = clause -> next ; } mutt_buffer_addch ( buf , ')' ) ; } } else { char term [ STRING ] ; char * delim = NULL ; switch ( pat -> op ) { case MUTT_HEADER : mutt_buffer_addstr ( buf , ""HEADER<S2SV_blank>"" ) ; delim = strchr ( pat -> p . str , ':' ) ; if ( ! delim ) { mutt_error ( _ ( ""Header<S2SV_blank>search<S2SV_blank>without<S2SV_blank>header<S2SV_blank>name:<S2SV_blank>%s"" ) , pat -> p . str ) ; return - 1 ; } * delim = '\\0' ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; mutt_buffer_addch ( buf , '<S2SV_blank>' ) ; * delim = ':' ; delim ++ ; SKIPWS ( delim ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , delim ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_BODY : mutt_buffer_addstr ( buf , ""BODY<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_WHOLE_MSG : mutt_buffer_addstr ( buf , ""TEXT<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; case MUTT_SERVERSEARCH : { struct ImapData * idata = ctx -> data ; if ( ! mutt_bit_isset ( idata -> capabilities , X_GM_EXT1 ) ) { mutt_error ( _ ( ""Server-side<S2SV_blank>custom<S2SV_blank>search<S2SV_blank>not<S2SV_blank>supported:<S2SV_blank>%s"" ) , pat -> p . str ) ; return - 1 ; } } mutt_buffer_addstr ( buf , ""X-GM-RAW<S2SV_blank>"" ) ; <S2SV_StartBug> imap_quote_string ( term , sizeof ( term ) , pat -> p . str ) ; <S2SV_EndBug> mutt_buffer_addstr ( buf , term ) ; break ; } } return 0 ; }
","<S2SV_ModStart> p . str , false <S2SV_ModStart> ) , delim , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false <S2SV_ModStart> p . str , false
",neomutt@neomutt/e52393740334443ae0206cab2d7caef381646725,CVE-2018-14357,https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725,2018-07-17T17:29Z
CWE-264,"CWE-264 static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; <S2SV_StartBug> if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) <S2SV_EndBug> continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
","<S2SV_ModStart> ; if ( pmd_none_or_trans_huge_or_clear_bad <S2SV_ModEnd> ( pmd )
",torvalds@linux/4a1d704194a441bf83c636004a479e01360ec850,CVE-2012-1179,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,2012-05-17T11:00Z
CWE-310,"CWE-310 static void test_simple ( ) { json_set_alloc_funcs ( my_malloc , my_free ) ; create_and_free_complex_object ( ) ; <S2SV_StartBug> if ( malloc_called != 20 || free_called != 20 ) <S2SV_EndBug> fail ( ""Custom<S2SV_blank>allocation<S2SV_blank>failed"" ) ; }
","<S2SV_ModStart> ( malloc_called != 1 <S2SV_ModEnd> || free_called != <S2SV_ModStart> || free_called != 1 <S2SV_ModEnd> ) fail (
",akheron@jansson/8f80c2d83808150724d31793e6ade92749b1faa4,CVE-2013-6401,https://github.com/akheron/jansson/commit/8f80c2d83808150724d31793e6ade92749b1faa4,2014-03-21T01:04Z
CWE-125,"CWE-125 static void <S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }
","<S2SV_ModStart> u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }
",the-tcpdump-group@tcpdump/cc4a7391c616be7a64ed65742ef9ed3f106eb165,CVE-2017-13006,https://github.com/the-tcpdump-group/tcpdump/commit/cc4a7391c616be7a64ed65742ef9ed3f106eb165,2017-09-14T06:29Z
CWE-284,"CWE-284 int bta_co_rfc_data_outgoing_size ( void * user_data , int * size ) { pthread_mutex_lock ( & slot_lock ) ; uint32_t id = ( uintptr_t ) user_data ; int ret = false ; * size = 0 ; rfc_slot_t * slot = find_rfc_slot_by_id ( id ) ; if ( ! slot ) goto out ; <S2SV_StartBug> if ( ioctl ( slot -> fd , FIONREAD , size ) == 0 ) { <S2SV_EndBug> ret = true ; } else { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>determine<S2SV_blank>bytes<S2SV_blank>remaining<S2SV_blank>to<S2SV_blank>be<S2SV_blank>read<S2SV_blank>on<S2SV_blank>fd<S2SV_blank>%d:<S2SV_blank>%s"" , __func__ , slot -> fd , strerror ( errno ) ) ; cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; return ret ; }
","<S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> FIONREAD , size )
",system@bt/472271b153c5dc53c28beac55480a8d8434b2d5c,CVE-2016-3839,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,2016-08-05T20:59Z
CWE-119,"CWE-119 int vp8_receive_raw_frame ( VP8_COMP * cpi , unsigned int frame_flags , YV12_BUFFER_CONFIG * sd , int64_t time_stamp , int64_t end_time ) { <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> int64_t store_reg [ 8 ] ; # if CONFIG_RUNTIME_CPU_DETECT VP8_COMMON * cm = & cpi -> common ; # endif # endif struct vpx_usec_timer timer ; int res = 0 ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & timer ) ; if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) { assert ( cpi -> oxcf . lag_in_frames < 2 ) ; dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; } if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ; vpx_usec_timer_mark ( & timer ) ; cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; <S2SV_StartBug> # if HAVE_NEON <S2SV_EndBug> # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return res ; }
","<S2SV_ModStart> end_time ) { <S2SV_ModEnd> struct vpx_usec_timer timer <S2SV_ModStart> = 0 ; <S2SV_ModEnd> vpx_usec_timer_start ( & <S2SV_ModStart> timer ) ; <S2SV_ModEnd> return res ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-354,"CWE-354 bool recovery_cipher_abort ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( awaiting_character ) { awaiting_character = false ; return true ; } return false ; }
","<S2SV_ModStart> void ) { recovery_started = false ;
",keepkey@keepkey-firmware/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,CVE-2019-18672,https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680,2019-12-06T18:15Z
CWE-200,"CWE-200 void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> h_dport ; } minfo . flags = 0 ;
",torvalds@linux/4116def2337991b39919f3b448326e21c40e0dbb,CVE-2016-5244,https://github.com/torvalds/linux/commit/4116def2337991b39919f3b448326e21c40e0dbb,2016-06-27T10:59Z
CWE-000,"CWE-000 static void bgp_packet_mpattr_tea ( struct bgp * bgp , struct peer * peer , struct stream * s , struct attr * attr , uint8_t attrtype ) { unsigned int attrlenfield = 0 ; unsigned int attrhdrlen = 0 ; struct bgp_attr_encap_subtlv * subtlvs ; struct bgp_attr_encap_subtlv * st ; const char * attrname ; if ( ! attr || ( attrtype == BGP_ATTR_ENCAP && ( ! attr -> encap_tunneltype || attr -> encap_tunneltype == BGP_ENCAP_TYPE_MPLS ) ) ) return ; switch ( attrtype ) { case BGP_ATTR_ENCAP : attrname = ""Tunnel<S2SV_blank>Encap"" ; subtlvs = attr -> encap_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 2 + 2 ; attrhdrlen = 1 + 1 ; break ; <S2SV_StartBug> # if ENABLE_BGP_VNC <S2SV_EndBug> case BGP_ATTR_VNC : attrname = ""VNC"" ; subtlvs = attr -> vnc_subtlvs ; if ( subtlvs == NULL ) return ; attrlenfield = 0 ; attrhdrlen = 2 + 2 ; break ; # endif default : assert ( 0 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { attrlenfield += ( attrhdrlen + st -> length ) ; } if ( attrlenfield > 0xffff ) { zlog_info ( ""%s<S2SV_blank>attribute<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(length=%d),<S2SV_blank>can\'t<S2SV_blank>send<S2SV_blank>it"" , attrname , attrlenfield ) ; return ; } if ( attrlenfield > 0xff ) { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_EXTLEN ) ; stream_putc ( s , attrtype ) ; stream_putw ( s , attrlenfield & 0xffff ) ; } else { stream_putc ( s , BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL ) ; stream_putc ( s , attrtype ) ; stream_putc ( s , attrlenfield & 0xff ) ; } if ( attrtype == BGP_ATTR_ENCAP ) { stream_putw ( s , attr -> encap_tunneltype ) ; stream_putw ( s , attrlenfield - 4 ) ; } for ( st = subtlvs ; st ; st = st -> next ) { if ( attrtype == BGP_ATTR_ENCAP ) { stream_putc ( s , st -> type ) ; stream_putc ( s , st -> length ) ; # if ENABLE_BGP_VNC } else { stream_putw ( s , st -> type ) ; stream_putw ( s , st -> length ) ; # endif } stream_put ( s , st -> value , st -> length ) ; } }
","<S2SV_ModStart> ; # if ENABLE_BGP_VNC_ATTR <S2SV_ModEnd> case BGP_ATTR_VNC :
",FRRouting@frr/943d595a018e69b550db08cccba1d0778a86705a,CVE-2019-5892,https://github.com/FRRouting/frr/commit/943d595a018e69b550db08cccba1d0778a86705a,2019-01-10T17:29Z
CWE-787,"CWE-787 static void InsertRow ( Image * image , unsigned char * p , ssize_t y , int bpp , ExceptionInfo * exception ) { int bit ; Quantum index ; register Quantum * q ; ssize_t x ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; <S2SV_StartBug> for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 4 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; <S2SV_StartBug> p ++ ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 4 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 1 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; <S2SV_StartBug> if ( ( image -> columns % 4 ) >= 2 ) <S2SV_EndBug> { index = ConstrainColormapIndex ( image , ( * p >> 2 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; } } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 4 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x0f , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; break ; } case 8 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p , exception ) ; SetPixelIndex ( image , index , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) index , q ) ; p ++ ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } break ; case 24 : q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; q += GetPixelChannels ( image ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } }
","<S2SV_ModStart> -> columns - 3 <S2SV_ModEnd> ) ; x <S2SV_ModStart> q ) ; q += GetPixelChannels ( image ) ; p ++ <S2SV_ModEnd> ; } if <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 1 ) { <S2SV_ModStart> % 4 ) > <S2SV_ModEnd> 2 ) {
",ImageMagick@ImageMagick/998c687fb83993c13fa711d75f59a95b38ceab77,CVE-2016-7526,https://github.com/ImageMagick/ImageMagick/commit/998c687fb83993c13fa711d75f59a95b38ceab77,2017-04-20T18:59Z
CWE-119,"CWE-119 int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; <S2SV_StartBug> int req_len ; <S2SV_EndBug> struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_SETADP_BASE_LEN + req_len , qeth_snmp_command_cb , ( void * ) & qinfo ) ; if ( rc ) QETH_DBF_MESSAGE ( 2 , ""SNMP<S2SV_blank>command<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s:<S2SV_blank>(0x%x)\\n"" , QETH_CARD_IFNAME ( card ) , rc ) ; else { if ( copy_to_user ( udata , qinfo . udata , qinfo . udata_len ) ) rc = - EFAULT ; } kfree ( ureq ) ; kfree ( qinfo . udata ) ; return rc ; }
","<S2SV_ModStart> * ureq ; unsigned <S2SV_ModStart> return - EFAULT ; if ( req_len > ( QETH_BUFSIZE - IPA_PDU_HEADER_SIZE - sizeof ( struct qeth_ipacmd_hdr ) - sizeof ( struct qeth_ipacmd_setadpparms_hdr ) ) ) return - EINVAL
",torvalds@linux/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,CVE-2013-6381,https://github.com/torvalds/linux/commit/6fb392b1a63ae36c31f62bc3fc8630b49d602b62,2013-11-27T04:43Z
CWE-119,"CWE-119 int vp9_receive_compressed_data ( VP9Decoder * pbi , <S2SV_StartBug> size_t size , const uint8_t * * psource , <S2SV_EndBug> int64_t time_stamp ) { <S2SV_StartBug> VP9_COMMON * const cm = & pbi -> common ; <S2SV_EndBug> const uint8_t * source = * psource ; int retcode = 0 ; cm -> error . error_code = VPX_CODEC_OK ; if ( size == 0 ) { <S2SV_StartBug> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <S2SV_EndBug> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; } <S2SV_StartBug> if ( cm -> new_fb_idx >= 0 && cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count == 0 ) <S2SV_EndBug> <S2SV_StartBug> cm -> release_fb_cb ( cm -> cb_priv , <S2SV_EndBug> <S2SV_StartBug> & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer ) ; <S2SV_EndBug> cm -> new_fb_idx = get_free_fb ( cm ) ; <S2SV_StartBug> if ( setjmp ( cm -> error . jmp ) ) { <S2SV_EndBug> <S2SV_StartBug> cm -> error . setjmp = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_refs [ 0 ] . idx != INT_MAX ) <S2SV_EndBug> cm -> frame_refs [ 0 ] . buf -> corrupted = 1 ; if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return - 1 ; } cm -> error . setjmp = 1 ; <S2SV_StartBug> retcode = vp9_decode_frame ( pbi , source , source + size , psource ) ; <S2SV_EndBug> <S2SV_StartBug> if ( retcode < 0 ) { <S2SV_EndBug> <S2SV_StartBug> cm -> error . error_code = VPX_CODEC_ERROR ; <S2SV_EndBug> <S2SV_StartBug> cm -> error . setjmp = 0 ; <S2SV_EndBug> if ( cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count > 0 ) cm -> frame_bufs [ cm -> new_fb_idx ] . ref_count -- ; return retcode ; } <S2SV_StartBug> swap_frame_buffers ( pbi ) ; <S2SV_EndBug> # if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame ) ; else write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 1000 ) ; # endif if ( ! pbi -> do_loopfilter_inline ) { if ( pbi -> num_tile_workers ) { vp9_loop_filter_frame_mt ( pbi , cm , & pbi -> mb , cm -> lf . filter_level , 0 , 0 ) ; } else { vp9_loop_filter_frame ( cm , & pbi -> mb , cm -> lf . filter_level , 0 , 0 ) ; } } # if WRITE_RECON_BUFFER == 2 if ( cm -> show_frame ) write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 2000 ) ; else write_dx_frame_to_file ( cm -> frame_to_show , cm -> current_video_frame + 3000 ) ; # endif # if WRITE_RECON_BUFFER == 1 if ( cm -> show_frame ) recon_write_yuv_frame ( ""recon.yuv"" , cm -> frame_to_show , cm -> width , cm -> height ) ; # endif vp9_clear_system_state ( ) ; cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( ! cm -> show_existing_frame ) cm -> last_show_frame = cm -> show_frame ; if ( cm -> show_frame ) { if ( ! cm -> show_existing_frame ) vp9_swap_mi_and_prev_mi ( cm ) ; cm -> current_video_frame ++ ; } pbi -> ready_for_new_data = 0 ; pbi -> last_time_stamp = time_stamp ; cm -> error . setjmp = 0 ; return retcode ; }
","<S2SV_ModStart> * * psource <S2SV_ModEnd> ) { VP9_COMMON <S2SV_ModStart> { VP9_COMMON * volatile <S2SV_ModStart> pbi -> common ; BufferPool * volatile const pool = cm -> buffer_pool ; RefCntBuffer * volatile const frame_bufs = cm -> buffer_pool -> frame_bufs <S2SV_ModStart> ] . idx > 0 ) { assert ( cm -> frame_refs [ 0 ] . buf != NULL ) ; <S2SV_ModEnd> cm -> frame_refs <S2SV_ModStart> 1 ; } } pbi -> ready_for_new_data = 0 ; if ( ! pbi -> frame_parallel_decode && <S2SV_ModEnd> cm -> new_fb_idx <S2SV_ModStart> >= 0 && <S2SV_ModEnd> frame_bufs [ cm <S2SV_ModStart> == 0 ) pool <S2SV_ModEnd> -> release_fb_cb ( <S2SV_ModStart> -> release_fb_cb ( pool <S2SV_ModEnd> -> cb_priv , <S2SV_ModStart> cb_priv , & <S2SV_ModEnd> frame_bufs [ cm <S2SV_ModStart> ; if ( cm -> new_fb_idx == INVALID_IDX ) return VPX_CODEC_MEM_ERROR ; cm -> cur_frame = & pool -> frame_bufs [ cm -> new_fb_idx ] ; pbi -> hold_ref_buf = 0 ; if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; vp9_frameworker_lock_stats ( worker ) ; frame_bufs [ cm -> new_fb_idx ] . frame_worker_owner = worker ; pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; pbi -> cur_buf -> row = - 1 ; pbi -> cur_buf -> col = - 1 ; vp9_frameworker_unlock_stats ( worker ) ; } else { pbi -> cur_buf = & frame_bufs [ cm -> new_fb_idx ] ; } if ( <S2SV_ModStart> ) ) { const VPxWorkerInterface * const winterface = vpx_get_worker_interface ( ) ; int i ; <S2SV_ModStart> = 0 ; pbi -> ready_for_new_data = 1 ; winterface -> sync ( & pbi -> lf_worker ) ; for ( i = 0 ; i < pbi -> num_tile_workers ; ++ i ) { winterface -> sync ( & pbi -> tile_workers [ i ] ) ; } lock_buffer_pool ( pool ) ; if ( pbi -> hold_ref_buf == 1 ) { int ref_index = 0 , mask ; for ( mask = pbi -> refresh_frame_flags ; mask ; mask >>= 1 ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; if ( ( mask & 1 ) && old_idx >= 0 ) { decrease_ref_count ( old_idx , frame_bufs , pool ) ; } ++ ref_index ; } for ( ; ref_index < REF_FRAMES && ! cm -> show_existing_frame ; ++ ref_index ) { const int old_idx = cm -> ref_frame_map [ ref_index ] ; decrease_ref_count ( old_idx , frame_bufs , pool ) ; } pbi -> hold_ref_buf = 0 ; } decrease_ref_count ( cm -> new_fb_idx , frame_bufs , pool ) ; unlock_buffer_pool ( pool ) ; vpx_clear_system_state ( ) <S2SV_ModEnd> ; return - <S2SV_ModStart> = 1 ; <S2SV_ModEnd> vp9_decode_frame ( pbi <S2SV_ModStart> psource ) ; swap_frame_buffers ( pbi ) ; vpx_clear_system_state ( ) ; if ( ! cm -> show_existing_frame ) { cm -> last_show_frame = cm -> show_frame ; cm -> prev_frame = cm -> cur_frame ; if ( cm -> seg . enabled && ! pbi -> frame_parallel_decode ) vp9_swap_current_and_last_seg_map ( cm ) ; } if ( pbi -> frame_parallel_decode ) { VPxWorker * const worker = pbi -> frame_worker_owner ; FrameWorkerData * const frame_worker_data = worker -> data1 ; vp9_frameworker_lock_stats ( worker ) ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } frame_worker_data -> frame_decoded = 1 ; frame_worker_data -> frame_context_ready = 1 ; vp9_frameworker_signal_stats ( worker ) ; vp9_frameworker_unlock_stats ( worker ) ; } else { cm -> last_width = cm -> width ; cm -> last_height = cm -> height ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; } } <S2SV_ModEnd> cm -> error <S2SV_ModStart> -> error . <S2SV_ModEnd> setjmp = 0 <S2SV_ModStart> setjmp = 0 <S2SV_ModEnd> ; return retcode <S2SV_ModStart> retcode ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-200,"CWE-200 int check_user_token ( const char * authfile , const char * username , const char * otp_id , int verbose , FILE * debug_file ) { char buf [ 1024 ] ; char * s_user , * s_token ; int retval = AUTH_ERROR ; int fd ; struct stat st ; FILE * opwfile ; fd = open ( authfile , O_RDONLY , 0 ) ; if ( fd < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>open<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; return retval ; } if ( fstat ( fd , & st ) < 0 ) { if ( verbose ) D ( debug_file , ""Cannot<S2SV_blank>stat<S2SV_blank>file:<S2SV_blank>%s<S2SV_blank>(%s)"" , authfile , strerror ( errno ) ) ; close ( fd ) ; return retval ; } if ( ! S_ISREG ( st . st_mode ) ) { if ( verbose ) D ( debug_file , ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file"" , authfile ) ; close ( fd ) ; return retval ; } opwfile = fdopen ( fd , ""r"" ) ; if ( opwfile == NULL ) { if ( verbose ) D ( debug_file , ""fdopen:<S2SV_blank>%s"" , strerror ( errno ) ) ; close ( fd ) ; return retval ; } retval = AUTH_NO_TOKENS ; while ( fgets ( buf , 1024 , opwfile ) ) { char * saveptr = NULL ; if ( buf [ strlen ( buf ) - 1 ] == '\\n' ) buf [ strlen ( buf ) - 1 ] = '\\0' ; if ( buf [ 0 ] == '#' ) { if ( verbose ) D ( debug_file , ""Skipping<S2SV_blank>comment<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; continue ; } if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>line:<S2SV_blank>%s"" , buf ) ; s_user = strtok_r ( buf , "":"" , & saveptr ) ; if ( s_user && strcmp ( username , s_user ) == 0 ) { if ( verbose ) D ( debug_file , ""Matched<S2SV_blank>user:<S2SV_blank>%s"" , s_user ) ; retval = AUTH_NOT_FOUND ; do { s_token = strtok_r ( NULL , "":"" , & saveptr ) ; if ( verbose ) D ( debug_file , ""Authorization<S2SV_blank>token:<S2SV_blank>%s"" , s_token ) ; if ( s_token && otp_id && strcmp ( otp_id , s_token ) == 0 ) { if ( verbose ) D ( debug_file , ""Match<S2SV_blank>user/token<S2SV_blank>as<S2SV_blank>%s/%s"" , username , otp_id ) ; <S2SV_StartBug> return AUTH_FOUND ; <S2SV_EndBug> } } while ( s_token != NULL ) ; } } fclose ( opwfile ) ; return retval ; }
","<S2SV_ModStart> otp_id ) ; fclose ( opwfile ) ;
",Yubico@yubico-pam/0f6ceabab0a8849b47f67d727aa526c2656089ba,CVE-2018-9275,https://github.com/Yubico/yubico-pam/commit/0f6ceabab0a8849b47f67d727aa526c2656089ba,2018-04-04T18:29Z
CWE-20,"CWE-20 void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ) ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>cm\\n"" , <S2SV_ModStart> y ) ; sendClean ( outputbuffer ) ;
",TeX-Live@texlive-source/9216833a3888a4105a18e8c349f65b045ddb1079,CVE-2019-18604,https://github.com/TeX-Live/texlive-source/commit/9216833a3888a4105a18e8c349f65b045ddb1079,2019-10-29T19:15Z
CWE-000,"CWE-000 static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) { struct module_state * state = GETSTATE ( self ) ; PyObject * value ; PyObject * error ; switch ( type ) { case 1 : { double d ; if ( max < 8 ) { goto invalid ; } memcpy ( & d , buffer + * position , 8 ) ; value = PyFloat_FromDouble ( d ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 2 : case 14 : { int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! value ) { return NULL ; } * position += value_length + 1 ; break ; } case 3 : { int size ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ; if ( ! value ) { return NULL ; } if ( strcmp ( buffer + * position + 5 , ""$ref"" ) == 0 ) { PyObject * dbref ; PyObject * collection = PyDict_GetItemString ( value , ""$ref"" ) ; PyObject * id = PyDict_GetItemString ( value , ""$id"" ) ; PyObject * database = PyDict_GetItemString ( value , ""$db"" ) ; Py_INCREF ( collection ) ; PyDict_DelItemString ( value , ""$ref"" ) ; <S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , ""$id"" ) ; <S2SV_EndBug> if ( database == NULL ) { database = Py_None ; Py_INCREF ( database ) ; } else { Py_INCREF ( database ) ; PyDict_DelItemString ( value , ""$db"" ) ; } dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ; Py_DECREF ( value ) ; value = dbref ; Py_DECREF ( id ) ; Py_DECREF ( collection ) ; Py_DECREF ( database ) ; if ( ! value ) { return NULL ; } } * position += size ; break ; } case 4 : { int size , end ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } end = * position + size - 1 ; * position += 4 ; value = PyList_New ( 0 ) ; if ( ! value ) { return NULL ; } while ( * position < end ) { PyObject * to_append ; int type = ( int ) buffer [ ( * position ) ++ ] ; int key_size = strlen ( buffer + * position ) ; * position += key_size + 1 ; to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ; if ( ! to_append ) { Py_DECREF ( value ) ; return NULL ; } PyList_Append ( value , to_append ) ; Py_DECREF ( to_append ) ; } ( * position ) ++ ; break ; } case 5 : { PyObject * data ; PyObject * st ; int length , subtype ; memcpy ( & length , buffer + * position , 4 ) ; if ( max < length ) { goto invalid ; } subtype = ( unsigned char ) buffer [ * position + 4 ] ; # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) { value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; * position += length + 5 ; break ; } if ( subtype == 2 ) { data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; } # else if ( subtype == 2 ) { data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ; } # endif if ( ! data ) { return NULL ; } if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) { PyObject * kwargs ; PyObject * args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( data ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( data ) ; Py_DECREF ( args ) ; return NULL ; } assert ( length == 16 ) ; if ( uuid_subtype == CSHARP_LEGACY ) { PyDict_SetItemString ( kwargs , ""bytes_le"" , data ) ; } else { if ( uuid_subtype == JAVA_LEGACY ) { char big_endian [ 16 ] ; _fix_java ( buffer + * position + 5 , big_endian ) ; Py_DECREF ( data ) ; # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ; # else data = PyString_FromStringAndSize ( big_endian , length ) ; # endif } PyDict_SetItemString ( kwargs , ""bytes"" , data ) ; } value = PyObject_Call ( state -> UUID , args , kwargs ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ; # else st = PyInt_FromLong ( subtype ) ; # endif if ( ! st ) { Py_DECREF ( data ) ; return NULL ; } value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ; Py_DECREF ( st ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } case 6 : case 10 : { value = Py_None ; Py_INCREF ( value ) ; break ; } case 7 : { if ( max < 12 ) { goto invalid ; } # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , ""y#"" , buffer + * position , 12 ) ; # else value = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; # endif if ( ! value ) { return NULL ; } * position += 12 ; break ; } case 8 : { value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ; Py_INCREF ( value ) ; break ; } case 9 : { PyObject * naive ; PyObject * replace ; PyObject * args ; PyObject * kwargs ; if ( max < 8 ) { goto invalid ; } naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ; * position += 8 ; if ( ! tz_aware ) { value = naive ; break ; } if ( ! naive ) { return NULL ; } replace = PyObject_GetAttrString ( naive , ""replace"" ) ; Py_DECREF ( naive ) ; if ( ! replace ) { return NULL ; } args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( replace ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; return NULL ; } if ( PyDict_SetItemString ( kwargs , ""tzinfo"" , state -> UTC ) == - 1 ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; return NULL ; } value = PyObject_Call ( replace , args , kwargs ) ; Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; break ; } case 11 : { PyObject * pattern ; int flags_length , flags , i ; int pattern_length = strlen ( buffer + * position ) ; if ( max < pattern_length ) { goto invalid ; } pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , ""strict"" ) ; if ( ! pattern ) { return NULL ; } * position += pattern_length + 1 ; flags_length = strlen ( buffer + * position ) ; if ( max < pattern_length + flags_length ) { Py_DECREF ( pattern ) ; goto invalid ; } flags = 0 ; for ( i = 0 ; i < flags_length ; i ++ ) { if ( buffer [ * position + i ] == 'i' ) { flags |= 2 ; } else if ( buffer [ * position + i ] == 'l' ) { flags |= 4 ; } else if ( buffer [ * position + i ] == 'm' ) { flags |= 8 ; } else if ( buffer [ * position + i ] == 's' ) { flags |= 16 ; } else if ( buffer [ * position + i ] == 'u' ) { flags |= 32 ; } else if ( buffer [ * position + i ] == 'x' ) { flags |= 64 ; } } * position += flags_length + 1 ; value = PyObject_CallFunction ( state -> RECompile , ""Oi"" , pattern , flags ) ; Py_DECREF ( pattern ) ; break ; } case 12 : { int collection_length ; PyObject * collection ; PyObject * id ; * position += 4 ; collection_length = strlen ( buffer + * position ) ; if ( max < collection_length ) { goto invalid ; } collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , ""strict"" ) ; if ( ! collection ) { return NULL ; } * position += collection_length + 1 ; if ( max < collection_length + 12 ) { Py_DECREF ( collection ) ; goto invalid ; } id = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; if ( ! id ) { Py_DECREF ( collection ) ; return NULL ; } * position += 12 ; value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ; Py_DECREF ( collection ) ; Py_DECREF ( id ) ; break ; } case 13 : { PyObject * code ; int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += value_length + 1 ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ; Py_DECREF ( code ) ; break ; } case 15 : { int code_length , scope_size ; PyObject * code ; PyObject * scope ; * position += 8 ; code_length = strlen ( buffer + * position ) ; if ( max < 8 + code_length ) { goto invalid ; } code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += code_length + 1 ; memcpy ( & scope_size , buffer + * position , 4 ) ; scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ; if ( ! scope ) { Py_DECREF ( code ) ; return NULL ; } * position += scope_size ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ; Py_DECREF ( code ) ; Py_DECREF ( scope ) ; break ; } case 16 : { int i ; if ( max < 4 ) { goto invalid ; } memcpy ( & i , buffer + * position , 4 ) ; # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ; # else value = PyInt_FromLong ( i ) ; # endif if ( ! value ) { return NULL ; } * position += 4 ; break ; } case 17 : { unsigned int time , inc ; if ( max < 8 ) { goto invalid ; } memcpy ( & inc , buffer + * position , 4 ) ; memcpy ( & time , buffer + * position + 4 , 4 ) ; value = PyObject_CallFunction ( state -> Timestamp , ""II"" , time , inc ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 18 : { long long ll ; if ( max < 8 ) { goto invalid ; } memcpy ( & ll , buffer + * position , 8 ) ; value = PyLong_FromLongLong ( ll ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case - 1 : { value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ; break ; } case 127 : { value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ; break ; } default : { PyObject * InvalidDocument = _error ( ""InvalidDocument"" ) ; PyErr_SetString ( InvalidDocument , ""no<S2SV_blank>c<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>this<S2SV_blank>type<S2SV_blank>yet"" ) ; Py_DECREF ( InvalidDocument ) ; return NULL ; } } return value ; invalid : error = _error ( ""InvalidBSON"" ) ; PyErr_SetNone ( error ) ; Py_DECREF ( error ) ; return NULL ; }
","<S2SV_ModStart> ""$ref"" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> ""$id"" ) ; }
",mongodb@mongo-python-driver/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2,CVE-2013-2132,https://github.com/mongodb/mongo-python-driver/commit/a060c15ef87e0f0e72974c7c0e57fe811bbd06a2,2013-08-15T17:55Z
CWE-369,"CWE-369 static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
","<S2SV_ModStart> ; if ( rpx >= 31 || ( ( comp -> dx << rpx ) >> rpx ) != comp -> dx || rpy >= 31 || ( ( comp -> dy << rpy ) >> rpy ) != comp -> dy ) { continue ; } if (
",uclouvain@openjpeg/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,CVE-2016-10506,https://github.com/uclouvain/openjpeg/commit/d27ccf01c68a31ad62b33d2dc1ba2bb1eeaafe7b,2017-08-30T09:29Z
CWE-264,"CWE-264 int touch ( const char * path ) { <S2SV_StartBug> return touch_file ( path , false , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> }
","<S2SV_ModStart> , GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }
",systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z
CWE-000,"CWE-000 static struct nfs4_state * nfs4_opendata_to_nfs4_state ( struct nfs4_opendata * data ) { struct inode * inode ; struct nfs4_state * state = NULL ; struct nfs_delegation * delegation ; int ret ; if ( ! data -> rpc_done ) { state = nfs4_try_open_cached ( data ) ; goto out ; } ret = - EAGAIN ; if ( ! ( data -> f_attr . valid & NFS_ATTR_FATTR ) ) goto err ; inode = nfs_fhget ( data -> dir -> d_sb , & data -> o_res . fh , & data -> f_attr ) ; ret = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto err ; ret = - ENOMEM ; state = nfs4_get_open_state ( inode , data -> owner ) ; if ( state == NULL ) goto err_put_inode ; if ( data -> o_res . delegation_type != 0 ) { int delegation_flags = 0 ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; if ( delegation ) delegation_flags = delegation -> flags ; rcu_read_unlock ( ) ; if ( ( delegation_flags & 1UL << NFS_DELEGATION_NEED_RECLAIM ) == 0 ) nfs_inode_set_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; else nfs_inode_reclaim_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; } update_open_stateid ( state , & data -> o_res . stateid , NULL , <S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug> iput ( inode ) ; out : return state ; err_put_inode : iput ( inode ) ; err : return ERR_PTR ( ret ) ; }
","<S2SV_ModStart> -> o_arg . fmode <S2SV_ModEnd> ) ; iput
",torvalds@linux/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,CVE-2011-4324,https://github.com/torvalds/linux/commit/dc0b027dfadfcb8a5504f7d8052754bf8d501ab9,2012-06-21T23:55Z
CWE-400,"CWE-400 static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }
","<S2SV_ModStart> { if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog
",ccxvii@mujs/00d4606c3baf813b7b1c176823b2729bf51002a2,CVE-2019-11413,https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2,2019-04-22T11:29Z
CWE-000,"CWE-000 static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; }
","<S2SV_ModStart> ctxt ) { int rc ; unsigned long eip ; rc = emulate_pop ( ctxt , & eip , <S2SV_ModEnd> ctxt -> op_bytes <S2SV_ModStart> ctxt -> op_bytes ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; return assign_eip_near ( ctxt , eip <S2SV_ModEnd> ) ; }
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
CWE-119,"CWE-119 static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; <S2SV_StartBug> int n ; <S2SV_EndBug> <S2SV_StartBug> if ( ! body -> unit_size ) <S2SV_EndBug> break ; <S2SV_StartBug> n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) <S2SV_EndBug> / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
","<S2SV_ModStart> -> data ; unsigned <S2SV_ModStart> body -> unit_size || len < sizeof ( struct oz_multiple_fixed ) - 1 <S2SV_ModStart> ( len - ( <S2SV_ModStart> struct oz_multiple_fixed ) - 1 ) <S2SV_ModEnd> ) / body
",torvalds@linux/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,CVE-2015-4002,https://github.com/torvalds/linux/commit/9a59029bc218b48eff8b5d4dde5662fd79d3e1a8,2015-06-07T23:59Z
CWE-119,"CWE-119 static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , ""Stored<S2SV_blank>object<S2SV_blank>is<S2SV_blank>of<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , ""Invalid<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; <S2SV_StartBug> while ( ibuf [ ind ] == 0x01 ) { <S2SV_EndBug> if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>allocated<S2SV_blank>and<S2SV_blank>uses<S2SV_blank>key_ref<S2SV_blank>%d"" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , ""Key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>unallocated"" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } iptr = ibuf + GEMSAFE_READ_QUANTUM ; while ( ( size_t ) ( iptr - ibuf ) < objlen ) { r = sc_read_binary ( card , iptr - ibuf , iptr , MIN ( GEMSAFE_READ_QUANTUM , objlen - ( iptr - ibuf ) ) , 0 ) ; if ( r < 0 ) { sc_log ( card -> ctx , ""Could<S2SV_blank>not<S2SV_blank>read<S2SV_blank>cert<S2SV_blank>object"" ) ; return SC_ERROR_INTERNAL ; } iptr += GEMSAFE_READ_QUANTUM ; } i = 0 ; while ( ind < objlen - 1 ) { if ( ibuf [ ind ] == 0x30 && ibuf [ ind + 1 ] == 0x82 ) { while ( i < gemsafe_cert_max && gemsafe_cert [ i ] . label == NULL ) i ++ ; if ( i == gemsafe_cert_max ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Found<S2SV_blank>orphaned<S2SV_blank>certificate<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d"" , ind ) ; return SC_SUCCESS ; } if ( ind + 3 >= sizeof ibuf ) return SC_ERROR_INVALID_DATA ; certlen = ( ( ( ( size_t ) ibuf [ ind + 2 ] ) << 8 ) | ibuf [ ind + 3 ] ) + 4 ; sc_log ( card -> ctx , ""Found<S2SV_blank>certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d,<S2SV_blank>len<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u"" , i + 1 , ind , certlen ) ; gemsafe_cert [ i ] . index = ind ; gemsafe_cert [ i ] . count = certlen ; ind += certlen ; i ++ ; } else ind ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { if ( gemsafe_cert [ i ] . label ) { sc_log ( card -> ctx , ""Warning:<S2SV_blank>Certificate<S2SV_blank>of<S2SV_blank>key<S2SV_blank>container<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>missing"" , i + 1 ) ; gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; } } return SC_SUCCESS ; }
","<S2SV_ModStart> ] == 0x01 && i < gemsafe_cert_max
",OpenSC@OpenSC/360e95d45ac4123255a4c796db96337f332160ad,CVE-2018-16391,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-477b7a40136bb418b10ce271c8664536,2018-09-03T14:29Z
CWE-264,"CWE-264 int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; <S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
","<S2SV_ModStart> if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
",systemd@systemd/ee735086f8670be1591fa9593e80dd60163a7a2f,CVE-2016-10156,https://github.com/systemd/systemd/commit/ee735086f8670be1591fa9593e80dd60163a7a2f,2017-01-23T07:59Z
CWE-125,"CWE-125 static int isis_print_mt_port_cap_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len ; const struct isis_subtlv_spb_mcid * subtlv_spb_mcid ; int i ; while ( len > 2 ) { <S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_port_cap_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_MCID : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ; <S2SV_EndBug> subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MCID:<S2SV_blank>"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> mcid ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AUX-MCID:<S2SV_blank>"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> aux_mcid ) ) ; <S2SV_StartBug> tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ; <S2SV_EndBug> len = len - sizeof ( struct isis_subtlv_spb_mcid ) ; break ; } case ISIS_SUBTLV_SPB_DIGEST : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d<S2SV_blank>V:<S2SV_blank>%d<S2SV_blank>A:<S2SV_blank>%d<S2SV_blank>D:<S2SV_blank>%d"" , ( * ( tptr ) >> 5 ) , ( ( ( * tptr ) >> 4 ) & 0x01 ) , ( ( * ( tptr ) >> 2 ) & 0x03 ) , ( ( * tptr ) & 0x03 ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Digest:<S2SV_blank>"" ) ) ; for ( i = 1 ; i <= 8 ; i ++ ) { ND_PRINT ( ( ndo , ""%08x<S2SV_blank>"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( i % 4 == 0 && i != 8 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; tptr = tptr + 4 ; } len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_StartBug> break ; <S2SV_EndBug> } case ISIS_SUBTLV_SPB_BVID : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , stlv_len ) ; <S2SV_EndBug> while ( len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>U:%01x<S2SV_blank>M:%01x<S2SV_blank>"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) , ( EXTRACT_16BITS ( tptr ) >> 3 ) & 0x01 , ( EXTRACT_16BITS ( tptr ) >> 2 ) & 0x01 ) ) ; tptr = tptr + 2 ; len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_StartBug> } <S2SV_EndBug> break ; } default : break ; } <S2SV_StartBug> } <S2SV_EndBug> return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }
","<S2SV_ModStart> 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> ; subtlv_spb_mcid = <S2SV_ModStart> = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> ; break ; <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID : { while ( stlv_len <S2SV_ModEnd> >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;
",the-tcpdump-group@tcpdump/b20e1639dbac84b3fcb393858521c13ad47a9d70,CVE-2017-13026,https://github.com/the-tcpdump-group/tcpdump/commit/b20e1639dbac84b3fcb393858521c13ad47a9d70,2017-09-14T06:29Z
CWE-189,"CWE-189 Datum varbit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; # ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; # endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else <S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen > atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_RIGHT_TRUNCATION ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>type<S2SV_blank>bit<S2SV_blank>varying(%d)"" , atttypmod ) ) ) ; len = VARBITTOTALLEN ( bitlen ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = Min ( bitlen , atttypmod ) ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>binary<S2SV_blank>digit"" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>hexadecimal<S2SV_blank>digit"" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x << 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }
","<S2SV_ModStart> slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }
",postgres@postgres/31400a673325147e1205326008e32135a78b4d8a,CVE-2014-2669,https://github.com/postgres/postgres/commit/31400a673325147e1205326008e32135a78b4d8a,2014-03-31T14:58Z
CWE-476,"CWE-476 int writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , ""w"" ) ; if ( ! f ) { warn ( ""open<S2SV_blank>%s:"" , name ) ; return - 1 ; } ret = 0 ; <S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> warn ( ""write<S2SV_blank>%s:"" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }
","<S2SV_ModStart> ; if ( s && ( <S2SV_ModStart> ) != 0 )
",michaelforney@samurai/e84b6d99c85043fa1ba54851ee500540ec206918,CVE-2021-30218,https://github.com/michaelforney/samurai/commit/e84b6d99c85043fa1ba54851ee500540ec206918,2021-04-29T15:15Z
CWE-400,"CWE-400 static int xen_evtchn_cpu_prepare ( unsigned int cpu ) { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> if ( evtchn_ops -> percpu_init ) ret = evtchn_ops -> percpu_init ( cpu ) ; return ret ; }
","<S2SV_ModStart> ret = 0 ; xen_cpu_init_eoi ( cpu )
",torvalds@linux/e99502f76271d6bc4e374fe368c50c67a1fd3070,CVE-2020-27673,https://github.com/torvalds/linux/commit/e99502f76271d6bc4e374fe368c50c67a1fd3070,2020-10-22T21:15Z
CWE-617,"CWE-617 static void pci_bus_write_dsdt ( int bus ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev ; int count , func , slot ; bi = pci_businfo [ bus ] ; if ( bi == NULL ) { if ( bus != 0 ) return ; } dsdt_line ( ""<S2SV_blank><S2SV_blank>Device<S2SV_blank>(PCI%01X)"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_HID,<S2SV_blank>EisaId<S2SV_blank>(\\""PNP0A03\\""))"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_ADR,<S2SV_blank>Zero)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Method<S2SV_blank>(_BBN,<S2SV_blank>0,<S2SV_blank>NotSerialized)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(0x%08X)"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Name<S2SV_blank>(_CRS,<S2SV_blank>ResourceTemplate<S2SV_blank>()"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordBusNumber<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>"" ""MaxFixed,<S2SV_blank>PosDecode,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , bus ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0001,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>)"" ) ; if ( bus == 0 ) { dsdt_indent ( 3 ) ; dsdt_fixed_ioport ( 0xCF8 , 8 ) ; dsdt_unindent ( 3 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0CF7,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0CF8,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0D00,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , PCI_EMUL_IOBASE - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" , PCI_EMUL_IOBASE - 0x0D00 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; if ( bi == NULL ) { dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>})"" ) ; goto done ; } } <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>"" ""PosDecode,<S2SV_blank>EntireRange,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum"" , bi -> iobase ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum"" , bi -> iolimit - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length"" , bi -> iolimit - bi -> iobase ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>DWordMemory<S2SV_blank>(ResourceProducer,<S2SV_blank>PosDecode,<S2SV_blank>"" ""MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>NonCacheable,<S2SV_blank>ReadWrite,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x00000000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum\\n"" , bi -> membase32 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum\\n"" , bi -> memlimit32 - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x00000000,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%08X,<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>//<S2SV_blank>Length\\n"" , bi -> memlimit32 - bi -> membase32 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>AddressRangeMemory,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>QWordMemory<S2SV_blank>(ResourceProducer,<S2SV_blank>PosDecode,<S2SV_blank>"" ""MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>NonCacheable,<S2SV_blank>ReadWrite,"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000000000000000,<S2SV_blank>//<S2SV_blank>Granularity"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Minimum\\n"" , bi -> membase64 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Range<S2SV_blank>Maximum\\n"" , bi -> memlimit64 - 1 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x0000000000000000,<S2SV_blank>//<S2SV_blank>Translation<S2SV_blank>Offset"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%016lX,<S2SV_blank>//<S2SV_blank>Length\\n"" , bi -> memlimit64 - bi -> membase64 ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>,,<S2SV_blank>,<S2SV_blank>AddressRangeMemory,<S2SV_blank>TypeStatic)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>})"" ) ; if ( ! is_rtvm ) { count = pci_count_lintr ( bus ) ; if ( count != 0 ) { dsdt_indent ( 2 ) ; dsdt_line ( ""Name<S2SV_blank>(PPRT,<S2SV_blank>Package<S2SV_blank>()"" ) ; dsdt_line ( ""{"" ) ; pci_walk_lintr ( bus , pci_pirq_prt_entry , NULL ) ; dsdt_line ( ""})"" ) ; dsdt_line ( ""Name<S2SV_blank>(APRT,<S2SV_blank>Package<S2SV_blank>()"" ) ; dsdt_line ( ""{"" ) ; pci_walk_lintr ( bus , pci_apic_prt_entry , NULL ) ; dsdt_line ( ""})"" ) ; dsdt_line ( ""Method<S2SV_blank>(_PRT,<S2SV_blank>0,<S2SV_blank>NotSerialized)"" ) ; dsdt_line ( ""{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>If<S2SV_blank>(PICM)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(APRT)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>Else"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>{"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Return<S2SV_blank>(PPRT)"" ) ; dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; dsdt_line ( ""}"" ) ; dsdt_unindent ( 2 ) ; } } dsdt_indent ( 2 ) ; for ( slot = 0 ; slot < MAXSLOTS ; slot ++ ) { si = & bi -> slotinfo [ slot ] ; for ( func = 0 ; func < MAXFUNCS ; func ++ ) { dev = si -> si_funcs [ func ] . fi_devi ; if ( dev != NULL && dev -> dev_ops -> vdev_write_dsdt != NULL ) dev -> dev_ops -> vdev_write_dsdt ( dev ) ; } } dsdt_unindent ( 2 ) ; done : dsdt_line ( ""<S2SV_blank><S2SV_blank>}"" ) ; }
","<S2SV_ModStart> ; } } <S2SV_ModEnd> dsdt_line ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>WordIO<S2SV_blank>(ResourceProducer,<S2SV_blank>MinFixed,<S2SV_blank>MaxFixed,<S2SV_blank>""
",projectacrn@acrn-hypervisor/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,CVE-2019-18844,https://github.com/projectacrn/acrn-hypervisor/commit/2b3dedfb9ba13f15887f22b935d373f36c9a59fa,2019-11-13T20:15Z
CWE-000,"CWE-000 int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( ""inspecting<S2SV_blank>content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd -> flags & DETECT_CONTENT_DISTANCE_BE ) { distance = det_ctx -> bj_values [ cd -> distance ] ; } if ( distance < 0 && ( uint32_t ) ( abs ( distance ) ) > offset ) offset = 0 ; else offset += distance ; SCLogDebug ( ""cd->distance<S2SV_blank>%"" PRIi32 "",<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , distance , offset , depth ) ; } if ( cd -> flags & DETECT_CONTENT_WITHIN ) { if ( cd -> flags & DETECT_CONTENT_WITHIN_BE ) { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ) ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ; } } else { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + cd -> within + distance ) ) { depth = prev_buffer_offset + cd -> within + distance ; } SCLogDebug ( ""cd->within<S2SV_blank>%"" PRIi32 "",<S2SV_blank>det_ctx->buffer_offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> within , prev_buffer_offset , depth ) ; } if ( stream_start_offset != 0 && prev_buffer_offset == 0 ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } } if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { if ( ( det_ctx -> bj_values [ cd -> depth ] + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> depth ] ; } } else { if ( cd -> depth != 0 ) { if ( ( cd -> depth + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + cd -> depth ; } SCLogDebug ( ""cd->depth<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , cd -> depth , depth ) ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) { if ( det_ctx -> bj_values [ cd -> offset ] > offset ) offset = det_ctx -> bj_values [ cd -> offset ] ; } else { if ( cd -> offset > offset ) { offset = cd -> offset ; SCLogDebug ( ""setting<S2SV_blank>offset<S2SV_blank>%"" PRIu32 , offset ) ; } } } else { if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { depth = det_ctx -> bj_values [ cd -> depth ] ; } else { if ( cd -> depth != 0 ) { depth = cd -> depth ; } } if ( stream_start_offset != 0 && cd -> flags & DETECT_CONTENT_DEPTH ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) offset = det_ctx -> bj_values [ cd -> offset ] ; else offset = cd -> offset ; prev_buffer_offset = 0 ; } SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , offset , prev_offset ) ; if ( prev_offset != 0 ) offset = prev_offset ; SCLogDebug ( ""offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>depth<S2SV_blank>%"" PRIu32 , offset , depth ) ; if ( depth > buffer_len ) depth = buffer_len ; if ( offset > depth || depth == 0 ) { if ( cd -> flags & DETECT_CONTENT_NEGATED ) { goto match ; } else { goto no_match ; } } uint8_t * sbuffer = buffer + offset ; uint32_t sbuffer_len = depth - offset ; uint32_t match_offset = 0 ; SCLogDebug ( ""sbuffer_len<S2SV_blank>%"" PRIu32 , sbuffer_len ) ; # ifdef DEBUG BUG_ON ( sbuffer_len > buffer_len ) ; # endif found = SpmScan ( cd -> spm_ctx , det_ctx -> spm_thread_ctx , sbuffer , sbuffer_len ) ; SCLogDebug ( ""found<S2SV_blank>%p<S2SV_blank>cd<S2SV_blank>negated<S2SV_blank>%s"" , found , cd -> flags & DETECT_CONTENT_NEGATED ? ""true"" : ""false"" ) ; if ( found == NULL && ! ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { <S2SV_StartBug> goto no_match ; <S2SV_EndBug> } else if ( found == NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { goto match ; } else if ( found != NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 "",<S2SV_blank>but<S2SV_blank>negated<S2SV_blank>so<S2SV_blank>no<S2SV_blank>match"" , cd -> id , match_offset ) ; if ( DETECT_CONTENT_IS_SINGLE ( cd ) ) det_ctx -> discontinue_matching = 1 ; goto no_match ; } else { match_offset = ( uint32_t ) ( ( found - buffer ) + cd -> content_len ) ; SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 ""<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%"" PRIu32 """" , cd -> id , match_offset ) ; det_ctx -> buffer_offset = match_offset ; if ( cd -> flags & DETECT_CONTENT_REPLACE ) { if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) { det_ctx -> replist = DetectReplaceAddToList ( det_ctx -> replist , found , cd ) ; } else { SCLogWarning ( SC_ERR_INVALID_VALUE , ""Can\'t<S2SV_blank>modify<S2SV_blank>payload<S2SV_blank>without<S2SV_blank>packet"" ) ; } } <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } if ( smd -> is_last ) { goto no_match ; } SCLogDebug ( ""content<S2SV_blank>%"" PRIu32 , cd -> id ) ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> goto no_match ; prev_offset = ( match_offset - ( cd -> content_len - 1 ) ) ; SCLogDebug ( ""trying<S2SV_blank>to<S2SV_blank>see<S2SV_blank>if<S2SV_blank>there<S2SV_blank>is<S2SV_blank>another<S2SV_blank>match<S2SV_blank>after<S2SV_blank>prev_offset<S2SV_blank>%"" PRIu32 , prev_offset ) ; } } while ( 1 ) ; } else if ( smd -> type == DETECT_ISDATAAT ) { SCLogDebug ( ""inspecting<S2SV_blank>isdataat"" ) ; DetectIsdataatData * id = ( DetectIsdataatData * ) smd -> ctx ; if ( id -> flags & ISDATAAT_RELATIVE ) { if ( det_ctx -> buffer_offset + id -> dataat > buffer_len ) { SCLogDebug ( ""det_ctx->buffer_offset<S2SV_blank>+<S2SV_blank>id->dataat<S2SV_blank>%"" PRIu32 ""<S2SV_blank>><S2SV_blank>%"" PRIu32 , det_ctx -> buffer_offset + id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } else { SCLogDebug ( ""relative<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } } else { if ( id -> dataat < buffer_len ) { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>match"" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } else { SCLogDebug ( ""absolute<S2SV_blank>isdataat<S2SV_blank>mismatch,<S2SV_blank>id->isdataat<S2SV_blank>%"" PRIu32 "",<S2SV_blank>buffer_len<S2SV_blank>%"" PRIu32 """" , id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } } } else if ( smd -> type == DETECT_PCRE ) { SCLogDebug ( ""inspecting<S2SV_blank>pcre"" ) ; DetectPcreData * pe = ( DetectPcreData * ) smd -> ctx ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; uint32_t prev_offset = 0 ; int r = 0 ; det_ctx -> pcre_match_start_offset = 0 ; do { Packet * p = NULL ; if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) p = ( Packet * ) data ; r = DetectPcrePayloadMatch ( det_ctx , s , smd , p , f , buffer , buffer_len ) ; if ( r == 0 ) { goto no_match ; } if ( ! ( pe -> flags & DETECT_PCRE_RELATIVE_NEXT ) ) { SCLogDebug ( ""no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match"" ) ; goto match ; } KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; prev_offset = det_ctx -> pcre_match_start_offset ; r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } if ( det_ctx -> discontinue_matching ) goto no_match ; det_ctx -> buffer_offset = prev_buffer_offset ; det_ctx -> pcre_match_start_offset = prev_offset ; } while ( 1 ) ; } else if ( smd -> type == DETECT_BYTETEST ) { DetectBytetestData * btd = ( DetectBytetestData * ) smd -> ctx ; uint8_t flags = btd -> flags ; int32_t offset = btd -> offset ; uint64_t value = btd -> value ; if ( flags & DETECT_BYTETEST_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTETEST_VALUE_BE ) { value = det_ctx -> bj_values [ value ] ; } if ( flags & DETECT_BYTETEST_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTETEST_LITTLE : 0 ) ; } if ( DetectBytetestDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset , value ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTEJUMP ) { DetectBytejumpData * bjd = ( DetectBytejumpData * ) smd -> ctx ; uint8_t flags = bjd -> flags ; int32_t offset = bjd -> offset ; if ( flags & DETECT_BYTEJUMP_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTEJUMP_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTEJUMP_LITTLE : 0 ) ; } if ( DetectBytejumpDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTE_EXTRACT ) { DetectByteExtractData * bed = ( DetectByteExtractData * ) smd -> ctx ; uint8_t endian = bed -> endian ; if ( ( bed -> flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN ) && endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; endian |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] == 0x10 ) ? DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG ) ; } if ( DetectByteExtractDoMatch ( det_ctx , smd , s , buffer , buffer_len , & det_ctx -> bj_values [ bed -> local_id ] , endian ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_AL_URILEN ) { SCLogDebug ( ""inspecting<S2SV_blank>uri<S2SV_blank>len"" ) ; int r = 0 ; DetectUrilenData * urilend = ( DetectUrilenData * ) smd -> ctx ; switch ( urilend -> mode ) { case DETECT_URILEN_EQ : if ( buffer_len == urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_LT : if ( buffer_len < urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_GT : if ( buffer_len > urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_RA : if ( buffer_len > urilend -> urilen1 && buffer_len < urilend -> urilen2 ) { r = 1 ; } break ; } if ( r == 1 ) { goto match ; } det_ctx -> discontinue_matching = 0 ; goto no_match ; # ifdef HAVE_LUA } else if ( smd -> type == DETECT_LUA ) { SCLogDebug ( ""lua<S2SV_blank>starting"" ) ; if ( DetectLuaMatchBuffer ( det_ctx , s , smd , buffer , buffer_len , det_ctx -> buffer_offset , f ) != 1 ) { SCLogDebug ( ""lua<S2SV_blank>no_match"" ) ; goto no_match ; } SCLogDebug ( ""lua<S2SV_blank>match"" ) ; goto match ; # endif } else if ( smd -> type == DETECT_BASE64_DECODE ) { if ( DetectBase64DecodeDoMatch ( det_ctx , s , smd , buffer , buffer_len ) ) { if ( s -> sm_arrays [ DETECT_SM_LIST_BASE64_DATA ] != NULL ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; if ( DetectBase64DataDoMatch ( de_ctx , det_ctx , s , f ) ) { goto final_match ; } } } } else { SCLogDebug ( ""sm->type<S2SV_blank>%u"" , smd -> type ) ; # ifdef DEBUG BUG_ON ( 1 ) ; # endif } no_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; match : if ( ! smd -> is_last ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; SCReturnInt ( r ) ; } final_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; SCReturnInt ( 1 ) ; }
","<S2SV_ModStart> ) ) { if ( ( cd -> flags & ( DETECT_CONTENT_DISTANCE | DETECT_CONTENT_WITHIN ) ) == 0 ) { det_ctx -> discontinue_matching = 1 ; } <S2SV_ModStart> } if ( smd -> is_last ) { goto match <S2SV_ModEnd> ; } SCLogDebug <S2SV_ModStart> ) ; } SCLogDebug ( ""no<S2SV_blank>match<S2SV_blank>for<S2SV_blank>\'next<S2SV_blank>sm\'"" ) ; <S2SV_ModStart> -> discontinue_matching ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>said<S2SV_blank>to<S2SV_blank>discontinue<S2SV_blank>this<S2SV_blank>right<S2SV_blank>now"" ) ; goto no_match ; } if ( ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) == 0 ) { SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>depend<S2SV_blank>on<S2SV_blank>me,<S2SV_blank>so<S2SV_blank>we<S2SV_blank>can<S2SV_blank>give<S2SV_blank>up"" ) ; det_ctx -> discontinue_matching = 1 ; goto no_match ; } SCLogDebug ( ""\'next<S2SV_blank>sm\'<S2SV_blank>depends<S2SV_blank>on<S2SV_blank>me<S2SV_blank>%p,<S2SV_blank>lets<S2SV_blank>see<S2SV_blank>what<S2SV_blank>we<S2SV_blank>can<S2SV_blank>do<S2SV_blank>(flags<S2SV_blank>%u)"" , cd , cd -> flags ) <S2SV_ModEnd> ; prev_offset =
",OISF@suricata/b9579fbe7dd408200ef03cbe20efddb624b73885,CVE-2017-15377,https://github.com/OISF/suricata/commit/b9579fbe7dd408200ef03cbe20efddb624b73885,2017-10-23T08:29Z
CWE-835,"CWE-835 void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; <S2SV_StartBug> if ( client -> priv -> protocol_timeout ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; client -> priv -> protocol_timeout = 0 ; } g_debug ( ""GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s"" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeletePropertiesProcMask ; callbacks_ret -> delete_properties . callback = delete_properties_callback ; callbacks_ret -> delete_properties . manager_data = client ; * mask_ret |= SmsGetPropertiesProcMask ; callbacks_ret -> get_properties . callback = get_properties_callback ; callbacks_ret -> get_properties . manager_data = client ; }
","<S2SV_ModStart> = conn ; <S2SV_ModEnd> g_debug ( ""GsmXSMPClient:<S2SV_blank>Initializing<S2SV_blank>client<S2SV_blank>%s""
",GNOME@gnome-session/b0dc999e0b45355314616321dbb6cb71e729fc9d,CVE-2017-11171,https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d,2017-07-11T20:29Z
CWE-125,"CWE-125 void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; <S2SV_StartBug> int hexdump ; <S2SV_EndBug> u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,<S2SV_blank>msg-type:<S2SV_blank>%s,<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>length:<S2SV_blank>%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,<S2SV_blank>type:<S2SV_blank>%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen ) ) ; if ( tlen < sizeof ( const struct lmp_common_header ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( tlen > len ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>long)"" ) ) ; tlen = len ; } tptr += sizeof ( const struct lmp_common_header ) ; tlen -= sizeof ( const struct lmp_common_header ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct lmp_object_header ) ) ; lmp_obj_header = ( const struct lmp_object_header * ) tptr ; lmp_obj_len = EXTRACT_16BITS ( lmp_obj_header -> length ) ; lmp_obj_ctype = ( lmp_obj_header -> ctype ) & 0x7f ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(%u),<S2SV_blank>Class-Type:<S2SV_blank>%s<S2SV_blank>(%u)<S2SV_blank>Flags:<S2SV_blank>[%snegotiable],<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( lmp_obj_values , ""Unknown"" , lmp_obj_header -> class_num ) , lmp_obj_header -> class_num , tok2str ( lmp_ctype_values , ""Unknown"" , ( ( lmp_obj_header -> class_num ) << 8 ) + lmp_obj_ctype ) , lmp_obj_ctype , ( lmp_obj_header -> ctype ) & 0x80 ? """" : ""non-"" , lmp_obj_len ) ) ; if ( lmp_obj_len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(too<S2SV_blank>short)"" ) ) ; return ; } if ( ( lmp_obj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)"" ) ) ; return ; } obj_tptr = tptr + sizeof ( struct lmp_object_header ) ; obj_tlen = lmp_obj_len - sizeof ( struct lmp_object_header ) ; ND_TCHECK2 ( * tptr , lmp_obj_len ) ; hexdump = FALSE ; switch ( lmp_obj_header -> class_num ) { case LMP_OBJ_CC_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Control<S2SV_blank>Channel<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_LINK_ID : case LMP_OBJ_INTERFACE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4_LOC : case LMP_CTYPE_IPV4_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv4<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_IPV6_LOC : case LMP_CTYPE_IPV6_RMT : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>IPv6<S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_UNMD_LOC : case LMP_CTYPE_UNMD_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Link<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_MESSAGE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; case LMP_CTYPE_2 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Message<S2SV_blank>ID<S2SV_blank>Ack:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_NODE_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_LOC : case LMP_CTYPE_RMT : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Node<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr ) , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO_CONFIG : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Interval:<S2SV_blank>%u\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Hello<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_HELLO : switch ( lmp_obj_ctype ) { case LMP_CTYPE_HELLO : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tx<S2SV_blank>Seq:<S2SV_blank>%u,<S2SV_blank>Rx<S2SV_blank>Seq:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_TE_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen != 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen != 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_te_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Link-ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_DATA_LINK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ipaddr_string ( ndo , obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_IPV6 : if ( obj_tlen < 36 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , ip6addr_string ( ndo , obj_tptr + 20 ) , EXTRACT_32BITS ( obj_tptr + 20 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 36 , 36 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; case LMP_CTYPE_UNMD : if ( obj_tlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>[%s]"" , bittok2str ( lmp_obj_data_link_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Remote<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 4 ) , EXTRACT_32BITS ( obj_tptr + 8 ) , EXTRACT_32BITS ( obj_tptr + 8 ) ) ) ; <S2SV_StartBug> if ( lmp_print_data_link_subobjs ( ndo , obj_tptr , obj_tlen - 12 , 12 ) ) <S2SV_EndBug> hexdump = TRUE ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_flag_values , ""none"" , EXTRACT_16BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Interval:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Data<S2SV_blank>links:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>type:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( obj_tptr + 8 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Mechanism:<S2SV_blank>%u<S2SV_blank>(0x%x)%s"" , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) , EXTRACT_16BITS ( obj_tptr + 10 ) & 8000 ? ""<S2SV_blank>(Payload<S2SV_blank>test<S2SV_blank>messages<S2SV_blank>capable)"" : """" ) ) ; bw . i = EXTRACT_32BITS ( obj_tptr + 12 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Transmission<S2SV_blank>Rate:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr + 16 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_BEGIN_ACK : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Dead<S2SV_blank>Interval:<S2SV_blank>%u"" ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>Transport<S2SV_blank>Response:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr ) , EXTRACT_16BITS ( obj_tptr + 2 ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_VERIFY_ID : switch ( lmp_obj_ctype ) { case LMP_CTYPE_1 : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>ID:<S2SV_blank>%u"" , EXTRACT_32BITS ( obj_tptr ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 20 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 16 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 16 ) & 0x3FFFFFF ) ) ; offset += 20 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 8 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Active:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ? ""Allocated"" : ""Non-allocated"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 31 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Direction:<S2SV_blank>%s<S2SV_blank>(%u)"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ? ""Transmit"" : ""Receive"" , ( EXTRACT_32BITS ( obj_tptr + offset + 4 ) >> 30 ) & 0x1 ) ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Channel<S2SV_blank>Status:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_obj_channel_status_values , ""Unknown"" , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) , EXTRACT_32BITS ( obj_tptr + offset + 4 ) & 0x3FFFFFF ) ) ; offset += 8 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_CHANNEL_STATUS_REQ : switch ( lmp_obj_ctype ) { case LMP_CTYPE_IPV4 : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; case LMP_CTYPE_IPV6 : offset = 0 ; while ( offset + 16 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ip6addr_string ( ndo , obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 16 ; } break ; case LMP_CTYPE_UNMD : offset = 0 ; while ( offset + 4 <= obj_tlen ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%u<S2SV_blank>(0x%08x)"" , EXTRACT_32BITS ( obj_tptr + offset ) , EXTRACT_32BITS ( obj_tptr + offset ) ) ) ; offset += 4 ; } break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_ERROR_CODE : switch ( lmp_obj_ctype ) { case LMP_CTYPE_BEGIN_VERIFY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_begin_verify_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; case LMP_CTYPE_LINK_SUMMARY_ERROR : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>Code:<S2SV_blank>%s"" , bittok2str ( lmp_obj_link_summary_error_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; case LMP_OBJ_SERVICE_CONFIG : switch ( lmp_obj_ctype ) { case LMP_CTYPE_SERVICE_CONFIG_SP : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_sp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>UNI<S2SV_blank>Version:<S2SV_blank>%u"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_CPSA : if ( obj_tlen != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } link_type = EXTRACT_8BITS ( obj_tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Link<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_link_type_values , ""Unknown"" , link_type ) , link_type ) ) ; switch ( link_type ) { case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SDH : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sdh_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; case LMP_SD_SERVICE_CONFIG_CPSA_LINK_TYPE_SONET : ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Signal<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( lmp_sd_service_config_cpsa_signal_type_sonet_values , ""Unknown"" , EXTRACT_8BITS ( obj_tptr + 1 ) ) , EXTRACT_8BITS ( obj_tptr + 1 ) ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_tp_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 2 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Contiguous<S2SV_blank>Concatenation<S2SV_blank>Types:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_cpsa_cct_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 4 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NCC:<S2SV_blank>%u"" , EXTRACT_16BITS ( obj_tptr + 6 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Minimum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 8 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Maximum<S2SV_blank>NVC:%u"" , EXTRACT_16BITS ( obj_tptr + 10 ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Local<S2SV_blank>Interface<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , obj_tptr + 12 ) , EXTRACT_32BITS ( obj_tptr + 12 ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_TRANSPARENCY_TCM : if ( obj_tlen != 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Transparency<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_transparency_flag_values , ""none"" , EXTRACT_32BITS ( obj_tptr ) ) ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>TCM<S2SV_blank>Monitoring<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_tcm_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 7 ) ) ) ) ; break ; case LMP_CTYPE_SERVICE_CONFIG_NETWORK_DIVERSITY : if ( obj_tlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(not<S2SV_blank>correct<S2SV_blank>for<S2SV_blank>object)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank>Diversity:<S2SV_blank>Flags:<S2SV_blank>%s"" , bittok2str ( lmp_obj_service_config_nsa_network_diversity_flag_values , ""none"" , EXTRACT_8BITS ( obj_tptr + 3 ) ) ) ) ; break ; default : hexdump = TRUE ; } break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , obj_tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , obj_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct lmp_object_header ) , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , lmp_obj_len - sizeof ( struct lmp_object_header ) ) ; tptr += lmp_obj_len ; tlen -= lmp_obj_len ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot"" ) ) ; }
","<S2SV_ModStart> ; int hexdump , ret <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 36 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE <S2SV_ModStart> ) ) ; ret = <S2SV_ModEnd> lmp_print_data_link_subobjs ( ndo <S2SV_ModStart> , 12 ) ; if ( ret == - 1 ) goto trunc ; if ( ret == TRUE
",the-tcpdump-group@tcpdump/d97e94223720684c6aa740ff219e0d19426c2220,CVE-2018-14464,https://github.com/the-tcpdump-group/tcpdump/commit/d97e94223720684c6aa740ff219e0d19426c2220,2019-10-03T16:15Z
CWE-362,"CWE-362 int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>slot<S2SV_blank>for<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>(range<S2SV_blank>0-%i),<S2SV_blank>error:<S2SV_blank>%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices ) ; init_rwsem ( & card -> controls_rwsem ) ; rwlock_init ( & card -> ctl_files_rwlock ) ; <S2SV_StartBug> INIT_LIST_HEAD ( & card -> controls ) ; <S2SV_EndBug> INIT_LIST_HEAD ( & card -> ctl_files ) ; spin_lock_init ( & card -> files_lock ) ; INIT_LIST_HEAD ( & card -> files_list ) ; # ifdef CONFIG_PM mutex_init ( & card -> power_lock ) ; init_waitqueue_head ( & card -> power_sleep ) ; # endif device_initialize ( & card -> card_dev ) ; card -> card_dev . parent = parent ; card -> card_dev . class = sound_class ; card -> card_dev . release = release_card_device ; card -> card_dev . groups = card_dev_attr_groups ; err = kobject_set_name ( & card -> card_dev . kobj , ""card%d"" , idx ) ; if ( err < 0 ) goto __error ; err = snd_ctl_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>control<S2SV_blank>minors\\n"" ) ; goto __error ; } err = snd_info_card_create ( card ) ; if ( err < 0 ) { dev_err ( parent , ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>card<S2SV_blank>info\\n"" ) ; goto __error_ctl ; } * card_ret = card ; return 0 ; __error_ctl : snd_device_free_all ( card ) ; __error : put_device ( & card -> card_dev ) ; return err ; }
","<S2SV_ModStart> ctl_files_rwlock ) ; mutex_init ( & card -> user_ctl_lock ) ;
",torvalds@linux/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,CVE-2014-4652,https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92,2014-07-03T04:22Z
CWE-863,"CWE-863 static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; if ( * pos != '\\0' ) goto out ; if ( ( extent . first == ( u32 ) - 1 ) || ( extent . lower_first == ( u32 ) - 1 ) ) goto out ; if ( ( extent . first + extent . count ) <= extent . first ) goto out ; if ( ( extent . lower_first + extent . count ) <= extent . lower_first ) goto out ; if ( mappings_overlap ( & new_map , & extent ) ) goto out ; if ( ( new_map . nr_extents + 1 ) == UID_GID_MAP_MAX_EXTENTS && ( next_line != NULL ) ) goto out ; ret = insert_extent ( & new_map , & extent ) ; if ( ret < 0 ) goto out ; ret = - EINVAL ; } if ( new_map . nr_extents == 0 ) goto out ; ret = - EPERM ; <S2SV_StartBug> if ( ! new_idmap_permitted ( file , ns , cap_setid , & new_map ) ) <S2SV_EndBug> goto out ; ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ; ret = - EPERM ; for ( idx = 0 ; idx < new_map . nr_extents ; idx ++ ) { struct uid_gid_extent * e ; u32 lower_first ; if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) e = & new_map . extent [ idx ] ; else e = & new_map . forward [ idx ] ; lower_first = map_id_range_down ( parent_map , e -> lower_first , e -> count ) ; if ( lower_first == ( u32 ) - 1 ) goto out ; e -> lower_first = lower_first ; } <S2SV_StartBug> if ( new_map . nr_extents <= UID_GID_MAP_MAX_BASE_EXTENTS ) { <S2SV_EndBug> memcpy ( map -> extent , new_map . extent , new_map . nr_extents * sizeof ( new_map . extent [ 0 ] ) ) ; } else { map -> forward = new_map . forward ; map -> reverse = new_map . reverse ; } smp_wmb ( ) ; map -> nr_extents = new_map . nr_extents ; * ppos = count ; ret = count ; out : if ( ret < 0 && new_map . nr_extents > UID_GID_MAP_MAX_BASE_EXTENTS ) { kfree ( new_map . forward ) ; kfree ( new_map . reverse ) ; map -> forward = NULL ; map -> reverse = NULL ; map -> nr_extents = 0 ; } mutex_unlock ( & userns_state_mutex ) ; kfree ( kbuf ) ; return ret ; }
","<S2SV_ModStart> & new_map ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> lower_first ; } ret = sort_idmaps ( & new_map ) ; if ( ret < 0 ) goto out ;
",torvalds@linux/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,CVE-2018-18955,https://github.com/torvalds/linux/commit/d2f007dbe7e4c9583eea6eb04d60001e85c6f1bd,2018-11-16T20:29Z
CWE-119,"CWE-119 static inline struct futex_hash_bucket * queue_lock ( struct futex_q * q ) { <S2SV_StartBug> struct futex_hash_bucket * hb ; <S2SV_EndBug> get_futex_key_refs ( & q -> key ) ; hb = hash_futex ( & q -> key ) ; q -> lock_ptr = & hb -> lock ; spin_lock ( & hb -> lock ) ; return hb ; }
","<S2SV_ModStart> futex_hash_bucket * hb <S2SV_ModEnd> ; hb =
",torvalds@linux/7ada876a8703f23befbb20a7465a702ee39b1704,CVE-2014-0205,https://github.com/torvalds/linux/commit/7ada876a8703f23befbb20a7465a702ee39b1704,2014-09-28T19:55Z
CWE-119,"CWE-119 ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ( ( char * ) buf ) + offs , len ) ; }
","<S2SV_ModStart> id ) { size_t ss = <S2SV_ModEnd> CDF_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> ( off_t ) pos , <S2SV_ModEnd> ( ( char
",glensc@file/1859fdb4e67c49c463c4e0078054335cd46ba295,CVE-2012-1571,https://github.com/glensc/file/commit/1859fdb4e67c49c463c4e0078054335cd46ba295,2012-07-17T21:55Z
CWE-119,"CWE-119 static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
","<S2SV_ModStart> x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
",erikd@libsndfile/708e996c87c5fae77b104ccfeb8f6db784c32074,CVE-2017-7586,https://github.com/erikd/libsndfile/commit/708e996c87c5fae77b104ccfeb8f6db784c32074,2017-04-07T20:59Z
CWE-200,"CWE-200 static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; <S2SV_StartBug> strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ; <S2SV_EndBug> return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }
","<S2SV_ModStart> ) ) ; nla_strlcpy <S2SV_ModEnd> ( link_info . <S2SV_ModStart> TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME
",torvalds@linux/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,CVE-2016-5243,https://github.com/torvalds/linux/commit/5d2be1422e02ccd697ccfcd45c85b4a26e6178e2,2016-06-27T10:59Z
CWE-120,"CWE-120 int lldp_decode ( struct lldpd * cfg , char * frame , int s , struct lldpd_hardware * hardware , struct lldpd_chassis * * newchassis , struct lldpd_port * * newport ) { struct lldpd_chassis * chassis ; struct lldpd_port * port ; const char lldpaddr [ ] = LLDP_MULTICAST_ADDR ; const char dot1 [ ] = LLDP_TLV_ORG_DOT1 ; const char dot3 [ ] = LLDP_TLV_ORG_DOT3 ; const char med [ ] = LLDP_TLV_ORG_MED ; const char dcbx [ ] = LLDP_TLV_ORG_DCBX ; unsigned char orgid [ 3 ] ; int length , gotend = 0 , ttl_received = 0 ; int tlv_size , tlv_type , tlv_subtype ; u_int8_t * pos , * tlv ; char * b ; # ifdef ENABLE_DOT1 struct lldpd_vlan * vlan = NULL ; int vlan_len ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi = NULL ; # endif struct lldpd_mgmt * mgmt ; int af ; u_int8_t addr_str_length , addr_str_buffer [ 32 ] ; u_int8_t addr_family , addr_length , * addr_ptr , iface_subtype ; u_int32_t iface_number , iface ; # ifdef ENABLE_CUSTOM struct lldpd_custom * custom = NULL ; # endif log_debug ( ""lldp"" , ""receive<S2SV_blank>LLDP<S2SV_blank>PDU<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; if ( ( chassis = calloc ( 1 , sizeof ( struct lldpd_chassis ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>chassis"" ) ; return - 1 ; } TAILQ_INIT ( & chassis -> c_mgmt ) ; if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>remote<S2SV_blank>port"" ) ; free ( chassis ) ; return - 1 ; } # ifdef ENABLE_DOT1 TAILQ_INIT ( & port -> p_vlans ) ; TAILQ_INIT ( & port -> p_ppvids ) ; TAILQ_INIT ( & port -> p_pids ) ; # endif # ifdef ENABLE_CUSTOM TAILQ_INIT ( & port -> p_custom_list ) ; # endif length = s ; pos = ( u_int8_t * ) frame ; if ( length < 2 * ETHER_ADDR_LEN + sizeof ( u_int16_t ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>short<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( PEEK_CMP ( lldpaddr , ETHER_ADDR_LEN ) != 0 ) { log_info ( ""lldp"" , ""frame<S2SV_blank>not<S2SV_blank>targeted<S2SV_blank>at<S2SV_blank>LLDP<S2SV_blank>multicast<S2SV_blank>address<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_DISCARD ( ETHER_ADDR_LEN ) ; if ( PEEK_UINT16 != ETHERTYPE_LLDP ) { log_info ( ""lldp"" , ""non<S2SV_blank>LLDP<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } while ( length && ( ! gotend ) ) { if ( length < 2 ) { log_warnx ( ""lldp"" , ""tlv<S2SV_blank>header<S2SV_blank>too<S2SV_blank>short<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } tlv_size = PEEK_UINT16 ; tlv_type = tlv_size >> 9 ; tlv_size = tlv_size & 0x1ff ; ( void ) PEEK_SAVE ( tlv ) ; if ( length < tlv_size ) { log_warnx ( ""lldp"" , ""frame<S2SV_blank>too<S2SV_blank>short<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } switch ( tlv_type ) { case LLDP_TLV_END : if ( tlv_size != 0 ) { log_warnx ( ""lldp"" , ""lldp<S2SV_blank>end<S2SV_blank>received<S2SV_blank>with<S2SV_blank>size<S2SV_blank>not<S2SV_blank>null<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( length ) log_debug ( ""lldp"" , ""extra<S2SV_blank>data<S2SV_blank>after<S2SV_blank>lldp<S2SV_blank>end<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; gotend = 1 ; break ; case LLDP_TLV_CHASSIS_ID : case LLDP_TLV_PORT_ID : CHECK_TLV_SIZE ( 2 , ""Port<S2SV_blank>Id"" ) ; tlv_subtype = PEEK_UINT8 ; if ( ( tlv_subtype == 0 ) || ( tlv_subtype > 7 ) ) { log_warnx ( ""lldp"" , ""unknown<S2SV_blank>subtype<S2SV_blank>for<S2SV_blank>tlv<S2SV_blank>id<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size - 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>id<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 1 ) ; if ( tlv_type == LLDP_TLV_PORT_ID ) { port -> p_id_subtype = tlv_subtype ; port -> p_id = b ; port -> p_id_len = tlv_size - 1 ; } else { chassis -> c_id_subtype = tlv_subtype ; chassis -> c_id = b ; chassis -> c_id_len = tlv_size - 1 ; } break ; case LLDP_TLV_TTL : CHECK_TLV_SIZE ( 2 , ""TTL"" ) ; chassis -> c_ttl = PEEK_UINT16 ; ttl_received = 1 ; break ; case LLDP_TLV_PORT_DESCR : case LLDP_TLV_SYSTEM_NAME : case LLDP_TLV_SYSTEM_DESCR : if ( tlv_size < 1 ) { log_debug ( ""lldp"" , ""empty<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( b = ( char * ) calloc ( 1 , tlv_size + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>string<S2SV_blank>tlv<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size ) ; if ( tlv_type == LLDP_TLV_PORT_DESCR ) port -> p_descr = b ; else if ( tlv_type == LLDP_TLV_SYSTEM_NAME ) chassis -> c_name = b ; else chassis -> c_descr = b ; break ; case LLDP_TLV_SYSTEM_CAP : CHECK_TLV_SIZE ( 4 , ""System<S2SV_blank>capabilities"" ) ; chassis -> c_cap_available = PEEK_UINT16 ; chassis -> c_cap_enabled = PEEK_UINT16 ; break ; case LLDP_TLV_MGMT_ADDR : CHECK_TLV_SIZE ( 1 , ""Management<S2SV_blank>address"" ) ; addr_str_length = PEEK_UINT8 ; <S2SV_StartBug> CHECK_TLV_SIZE ( 1 + addr_str_length , ""Management<S2SV_blank>address"" ) ; <S2SV_EndBug> PEEK_BYTES ( addr_str_buffer , addr_str_length ) ; addr_length = addr_str_length - 1 ; addr_family = addr_str_buffer [ 0 ] ; addr_ptr = & addr_str_buffer [ 1 ] ; CHECK_TLV_SIZE ( 1 + addr_str_length + 5 , ""Management<S2SV_blank>address"" ) ; iface_subtype = PEEK_UINT8 ; iface_number = PEEK_UINT32 ; af = lldpd_af_from_lldp_proto ( addr_family ) ; if ( af == LLDPD_AF_UNSPEC ) break ; if ( iface_subtype == LLDP_MGMT_IFACE_IFINDEX ) iface = iface_number ; else iface = 0 ; mgmt = lldpd_alloc_mgmt ( af , addr_ptr , addr_length , iface ) ; if ( mgmt == NULL ) { assert ( errno == ENOMEM ) ; log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>management<S2SV_blank>address"" ) ; goto malformed ; } TAILQ_INSERT_TAIL ( & chassis -> c_mgmt , mgmt , m_entries ) ; break ; case LLDP_TLV_ORG : <S2SV_StartBug> CHECK_TLV_SIZE ( 4 , ""Organisational"" ) ; <S2SV_EndBug> PEEK_BYTES ( orgid , sizeof ( orgid ) ) ; tlv_subtype = PEEK_UINT8 ; if ( memcmp ( dot1 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT1 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT1_VLANNAME : CHECK_TLV_SIZE ( 7 , ""VLAN"" ) ; if ( ( vlan = ( struct lldpd_vlan * ) calloc ( 1 , sizeof ( struct lldpd_vlan ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } vlan -> v_vid = PEEK_UINT16 ; vlan_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 7 + vlan_len , ""VLAN"" ) ; if ( ( vlan -> v_name = ( char * ) calloc ( 1 , vlan_len + 1 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>vlan<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( vlan -> v_name , vlan_len ) ; TAILQ_INSERT_TAIL ( & port -> p_vlans , vlan , v_entries ) ; vlan = NULL ; break ; case LLDP_TLV_DOT1_PVID : CHECK_TLV_SIZE ( 6 , ""PVID"" ) ; port -> p_pvid = PEEK_UINT16 ; break ; case LLDP_TLV_DOT1_PPVID : CHECK_TLV_SIZE ( 7 , ""PPVID"" ) ; if ( ( ppvid = ( struct lldpd_ppvid * ) calloc ( 1 , sizeof ( struct lldpd_ppvid ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>ppvid<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } ppvid -> p_cap_status = PEEK_UINT8 ; ppvid -> p_ppvid = PEEK_UINT16 ; TAILQ_INSERT_TAIL ( & port -> p_ppvids , ppvid , p_entries ) ; break ; case LLDP_TLV_DOT1_PI : CHECK_TLV_SIZE ( 5 , ""PI"" ) ; if ( ( pi = ( struct lldpd_pi * ) calloc ( 1 , sizeof ( struct lldpd_pi ) ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>PI<S2SV_blank>"" ""structure<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } pi -> p_pi_len = PEEK_UINT8 ; CHECK_TLV_SIZE ( 5 + pi -> p_pi_len , ""PI"" ) ; if ( ( pi -> p_pi = ( char * ) calloc ( 1 , pi -> p_pi_len ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>pid<S2SV_blank>name<S2SV_blank>for<S2SV_blank>"" ""tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( pi -> p_pi , pi -> p_pi_len ) ; TAILQ_INSERT_TAIL ( & port -> p_pids , pi , p_entries ) ; pi = NULL ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dot3 , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_DOT3 hardware -> h_rx_unrecognized_cnt ++ ; # else switch ( tlv_subtype ) { case LLDP_TLV_DOT3_MAC : CHECK_TLV_SIZE ( 9 , ""MAC/PHY"" ) ; port -> p_macphy . autoneg_support = PEEK_UINT8 ; port -> p_macphy . autoneg_enabled = ( port -> p_macphy . autoneg_support & 0x2 ) >> 1 ; port -> p_macphy . autoneg_support = port -> p_macphy . autoneg_support & 0x1 ; port -> p_macphy . autoneg_advertised = PEEK_UINT16 ; port -> p_macphy . mau_type = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_LA : CHECK_TLV_SIZE ( 9 , ""Link<S2SV_blank>aggregation"" ) ; PEEK_DISCARD_UINT8 ; port -> p_aggregid = PEEK_UINT32 ; break ; case LLDP_TLV_DOT3_MFS : CHECK_TLV_SIZE ( 6 , ""MFS"" ) ; port -> p_mfs = PEEK_UINT16 ; break ; case LLDP_TLV_DOT3_POWER : CHECK_TLV_SIZE ( 7 , ""Power"" ) ; port -> p_power . devicetype = PEEK_UINT8 ; port -> p_power . supported = ( port -> p_power . devicetype & 0x2 ) >> 1 ; port -> p_power . enabled = ( port -> p_power . devicetype & 0x4 ) >> 2 ; port -> p_power . paircontrol = ( port -> p_power . devicetype & 0x8 ) >> 3 ; port -> p_power . devicetype = ( port -> p_power . devicetype & 0x1 ) ? LLDP_DOT3_POWER_PSE : LLDP_DOT3_POWER_PD ; port -> p_power . pairs = PEEK_UINT8 ; port -> p_power . class = PEEK_UINT8 ; if ( tlv_size >= 12 ) { port -> p_power . powertype = PEEK_UINT8 ; port -> p_power . source = ( port -> p_power . powertype & ( 1 << 5 | 1 << 4 ) ) >> 4 ; port -> p_power . priority = ( port -> p_power . powertype & ( 1 << 1 | 1 << 0 ) ) ; port -> p_power . powertype = ( port -> p_power . powertype & ( 1 << 7 ) ) ? LLDP_DOT3_POWER_8023AT_TYPE1 : LLDP_DOT3_POWER_8023AT_TYPE2 ; port -> p_power . requested = PEEK_UINT16 ; port -> p_power . allocated = PEEK_UINT16 ; } else port -> p_power . powertype = LLDP_DOT3_POWER_8023AT_OFF ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( med , orgid , sizeof ( orgid ) ) == 0 ) { # ifndef ENABLE_LLDPMED hardware -> h_rx_unrecognized_cnt ++ ; # else u_int32_t policy ; unsigned loctype ; unsigned power ; switch ( tlv_subtype ) { case LLDP_TLV_MED_CAP : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>capabilities"" ) ; chassis -> c_med_cap_available = PEEK_UINT16 ; chassis -> c_med_type = PEEK_UINT8 ; port -> p_med_cap_enabled |= LLDP_MED_CAP_CAP ; break ; case LLDP_TLV_MED_POLICY : CHECK_TLV_SIZE ( 8 , ""LLDP-MED<S2SV_blank>policy"" ) ; policy = PEEK_UINT32 ; if ( ( ( policy >> 24 ) < 1 ) || ( ( policy >> 24 ) > LLDP_MED_APPTYPE_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>policy<S2SV_blank>field<S2SV_blank>%d<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , policy , hardware -> h_ifname ) ; break ; } port -> p_med_policy [ ( policy >> 24 ) - 1 ] . type = ( policy >> 24 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . unknown = ( ( policy & 0x800000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . tagged = ( ( policy & 0x400000 ) != 0 ) ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . vid = ( policy & 0x001FFE00 ) >> 9 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . priority = ( policy & 0x1C0 ) >> 6 ; port -> p_med_policy [ ( policy >> 24 ) - 1 ] . dscp = policy & 0x3F ; port -> p_med_cap_enabled |= LLDP_MED_CAP_POLICY ; break ; case LLDP_TLV_MED_LOCATION : CHECK_TLV_SIZE ( 5 , ""LLDP-MED<S2SV_blank>Location"" ) ; loctype = PEEK_UINT8 ; if ( ( loctype < 1 ) || ( loctype > LLDP_MED_LOCFORMAT_LAST ) ) { log_info ( ""lldp"" , ""unknown<S2SV_blank>location<S2SV_blank>type<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; break ; } if ( ( port -> p_med_location [ loctype - 1 ] . data = ( char * ) malloc ( tlv_size - 5 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>"" ""for<S2SV_blank>LLDP-MED<S2SV_blank>location<S2SV_blank>for<S2SV_blank>"" ""frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( port -> p_med_location [ loctype - 1 ] . data , tlv_size - 5 ) ; port -> p_med_location [ loctype - 1 ] . data_len = tlv_size - 5 ; port -> p_med_location [ loctype - 1 ] . format = loctype ; port -> p_med_cap_enabled |= LLDP_MED_CAP_LOCATION ; break ; case LLDP_TLV_MED_MDI : CHECK_TLV_SIZE ( 7 , ""LLDP-MED<S2SV_blank>PoE-MDI"" ) ; power = PEEK_UINT8 ; switch ( power & 0xC0 ) { case 0x0 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PSE ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PSE ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PRIMARY ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BACKUP ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_RESERVED ; } break ; case 0x40 : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_PD ; port -> p_med_cap_enabled |= LLDP_MED_CAP_MDI_PD ; switch ( power & 0x30 ) { case 0x0 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_UNKNOWN ; break ; case 0x10 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_PSE ; break ; case 0x20 : port -> p_med_power . source = LLDP_MED_POW_SOURCE_LOCAL ; break ; default : port -> p_med_power . source = LLDP_MED_POW_SOURCE_BOTH ; } break ; default : port -> p_med_power . devicetype = LLDP_MED_POW_TYPE_RESERVED ; } if ( ( power & 0x0F ) > LLDP_MED_POW_PRIO_LOW ) port -> p_med_power . priority = LLDP_MED_POW_PRIO_UNKNOWN ; else port -> p_med_power . priority = power & 0x0F ; port -> p_med_power . val = PEEK_UINT16 ; break ; case LLDP_TLV_MED_IV_HW : case LLDP_TLV_MED_IV_SW : case LLDP_TLV_MED_IV_FW : case LLDP_TLV_MED_IV_SN : case LLDP_TLV_MED_IV_MANUF : case LLDP_TLV_MED_IV_MODEL : case LLDP_TLV_MED_IV_ASSET : if ( tlv_size <= 4 ) b = NULL ; else { if ( ( b = ( char * ) malloc ( tlv_size - 3 ) ) == NULL ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>"" ""memory<S2SV_blank>for<S2SV_blank>LLDP-MED<S2SV_blank>"" ""inventory<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>"" ""received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } PEEK_BYTES ( b , tlv_size - 4 ) ; b [ tlv_size - 4 ] = '\\0' ; } switch ( tlv_subtype ) { case LLDP_TLV_MED_IV_HW : chassis -> c_med_hw = b ; break ; case LLDP_TLV_MED_IV_FW : chassis -> c_med_fw = b ; break ; case LLDP_TLV_MED_IV_SW : chassis -> c_med_sw = b ; break ; case LLDP_TLV_MED_IV_SN : chassis -> c_med_sn = b ; break ; case LLDP_TLV_MED_IV_MANUF : chassis -> c_med_manuf = b ; break ; case LLDP_TLV_MED_IV_MODEL : chassis -> c_med_model = b ; break ; case LLDP_TLV_MED_IV_ASSET : chassis -> c_med_asset = b ; break ; } port -> p_med_cap_enabled |= LLDP_MED_CAP_IV ; break ; default : hardware -> h_rx_unrecognized_cnt ++ ; } # endif } else if ( memcmp ( dcbx , orgid , sizeof ( orgid ) ) == 0 ) { log_debug ( ""lldp"" , ""unsupported<S2SV_blank>DCBX<S2SV_blank>tlv<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>ignore"" , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; } else { log_debug ( ""lldp"" , ""unknown<S2SV_blank>org<S2SV_blank>tlv<S2SV_blank>[%02x:%02x:%02x]<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , orgid [ 0 ] , orgid [ 1 ] , orgid [ 2 ] , hardware -> h_ifname ) ; hardware -> h_rx_unrecognized_cnt ++ ; # ifdef ENABLE_CUSTOM custom = ( struct lldpd_custom * ) calloc ( 1 , sizeof ( struct lldpd_custom ) ) ; if ( ! custom ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV"" ) ; goto malformed ; } custom -> oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0 ; memcpy ( custom -> oui , orgid , sizeof ( custom -> oui ) ) ; custom -> subtype = tlv_subtype ; if ( custom -> oui_info_len > 0 ) { custom -> oui_info = malloc ( custom -> oui_info_len ) ; if ( ! custom -> oui_info ) { log_warn ( ""lldp"" , ""unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>custom<S2SV_blank>TLV<S2SV_blank>data"" ) ; goto malformed ; } PEEK_BYTES ( custom -> oui_info , custom -> oui_info_len ) ; } TAILQ_INSERT_TAIL ( & port -> p_custom_list , custom , next ) ; custom = NULL ; # endif } break ; default : log_warnx ( ""lldp"" , ""unknown<S2SV_blank>tlv<S2SV_blank>(%d)<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , tlv_type , hardware -> h_ifname ) ; goto malformed ; } if ( pos > tlv + tlv_size ) { log_warnx ( ""lldp"" , ""BUG:<S2SV_blank>already<S2SV_blank>past<S2SV_blank>TLV!"" ) ; goto malformed ; } PEEK_DISCARD ( tlv + tlv_size - pos ) ; } if ( ( chassis -> c_id == NULL ) || ( port -> p_id == NULL ) || ( ! ttl_received ) || ( gotend == 0 ) ) { log_warnx ( ""lldp"" , ""some<S2SV_blank>mandatory<S2SV_blank>tlv<S2SV_blank>are<S2SV_blank>missing<S2SV_blank>for<S2SV_blank>frame<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } * newchassis = chassis ; * newport = port ; return 1 ; malformed : # ifdef ENABLE_CUSTOM free ( custom ) ; # endif # ifdef ENABLE_DOT1 free ( vlan ) ; free ( pi ) ; # endif lldpd_chassis_cleanup ( chassis , 1 ) ; lldpd_port_cleanup ( port , 1 ) ; free ( port ) ; return - 1 ; }
","<S2SV_ModStart> = PEEK_UINT8 ; if ( addr_str_length > sizeof ( addr_str_buffer ) ) { log_warnx ( ""lldp"" , ""too<S2SV_blank>large<S2SV_blank>management<S2SV_blank>address<S2SV_blank>on<S2SV_blank>%s"" , hardware -> h_ifname ) ; goto malformed ; } <S2SV_ModStart> : CHECK_TLV_SIZE ( 1 + ( int ) sizeof ( orgid ) <S2SV_ModEnd> , ""Organisational"" )
",vincentbernat@lldpd/dd4f16e7e816f2165fba76e3d162cd8d2978dcb2,CVE-2015-8011,https://github.com/vincentbernat/lldpd/commit/dd4f16e7e816f2165fba76e3d162cd8d2978dcb2,2020-01-28T19:15Z
CWE-20,"CWE-20 void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; struct stat stb ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerr ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpected<S2SV_blank>off_t/time_t<S2SV_blank>size"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguous<S2SV_blank>target"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; if ( src != NULL && ! iamrecursive && ! Tflag ) { if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>expand<S2SV_blank>pattern"" , __func__ ) ; } for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<S2SV_blank><newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lost<S2SV_blank>connection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:<S2SV_blank>%s"" , buf ) ; if ( buf [ 0 ] == '\\01' || buf [ 0 ] == '\\02' ) { if ( iamremote == 0 ) { ( void ) snmprintf ( visbuf , sizeof ( visbuf ) , NULL , ""%s"" , buf + 1 ) ; ( void ) atomicio ( vwrite , STDERR_FILENO , visbuf , strlen ( visbuf ) ) ; } if ( buf [ 0 ] == '\\02' ) exit ( 1 ) ; ++ errs ; continue ; } if ( buf [ 0 ] == 'E' ) { ( void ) atomicio ( vwrite , remout , """" , 1 ) ; goto done ; } if ( ch == '\\n' ) * -- cp = 0 ; cp = buf ; if ( * cp == 'T' ) { setimes ++ ; cp ++ ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mtime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; mtime . tv_sec = ull ; mtime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' || mtime . tv_usec < 0 || mtime . tv_usec > 999999 ) SCREWUP ( ""mtime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""atime.sec<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( time_t , ull ) ) setimes = 0 ; atime . tv_sec = ull ; atime . tv_usec = strtol ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '\\0' || atime . tv_usec < 0 || atime . tv_usec > 999999 ) SCREWUP ( ""atime.usec<S2SV_blank>not<S2SV_blank>delimited"" ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; continue ; } if ( * cp != 'C' && * cp != 'D' ) { if ( first ) { run_err ( ""%s"" , cp ) ; exit ( 1 ) ; } SCREWUP ( ""expected<S2SV_blank>control<S2SV_blank>record"" ) ; } mode = 0 ; for ( ++ cp ; cp < buf + 5 ; cp ++ ) { if ( * cp < '0' || * cp > '7' ) SCREWUP ( ""bad<S2SV_blank>mode"" ) ; mode = ( mode << 3 ) | ( * cp - '0' ) ; } if ( ! pflag ) mode &= ~ mask ; if ( * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""mode<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( ! isdigit ( ( unsigned char ) * cp ) ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>present"" ) ; ull = strtoull ( cp , & cp , 10 ) ; if ( ! cp || * cp ++ != '<S2SV_blank>' ) SCREWUP ( ""size<S2SV_blank>not<S2SV_blank>delimited"" ) ; if ( TYPE_OVERFLOW ( off_t , ull ) ) SCREWUP ( ""size<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range"" ) ; size = ( off_t ) ull ; if ( * cp == '\\0' || strchr ( cp , '/' ) != NULL || strcmp ( cp , ""."" ) == 0 || strcmp ( cp , "".."" ) == 0 ) { run_err ( ""error:<S2SV_blank>unexpected<S2SV_blank>filename:<S2SV_blank>%s"" , cp ) ; exit ( 1 ) ; } if ( npatterns > 0 ) { for ( n = 0 ; n < npatterns ; n ++ ) { if ( fnmatch ( patterns [ n ] , cp , 0 ) == 0 ) break ; } if ( n >= npatterns ) SCREWUP ( ""filename<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>request"" ) ; } if ( targisdir ) { static char * namebuf ; static size_t cursize ; size_t need ; need = strlen ( targ ) + strlen ( cp ) + 250 ; if ( need > cursize ) { free ( namebuf ) ; namebuf = xmalloc ( need ) ; cursize = need ; } ( void ) snprintf ( namebuf , need , ""%s%s%s"" , targ , strcmp ( targ , ""/"" ) ? ""/"" : """" , cp ) ; np = namebuf ; } else np = targ ; curfile = cp ; exists = stat ( np , & stb ) == 0 ; if ( buf [ 0 ] == 'D' ) { int mod_flag = pflag ; if ( ! iamrecursive ) SCREWUP ( ""received<S2SV_blank>directory<S2SV_blank>without<S2SV_blank>-r"" ) ; if ( exists ) { if ( ! S_ISDIR ( stb . st_mode ) ) { errno = ENOTDIR ; goto bad ; } if ( pflag ) ( void ) chmod ( np , mode ) ; } else { mod_flag = 1 ; if ( mkdir ( np , mode | S_IRWXU ) == - 1 ) goto bad ; } vect [ 0 ] = xstrdup ( np ) ; sink ( 1 , vect , src ) ; if ( setimes ) { setimes = 0 ; <S2SV_StartBug> if ( utimes ( vect [ 0 ] , tv ) == - 1 ) <S2SV_EndBug> run_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , vect [ 0 ] , strerror ( errno ) ) ; } if ( mod_flag ) ( void ) chmod ( vect [ 0 ] , mode ) ; free ( vect [ 0 ] ) ; continue ; } omode = mode ; mode |= S_IWUSR ; if ( ( ofd = open ( np , O_WRONLY | O_CREAT , mode ) ) == - 1 ) { bad : run_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; continue ; } ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( ( bp = allocbuf ( & buffer , ofd , COPY_BUFLEN ) ) == NULL ) { ( void ) close ( ofd ) ; continue ; } cp = bp -> buf ; wrerr = 0 ; statbytes = 0 ; if ( showprogress ) start_progress_meter ( curfile , size , & statbytes ) ; set_nonblock ( remin ) ; for ( count = i = 0 ; i < size ; i += bp -> cnt ) { amt = bp -> cnt ; if ( i + amt > size ) amt = size - i ; count += amt ; do { j = atomicio6 ( read , remin , cp , amt , scpio , & statbytes ) ; if ( j == 0 ) { run_err ( ""%s"" , j != EPIPE ? strerror ( errno ) : ""dropped<S2SV_blank>connection"" ) ; exit ( 1 ) ; } amt -= j ; cp += j ; } while ( amt > 0 ) ; if ( count == bp -> cnt ) { if ( ! wrerr ) { if ( atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } } count = 0 ; cp = bp -> buf ; } } unset_nonblock ( remin ) ; if ( count != 0 && ! wrerr && atomicio ( vwrite , ofd , bp -> buf , count ) != count ) { note_err ( ""%s:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; wrerr = 1 ; } if ( ! wrerr && ( ! exists || S_ISREG ( stb . st_mode ) ) && ftruncate ( ofd , size ) != 0 ) note_err ( ""%s:<S2SV_blank>truncate:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; if ( pflag ) { if ( exists || omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode ) ) { # else if ( chmod ( np , omode ) ) { # endif note_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; } } else { if ( ! exists && omode != mode ) # ifdef HAVE_FCHMOD if ( fchmod ( ofd , omode & ~ mask ) ) { # else if ( chmod ( np , omode & ~ mask ) ) { # endif note_err ( ""%s:<S2SV_blank>set<S2SV_blank>mode:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; } } if ( close ( ofd ) == - 1 ) note_err ( np , ""%s:<S2SV_blank>close:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; ( void ) response ( ) ; if ( showprogress ) stop_progress_meter ( ) ; if ( setimes && ! wrerr ) { setimes = 0 ; if ( utimes ( np , tv ) == - 1 ) { note_err ( ""%s:<S2SV_blank>set<S2SV_blank>times:<S2SV_blank>%s"" , np , strerror ( errno ) ) ; } } if ( note_err ( NULL ) == 0 ) ( void ) atomicio ( vwrite , remout , """" , 1 ) ; } done : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; return ; screwup : for ( n = 0 ; n < npatterns ; n ++ ) free ( patterns [ n ] ) ; free ( patterns ) ; run_err ( ""protocol<S2SV_blank>error:<S2SV_blank>%s"" , why ) ; exit ( 1 ) ; }
","<S2SV_ModStart> = 0 ; ( void ) <S2SV_ModEnd> utimes ( vect <S2SV_ModStart> ] , tv <S2SV_ModEnd> ) ; }
",openssh@openssh-portable/955854cafca88e0cdcd3d09ca1ad4ada465364a1,CVE-2020-12062,https://github.com/openssh/openssh-portable/commit/955854cafca88e0cdcd3d09ca1ad4ada465364a1,2020-06-01T16:15Z
CWE-399,"CWE-399 static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; <S2SV_StartBug> update_db_bp_intercept ( vcpu ) ; <S2SV_EndBug> }
","<S2SV_ModStart> X86_EFLAGS_RF ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/cbdb967af3d54993f5814f1cee0ed311a055377d,CVE-2015-8104,https://github.com/torvalds/linux/commit/cbdb967af3d54993f5814f1cee0ed311a055377d,2015-11-16T11:59Z
CWE-269,"CWE-269 static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
","<S2SV_ModStart> . mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
",torvalds@linux/a6138db815df5ee542d848318e5dae681590fccd,CVE-2014-5206,https://github.com/torvalds/linux/commit/a6138db815df5ee542d848318e5dae681590fccd,2014-08-18T11:15Z
CWE-119,"CWE-119 static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MaxTextExtent ] , implicit_vr [ MaxTextExtent ] , magick [ MaxTextExtent ] , photometric [ MaxTextExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , ""DICM"" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } ( void ) CopyMagickString ( photometric , ""MONOCHROME1<S2SV_blank>"" , MaxTextExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MaxTextExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strcmp ( implicit_vr , ""xs"" ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MaxTextExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strcmp ( implicit_vr , ""!!"" ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strcmp ( explicit_vr , ""OB"" ) == 0 ) || ( strcmp ( explicit_vr , ""UN"" ) == 0 ) || ( strcmp ( explicit_vr , ""OW"" ) == 0 ) || ( strcmp ( explicit_vr , ""SQ"" ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBLong ( image ) ; else datum = ( int ) ReadBlobLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBShort ( image ) ; else datum = ( int ) ReadBlobShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strcmp ( implicit_vr , ""SS"" ) == 0 ) || ( strcmp ( implicit_vr , ""US"" ) == 0 ) ) quantum = 2 ; else if ( ( strcmp ( implicit_vr , ""UL"" ) == 0 ) || ( strcmp ( implicit_vr , ""SL"" ) == 0 ) || ( strcmp ( implicit_vr , ""FL"" ) == 0 ) ) quantum = 4 ; else if ( strcmp ( implicit_vr , ""FD"" ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , ""0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)"" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""<S2SV_blank>%s"" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , "":<S2SV_blank>"" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ( int ) ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBShort ( image ) ; else datum = ( int ) ReadBlobShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ( int ) ReadBlobLSBLong ( image ) ; else datum = ( int ) ReadBlobLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""count=%d<S2SV_blank>quantum=%d<S2SV_blank>"" ""length=%d<S2SV_blank>group=%d\\n"" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MaxTextExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n"" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MaxTextExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""transfer_syntax=%s\\n"" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , ""1.2.840.10008.1.2"" , 17 ) == 0 ) { int subtype , type ; type = 0 ; subtype = 0 ; ( void ) sscanf ( transfer_syntax + 17 , "".%d.%d"" , & type , & subtype ) ; switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MaxTextExtent - 1 ) ; i ++ ) photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , ""MONOCHROME1<S2SV_blank>"" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : { number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , ""INVERSE"" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( ""dcm:"" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , ""<S2SV_blank>"" , """" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , ""%d\\n"" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , ""%d"" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , ""%c"" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , ""%c"" , '.' ) ; ( void ) FormatLocaleFile ( stdout , ""\\n"" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MaxTextExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , ""wb"" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , ""UnableToCreateTemporaryFile"" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""jpeg:%s"" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , ""j2k:%s"" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property ) ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; range = GetQuantumRange ( depth ) ; for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; <S2SV_StartBug> image -> colorspace = RGBColorspace ; <S2SV_EndBug> if ( ( image -> colormap == ( PixelPacket * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( Quantum ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( Quantum ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( Quantum ) index ; image -> colormap [ i ] . green = ( Quantum ) index ; image -> colormap [ i ] . blue = ( Quantum ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ( ( int ) ReadBlobLSBLong ( image ) ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 1 : { SetPixelGreen ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 2 : { SetPixelBlue ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } case 3 : { SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) ) ; break ; } default : break ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; LongPixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , ""dcm:display-range"" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , ""reset"" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = pixel_value ; if ( window_width == 0 ) { if ( signed_data == 1 ) index = pixel_value - 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) pixel_value <= window_min ) index = 0 ; else if ( ( ssize_t ) pixel_value > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( pixel_value - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; SetPixelIndex ( indexes + x , index ) ; pixel . red = 1U * image -> colormap [ index ] . red ; pixel . green = 1U * image -> colormap [ index ] . green ; pixel . blue = 1U * image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( q , pixel . red ) ; SetPixelGreen ( q , pixel . green ) ; SetPixelBlue ( q , pixel . blue ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ( int ) ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = pixel_value ; if ( window_width == 0 ) { if ( signed_data == 1 ) index = pixel_value - 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) pixel_value <= window_min ) index = 0 ; else if ( ( ssize_t ) pixel_value > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( pixel_value - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index ) ; SetPixelIndex ( indexes + x , ( ( ( size_t ) GetPixelIndex ( indexes + x ) ) | ( ( ( size_t ) index ) << 8 ) ) ) ; pixel . red = 1U * image -> colormap [ index ] . red ; pixel . green = 1U * image -> colormap [ index ] . green ; pixel . blue = 1U * image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( q , ( ( ( size_t ) GetPixelRed ( q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) ) ; SetPixelGreen ( q , ( ( ( size_t ) GetPixelGreen ( q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) ) ; SetPixelBlue ( q , ( ( ( size_t ) GetPixelBlue ( q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( IsGrayImage ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> = depth ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; break ; }
",ImageMagick@ImageMagick/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,CVE-2016-10066,https://github.com/ImageMagick/ImageMagick/commit/f6e9d0d9955e85bdd7540b251cd50d598dacc5e6,2017-03-03T17:59Z
CWE-120,"CWE-120 int mwifiex_cmd_802_11_ad_hoc_start ( struct mwifiex_private * priv , struct host_cmd_ds_command * cmd , struct cfg80211_ssid * req_ssid ) { int rsn_ie_len = 0 ; struct mwifiex_adapter * adapter = priv -> adapter ; struct host_cmd_ds_802_11_ad_hoc_start * adhoc_start = & cmd -> params . adhoc_start ; struct mwifiex_bssdescriptor * bss_desc ; u32 cmd_append_size = 0 ; u32 i ; u16 tmp_cap ; struct mwifiex_ie_types_chan_list_param_set * chan_tlv ; u8 radio_type ; struct mwifiex_ie_types_htcap * ht_cap ; struct mwifiex_ie_types_htinfo * ht_info ; u8 * pos = ( u8 * ) adhoc_start + sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) ; if ( ! adapter ) return - 1 ; cmd -> command = cpu_to_le16 ( HostCmd_CMD_802_11_AD_HOC_START ) ; bss_desc = & priv -> curr_bss_params . bss_descriptor ; priv -> attempted_bss_desc = bss_desc ; <S2SV_StartBug> memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; <S2SV_EndBug> memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>SSID<S2SV_blank>=<S2SV_blank>%s\\n"" , adhoc_start -> ssid ) ; memset ( bss_desc -> ssid . ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; memcpy ( bss_desc -> ssid . ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; bss_desc -> ssid . ssid_len = req_ssid -> ssid_len ; adhoc_start -> bss_mode = HostCmd_BSS_MODE_IBSS ; bss_desc -> bss_mode = NL80211_IFTYPE_ADHOC ; adhoc_start -> beacon_period = cpu_to_le16 ( priv -> beacon_period ) ; bss_desc -> beacon_period = priv -> beacon_period ; # define DS_PARA_IE_ID 3 # define DS_PARA_IE_LEN 1 adhoc_start -> phy_param_set . ds_param_set . element_id = DS_PARA_IE_ID ; adhoc_start -> phy_param_set . ds_param_set . len = DS_PARA_IE_LEN ; if ( ! mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , ( u16 ) priv -> adhoc_channel , 0 ) ) { struct mwifiex_chan_freq_power * cfp ; cfp = mwifiex_get_cfp ( priv , adapter -> adhoc_start_band , FIRST_VALID_CHANNEL , 0 ) ; if ( cfp ) priv -> adhoc_channel = ( u8 ) cfp -> channel ; } if ( ! priv -> adhoc_channel ) { mwifiex_dbg ( adapter , ERROR , ""ADHOC_S_CMD:<S2SV_blank>adhoc_channel<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>0\\n"" ) ; return - 1 ; } mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>creating<S2SV_blank>ADHOC<S2SV_blank>on<S2SV_blank>channel<S2SV_blank>%d\\n"" , priv -> adhoc_channel ) ; priv -> curr_bss_params . bss_descriptor . channel = priv -> adhoc_channel ; priv -> curr_bss_params . band = adapter -> adhoc_start_band ; bss_desc -> channel = priv -> adhoc_channel ; adhoc_start -> phy_param_set . ds_param_set . current_chan = priv -> adhoc_channel ; memcpy ( & bss_desc -> phy_param_set , & adhoc_start -> phy_param_set , sizeof ( union ieee_types_phy_param_set ) ) ; # define IBSS_PARA_IE_ID 6 # define IBSS_PARA_IE_LEN 2 adhoc_start -> ss_param_set . ibss_param_set . element_id = IBSS_PARA_IE_ID ; adhoc_start -> ss_param_set . ibss_param_set . len = IBSS_PARA_IE_LEN ; adhoc_start -> ss_param_set . ibss_param_set . atim_window = cpu_to_le16 ( priv -> atim_window ) ; memcpy ( & bss_desc -> ss_param_set , & adhoc_start -> ss_param_set , sizeof ( union ieee_types_ss_param_set ) ) ; bss_desc -> cap_info_bitmap |= WLAN_CAPABILITY_IBSS ; tmp_cap = WLAN_CAPABILITY_IBSS ; if ( priv -> sec_info . encryption_mode ) { mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>set<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>WEP\\n"" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_8021X_WEP ; tmp_cap |= WLAN_CAPABILITY_PRIVACY ; } else { mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>wep_status<S2SV_blank>NOT<S2SV_blank>set,\\t"" ""setting<S2SV_blank>privacy<S2SV_blank>to<S2SV_blank>ACCEPT<S2SV_blank>ALL\\n"" ) ; bss_desc -> privacy = MWIFIEX_802_11_PRIV_FILTER_ACCEPT_ALL ; } memset ( adhoc_start -> data_rate , 0 , sizeof ( adhoc_start -> data_rate ) ) ; mwifiex_get_active_data_rates ( priv , adhoc_start -> data_rate ) ; if ( ( adapter -> adhoc_start_band & BAND_G ) && ( priv -> curr_pkt_filter & HostCmd_ACT_MAC_ADHOC_G_PROTECTION_ON ) ) { if ( mwifiex_send_cmd ( priv , HostCmd_CMD_MAC_CONTROL , HostCmd_ACT_GEN_SET , 0 , & priv -> curr_pkt_filter , false ) ) { mwifiex_dbg ( adapter , ERROR , ""ADHOC_S_CMD:<S2SV_blank>G<S2SV_blank>Protection<S2SV_blank>config<S2SV_blank>failed\\n"" ) ; return - 1 ; } } for ( i = 0 ; i < sizeof ( adhoc_start -> data_rate ) ; i ++ ) if ( ! adhoc_start -> data_rate [ i ] ) break ; priv -> curr_bss_params . num_of_rates = i ; memcpy ( & priv -> curr_bss_params . data_rates , & adhoc_start -> data_rate , priv -> curr_bss_params . num_of_rates ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>rates=%4ph\\n"" , adhoc_start -> data_rate ) ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>AD-HOC<S2SV_blank>Start<S2SV_blank>command<S2SV_blank>is<S2SV_blank>ready\\n"" ) ; if ( IS_SUPPORT_MULTI_BANDS ( adapter ) ) { chan_tlv = ( struct mwifiex_ie_types_chan_list_param_set * ) pos ; chan_tlv -> header . type = cpu_to_le16 ( TLV_TYPE_CHANLIST ) ; chan_tlv -> header . len = cpu_to_le16 ( sizeof ( struct mwifiex_chan_scan_param_set ) ) ; memset ( chan_tlv -> chan_scan_param , 0x00 , sizeof ( struct mwifiex_chan_scan_param_set ) ) ; chan_tlv -> chan_scan_param [ 0 ] . chan_number = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Chan<S2SV_blank>=<S2SV_blank>%d\\n"" , chan_tlv -> chan_scan_param [ 0 ] . chan_number ) ; chan_tlv -> chan_scan_param [ 0 ] . radio_type = mwifiex_band_to_radio_type ( priv -> curr_bss_params . band ) ; if ( adapter -> adhoc_start_band & BAND_GN || adapter -> adhoc_start_band & BAND_AN ) { if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_ABOVE ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_ABOVE << 4 ) ; else if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_BELOW ) chan_tlv -> chan_scan_param [ 0 ] . radio_type |= ( IEEE80211_HT_PARAM_CHA_SEC_BELOW << 4 ) ; } mwifiex_dbg ( adapter , INFO , ""info:<S2SV_blank>ADHOC_S_CMD:<S2SV_blank>TLV<S2SV_blank>Band<S2SV_blank>=<S2SV_blank>%d\\n"" , chan_tlv -> chan_scan_param [ 0 ] . radio_type ) ; pos += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; cmd_append_size += sizeof ( chan_tlv -> header ) + sizeof ( struct mwifiex_chan_scan_param_set ) ; } cmd_append_size += mwifiex_cmd_append_vsie_tlv ( priv , MWIFIEX_VSIE_MASK_ADHOC , & pos ) ; if ( priv -> sec_info . wpa_enabled ) { rsn_ie_len = mwifiex_append_rsn_ie_wpa_wpa2 ( priv , & pos ) ; if ( rsn_ie_len == - 1 ) return - 1 ; cmd_append_size += rsn_ie_len ; } if ( adapter -> adhoc_11n_enabled ) { ht_cap = ( struct mwifiex_ie_types_htcap * ) pos ; memset ( ht_cap , 0 , sizeof ( struct mwifiex_ie_types_htcap ) ) ; ht_cap -> header . type = cpu_to_le16 ( WLAN_EID_HT_CAPABILITY ) ; ht_cap -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_cap ) ) ; radio_type = mwifiex_band_to_radio_type ( priv -> adapter -> config_bands ) ; mwifiex_fill_cap_info ( priv , radio_type , & ht_cap -> ht_cap ) ; if ( adapter -> sec_chan_offset == IEEE80211_HT_PARAM_CHA_SEC_NONE ) { u16 tmp_ht_cap ; tmp_ht_cap = le16_to_cpu ( ht_cap -> ht_cap . cap_info ) ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SUP_WIDTH_20_40 ; tmp_ht_cap &= ~ IEEE80211_HT_CAP_SGI_40 ; ht_cap -> ht_cap . cap_info = cpu_to_le16 ( tmp_ht_cap ) ; } pos += sizeof ( struct mwifiex_ie_types_htcap ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htcap ) ; ht_info = ( struct mwifiex_ie_types_htinfo * ) pos ; memset ( ht_info , 0 , sizeof ( struct mwifiex_ie_types_htinfo ) ) ; ht_info -> header . type = cpu_to_le16 ( WLAN_EID_HT_OPERATION ) ; ht_info -> header . len = cpu_to_le16 ( sizeof ( struct ieee80211_ht_operation ) ) ; ht_info -> ht_oper . primary_chan = ( u8 ) priv -> curr_bss_params . bss_descriptor . channel ; if ( adapter -> sec_chan_offset ) { ht_info -> ht_oper . ht_param = adapter -> sec_chan_offset ; ht_info -> ht_oper . ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY ; } ht_info -> ht_oper . operation_mode = cpu_to_le16 ( IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT ) ; ht_info -> ht_oper . basic_set [ 0 ] = 0xff ; pos += sizeof ( struct mwifiex_ie_types_htinfo ) ; cmd_append_size += sizeof ( struct mwifiex_ie_types_htinfo ) ; } cmd -> size = cpu_to_le16 ( ( u16 ) ( sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) + S_DS_GEN + cmd_append_size ) ) ; if ( adapter -> adhoc_start_band == BAND_B ) tmp_cap &= ~ WLAN_CAPABILITY_SHORT_SLOT_TIME ; else tmp_cap |= WLAN_CAPABILITY_SHORT_SLOT_TIME ; adhoc_start -> cap_info_bitmap = cpu_to_le16 ( tmp_cap ) ; return 0 ; }
","<S2SV_ModStart> , IEEE80211_MAX_SSID_LEN ) ; if ( req_ssid -> ssid_len > IEEE80211_MAX_SSID_LEN ) req_ssid -> ssid_len = IEEE80211_MAX_SSID_LEN
",torvalds@linux/5c455c5ab332773464d02ba17015acdca198f03d,CVE-2020-36158,https://github.com/torvalds/linux/commit/5c455c5ab332773464d02ba17015acdca198f03d,2021-01-05T05:15Z
CWE-119,"CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; <S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free
",ckolivas@cgminer/e1c5050734123973b99d181c45e74b2cbb00272e,CVE-2014-4501,https://github.com/ckolivas/cgminer/commit/e1c5050734123973b99d181c45e74b2cbb00272e,2014-07-23T14:55Z
CWE-000,"CWE-000 int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklisted<S2SV_blank>by<S2SV_blank>%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , ""usb%d"" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , ""eth%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , ""wlan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , ""wwan%d"" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , ""register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n"" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }
","<S2SV_ModStart> ; out1 : cancel_work_sync ( & dev -> kevent ) ; del_timer_sync ( & dev -> delay ) ;
",torvalds@linux/1666984c8625b3db19a9abc298931d35ab7bc64b,CVE-2016-3951,https://github.com/torvalds/linux/commit/1666984c8625b3db19a9abc298931d35ab7bc64b,2016-05-02T10:59Z
CWE-000,"CWE-000 int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { <S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }
","<S2SV_ModStart> if ( left == 0 && extend ) return 0 ; if ( left
",openssl@openssl/feba02f3919495e1b960c33ba849e10e77d0785d,CVE-2014-3571,https://github.com/openssl/openssl/commit/feba02f3919495e1b960c33ba849e10e77d0785d,2015-01-09T02:59Z
CWE-264,"CWE-264 int generic_permission ( struct inode * inode , int mask ) { int ret ; ret = acl_permission_check ( inode , mask ) ; if ( ret != - EACCES ) return ret ; if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; if ( ! ( mask & MAY_WRITE ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; } if ( ! ( mask & MAY_EXEC ) || ( inode -> i_mode & S_IXUGO ) ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_OVERRIDE ) ) <S2SV_EndBug> return 0 ; mask &= MAY_READ | MAY_WRITE | MAY_EXEC ; if ( mask == MAY_READ ) <S2SV_StartBug> if ( inode_capable ( inode , CAP_DAC_READ_SEARCH ) ) <S2SV_EndBug> return 0 ; return - EACCES ; }
","<S2SV_ModStart> { if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode , <S2SV_ModStart> ) if ( capable_wrt_inode_uidgid <S2SV_ModEnd> ( inode ,
",torvalds@linux/23adbe12ef7d3d4195e80800ab36b37bee28cd03,CVE-2014-4014,https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03,2014-06-23T11:21Z
CWE-119,"CWE-119 static void update_mbgraph_mb_stats ( VP9_COMP * cpi , MBGRAPH_MB_STATS * stats , YV12_BUFFER_CONFIG * buf , int mb_y_offset , YV12_BUFFER_CONFIG * golden_ref , <S2SV_StartBug> int_mv * prev_golden_ref_mv , <S2SV_EndBug> YV12_BUFFER_CONFIG * alt_ref , int mb_row , int mb_col ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; int intra_error ; VP9_COMMON * cm = & cpi -> common ; x -> plane [ 0 ] . src . buf = buf -> y_buffer + mb_y_offset ; x -> plane [ 0 ] . src . stride = buf -> y_stride ; xd -> plane [ 0 ] . dst . buf = get_frame_new_buffer ( cm ) -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . dst . stride = get_frame_new_buffer ( cm ) -> y_stride ; intra_error = find_best_16x16_intra ( cpi , & stats -> ref [ INTRA_FRAME ] . m . mode ) ; if ( intra_error <= 0 ) intra_error = 1 ; stats -> ref [ INTRA_FRAME ] . err = intra_error ; if ( golden_ref ) { int g_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = golden_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = golden_ref -> y_stride ; g_motion_error = do_16x16_motion_search ( cpi , prev_golden_ref_mv , & stats -> ref [ GOLDEN_FRAME ] . m . mv , mb_row , mb_col ) ; stats -> ref [ GOLDEN_FRAME ] . err = g_motion_error ; } else { stats -> ref [ GOLDEN_FRAME ] . err = INT_MAX ; stats -> ref [ GOLDEN_FRAME ] . m . mv . as_int = 0 ; } if ( alt_ref ) { int a_motion_error ; xd -> plane [ 0 ] . pre [ 0 ] . buf = alt_ref -> y_buffer + mb_y_offset ; xd -> plane [ 0 ] . pre [ 0 ] . stride = alt_ref -> y_stride ; a_motion_error = do_16x16_zerozero_search ( cpi , & stats -> ref [ ALTREF_FRAME ] . m . mv ) ; stats -> ref [ ALTREF_FRAME ] . err = a_motion_error ; } else { stats -> ref [ ALTREF_FRAME ] . err = INT_MAX ; stats -> ref [ ALTREF_FRAME ] . m . mv . as_int = 0 ; } }
","<S2SV_ModStart> * golden_ref , const MV <S2SV_ModEnd> * prev_golden_ref_mv , <S2SV_ModStart> & cpi -> td .
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp8cx_pick_filter_level_fast ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filt_val ; <S2SV_StartBug> int best_filt_val = cm -> filter_level ; <S2SV_EndBug> YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; if ( cm -> sharpness_level != cm -> last_sharpness_level ) { vp8_loop_filter_update_sharpness ( & cm -> lf_info , cm -> sharpness_level ) ; cm -> last_sharpness_level = cm -> sharpness_level ; } if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; else if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; filt_val = cm -> filter_level ; best_filt_val = filt_val ; <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; best_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; filt_val -= 1 + ( filt_val > 10 ) ; while ( filt_val >= min_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err ; best_filt_val = filt_val ; } else break ; filt_val -= 1 + ( filt_val > 10 ) ; } filt_val = cm -> filter_level + 1 + ( filt_val > 10 ) ; if ( best_filt_val == cm -> filter_level ) { best_err -= ( best_err >> 10 ) ; while ( filt_val < max_filter_level ) { <S2SV_StartBug> vp8_yv12_copy_partial_frame ( saved_frame , cm -> frame_to_show ) ; <S2SV_EndBug> vp8_loop_filter_partial_frame ( cm , & cpi -> mb . e_mbd , filt_val ) ; filt_err = calc_partial_ssl_err ( sd , cm -> frame_to_show ) ; if ( filt_err < best_err ) { best_err = filt_err - ( filt_err >> 10 ) ; best_filt_val = filt_val ; } else break ; filt_val += 1 + ( filt_val > 10 ) ; } } cm -> filter_level = best_filt_val ; if ( cm -> filter_level < min_filter_level ) cm -> filter_level = min_filter_level ; if ( cm -> filter_level > max_filter_level ) cm -> filter_level = max_filter_level ; cm -> frame_to_show = saved_frame ; }
","<S2SV_ModStart> ; int best_filt_val <S2SV_ModEnd> ; YV12_BUFFER_CONFIG * <S2SV_ModStart> = filt_val ; yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , <S2SV_ModStart> min_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame , <S2SV_ModStart> max_filter_level ) { yv12_copy_partial_frame <S2SV_ModEnd> ( saved_frame ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-20,"CWE-20 static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
","<S2SV_ModStart> len ) ; <S2SV_ModEnd> lock_sock ( sk
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-119,"CWE-119 static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID : <S2SV_StartBug> if ( Int_val ( Field ( ( value ) dest , 1 ) ) >= 0 ) <S2SV_EndBug> caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , String_tag , intern_color ) ; intern_dest += 1 + size ; Field ( v , size - 1 ) = 0 ; ofs_ind = Bsize_wsize ( size ) - 1 ; Byte ( v , ofs_ind ) = ofs_ind - len ; readblock ( String_val ( v ) , len ) ; } else { switch ( code ) { case CODE_INT8 : v = Val_long ( read8s ( ) ) ; break ; case CODE_INT16 : v = Val_long ( read16s ( ) ) ; break ; case CODE_INT32 : v = Val_long ( read32s ( ) ) ; break ; case CODE_INT64 : # ifdef ARCH_SIXTYFOUR v = Val_long ( read64s ( ) ) ; break ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>integer<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_SHARED8 : ofs = read8u ( ) ; read_shared : Assert ( ofs > 0 ) ; Assert ( ofs <= obj_counter ) ; Assert ( intern_obj_table != NULL ) ; v = intern_obj_table [ obj_counter - ofs ] ; break ; case CODE_SHARED16 : ofs = read16u ( ) ; goto read_shared ; case CODE_SHARED32 : ofs = read32u ( ) ; goto read_shared ; case CODE_BLOCK32 : header = ( header_t ) read32u ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; case CODE_BLOCK64 : # ifdef ARCH_SIXTYFOUR header = ( header_t ) read64s ( ) ; tag = Tag_hd ( header ) ; size = Wosize_hd ( header ) ; goto read_block ; # else intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>data<S2SV_blank>block<S2SV_blank>too<S2SV_blank>large"" ) ; break ; # endif case CODE_STRING8 : len = read8u ( ) ; goto read_string ; case CODE_STRING32 : len = read32u ( ) ; goto read_string ; case CODE_DOUBLE_LITTLE : case CODE_DOUBLE_BIG : v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( Double_wosize , Double_tag , intern_color ) ; intern_dest += 1 + Double_wosize ; readfloat ( ( double * ) v , code ) ; break ; case CODE_DOUBLE_ARRAY8_LITTLE : case CODE_DOUBLE_ARRAY8_BIG : len = read8u ( ) ; read_double_array : size = len * Double_wosize ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Double_array_tag , intern_color ) ; intern_dest += 1 + size ; readfloats ( ( double * ) v , len , code ) ; break ; case CODE_DOUBLE_ARRAY32_LITTLE : case CODE_DOUBLE_ARRAY32_BIG : len = read32u ( ) ; goto read_double_array ; case CODE_CODEPOINTER : ofs = read32u ( ) ; readblock ( digest , 16 ) ; codeptr = intern_resolve_code_pointer ( digest , ofs ) ; if ( codeptr != NULL ) { v = ( value ) codeptr ; } else { value * function_placeholder = caml_named_value ( ""Debugger.function_placeholder"" ) ; if ( function_placeholder != NULL ) { v = * function_placeholder ; } else { intern_cleanup ( ) ; intern_bad_code_pointer ( digest ) ; } } break ; case CODE_INFIXPOINTER : ofs = read32u ( ) ; PushItem ( ) ; sp -> dest = dest ; sp -> op = OShift ; sp -> arg = ofs ; ReadItems ( dest , 1 ) ; continue ; case CODE_CUSTOM : ops = caml_find_custom_operations ( ( char * ) intern_src ) ; if ( ops == NULL ) { intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>unknown<S2SV_blank>custom<S2SV_blank>block<S2SV_blank>identifier"" ) ; } while ( * intern_src ++ != 0 ) ; size = ops -> deserialize ( ( void * ) ( intern_dest + 2 ) ) ; size = 1 + ( size + sizeof ( value ) - 1 ) / sizeof ( value ) ; v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , Custom_tag , intern_color ) ; Custom_ops_val ( v ) = ops ; if ( ops -> finalize != NULL && Is_young ( v ) ) { if ( caml_finalize_table . ptr >= caml_finalize_table . limit ) { CAMLassert ( caml_finalize_table . ptr == caml_finalize_table . limit ) ; caml_realloc_ref_table ( & caml_finalize_table ) ; } * caml_finalize_table . ptr ++ = ( value * ) v ; } intern_dest += 1 + size ; break ; default : intern_cleanup ( ) ; caml_failwith ( ""input_value:<S2SV_blank>ill-formed<S2SV_blank>message"" ) ; } } } * dest = v ; break ; default : Assert ( 0 ) ; } } intern_free_stack ( ) ; }
","<S2SV_ModStart> : if ( Long_val <S2SV_ModEnd> ( Field (
",ocaml@ocaml/659615c7b100a89eafe6253e7a5b9d84d0e8df74,CVE-2015-8869,https://github.com/ocaml/ocaml/commit/659615c7b100a89eafe6253e7a5b9d84d0e8df74,2016-06-13T19:59Z
CWE-787,"CWE-787 size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , ""rb"" ) ; # else mp4 -> mediafp = fopen ( filename , ""rb"" ) ; # endif if ( mp4 -> mediafp ) { <S2SV_StartBug> uint32_t qttag , qtsize32 , len ; <S2SV_EndBug> int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }
","<S2SV_ModStart> qttag , qtsize32 ; size_t <S2SV_ModEnd> len ; int32_t <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , lastsize - <S2SV_ModStart> 8 - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE <S2SV_ModStart> ) ) { LongSeek ( mp4 <S2SV_ModEnd> , qtsize - <S2SV_ModStart> qtsize - 8 <S2SV_ModEnd> ) ; NESTSIZE
",gopro@gpmf-parser/341f12cd5b97ab419e53853ca00176457c9f1681,CVE-2019-15148,https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681,2019-08-18T19:15Z
CWE-400,"CWE-400 struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , struct user_namespace * user_ns , struct fs_struct * new_fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old ; struct mount * new ; int copy_flags ; BUG_ON ( ! ns ) ; if ( likely ( ! ( flags & CLONE_NEWNS ) ) ) { get_mnt_ns ( ns ) ; return ns ; } old = ns -> root ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; namespace_lock ( ) ; copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE ; if ( user_ns != ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ; new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { namespace_unlock ( ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; <S2SV_StartBug> if ( new_fs ) { <S2SV_EndBug> if ( & p -> mnt == new_fs -> root . mnt ) { new_fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == new_fs -> pwd . mnt ) { new_fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; if ( ! q ) break ; while ( p -> mnt . mnt_root != q -> mnt . mnt_root ) p = next_mnt ( p , old ) ; } namespace_unlock ( ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }
","<S2SV_ModStart> = new_ns ; new_ns -> mounts ++ ;
",torvalds@linux/d29216842a85c7970c536108e093963f02714498,CVE-2016-6213,https://github.com/torvalds/linux/commit/d29216842a85c7970c536108e093963f02714498,2016-12-28T07:59Z
CWE-119,"CWE-119 static void numtostr ( js_State * J , const char * fmt , int w , double n ) { <S2SV_StartBug> char buf [ 32 ] , * e ; <S2SV_EndBug> sprintf ( buf , fmt , w , n ) ; e = strchr ( buf , 'e' ) ; if ( e ) { int exp = atoi ( e + 1 ) ; sprintf ( e , ""e%+d"" , exp ) ; } js_pushstring ( J , buf ) ; }
","<S2SV_ModStart> char buf [ 50 <S2SV_ModEnd> ] , *
",ccxvii@mujs/da632ca08f240590d2dec786722ed08486ce1be6,CVE-2019-11411,https://github.com/ccxvii/mujs/commit/da632ca08f240590d2dec786722ed08486ce1be6,2019-04-22T11:29Z
CWE-400,"CWE-400 int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , <S2SV_EndBug> regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x0500 : goto simple ; case 0x0B00 : break ; case 0x0F00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) != 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; case 0x0900 : break ; case 0x0D00 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { # if defined ( CONFIG_CPU_SH4 ) || defined ( CONFIG_SH7705_CACHE_32KB ) if ( ( regs -> sr & 0x00000001 ) == 0 ) regs -> pc += 4 ; else # endif regs -> pc += SH_PC_8BIT_OFFSET ( instruction ) ; } break ; } break ; case 0xA000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; break ; case 0xB000 : ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += SH_PC_12BIT_OFFSET ( instruction ) ; } break ; } return ret ; simple : ret = handle_unaligned_ins ( instruction , regs , ma ) ; if ( ret == 0 ) regs -> pc += instruction_size ( instruction ) ; return ret ; }
","<S2SV_ModStart> , 1 , <S2SV_ModEnd> regs , address
",torvalds@linux/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,CVE-2011-2918,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,2012-05-24T23:55Z
CWE-125,"CWE-125 int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
","<S2SV_ModStart> prevhdr ) ; if ( hlen < 0 ) { err = hlen ; goto fail ; }
",torvalds@linux/2423496af35d94a87156b063ea5cedffc10a70a1,CVE-2017-9074,https://github.com/torvalds/linux/commit/2423496af35d94a87156b063ea5cedffc10a70a1,2017-05-19T07:29Z
CWE-20,"CWE-20 static int mISDN_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sk_buff * skb ; <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_mISDN * maddr ; int copied , err ; if ( * debug & DEBUG_SOCKET ) printk ( KERN_DEBUG ""%s:<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>flags<S2SV_blank>%x<S2SV_blank>ch.nr<S2SV_blank>%d,<S2SV_blank>proto<S2SV_blank>%x\\n"" , __func__ , ( int ) len , flags , _pms ( sk ) -> ch . nr , sk -> sk_protocol ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; if ( sk -> sk_state == MISDN_CLOSED ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; <S2SV_StartBug> if ( msg -> msg_namelen >= sizeof ( struct sockaddr_mISDN ) ) { <S2SV_EndBug> msg -> msg_namelen = sizeof ( struct sockaddr_mISDN ) ; maddr = ( struct sockaddr_mISDN * ) msg -> msg_name ; maddr -> family = AF_ISDN ; maddr -> dev = _pms ( sk ) -> dev -> id ; if ( ( sk -> sk_protocol == ISDN_P_LAPD_TE ) || ( sk -> sk_protocol == ISDN_P_LAPD_NT ) ) { maddr -> channel = ( mISDN_HEAD_ID ( skb ) >> 16 ) & 0xff ; maddr -> tei = ( mISDN_HEAD_ID ( skb ) >> 8 ) & 0xff ; maddr -> sapi = mISDN_HEAD_ID ( skb ) & 0xff ; } else { maddr -> channel = _pms ( sk ) -> ch . nr ; maddr -> sapi = _pms ( sk ) -> ch . addr & 0xFF ; maddr -> tei = ( _pms ( sk ) -> ch . addr >> 8 ) & 0xFF ; } <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( msg -> msg_namelen ) <S2SV_EndBug> printk ( KERN_WARNING ""%s:<S2SV_blank>too<S2SV_blank>small<S2SV_blank>namelen<S2SV_blank>%d\\n"" , __func__ , msg -> msg_namelen ) ; msg -> msg_namelen = 0 ; } copied = skb -> len + MISDN_HEADER_LEN ; if ( len < copied ) { if ( flags & MSG_PEEK ) atomic_dec ( & skb -> users ) ; else skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - ENOSPC ; } memcpy ( skb_push ( skb , MISDN_HEADER_LEN ) , mISDN_HEAD_P ( skb ) , MISDN_HEADER_LEN ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; mISDN_sock_cmsg ( sk , msg , skb ) ; skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
","<S2SV_ModStart> sock -> sk <S2SV_ModEnd> ; int copied <S2SV_ModStart> ( msg -> msg_name ) { struct sockaddr_mISDN * maddr = <S2SV_ModEnd> msg -> msg_name <S2SV_ModStart> 0xFF ; } <S2SV_ModEnd> msg -> msg_namelen <S2SV_ModStart> msg -> msg_namelen = sizeof ( * maddr ) <S2SV_ModEnd> ; } copied
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-000,"CWE-000 static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
","<S2SV_ModStart> ctxt ) { int rc = X86EMUL_CONTINUE ; <S2SV_ModStart> == 0 ) rc = <S2SV_ModStart> ) ; return rc <S2SV_ModEnd> ; } <S2SV_null>
",torvalds@linux/234f3ce485d54017f15cf5e0699cff4100121601,CVE-2014-3647,https://github.com/torvalds/linux/commit/234f3ce485d54017f15cf5e0699cff4100121601,2014-11-10T11:55Z
CWE-119,"CWE-119 static inline void handle_socket_receive_unknown ( fastd_socket_t * sock , const fastd_peer_address_t * local_addr , const fastd_peer_address_t * remote_addr , fastd_buffer_t * buffer ) { const uint8_t * packet_type = buffer -> data ; switch ( * packet_type ) { case PACKET_DATA : fastd_buffer_free ( buffer ) ; if ( ! backoff_unknown ( remote_addr ) ) { pr_debug ( ""unexpectedly<S2SV_blank>received<S2SV_blank>payload<S2SV_blank>data<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ; conf . protocol -> handshake_init ( sock , local_addr , remote_addr , NULL ) ; } break ; case PACKET_HANDSHAKE : fastd_handshake_handle ( sock , local_addr , remote_addr , NULL , buffer ) ; <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> buffer ) ; break ; default : fastd_buffer_free ( buffer ) ; pr_debug ( ""received<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>invalid<S2SV_blank>type<S2SV_blank>from<S2SV_blank>unknown<S2SV_blank>address<S2SV_blank>%I"" , remote_addr ) ;
",NeoRaider@fastd/737925113363b6130879729cdff9ccc46c33eaea,CVE-2020-27638,https://github.com/NeoRaider/fastd/commit/737925113363b6130879729cdff9ccc46c33eaea,2020-10-22T13:15Z
CWE-22,"CWE-22 PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }
","<S2SV_ModStart> ) ) { if ( uri_ptr [ alias_len ] == '.' ) { char * s = uri_ptr + alias_len + 1 ; if ( * s == '.' ) ++ s ; if ( * s == '/' || * s == '\\0' ) { size_t vlen = buffer_string_length ( ds -> value ) ; if ( 0 != alias_len && ds -> key -> ptr [ alias_len - 1 ] != '/' && 0 != vlen && ds -> value -> ptr [ vlen - 1 ] == '/' ) { con -> http_status = 403 ; return HANDLER_FINISHED ; } } }
",lighttpd@lighttpd1.4/2105dae0f9d7a964375ce681e53cb165375f84c1,CVE-2018-19052,https://github.com/lighttpd/lighttpd1.4/commit/2105dae0f9d7a964375ce681e53cb165375f84c1,2018-11-07T05:29Z
CWE-200,"CWE-200 static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; <S2SV_StartBug> strlcpy ( rcomp . type , ""compression"" , sizeof ( rcomp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
","<S2SV_ModStart> crypto_report_comp rcomp ; strncpy <S2SV_ModEnd> ( rcomp .
",torvalds@linux/f43f39958beb206b53292801e216d9b8a660f087,CVE-2018-19854,https://github.com/torvalds/linux/commit/f43f39958beb206b53292801e216d9b8a660f087,2018-12-04T16:29Z
CWE-476,"CWE-476 static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) { const char * passwd ; const uint8_t * key ; bool ok ; SBuf * sbuf = & client -> sbuf ; if ( incomplete_pkt ( pkt ) ) { disconnect_client ( client , true , ""client<S2SV_blank>sent<S2SV_blank>partial<S2SV_blank>pkt<S2SV_blank>in<S2SV_blank>startup<S2SV_blank>phase"" ) ; return false ; } if ( client -> wait_for_welcome ) { if ( finish_client_login ( client ) ) { sbuf_prepare_skip ( sbuf , pkt -> len ) ; return true ; } else return false ; } switch ( pkt -> type ) { case PKT_SSLREQ : slog_noise ( client , ""C:<S2SV_blank>req<S2SV_blank>SSL"" ) ; slog_noise ( client , ""P:<S2SV_blank>nak"" ) ; if ( ! sbuf_answer ( & client -> sbuf , ""N"" , 1 ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>nak<S2SV_blank>SSL"" ) ; return false ; } break ; case PKT_STARTUP_V2 : disconnect_client ( client , true , ""Old<S2SV_blank>V2<S2SV_blank>protocol<S2SV_blank>not<S2SV_blank>supported"" ) ; return false ; case PKT_STARTUP : if ( client -> pool ) { disconnect_client ( client , true , ""client<S2SV_blank>re-sent<S2SV_blank>startup<S2SV_blank>pkt"" ) ; return false ; } if ( ! decide_startup_pool ( client , pkt ) ) return false ; if ( client -> pool -> db -> admin ) { if ( ! admin_pre_login ( client ) ) return false ; } if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { if ( ! finish_client_login ( client ) ) return false ; } else { if ( ! send_client_authreq ( client ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>auth<S2SV_blank>req"" ) ; return false ; } } break ; case 'p' : <S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ; return false ; } ok = mbuf_get_string ( & pkt -> data , & passwd ) ; if ( ok && check_client_passwd ( client , passwd ) ) { if ( ! finish_client_login ( client ) ) return false ; } else { disconnect_client ( client , true , ""Auth<S2SV_blank>failed"" ) ; return false ; } break ; case PKT_CANCEL : if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) { memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; accept_cancel_request ( client ) ; } else disconnect_client ( client , false , ""bad<S2SV_blank>cancel<S2SV_blank>request"" ) ; return false ; default : disconnect_client ( client , false , ""bad<S2SV_blank>packet"" ) ; return false ; } sbuf_prepare_skip ( sbuf , pkt -> len ) ; client -> request_time = get_cached_time ( ) ; return true ; }
","<S2SV_ModStart> : if ( ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if (
",pgbouncer@pgbouncer/74d6e5f7de5ec736f71204b7b422af7380c19ac5,CVE-2015-4054,https://github.com/pgbouncer/pgbouncer/commit/74d6e5f7de5ec736f71204b7b422af7380c19ac5,2017-05-23T04:29Z
CWE-190,"CWE-190 <S2SV_StartBug> int mongo_env_read_socket ( mongo * conn , void * buf , int len ) { <S2SV_EndBug> char * cbuf = buf ; while ( len ) { <S2SV_StartBug> int sent = recv ( conn -> sock , cbuf , len , 0 ) ; <S2SV_EndBug> if ( sent == 0 || sent == - 1 ) { __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
","<S2SV_ModStart> * buf , size_t <S2SV_ModEnd> len ) { <S2SV_ModStart> len ) { size_t <S2SV_ModEnd> sent = recv
",10gen-archive@mongo-c-driver-legacy/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,CVE-2020-12135,https://github.com/10gen-archive/mongo-c-driver-legacy/commit/1a1f5e26a4309480d88598913f9eebf9e9cba8ca,2020-04-24T01:15Z
CWE-399,"CWE-399 static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }
","<S2SV_ModStart> ) ; } account_pipe_buffers ( pipe , pipe -> buffers , nr_pages ) ;
",torvalds@linux/759c01142a5d0f364a462346168a56de28a80f52,CVE-2016-2847,https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52,2016-04-27T17:59Z
CWE-200,"CWE-200 static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union { struct tpacket_hdr * h1 ; struct tpacket2_hdr * h2 ; void * raw ; } h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timeval tv ; struct timespec ts ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; macoff = netoff - maclen ; } if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < ( unsigned ) sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; if ( ! h . raw ) goto ring_is_full ; packet_increment_head ( & po -> rx_ring ) ; po -> stats . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } if ( ! po -> stats . tp_drops ) status &= ~ TP_STATUS_LOSING ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) tv = ktime_to_timeval ( skb -> tstamp ) ; else do_gettimeofday ( & tv ) ; h . h1 -> tp_sec = tv . tv_sec ; h . h1 -> tp_usec = tv . tv_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) ts = ktime_to_timespec ( skb -> tstamp ) ; else getnstimeofday ( & ts ) ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( vlan_tx_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; status |= TP_STATUS_VLAN_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; } <S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; __packet_set_status ( po , h . raw , status ) ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } # endif sk -> sk_data_ready ( sk , 0 ) ; drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : kfree_skb ( skb ) ; return 0 ; ring_is_full : po -> stats . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk , 0 ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
","<S2SV_ModStart> 0 ; } h . h2 -> tp_padding = 0 ;
",torvalds@linux/13fcb7bd322164c67926ffe272846d4860196dc6,CVE-2011-2898,https://github.com/torvalds/linux/commit/13fcb7bd322164c67926ffe272846d4860196dc6,2012-05-24T23:55Z
CWE-119,"CWE-119 <S2SV_StartBug> static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int reference_flag = va_arg ( args , int ) ; vp8_use_as_reference ( ctx -> cpi , reference_flag ) ; return VPX_CODEC_OK ; }
","<S2SV_ModStart> vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-125,"CWE-125 static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { <S2SV_StartBug> int all_whitespace = 1 ; <S2SV_EndBug> int kind ; void * data ; PyCompilerFlags cf ; <S2SV_StartBug> mod_ty mod ; <S2SV_EndBug> char * str ; <S2SV_StartBug> PyObject * o , * fstring_name ; <S2SV_EndBug> Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; <S2SV_StartBug> o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL ) ; <S2SV_EndBug> if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) <S2SV_StartBug> return NULL ; <S2SV_EndBug> str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; <S2SV_StartBug> fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; <S2SV_EndBug> mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; <S2SV_StartBug> PyMem_RawFree ( str ) ; <S2SV_EndBug> if ( ! mod ) return NULL ; return mod -> v . Expression . body ; }
","<S2SV_ModStart> n ) { <S2SV_ModEnd> PyCompilerFlags cf ; <S2SV_ModStart> PyCompilerFlags cf ; node * mod_n ; <S2SV_ModStart> * str ; Py_ssize_t len ; const char * s ; PyObject * fstring_name <S2SV_ModEnd> ; assert ( <S2SV_ModStart> ':' ) ; for ( s = expr_start ; s != expr_end ; s ++ ) { char c = * s ; if ( ! ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\f' ) ) { break ; } } if ( s == expr_end ) { ast_error ( c , n , ""f-string:<S2SV_blank>empty<S2SV_blank>expression<S2SV_blank>not<S2SV_blank>allowed"" ) ; return NULL ; } len = <S2SV_ModEnd> expr_end - expr_start <S2SV_ModStart> expr_end - expr_start <S2SV_ModEnd> ; str = <S2SV_ModStart> == NULL ) { PyErr_NoMemory ( ) ; return NULL ; } <S2SV_ModEnd> str [ 0 <S2SV_ModStart> = PyCF_ONLY_AST ; mod_n = PyParser_SimpleParseStringFlagsFilename ( str , ""<fstring>"" , Py_eval_input , 0 ) ; if ( ! mod_n ) { PyMem_RawFree ( str ) ; return NULL ; } str [ 0 ] = '{' ; str [ len + 1 ] = '}' ; fstring_fix_node_location ( n , mod_n , str ) ; <S2SV_ModStart> PyMem_RawFree ( str ) ; Ta3Node_Free ( mod_n
",python@typed_ast/156afcb26c198e162504a57caddfe0acd9ed7dce,CVE-2019-19275,https://github.com/python/typed_ast/commit/156afcb26c198e162504a57caddfe0acd9ed7dce,2019-11-26T15:15Z
CWE-119,"CWE-119 static void setup_decoding_thread_data ( VP8D_COMP * pbi , MACROBLOCKD * xd , MB_ROW_DEC * mbrd , int count ) { VP8_COMMON * const pc = & pbi -> common ; int i ; for ( i = 0 ; i < count ; i ++ ) { MACROBLOCKD * mbd = & mbrd [ i ] . mbd ; mbd -> subpixel_predict = xd -> subpixel_predict ; mbd -> subpixel_predict8x4 = xd -> subpixel_predict8x4 ; mbd -> subpixel_predict8x8 = xd -> subpixel_predict8x8 ; mbd -> subpixel_predict16x16 = xd -> subpixel_predict16x16 ; mbd -> mode_info_context = pc -> mi + pc -> mode_info_stride * ( i + 1 ) ; mbd -> mode_info_stride = pc -> mode_info_stride ; mbd -> frame_type = pc -> frame_type ; mbd -> pre = xd -> pre ; mbd -> dst = xd -> dst ; mbd -> segmentation_enabled = xd -> segmentation_enabled ; mbd -> mb_segement_abs_delta = xd -> mb_segement_abs_delta ; <S2SV_StartBug> vpx_memcpy ( mbd -> segment_feature_data , xd -> segment_feature_data , sizeof ( xd -> segment_feature_data ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> ref_lf_deltas , xd -> ref_lf_deltas , sizeof ( xd -> ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> mode_lf_deltas , xd -> mode_lf_deltas , sizeof ( xd -> mode_lf_deltas ) ) ; <S2SV_EndBug> mbd -> mode_ref_lf_delta_enabled = xd -> mode_ref_lf_delta_enabled ; mbd -> mode_ref_lf_delta_update = xd -> mode_ref_lf_delta_update ; mbd -> current_bc = & pbi -> mbc [ 0 ] ; <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1_dc , xd -> dequant_y1_dc , sizeof ( xd -> dequant_y1_dc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y1 , xd -> dequant_y1 , sizeof ( xd -> dequant_y1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_y2 , xd -> dequant_y2 , sizeof ( xd -> dequant_y2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( mbd -> dequant_uv , xd -> dequant_uv , sizeof ( xd -> dequant_uv ) ) ; <S2SV_EndBug> mbd -> fullpixel_mask = 0xffffffff ; if ( pc -> full_pixel ) mbd -> fullpixel_mask = 0xfffffff8 ; } for ( i = 0 ; i < pc -> mb_rows ; i ++ ) pbi -> mt_current_mb_col [ i ] = - 1 ; }
","<S2SV_ModStart> -> mb_segement_abs_delta ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> 0 ] ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd -> <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( mbd ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-264,"CWE-264 int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }
","<S2SV_ModStart> arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ;
",torvalds@linux/0bfc96cb77224736dfa35c3c555d37b3646ef35e,CVE-2011-4127,https://github.com/torvalds/linux/commit/0bfc96cb77224736dfa35c3c555d37b3646ef35e,2012-07-03T16:40Z
CWE-787,"CWE-787 SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( ""selReadStream"" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file"" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( ""invalid<S2SV_blank>sel<S2SV_blank>version"" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( ""error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf"" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------"" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , ""<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n"" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""dimensions<S2SV_blank>not<S2SV_blank>read"" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( ""sel<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , ""%1d"" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , ""\\n"" ) ; } ignore = fscanf ( fp , ""\\n"" ) ; LEPT_FREE ( selname ) ; return sel ; }
","<S2SV_ModStart> char linebuf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( linebuf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( linebuf , ""<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%200s<S2SV_blank><S2SV_blank>------"" <S2SV_ModEnd> , selname )
",DanBloomberg@leptonica/ee301cb2029db8a6289c5295daa42bba7715e99a,CVE-2018-7186,https://github.com/DanBloomberg/leptonica/commit/ee301cb2029db8a6289c5295daa42bba7715e99a,2018-02-16T16:29Z
CWE-119,"CWE-119 int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , ""openssl"" , sizeof ( ""openssl"" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>not<S2SV_blank>loaded"" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , ""%s.pubkey"" , fname ) ; pfp = php_stream_open_wrapper ( pfile , ""rb"" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>public<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>read"" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 , & sig , & tempsig ) ) { if ( pubkey ) { zend_string_release ( pubkey ) ; } if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>verified"" ) ; } return FAILURE ; } if ( pubkey ) { zend_string_release ( pubkey ) ; } sig_len = tempsig ; # else in = BIO_new_mem_buf ( pubkey ? ZSTR_VAL ( pubkey ) : NULL , pubkey ? ZSTR_LEN ( pubkey ) : 0 ) ; if ( NULL == in ) { zend_string_release ( pubkey ) ; if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } key = PEM_read_bio_PUBKEY ( in , NULL , NULL , NULL ) ; BIO_free ( in ) ; zend_string_release ( pubkey ) ; if ( NULL == key ) { if ( error ) { spprintf ( error , 0 , ""openssl<S2SV_blank>signature<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>processed"" ) ; } return FAILURE ; } EVP_VerifyInit ( & md_ctx , mdtype ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; while ( read_size && ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { EVP_VerifyUpdate ( & md_ctx , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } if ( EVP_VerifyFinal ( & md_ctx , ( unsigned char * ) sig , sig_len , key ) != 1 ) { EVP_MD_CTX_cleanup ( & md_ctx ) ; if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>openssl<S2SV_blank>signature"" ) ; } return FAILURE ; } EVP_MD_CTX_cleanup ( & md_ctx ) ; # endif * signature_len = phar_hex_str ( ( const char * ) sig , sig_len , signature ) ; } break ; # ifdef PHAR_HASH_OK case PHAR_SIG_SHA512 : { unsigned char digest [ 64 ] ; PHP_SHA512_CTX context ; <S2SV_StartBug> PHP_SHA512Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA512Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA512Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_SHA256 : { unsigned char digest [ 32 ] ; PHP_SHA256_CTX context ; <S2SV_StartBug> PHP_SHA256Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA256Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA256Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } # else case PHAR_SIG_SHA512 : case PHAR_SIG_SHA256 : if ( error ) { spprintf ( error , 0 , ""unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; # endif case PHAR_SIG_SHA1 : { unsigned char digest [ 20 ] ; PHP_SHA1_CTX context ; <S2SV_StartBug> PHP_SHA1Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_SHA1Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_SHA1Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; break ; } case PHAR_SIG_MD5 : { unsigned char digest [ 16 ] ; PHP_MD5_CTX context ; <S2SV_StartBug> PHP_MD5Init ( & context ) ; <S2SV_EndBug> read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_StartBug> * signature_len = phar_hex_str ( ( const char * ) digest , sizeof ( digest ) , signature ) ; <S2SV_EndBug> break ; } default : if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>or<S2SV_blank>unsupported<S2SV_blank>signature"" ) ; } return FAILURE ; } return SUCCESS ; }
","<S2SV_ModStart> PHP_SHA512_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA256_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_SHA1_CTX context ; if ( sig_len < sizeof ( digest ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; } <S2SV_ModStart> PHP_MD5_CTX context ; if ( sig_len < sizeof ( digest <S2SV_ModEnd> ) ) { <S2SV_ModStart> FAILURE ; } PHP_MD5Init ( & context ) ; read_len = end_of_phar ; if ( read_len > sizeof ( buf ) ) { read_size = sizeof ( buf ) ; } else { read_size = ( int ) read_len ; } while ( ( len = php_stream_read ( fp , ( char * ) buf , read_size ) ) > 0 ) { PHP_MD5Update ( & context , buf , len ) ; read_len -= ( zend_off_t ) len ; if ( read_len < read_size ) { read_size = ( int ) read_len ; } } PHP_MD5Final ( digest , & context ) ; if ( memcmp ( digest , sig , sizeof ( digest ) ) ) { if ( error ) { spprintf ( error , 0 , ""broken<S2SV_blank>signature"" ) ; } return FAILURE ; }
",php@php-src/0bfb970f43acd1e81d11be1154805f86655f15d5,CVE-2016-7414,https://github.com/php/php-src/commit/0bfb970f43acd1e81d11be1154805f86655f15d5,2016-09-17T21:59Z
CWE-264,"CWE-264 SYSCALL_DEFINE4 ( osf_wait4 , pid_t , pid , int __user * , ustatus , int , options , struct rusage32 __user * , ur ) { struct rusage r ; long ret , err ; <S2SV_StartBug> mm_segment_t old_fs ; <S2SV_EndBug> if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ; old_fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; <S2SV_StartBug> ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & r ) ; <S2SV_EndBug> set_fs ( old_fs ) ; if ( ! access_ok ( VERIFY_WRITE , ur , sizeof ( * ur ) ) ) return - EFAULT ; err = 0 ; <S2SV_StartBug> err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; <S2SV_EndBug> err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ; err |= __put_user ( r . ru_stime . tv_sec , & ur -> ru_stime . tv_sec ) ; err |= __put_user ( r . ru_stime . tv_usec , & ur -> ru_stime . tv_usec ) ; err |= __put_user ( r . ru_maxrss , & ur -> ru_maxrss ) ; err |= __put_user ( r . ru_ixrss , & ur -> ru_ixrss ) ; err |= __put_user ( r . ru_idrss , & ur -> ru_idrss ) ; err |= __put_user ( r . ru_isrss , & ur -> ru_isrss ) ; err |= __put_user ( r . ru_minflt , & ur -> ru_minflt ) ; err |= __put_user ( r . ru_majflt , & ur -> ru_majflt ) ; err |= __put_user ( r . ru_nswap , & ur -> ru_nswap ) ; err |= __put_user ( r . ru_inblock , & ur -> ru_inblock ) ; err |= __put_user ( r . ru_oublock , & ur -> ru_oublock ) ; err |= __put_user ( r . ru_msgsnd , & ur -> ru_msgsnd ) ; err |= __put_user ( r . ru_msgrcv , & ur -> ru_msgrcv ) ; err |= __put_user ( r . ru_nsignals , & ur -> ru_nsignals ) ; err |= __put_user ( r . ru_nvcsw , & ur -> ru_nvcsw ) ; err |= __put_user ( r . ru_nivcsw , & ur -> ru_nivcsw ) ; return err ? err : ret ; }
","<S2SV_ModStart> , err ; unsigned int status = 0 ; <S2SV_ModStart> ( pid , ( unsigned int __user * ) & status <S2SV_ModEnd> , options , <S2SV_ModStart> ; err |= put_user ( status , ustatus ) ; err |=
",torvalds@linux/21c5977a836e399fc710ff2c5367845ed5c2527f,CVE-2011-2211,https://github.com/torvalds/linux/commit/21c5977a836e399fc710ff2c5367845ed5c2527f,2012-06-13T10:24Z
CWE-119,"CWE-119 <S2SV_StartBug> static int prob_diff_update_cost ( vp9_prob newp , vp9_prob oldp ) { <S2SV_EndBug> int delp = remap_prob ( newp , oldp ) ; return update_bits [ delp ] * 256 ; }
","<S2SV_ModStart> int prob_diff_update_cost ( vpx_prob newp , vpx_prob <S2SV_ModEnd> oldp ) {
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-189,"CWE-189 static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ; <S2SV_StartBug> tp -> prr_delivered += newly_acked_sacked ; <S2SV_EndBug> if ( delta < 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }
","<S2SV_ModStart> sacked_out ) ; if ( newly_acked_sacked <= 0 || WARN_ON_ONCE ( ! tp -> prior_cwnd ) ) return ;
",torvalds@linux/8b8a321ff72c785ed5e8b4cf6eda20b35d427390,CVE-2016-2070,https://github.com/torvalds/linux/commit/8b8a321ff72c785ed5e8b4cf6eda20b35d427390,2016-05-02T10:59Z
CWE-200,"CWE-200 static void save_bt_to_dump_dir ( const char * bt , const char * exe , const char * reason ) { time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! ( g_opts & OPT_x ) ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> char base [ sizeof ( ""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , ""xorg-%s-%lu-%u"" , iso_date , ( long ) my_pid , g_bt_count ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""xorg"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""xorg"" ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; dd_save_text ( dd , FILENAME_BACKTRACE , bt ) ; if ( ! exe ) { exe = ""/usr/bin/X"" ; if ( access ( ""/usr/bin/Xorg"" , X_OK ) == 0 ) exe = ""/usr/bin/Xorg"" ; } dd_save_text ( dd , FILENAME_EXECUTABLE , exe ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } free ( path ) ; }
","<S2SV_ModStart> ) ; } if ( g_settings_privatereports ) { if ( ( g_opts & OPT_x ) ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }
",abrt@abrt/8939398b82006ba1fec4ed491339fc075f43fc7c,CVE-2015-1870,https://github.com/abrt/abrt/commit/8939398b82006ba1fec4ed491339fc075f43fc7c,2017-06-26T15:29Z
CWE-416,"CWE-416 void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }
","<S2SV_ModStart> handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
",torvalds@linux/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,CVE-2016-9120,https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7,2016-12-08T21:59Z
CWE-399,"CWE-399 static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) <S2SV_StartBug> # define PCDGetBits ( n ) { sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } } <S2SV_EndBug> typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) { PCDGetBits ( 8 ) ; length = ( sum & 0xff ) + 1 ; pcd_table [ i ] = ( PCDTable * ) AcquireQuantumMemory ( length , sizeof ( * pcd_table [ i ] ) ) ; if ( pcd_table [ i ] == ( PCDTable * ) NULL ) { buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_StartBug> ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , <S2SV_EndBug> image -> filename ) ; } r = pcd_table [ i ] ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { PCDGetBits ( 8 ) ; r -> length = ( unsigned int ) ( sum & 0xff ) + 1 ; if ( r -> length > 16 ) { <S2SV_StartBug> buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; <S2SV_EndBug> return ( MagickFalse ) ; } PCDGetBits ( 16 ) ; r -> sequence = ( unsigned int ) ( sum & 0xffff ) << 16 ; PCDGetBits ( 8 ) ; r -> key = ( unsigned char ) ( sum & 0xff ) ; r -> mask = ( ~ ( ( 1U << ( 32 - r -> length ) ) - 1 ) ) ; r ++ ; } pcd_length [ i ] = ( size_t ) length ; } for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; for ( i = 0 ; i < 1 ; i ++ ) PCDGetBits ( 16 ) ; while ( ( sum & 0x00fff000UL ) != 0x00fff000UL ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; count = 0 ; length = 0 ; plane = 0 ; row = 0 ; q = luma ; for ( ; ; ) { if ( IsSync ( sum ) != 0 ) { PCDGetBits ( 16 ) ; row = ( ( sum >> 9 ) & 0x1fff ) ; if ( row == image -> rows ) break ; PCDGetBits ( 8 ) ; plane = sum >> 30 ; PCDGetBits ( 16 ) ; switch ( plane ) { case 0 : { q = luma + row * image -> columns ; count = ( ssize_t ) image -> columns ; break ; } case 2 : { q = chroma1 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } case 3 : { q = chroma2 + ( row >> 1 ) * image -> columns ; count = ( ssize_t ) ( image -> columns >> 1 ) ; plane -- ; break ; } default : { for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; ThrowBinaryException ( CorruptImageError , ""CorruptImage"" , image -> filename ) ; } } length = pcd_length [ plane ] ; continue ; } r = pcd_table [ plane ] ; for ( i = 0 ; ( ( i < ( ssize_t ) length ) && ( ( sum & r -> mask ) != r -> sequence ) ) ; i ++ ) r ++ ; if ( ( row > image -> rows ) || ( r == ( PCDTable * ) NULL ) ) { ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""SkipToSyncByte"" , ""`%s\'"" , image -> filename ) ; while ( ( sum & 0x00fff000 ) != 0x00fff000 ) PCDGetBits ( 8 ) ; while ( IsSync ( sum ) == 0 ) PCDGetBits ( 1 ) ; continue ; } if ( r -> key < 128 ) quantum = ( ssize_t ) ( * q ) + r -> key ; else quantum = ( ssize_t ) ( * q ) + r -> key - 256 ; * q = ( unsigned char ) ( ( quantum < 0 ) ? 0 : ( quantum > 255 ) ? 255 : quantum ) ; q ++ ; PCDGetBits ( r -> length ) ; count -- ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) pcd_table [ i ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ i ] ) ; buffer = ( unsigned char * ) RelinquishMagickMemory ( buffer ) ; return ( MagickTrue ) ; }
","<S2SV_ModStart> ( n ) \\\n{ <S2SV_ModEnd> sum = ( <S2SV_ModStart> ++ ; } \\\n} <S2SV_ModEnd> typedef struct PCDTable <S2SV_ModStart> buffer ) ; for ( j = 0 ; j < i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ] ) ; <S2SV_ModStart> RelinquishMagickMemory ( buffer ) ; for ( j = 0 ; j <= i ; j ++ ) pcd_table [ j ] = ( PCDTable * ) RelinquishMagickMemory ( pcd_table [ j ]
",ImageMagick@ImageMagick/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,CVE-2019-7175,https://github.com/ImageMagick/ImageMagick/commit/1e6a3ace073c9ec9c71e439c111d23c6e66cb6ae,2019-03-07T23:29Z
CWE-125,"CWE-125 int main ( int argc , char * * argv ) { const char command0 [ ] = { 0x00 , 0x00 } ; char command1 [ ] = ""\\x01\\x00urn:schemas-upnp-org:device:InternetGatewayDevice"" ; char command2 [ ] = ""\\x02\\x00uuid:fc4ec57e-b051-11db-88f8-0060085db3f6::upnp:rootdevice"" ; const char command3 [ ] = { 0x03 , 0x00 } ; char command3compat [ ] = ""\\x03\\x00ssdp:all"" ; char command4 [ ] = ""\\x04\\x00test:test:test"" ; const char bad_command [ ] = { 0xff , 0xff } ; const char overflow [ ] = { 0x01 , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff , 0xff } ; <S2SV_StartBug> const char command5 [ ] = { 0x05 , 0x00 } ; <S2SV_EndBug> int s ; int i ; void * tmp ; unsigned char * resp = NULL ; size_t respsize = 0 ; unsigned char buf [ 4096 ] ; ssize_t n ; int total = 0 ; const char * sockpath = ""/var/run/minissdpd.sock"" ; for ( i = 0 ; i < argc - 1 ; i ++ ) { if ( 0 == strcmp ( argv [ i ] , ""-s"" ) ) sockpath = argv [ ++ i ] ; } command1 [ 1 ] = sizeof ( command1 ) - 3 ; command2 [ 1 ] = sizeof ( command2 ) - 3 ; command3compat [ 1 ] = sizeof ( command3compat ) - 3 ; command4 [ 1 ] = sizeof ( command4 ) - 3 ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command0 , sizeof ( command0 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; if ( n > 0 ) { printversion ( buf , n ) ; } else { printf ( ""Command<S2SV_blank>0<S2SV_blank>(get<S2SV_blank>version)<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command1 , sizeof ( command1 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command2 , sizeof ( command2 ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } buf [ 0 ] = 0 ; n = SENDCOMMAND ( command3 , sizeof ( command3 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; if ( n == 0 ) { printf ( ""command3<S2SV_blank>failed,<S2SV_blank>testing<S2SV_blank>compatible<S2SV_blank>one\\n"" ) ; close ( s ) ; s = connect_unix_socket ( sockpath ) ; n = SENDCOMMAND ( command3compat , sizeof ( command3compat ) - 1 ) ; n = read ( s , buf , sizeof ( buf ) ) ; } printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printf ( ""Number<S2SV_blank>of<S2SV_blank>devices<S2SV_blank>%d\\n"" , ( int ) buf [ 0 ] ) ; while ( n > 0 ) { tmp = realloc ( resp , respsize + n ) ; if ( tmp == NULL ) { fprintf ( stderr , ""memory<S2SV_blank>allocation<S2SV_blank>error\\n"" ) ; break ; } resp = tmp ; respsize += n ; if ( n > 0 ) { memcpy ( resp + total , buf , n ) ; total += n ; } if ( n < ( ssize_t ) sizeof ( buf ) ) { break ; } n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; } if ( resp != NULL ) { printresponse ( resp , total ) ; free ( resp ) ; resp = NULL ; } if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command4 , sizeof ( command4 ) ) ; n = SENDCOMMAND ( bad_command , sizeof ( bad_command ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( overflow , sizeof ( overflow ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; if ( n == 0 ) { close ( s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( command5 , sizeof ( command5 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; <S2SV_StartBug> close ( s ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> 0x05 , 0x00 } ; const char bad_command4 [ ] = { 0x04 , 0x01 , 0x60 , 0x8f , 0xff , 0xff , 0xff , 0x7f <S2SV_ModStart> n ) ; if ( n == 0 ) { <S2SV_ModStart> s ) ; s = connect_unix_socket ( sockpath ) ; } n = SENDCOMMAND ( bad_command4 , sizeof ( bad_command4 ) ) ; n = read ( s , buf , sizeof ( buf ) ) ; printf ( ""Response<S2SV_blank>received<S2SV_blank>%d<S2SV_blank>bytes\\n"" , ( int ) n ) ; printresponse ( buf , n ) ; close ( s ) ;
",miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z
CWE-90,"CWE-90 kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
","<S2SV_ModStart> return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail != NULL ; tl_data_tail = tl_data_tail -> tl_data_next ) { if ( tl_data_tail -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; } }
",krb5@krb5/e1caf6fb74981da62039846931ebdffed71309d1,CVE-2018-5730,https://github.com/krb5/krb5/commit/e1caf6fb74981da62039846931ebdffed71309d1,2018-03-06T20:29Z
CWE-416,"CWE-416 static int packet_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; struct packet_sock * po = pkt_sk ( sk ) ; int ret ; if ( level != SOL_PACKET ) return - ENOPROTOOPT ; switch ( optname ) { case PACKET_ADD_MEMBERSHIP : case PACKET_DROP_MEMBERSHIP : { struct packet_mreq_max mreq ; int len = optlen ; memset ( & mreq , 0 , sizeof ( mreq ) ) ; if ( len < sizeof ( struct packet_mreq ) ) return - EINVAL ; if ( len > sizeof ( mreq ) ) len = sizeof ( mreq ) ; if ( copy_from_user ( & mreq , optval , len ) ) return - EFAULT ; if ( len < ( mreq . mr_alen + offsetof ( struct packet_mreq , mr_address ) ) ) return - EINVAL ; if ( optname == PACKET_ADD_MEMBERSHIP ) ret = packet_mc_add ( sk , & mreq ) ; else ret = packet_mc_drop ( sk , & mreq ) ; return ret ; } case PACKET_RX_RING : case PACKET_TX_RING : { union tpacket_req_u req_u ; int len ; switch ( po -> tp_version ) { case TPACKET_V1 : case TPACKET_V2 : len = sizeof ( req_u . req ) ; break ; case TPACKET_V3 : default : len = sizeof ( req_u . req3 ) ; break ; } if ( optlen < len ) return - EINVAL ; if ( copy_from_user ( & req_u . req , optval , len ) ) return - EFAULT ; return packet_set_ring ( sk , & req_u , 0 , optname == PACKET_TX_RING ) ; } case PACKET_COPY_THRESH : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; pkt_sk ( sk ) -> copy_thresh = val ; return 0 ; } case PACKET_VERSION : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; <S2SV_StartBug> if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) <S2SV_EndBug> <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) <S2SV_EndBug> return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : po -> tp_version = val ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> default : return - EINVAL ; } } case PACKET_RESERVE : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_reserve = val ; return 0 ; } case PACKET_LOSS : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_loss = ! ! val ; return 0 ; } case PACKET_AUXDATA : { int val ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> auxdata = ! ! val ; return 0 ; } case PACKET_ORIGDEV : { int val ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> origdev = ! ! val ; return 0 ; } case PACKET_VNET_HDR : { int val ; if ( sock -> type != SOCK_RAW ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( optlen < sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> has_vnet_hdr = ! ! val ; return 0 ; } case PACKET_TIMESTAMP : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_tstamp = val ; return 0 ; } case PACKET_FANOUT : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; return fanout_add ( sk , val & 0xffff , val >> 16 ) ; } case PACKET_FANOUT_DATA : { if ( ! po -> fanout ) return - EINVAL ; return fanout_set_data ( po , optval , optlen ) ; } case PACKET_TX_HAS_OFF : { unsigned int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( po -> rx_ring . pg_vec || po -> tx_ring . pg_vec ) return - EBUSY ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> tp_tx_has_off = ! ! val ; return 0 ; } case PACKET_QDISC_BYPASS : { int val ; if ( optlen != sizeof ( val ) ) return - EINVAL ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; po -> xmit = val ? packet_direct_xmit : dev_queue_xmit ; return 0 ; } default : return - ENOPROTOOPT ; } }
","<S2SV_ModStart> ; if ( copy_from_user ( & val , optval , sizeof ( val ) ) ) return - EFAULT ; switch ( val ) { case TPACKET_V1 : case TPACKET_V2 : case TPACKET_V3 : break ; default : return - EINVAL ; } lock_sock ( sk ) ; if ( <S2SV_ModStart> . pg_vec ) { ret = <S2SV_ModEnd> - EBUSY ; <S2SV_ModStart> - EBUSY ; } else { <S2SV_ModEnd> po -> tp_version <S2SV_ModStart> = val ; ret = 0 ; } release_sock ( sk ) ; return ret ; <S2SV_ModEnd> } case PACKET_RESERVE
",torvalds@linux/84ac7260236a49c79eede91617700174c2c19b0c,CVE-2016-8655,https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c,2016-12-08T08:59Z
CWE-416,"CWE-416 int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; <S2SV_StartBug> char * identifier ; <S2SV_EndBug> char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif <S2SV_StartBug> break ; <S2SV_EndBug> case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> yr_free ( stack ) ; return result ; }
","<S2SV_ModStart> * function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;
",VirusTotal@yara/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,CVE-2017-8929,https://github.com/VirusTotal/yara/commit/053e67e3ec81cc9268ce30eaf0d6663d8639ed1e,2017-05-14T22:29Z
CWE-254,"CWE-254 static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
","<S2SV_ModStart> = seq ; if ( unlikely ( ! path_connected ( & nd -> path ) ) ) return - ENOENT ;
",torvalds@linux/397d425dc26da728396e66d392d5dcb8dac30c37,CVE-2015-2925,https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37,2015-11-16T11:59Z
CWE-119,"CWE-119 static plist_t parse_string_node ( const char * * bnode , uint64_t size ) { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_STRING ; data -> strval = ( char * ) malloc ( sizeof ( char ) * ( size + 1 ) ) ; <S2SV_StartBug> memcpy ( data -> strval , * bnode , size ) ; <S2SV_EndBug> data -> strval [ size ] = '\\0' ; data -> length = strlen ( data -> strval ) ; return node_create ( NULL , data ) ; }
","<S2SV_ModStart> ) ) ; if ( ! data -> strval ) { plist_free_data ( data ) ; PLIST_BIN_ERR ( ""%s:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>%"" PRIu64 ""<S2SV_blank>bytes\\n"" , __func__ , sizeof ( char ) * ( size + 1 ) ) ; return NULL ; }
",libimobiledevice@libplist/fbd8494d5e4e46bf2e90cb6116903e404374fb56,CVE-2017-6435,https://github.com/libimobiledevice/libplist/commit/fbd8494d5e4e46bf2e90cb6116903e404374fb56,2017-03-15T14:59Z
CWE-119,"CWE-119 static int rd_pick_intra4x4block ( MACROBLOCK * x , BLOCK * be , BLOCKD * b , B_PREDICTION_MODE * best_mode , const int * bmode_costs , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l , int * bestrate , int * bestratey , int * bestdistortion ) { B_PREDICTION_MODE mode ; int best_rd = INT_MAX ; int rate = 0 ; int distortion ; ENTROPY_CONTEXT ta = * a , tempa = * a ; ENTROPY_CONTEXT tl = * l , templ = * l ; <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , best_predictor , 16 * 4 ) ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , short , best_dqcoeff , 16 ) ; <S2SV_EndBug> int dst_stride = x -> e_mbd . dst . y_stride ; unsigned char * dst = x -> e_mbd . dst . y_buffer + b -> offset ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; unsigned char top_left = Above [ - 1 ] ; for ( mode = B_DC_PRED ; mode <= B_HU_PRED ; mode ++ ) { int this_rd ; int ratey ; rate = bmode_costs [ mode ] ; vp8_intra4x4_predict ( Above , yleft , dst_stride , mode , b -> predictor , 16 , top_left ) ; vp8_subtract_b ( be , b , 16 ) ; x -> short_fdct4x4 ( be -> src_diff , be -> coeff , 32 ) ; x -> quantize_b ( be , b ) ; tempa = ta ; templ = tl ; ratey = cost_coeffs ( x , b , PLANE_TYPE_Y_WITH_DC , & tempa , & templ ) ; rate += ratey ; distortion = vp8_block_error ( be -> coeff , b -> dqcoeff ) >> 2 ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( this_rd < best_rd ) { * bestrate = rate ; * bestratey = ratey ; * bestdistortion = distortion ; best_rd = this_rd ; * best_mode = mode ; * a = tempa ; * l = templ ; copy_predictor ( best_predictor , b -> predictor ) ; <S2SV_StartBug> vpx_memcpy ( best_dqcoeff , b -> dqcoeff , 32 ) ; <S2SV_EndBug> } } b -> bmi . as_mode = * best_mode ; vp8_short_idct4x4llm ( best_dqcoeff , best_predictor , 16 , dst , dst_stride ) ; return best_rd ; }
","<S2SV_ModStart> * l ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> char , best_predictor [ <S2SV_ModEnd> 16 * 4 <S2SV_ModStart> 16 * 4 ] ) ; DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> short , best_dqcoeff [ 16 ] <S2SV_ModEnd> ) ; int <S2SV_ModStart> predictor ) ; memcpy <S2SV_ModEnd> ( best_dqcoeff ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void <S2SV_EndBug> horDiff32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; wp += wc - 1 ; do { REPEAT4 ( stride , wp [ stride ] -= wp [ 0 ] ; wp -- ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
","<S2SV_ModStart> <S2SV_null> <S2SV_null> static int <S2SV_ModEnd> horDiff32 ( TIFF <S2SV_ModStart> / 4 ; if <S2SV_ModEnd> ( ( cc <S2SV_ModStart> stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff32"" , ""%s"" , ""(cc%(4*stride))!=0"" ) ; return 0 ; } <S2SV_ModEnd> if ( wc <S2SV_ModStart> ) ; } return 1 ;
",vadz@libtiff/3ca657a8793dd011bf869695d72ad31c779c3cc1,CVE-2016-9535,https://github.com/vadz/libtiff/commit/3ca657a8793dd011bf869695d72ad31c779c3cc1,2016-11-22T19:59Z
CWE-119,"CWE-119 void vp8_dequant_idct_add_uv_block_c ( short * q , short * dq , unsigned char * dstu , unsigned char * dstv , int stride , char * eobs ) { int i , j ; for ( i = 0 ; i < 2 ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dstu , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstu , stride , dstu , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 16 ; dstu += 4 ; } dstu += 4 * stride - 8 ; } for ( i = 0 ; i < 2 ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { if ( * eobs ++ > 1 ) vp8_dequant_idct_add_c ( q , dq , dstv , stride ) ; else { vp8_dc_only_idct_add_c ( q [ 0 ] * dq [ 0 ] , dstv , stride , dstv , stride ) ; <S2SV_StartBug> vpx_memset ( q , 0 , 2 * sizeof ( q [ 0 ] ) ) ; <S2SV_EndBug> } q += 16 ; dstv += 4 ; } dstv += 4 * stride - 8 ; } }
","<S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q , <S2SV_ModStart> stride ) ; memset <S2SV_ModEnd> ( q ,
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 <S2SV_StartBug> static void predict_and_reconstruct_intra_block ( int plane , int block , <S2SV_EndBug> BLOCK_SIZE plane_bsize , <S2SV_StartBug> TX_SIZE tx_size , void * arg ) { <S2SV_EndBug> struct intra_args * const args = ( struct intra_args * ) arg ; VP9_COMMON * const cm = args -> cm ; MACROBLOCKD * const xd = args -> xd ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> MODE_INFO * const mi = xd -> mi [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> const MB_PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) <S2SV_EndBug> : mi -> mbmi . uv_mode ; int x , y ; uint8_t * dst ; <S2SV_StartBug> txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ; <S2SV_EndBug> <S2SV_StartBug> dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ; <S2SV_EndBug> <S2SV_StartBug> vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , <S2SV_EndBug> b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ; <S2SV_StartBug> if ( ! mi -> mbmi . skip ) { <S2SV_EndBug> <S2SV_StartBug> const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , <S2SV_EndBug> plane_bsize , x , y , tx_size , args -> r ) ; inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ; } }
","<S2SV_ModStart> void predict_and_reconstruct_intra_block ( MACROBLOCKD * const xd , vpx_reader * r , MB_MODE_INFO * const mbmi , int plane , int row , int col <S2SV_ModEnd> , TX_SIZE tx_size <S2SV_ModStart> , TX_SIZE tx_size ) { <S2SV_ModEnd> struct macroblockd_plane * <S2SV_ModStart> plane ] ; PREDICTION_MODE <S2SV_ModEnd> mode = ( <S2SV_ModStart> 0 ) ? mbmi -> mode : mbmi -> uv_mode ; <S2SV_ModEnd> uint8_t * dst <S2SV_ModStart> * dst ; <S2SV_ModEnd> dst = & <S2SV_ModStart> [ 4 * row <S2SV_ModEnd> * pd -> <S2SV_ModStart> + 4 * col ] ; if ( mbmi -> sb_type < BLOCK_8X8 ) if ( plane == 0 ) mode = xd -> mi [ 0 ] -> bmi [ ( row <S2SV_ModEnd> << 1 ) <S2SV_ModStart> << 1 ) + col ] . as_mode ; vp9_predict_intra_block ( xd , pd -> n4_wl , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , col , row <S2SV_ModEnd> , plane ) <S2SV_ModStart> if ( ! mbmi -> <S2SV_ModEnd> skip ) { <S2SV_ModStart> ) { const TX_TYPE tx_type = ( plane || xd -> lossless ) ? DCT_DCT : intra_mode_to_tx_type_lookup [ mode ] ; const scan_order * sc = ( plane || xd -> lossless ) ? & vp9_default_scan_orders [ tx_size ] : & vp9_scan_orders [ tx_size ] [ tx_type ] ; const <S2SV_ModStart> = vp9_decode_block_tokens ( xd , plane , sc , col , row , tx_size , r , mbmi -> segment_id ) ; inverse_transform_block_intra ( xd , plane , tx_type , tx_size , dst , pd -> dst . stride , <S2SV_ModEnd> eob ) ;
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-119,"CWE-119 void vp8_bilinear_predict4x4_neon ( unsigned char * src_ptr , int src_pixels_per_line , int xoffset , int yoffset , unsigned char * dst_ptr , int dst_pitch ) { uint8x8_t d0u8 , d1u8 , d2u8 , d3u8 , d4u8 , d5u8 , d6u8 ; uint8x8_t d26u8 , d27u8 , d28u8 , d29u8 , d30u8 ; <S2SV_StartBug> uint32x2_t d28u32 , d29u32 , d30u32 ; <S2SV_EndBug> uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 0 ) ; src_ptr += src_pixels_per_line ; d28u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d28u32 , 1 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 0 ) ; src_ptr += src_pixels_per_line ; d29u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d29u32 , 1 ) ; src_ptr += src_pixels_per_line ; d30u32 = vld1_lane_u32 ( ( const uint32_t * ) src_ptr , d30u32 , 0 ) ; d28u8 = vreinterpret_u8_u32 ( d28u32 ) ; d29u8 = vreinterpret_u8_u32 ( d29u32 ) ; d30u8 = vreinterpret_u8_u32 ( d30u32 ) ; } else { d2u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d3u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d4u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d5u8 = vld1_u8 ( src_ptr ) ; src_ptr += src_pixels_per_line ; d6u8 = vld1_u8 ( src_ptr ) ; q1u8 = vcombine_u8 ( d2u8 , d3u8 ) ; q2u8 = vcombine_u8 ( d4u8 , d5u8 ) ; <S2SV_StartBug> d0u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> d1u8 = vdup_n_u8 ( ( uint8_t ) bifilter4_coeff [ xoffset ] [ 1 ] ) ; <S2SV_EndBug> q4u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q1u8 ) , 8 ) ; q5u64 = vshrq_n_u64 ( vreinterpretq_u64_u8 ( q2u8 ) , 8 ) ; d12u64 = vshr_n_u64 ( vreinterpret_u64_u8 ( d6u8 ) , 8 ) ; d0u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q1u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q1u8 ) ) ) ; d1u32x2 = vzip_u32 ( vreinterpret_u32_u8 ( vget_low_u8 ( q2u8 ) ) , vreinterpret_u32_u8 ( vget_high_u8 ( q2u8 ) ) ) ; d2u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q4u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q4u64 ) ) ) ; d3u32x2 = vzip_u32 ( vreinterpret_u32_u64 ( vget_low_u64 ( q5u64 ) ) , vreinterpret_u32_u64 ( vget_high_u64 ( q5u64 ) ) ) ; q7u16 = vmull_u8 ( vreinterpret_u8_u32 ( d0u32x2 . val [ 0 ] ) , d0u8 ) ; q8u16 = vmull_u8 ( vreinterpret_u8_u32 ( d1u32x2 . val [ 0 ] ) , d0u8 ) ; q9u16 = vmull_u8 ( d6u8 , d0u8 ) ; q7u16 = vmlal_u8 ( q7u16 , vreinterpret_u8_u32 ( d2u32x2 . val [ 0 ] ) , d1u8 ) ; q8u16 = vmlal_u8 ( q8u16 , vreinterpret_u8_u32 ( d3u32x2 . val [ 0 ] ) , d1u8 ) ; q9u16 = vmlal_u8 ( q9u16 , vreinterpret_u8_u64 ( d12u64 ) , d1u8 ) ; d28u8 = vqrshrn_n_u16 ( q7u16 , 7 ) ; d29u8 = vqrshrn_n_u16 ( q8u16 , 7 ) ; d30u8 = vqrshrn_n_u16 ( q9u16 , 7 ) ; } if ( yoffset == 0 ) { vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d28u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d29u8 ) , 1 ) ; } else { d0u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 0 ] ) ; d1u8 = vdup_n_u8 ( bifilter4_coeff [ yoffset ] [ 1 ] ) ; q1u16 = vmull_u8 ( d28u8 , d0u8 ) ; q2u16 = vmull_u8 ( d29u8 , d0u8 ) ; d26u8 = vext_u8 ( d28u8 , d29u8 , 4 ) ; d27u8 = vext_u8 ( d29u8 , d30u8 , 4 ) ; q1u16 = vmlal_u8 ( q1u16 , d26u8 , d1u8 ) ; q2u16 = vmlal_u8 ( q2u16 , d27u8 , d1u8 ) ; d2u8 = vqrshrn_n_u16 ( q1u16 , 7 ) ; d3u8 = vqrshrn_n_u16 ( q2u16 , 7 ) ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d2u8 ) , 1 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 0 ) ; dst_ptr += dst_pitch ; vst1_lane_u32 ( ( uint32_t * ) dst_ptr , vreinterpret_u32_u8 ( d3u8 ) , 1 ) ; } return ; }
","<S2SV_ModStart> , d30u8 ; uint8x16_t q1u8 , q2u8 ; uint16x8_t q1u16 , q2u16 ; uint16x8_t q7u16 , q8u16 , q9u16 ; uint64x2_t q4u64 , q5u64 ; uint64x1_t d12u64 ; uint32x2x2_t d0u32x2 , d1u32x2 , d2u32x2 , d3u32x2 ; if ( xoffset == 0 ) { uint32x2_t d28u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d29u32 = vdup_n_u32 ( 0 ) ; uint32x2_t d30u32 = vdup_n_u32 ( 0 ) ; <S2SV_ModEnd> d28u32 = vld1_lane_u32 <S2SV_ModStart> = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset <S2SV_ModStart> = vdup_n_u8 ( <S2SV_ModEnd> bifilter4_coeff [ xoffset
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-772,"CWE-772 static Image * ReadPALMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; IndexPacket index ; MagickBooleanType status ; MagickOffsetType totalOffset , seekNextDepth ; MagickPixelPacket transpix ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; size_t bytes_per_row , flags , bits_per_pixel , version , nextDepthOffset , transparentIndex , compressionType , byte , mask , redbits , greenbits , bluebits , one , pad , size , bit ; ssize_t count , y ; unsigned char <S2SV_StartBug> * lastrow , <S2SV_EndBug> * one_row , * ptr ; unsigned short color16 ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } totalOffset = 0 ; do { image -> columns = ReadBlobMSBShort ( image ) ; image -> rows = ReadBlobMSBShort ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } bytes_per_row = ReadBlobMSBShort ( image ) ; flags = ReadBlobMSBShort ( image ) ; bits_per_pixel = ( size_t ) ReadBlobByte ( image ) ; if ( ( bits_per_pixel != 1 ) && ( bits_per_pixel != 2 ) && ( bits_per_pixel != 4 ) && ( bits_per_pixel != 8 ) && ( bits_per_pixel != 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; version = ( size_t ) ReadBlobByte ( image ) ; if ( ( version != 0 ) && ( version != 1 ) && ( version != 2 ) ) ThrowReaderException ( CorruptImageError , ""FileFormatVersionMismatch"" ) ; nextDepthOffset = ( size_t ) ReadBlobMSBShort ( image ) ; transparentIndex = ( size_t ) ReadBlobByte ( image ) ; compressionType = ( size_t ) ReadBlobByte ( image ) ; if ( ( compressionType != PALM_COMPRESSION_NONE ) && ( compressionType != PALM_COMPRESSION_SCANLINE ) && ( compressionType != PALM_COMPRESSION_RLE ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; pad = ReadBlobMSBShort ( image ) ; ( void ) pad ; one = 1 ; if ( ( bits_per_pixel < 16 ) && ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; GetMagickPixelPacket ( image , & transpix ) ; if ( bits_per_pixel == 16 ) { redbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) redbits ; greenbits = ( size_t ) ReadBlobByte ( image ) ; ( void ) greenbits ; bluebits = ( size_t ) ReadBlobByte ( image ) ; ( void ) bluebits ; ReadBlobByte ( image ) ; ReadBlobByte ( image ) ; transpix . red = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; transpix . green = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 63 ) ; transpix . blue = ( MagickRealType ) ( QuantumRange * ReadBlobByte ( image ) / 31 ) ; } if ( bits_per_pixel == 8 ) { IndexPacket index ; if ( flags & PALM_HAS_COLORMAP_FLAG ) { count = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) count ; i ++ ) { ReadBlobByte ( image ) ; index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; } } else for ( i = 0 ; i < ( ssize_t ) ( 1L << bits_per_pixel ) ; i ++ ) { index = ConstrainColormapIndex ( image , ( size_t ) ( 255 - i ) ) ; image -> colormap [ ( int ) index ] . red = ScaleCharToQuantum ( PalmPalette [ i ] [ 0 ] ) ; image -> colormap [ ( int ) index ] . green = ScaleCharToQuantum ( PalmPalette [ i ] [ 1 ] ) ; image -> colormap [ ( int ) index ] . blue = ScaleCharToQuantum ( PalmPalette [ i ] [ 2 ] ) ; } } if ( flags & PALM_IS_COMPRESSED_FLAG ) size = ReadBlobMSBShort ( image ) ; ( void ) size ; image -> storage_class = DirectClass ; if ( bits_per_pixel < 16 ) { image -> storage_class = PseudoClass ; image -> depth = 8 ; } if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( image ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } one_row = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , 2 * image -> columns ) , sizeof ( * one_row ) ) ; if ( one_row == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; <S2SV_StartBug> lastrow = ( unsigned char * ) NULL ; <S2SV_EndBug> if ( compressionType == PALM_COMPRESSION_SCANLINE ) { <S2SV_StartBug> lastrow = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( bytes_per_row , <S2SV_EndBug> <S2SV_StartBug> 2 * image -> columns ) , sizeof ( * lastrow ) ) ; <S2SV_EndBug> if ( lastrow == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } mask = ( size_t ) ( 1U << bits_per_pixel ) - 1 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( ( flags & PALM_IS_COMPRESSED_FLAG ) == 0 ) { image -> compression = NoCompression ; count = ReadBlob ( image , bytes_per_row , one_row ) ; if ( count != ( ssize_t ) bytes_per_row ) break ; } else { if ( compressionType == PALM_COMPRESSION_RLE ) { image -> compression = RLECompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; count = MagickMin ( count , ( ssize_t ) bytes_per_row - i ) ; byte = ( size_t ) ReadBlobByte ( image ) ; ( void ) ResetMagickMemory ( one_row + i , ( int ) byte , ( size_t ) count ) ; i += count ; } } else if ( compressionType == PALM_COMPRESSION_SCANLINE ) { size_t one ; one = 1 ; image -> compression = FaxCompression ; for ( i = 0 ; i < ( ssize_t ) bytes_per_row ; i += 8 ) { count = ( ssize_t ) ReadBlobByte ( image ) ; if ( count < 0 ) break ; byte = ( size_t ) MagickMin ( ( ssize_t ) bytes_per_row - i , 8 ) ; for ( bit = 0 ; bit < byte ; bit ++ ) { if ( ( y == 0 ) || ( count & ( one << ( 7 - bit ) ) ) ) one_row [ i + bit ] = ( unsigned char ) ReadBlobByte ( image ) ; else <S2SV_StartBug> one_row [ i + bit ] = lastrow [ i + bit ] ; <S2SV_EndBug> } } <S2SV_StartBug> ( void ) CopyMagickMemory ( lastrow , one_row , bytes_per_row ) ; <S2SV_EndBug> } } ptr = one_row ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; if ( bits_per_pixel == 16 ) { if ( image -> columns > ( 2 * bytes_per_row ) ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { color16 = ( * ptr ++ << 8 ) ; color16 |= ( * ptr ++ ) ; SetPixelRed ( q , ( QuantumRange * ( ( color16 >> 11 ) & 0x1f ) ) / 0x1f ) ; SetPixelGreen ( q , ( QuantumRange * ( ( color16 >> 5 ) & 0x3f ) ) / 0x3f ) ; SetPixelBlue ( q , ( QuantumRange * ( ( color16 >> 0 ) & 0x1f ) ) / 0x1f ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } else { bit = 8 - bits_per_pixel ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( ( size_t ) ( ptr - one_row ) >= bytes_per_row ) { one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } index = ( IndexPacket ) ( mask - ( ( ( * ptr ) & ( mask << bit ) ) >> bit ) ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; if ( bit ) bit -= bits_per_pixel ; else { ptr ++ ; bit = 8 - bits_per_pixel ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( flags & PALM_HAS_TRANSPARENCY_FLAG ) { IndexPacket index = ConstrainColormapIndex ( image , ( mask - transparentIndex ) ) ; if ( bits_per_pixel != 16 ) SetMagickPixelPacket ( image , image -> colormap + ( ssize_t ) index , ( const IndexPacket * ) NULL , & transpix ) ; ( void ) TransparentPaintImage ( image , & transpix , ( Quantum ) TransparentOpacity , MagickFalse ) ; } one_row = ( unsigned char * ) RelinquishMagickMemory ( one_row ) ; if ( compressionType == PALM_COMPRESSION_SCANLINE ) <S2SV_StartBug> lastrow = ( unsigned char * ) RelinquishMagickMemory ( lastrow ) ; <S2SV_EndBug> if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( nextDepthOffset != 0 ) { totalOffset += ( MagickOffsetType ) ( nextDepthOffset * 4 ) ; if ( totalOffset >= ( MagickOffsetType ) GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else seekNextDepth = SeekBlob ( image , totalOffset , SEEK_SET ) ; if ( seekNextDepth != totalOffset ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { ( void ) DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( nextDepthOffset != 0 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
","<S2SV_ModStart> unsigned char * last_row <S2SV_ModEnd> , * one_row <S2SV_ModStart> ""MemoryAllocationFailed"" ) ; last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> PALM_COMPRESSION_SCANLINE ) { last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> sizeof ( * last_row ) ) ; if ( last_row <S2SV_ModEnd> == ( unsigned <S2SV_ModStart> bit ] = last_row <S2SV_ModEnd> [ i + <S2SV_ModStart> ) CopyMagickMemory ( last_row <S2SV_ModEnd> , one_row , <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; ThrowReaderException <S2SV_ModStart> == PALM_COMPRESSION_SCANLINE ) last_row <S2SV_ModEnd> = ( unsigned <S2SV_ModStart> ) RelinquishMagickMemory ( last_row <S2SV_ModEnd> ) ; if
",ImageMagick@ImageMagick/db1ffb6cf44bcfe5c4d5fcf9d9109ded5617387f,CVE-2017-12664,https://github.com/ImageMagick/ImageMagick/commit/db1ffb6cf44bcfe5c4d5fcf9d9109ded5617387f,2017-08-07T21:29Z
CWE-000,"CWE-000 int main ( int argc , char * argv [ ] ) { int result ; int infoOnly = 0 ; int writeToStdio = 0 ; int readFromStdin = 0 ; int object_type = LC ; int def_srate = 0 ; int downMatrix = 0 ; int format = 1 ; int outputFormat = FAAD_FMT_16BIT ; int outfile_set = 0 ; int adts_out = 0 ; int old_format = 0 ; int showHelp = 0 ; int mp4file = 0 ; int noGapless = 0 ; char * fnp ; <S2SV_StartBug> char aacFileName [ 255 ] ; <S2SV_EndBug> char audioFileName [ 255 ] ; char adtsFileName [ 255 ] ; unsigned char header [ 8 ] ; float length = 0 ; FILE * hMP4File ; # ifdef _WIN32 long begin ; # else clock_t begin ; # endif unsigned long cap = NeAACDecGetCapabilities ( ) ; progName = argv [ 0 ] ; while ( 1 ) { int c = - 1 ; int option_index = 0 ; static struct option long_options [ ] = { { ""quiet"" , 0 , 0 , 'q' } , { ""outfile"" , 0 , 0 , 'o' } , { ""adtsout"" , 0 , 0 , 'a' } , { ""oldformat"" , 0 , 0 , 't' } , { ""format"" , 0 , 0 , 'f' } , { ""bits"" , 0 , 0 , 'b' } , { ""samplerate"" , 0 , 0 , 's' } , { ""objecttype"" , 0 , 0 , 'l' } , { ""downmix"" , 0 , 0 , 'd' } , { ""info"" , 0 , 0 , 'i' } , { ""stdio"" , 0 , 0 , 'w' } , { ""stdio"" , 0 , 0 , 'g' } , { ""help"" , 0 , 0 , 'h' } , { 0 , 0 , 0 , 0 } } ; c = getopt_long ( argc , argv , ""o:a:s:f:b:l:wgdhitq"" , long_options , & option_index ) ; if ( c == - 1 ) break ; switch ( c ) { case 'o' : if ( optarg ) { outfile_set = 1 ; <S2SV_StartBug> strcpy ( audioFileName , optarg ) ; <S2SV_EndBug> } break ; case 'a' : if ( optarg ) { adts_out = 1 ; <S2SV_StartBug> strcpy ( adtsFileName , optarg ) ; <S2SV_EndBug> } break ; case 's' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { def_srate = 0 ; } else { def_srate = atoi ( dr ) ; } } break ; case 'f' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { format = 1 ; } else { format = atoi ( dr ) ; if ( ( format < 1 ) || ( format > 2 ) ) showHelp = 1 ; } } break ; case 'b' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { outputFormat = FAAD_FMT_16BIT ; } else { outputFormat = atoi ( dr ) ; if ( ( outputFormat < 1 ) || ( outputFormat > 5 ) ) showHelp = 1 ; } } break ; case 'l' : if ( optarg ) { char dr [ 10 ] ; if ( sscanf ( optarg , ""%s"" , dr ) < 1 ) { object_type = LC ; } else { object_type = atoi ( dr ) ; if ( ( object_type != LC ) && ( object_type != MAIN ) && ( object_type != LTP ) && ( object_type != LD ) ) { showHelp = 1 ; } } } break ; case 't' : old_format = 1 ; break ; case 'd' : downMatrix = 1 ; break ; case 'w' : writeToStdio = 1 ; break ; case 'g' : noGapless = 1 ; break ; case 'i' : infoOnly = 1 ; break ; case 'h' : showHelp = 1 ; break ; case 'q' : quiet = 1 ; break ; default : break ; } } faad_fprintf ( stderr , ""<S2SV_blank>***********<S2SV_blank>Ahead<S2SV_blank>Software<S2SV_blank>MPEG-4<S2SV_blank>AAC<S2SV_blank>Decoder<S2SV_blank>V%s<S2SV_blank>******************\\n\\n"" , FAAD2_VERSION ) ; faad_fprintf ( stderr , ""<S2SV_blank>Build:<S2SV_blank>%s\\n"" , __DATE__ ) ; faad_fprintf ( stderr , ""<S2SV_blank>Copyright<S2SV_blank>2002-2004:<S2SV_blank>Ahead<S2SV_blank>Software<S2SV_blank>AG\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>http://www.audiocoding.com\\n"" ) ; if ( cap & FIXED_POINT_CAP ) faad_fprintf ( stderr , ""<S2SV_blank>Fixed<S2SV_blank>point<S2SV_blank>version\\n"" ) ; else faad_fprintf ( stderr , ""<S2SV_blank>Floating<S2SV_blank>point<S2SV_blank>version\\n"" ) ; faad_fprintf ( stderr , ""\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License.\\n"" ) ; faad_fprintf ( stderr , ""\\n"" ) ; faad_fprintf ( stderr , ""<S2SV_blank>**************************************************************************\\n\\n"" ) ; if ( ( ( argc - optind ) < 1 ) || showHelp ) { usage ( ) ; return 1 ; } # if 0 if ( writeToStdio == 1 ) { format = 2 ; } <S2SV_StartBug> # endif <S2SV_EndBug> strcpy ( aacFileName , argv [ optind ] ) ; # ifdef _WIN32 begin = GetTickCount ( ) ; # else begin = clock ( ) ; # endif if ( ! writeToStdio && ! outfile_set ) { <S2SV_StartBug> strcpy ( audioFileName , aacFileName ) ; <S2SV_EndBug> fnp = ( char * ) strrchr ( audioFileName , '.' ) ; if ( fnp ) fnp [ 0 ] = '\\0' ; strcat ( audioFileName , file_ext [ format ] ) ; } if ( 0 == strcmp ( aacFileName , ""-"" ) ) { faad_fprintf ( stderr , ""Reading<S2SV_blank>from<S2SV_blank>stdin:<S2SV_blank>%s\\n"" , aacFileName ) ; readFromStdin = 1 ; hMP4File = stdin ; # ifdef _WIN32 setmode ( fileno ( stdin ) , O_BINARY ) ; # endif } else { mp4file = 0 ; hMP4File = fopen ( aacFileName , ""rb"" ) ; if ( ! hMP4File ) { faad_fprintf ( stderr , ""Error<S2SV_blank>opening<S2SV_blank>file:<S2SV_blank>%s\\n"" , aacFileName ) ; return 1 ; } } fread ( header , 1 , 8 , hMP4File ) ; if ( ! readFromStdin ) fclose ( hMP4File ) ; if ( header [ 4 ] == 'f' && header [ 5 ] == 't' && header [ 6 ] == 'y' && header [ 7 ] == 'p' ) mp4file = 1 ; if ( mp4file ) { result = decodeMP4file ( aacFileName , audioFileName , adtsFileName , writeToStdio , outputFormat , format , downMatrix , noGapless , infoOnly , adts_out , & length ) ; } else { if ( readFromStdin == 1 ) { ungetc ( header [ 7 ] , hMP4File ) ; ungetc ( header [ 6 ] , hMP4File ) ; ungetc ( header [ 5 ] , hMP4File ) ; ungetc ( header [ 4 ] , hMP4File ) ; ungetc ( header [ 3 ] , hMP4File ) ; ungetc ( header [ 2 ] , hMP4File ) ; ungetc ( header [ 1 ] , hMP4File ) ; ungetc ( header [ 0 ] , hMP4File ) ; } result = decodeAACfile ( aacFileName , audioFileName , adtsFileName , writeToStdio , def_srate , object_type , outputFormat , format , downMatrix , infoOnly , adts_out , old_format , & length ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! result && ! infoOnly ) { # ifdef _WIN32 float dec_length = ( float ) ( GetTickCount ( ) - begin ) / 1000.0 ; SetConsoleTitle ( ""FAAD"" ) ; # else float dec_length = ( float ) ( clock ( ) - begin ) / ( float ) CLOCKS_PER_SEC ; # endif faad_fprintf ( stderr , ""Decoding<S2SV_blank>%s<S2SV_blank>took:<S2SV_blank>%5.2f<S2SV_blank>sec.<S2SV_blank>%5.2fx<S2SV_blank>real-time.\\n"" , aacFileName , dec_length , length / dec_length ) ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> fnp ; char * aacFileName = NULL ; char * audioFileName = NULL ; char * adtsFileName = NULL <S2SV_ModEnd> ; unsigned char <S2SV_ModStart> = 1 ; audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> = 1 ; adtsFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( optarg ) + 1 ) ) ; if ( adtsFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>adtsFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> } # endif aacFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( argv [ optind ] ) + 1 ) ) ; if ( aacFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>aacFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> outfile_set ) { audioFileName = ( char * ) malloc ( sizeof ( char ) * ( strlen ( aacFileName ) + strlen ( file_ext [ format ] ) + 1 ) ) ; if ( audioFileName == NULL ) { faad_fprintf ( stderr , ""Error<S2SV_blank>allocating<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>audioFileName.\\n"" ) ; return 1 ; } <S2SV_ModStart> ) ; } if ( audioFileName != NULL ) free ( audioFileName ) ; if ( adtsFileName != NULL ) free ( adtsFileName ) ; <S2SV_ModStart> ) ; } if ( aacFileName != NULL ) free ( aacFileName ) ;
",knik0@faad2/720f7004d6c4aabee19aad16e7c456ed76a3ebfa,CVE-2021-26567,https://github.com/knik0/faad2/commit/720f7004d6c4aabee19aad16e7c456ed76a3ebfa,2021-02-26T22:15Z
CWE-119,"CWE-119 void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }
","<S2SV_ModStart> = abs_delta ; memcpy <S2SV_ModEnd> ( seg ->
",external@libvpx/5a9753fca56f0eeb9f61e342b2fccffc364f9426,CVE-2016-1621,https://android.googlesource.com/platform/external/libvpx/+/5a9753fca56f0eeb9f61e342b2fccffc364f9426,2016-03-12T21:59Z
CWE-190,"CWE-190 int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : <S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> - EFAULT : 0 ; default : return - EFAULT ; } }
","<S2SV_ModStart> case RXE_MEM_TYPE_FMR : if <S2SV_ModEnd> ( iova < <S2SV_ModStart> mem -> iova || length > mem -> length || iova > <S2SV_ModEnd> mem -> iova <S2SV_ModStart> mem -> length - length ) return - EFAULT ; return <S2SV_ModEnd> 0 ; default
",torvalds@linux/647bf3d8a8e5777319da92af672289b2a6c4dc66,CVE-2016-8636,https://github.com/torvalds/linux/commit/647bf3d8a8e5777319da92af672289b2a6c4dc66,2017-02-22T16:59Z
CWE-269,"CWE-269 static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>a<S2SV_blank>symbolic<S2SV_blank>link\\n"" , dest ) ; exit ( 1 ) ; } <S2SV_StartBug> pid_t child = fork ( ) ; <S2SV_EndBug> if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) ; <S2SV_StartBug> if ( rv ) <S2SV_EndBug> fprintf ( stderr , ""Warning:<S2SV_blank>cannot<S2SV_blank>transfer<S2SV_blank>.asoundrc<S2SV_blank>in<S2SV_blank>private<S2SV_blank>home<S2SV_blank>directory\\n"" ) ; else { <S2SV_StartBug> fs_logger2 ( ""clone"" , dest ) ; <S2SV_EndBug> } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; unlink ( src ) ; }
","<S2SV_ModStart> ) ; } copy_file_as_user <S2SV_ModEnd> ( src , <S2SV_ModStart> S_IWUSR ) ; <S2SV_ModEnd> fs_logger2 ( ""clone"" <S2SV_ModStart> ""clone"" , dest <S2SV_ModEnd> ) ; unlink
",netblue30@firejail/b8a4ff9775318ca5e679183884a6a63f3da8f863,CVE-2017-5940,https://github.com/netblue30/firejail/commit/b8a4ff9775318ca5e679183884a6a63f3da8f863,2017-02-09T18:59Z
CWE-20,"CWE-20 void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( ""tcp_sack_option"" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }
","<S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
",openbsd@src/ed8fdce754a5d8d14c09e989d8877707bd43906f,CVE-2019-8460,https://github.com/openbsd/src/commit/ed8fdce754a5d8d14c09e989d8877707bd43906f,2019-08-26T20:15Z
CWE-772,"CWE-772 gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_strings"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
","<S2SV_ModStart> ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
",krb5@krb5/83ed75feba32e46f736fcce0d96a0445f29b96c2,CVE-2015-8631,https://github.com/krb5/krb5/commit/83ed75feba32e46f736fcce0d96a0445f29b96c2,2016-02-13T02:59Z
CWE-295,"CWE-295 int luaopen_x509 ( lua_State * L ) { auxiliar_newclass ( L , ""openssl.x509"" , x509_funcs ) ; lua_newtable ( L ) ; luaL_setfuncs ( L , R , 0 ) ; openssl_register_xname ( L ) ; lua_setfield ( L , - 2 , ""name"" ) ; openssl_register_xattribute ( L ) ; lua_setfield ( L , - 2 , ""attribute"" ) ; openssl_register_xextension ( L ) ; lua_setfield ( L , - 2 , ""extension"" ) ; openssl_register_xstore ( L ) ; lua_setfield ( L , - 2 , ""store"" ) ; openssl_register_xalgor ( L ) ; lua_setfield ( L , - 2 , ""algor"" ) ; luaopen_x509_req ( L ) ; lua_setfield ( L , - 2 , ""req"" ) ; luaopen_x509_crl ( L ) ; lua_setfield ( L , - 2 , ""crl"" ) ; lua_pushliteral ( L , ""version"" ) ; lua_pushliteral ( L , MYVERSION ) ; lua_settable ( L , - 3 ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }
","<S2SV_ModStart> 3 ) ; # if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ; lua_newtable ( L ) ; auxiliar_enumerate ( L , - 1 , check_flags_const ) ; lua_settable ( L , - 3 ) ; # endif
",zhaozg@lua-openssl/a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca,CVE-2020-9434,https://github.com/zhaozg/lua-openssl/commit/a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca,2020-02-27T23:15Z
CWE-190,"CWE-190 jas_matrix_t * jas_matrix_copy ( jas_matrix_t * x ) { jas_matrix_t * y ; <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; y = jas_matrix_create ( x -> numrows_ , x -> numcols_ ) ; for ( i = 0 ; i < x -> numrows_ ; ++ i ) { for ( j = 0 ; j < x -> numcols_ ; ++ j ) { * jas_matrix_getref ( y , i , j ) = jas_matrix_get ( x , i , j ) ; } } return y ; }
","<S2SV_ModStart> * y ; jas_matind_t i ; jas_matind_t <S2SV_ModEnd> j ; y
",mdadams@jasper/d42b2388f7f8e0332c846675133acea151fc557a,CVE-2016-9557,https://github.com/mdadams/jasper/commit/d42b2388f7f8e0332c846675133acea151fc557a,2017-03-23T18:59Z
CWE-200,"CWE-200 static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock<S2SV_blank>%p<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; }
","<S2SV_ModStart> -> id ; haddr -> hci_channel = 0 ;
",torvalds@linux/3f68ba07b1da811bf383b4b701b129bfcb2e4988,CVE-2012-6544,https://github.com/torvalds/linux/commit/3f68ba07b1da811bf383b4b701b129bfcb2e4988,2013-03-15T20:55Z
CWE-476,"CWE-476 static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; int flags = 0 ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; if ( PF_INET6 == assoc -> base . sk -> sk_family ) flags = SCTP_ADDR6_ALLOWED ; if ( assoc -> peer . ipv4_address ) flags |= SCTP_ADDR4_PEERSUPP ; if ( assoc -> peer . ipv6_address ) flags |= SCTP_ADDR6_PEERSUPP ; sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } skb_queue_head_init ( & newsp -> pd_lobby ) ; sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; if ( sctp_sk ( oldsk ) -> pd_mode ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } if ( assoc -> ulpq . pd_mode ) <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> } newsp -> type = type ; sctp_lock_sock ( newsk ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; sctp_release_sock ( newsk ) ; }
","<S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk
",torvalds@linux/ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d,CVE-2011-2482,https://github.com/torvalds/linux/commit/ea2bc483ff5caada7c4aa0d5fbf87d3a6590273d,2013-06-08T13:05Z
CWE-125,"CWE-125 void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding<S2SV_blank>l=%u<S2SV_blank>n=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0,<S2SV_blank>type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SEARCH_TYPE : case MINISSDPD_SEARCH_USN : case MINISSDPD_SEARCH_ALL : rp = rbuf + 1 ; while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == MINISSDPD_SEARCH_TYPE && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_USN && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == MINISSDPD_SEARCH_ALL ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write_or_buffer ( req , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case MINISSDPD_SUBMIT : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ; if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; <S2SV_StartBug> if ( p + l > buf + n ) { <S2SV_EndBug> syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>already<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; sendNotifications ( NOTIF_NEW , NULL , newserv ) ; newserv = NULL ; break ; case MINISSDPD_NOTIF : rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } req -> is_notify = 1 ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write_or_buffer ( req , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }
","<S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p ) <S2SV_ModStart> ; if ( l > ( unsigned ) ( <S2SV_ModEnd> buf + n <S2SV_ModStart> buf + n - p )
",miniupnp@miniupnp/b238cade9a173c6f751a34acf8ccff838a62aa47,CVE-2016-3178,https://github.com/miniupnp/miniupnp/commit/b238cade9a173c6f751a34acf8ccff838a62aa47,2017-03-24T15:59Z
CWE-362,"CWE-362 static int <S2SV_StartBug> mptctl_do_fw_download ( int ioc , char __user * ufwbuf , size_t fwlen ) <S2SV_EndBug> { FWDownload_t * dlmsg ; <S2SV_StartBug> MPT_FRAME_HDR * mf ; <S2SV_EndBug> MPT_ADAPTER * iocp ; FWDownloadTCSGE_t * ptsge ; MptSge_t * sgl , * sgIn ; char * sgOut ; struct buflist * buflist ; struct buflist * bl ; dma_addr_t sgl_dma ; int ret ; int numfrags = 0 ; int maxfrags ; int n = 0 ; u32 sgdir ; u32 nib ; int fw_bytes_copied = 0 ; int i ; int sge_offset = 0 ; u16 iocstat ; pFWDownloadReply_t ReplyMsg = NULL ; unsigned long timeleft ; <S2SV_StartBug> if ( mpt_verify_adapter ( ioc , & iocp ) < 0 ) { <S2SV_EndBug> printk ( KERN_DEBUG MYNAM ""ioctl_fwdl<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , ioc ) ; return - ENODEV ; } else { if ( ( mf = mpt_get_msg_frame ( mptctl_id , iocp ) ) == NULL ) return - EAGAIN ; <S2SV_StartBug> } <S2SV_EndBug> dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""mptctl_do_fwdl<S2SV_blank>called.<S2SV_blank>mptctl_id<S2SV_blank>=<S2SV_blank>%xh.\\n"" , iocp -> name , mptctl_id ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.bufp<S2SV_blank><S2SV_blank>=<S2SV_blank>%p\\n"" , iocp -> name , ufwbuf ) ) ; dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.fwlen<S2SV_blank>=<S2SV_blank>%d\\n"" , <S2SV_StartBug> iocp -> name , ( int ) fwlen ) ) ; <S2SV_EndBug> dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>kfwdl.ioc<S2SV_blank><S2SV_blank><S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , ioc ) ) ; dlmsg = ( FWDownload_t * ) mf ; ptsge = ( FWDownloadTCSGE_t * ) & dlmsg -> SGL ; sgOut = ( char * ) ( ptsge + 1 ) ; dlmsg -> ImageType = MPI_FW_DOWNLOAD_ITYPE_FW ; dlmsg -> Reserved = 0 ; dlmsg -> ChainOffset = 0 ; dlmsg -> Function = MPI_FUNCTION_FW_DOWNLOAD ; dlmsg -> Reserved1 [ 0 ] = dlmsg -> Reserved1 [ 1 ] = dlmsg -> Reserved1 [ 2 ] = 0 ; if ( iocp -> facts . MsgVersion >= MPI_VERSION_01_05 ) dlmsg -> MsgFlags = MPI_FW_DOWNLOAD_MSGFLGS_LAST_SEGMENT ; else dlmsg -> MsgFlags = 0 ; ptsge -> Reserved = 0 ; ptsge -> ContextSize = 0 ; ptsge -> DetailsLength = 12 ; ptsge -> Flags = MPI_SGE_FLAGS_TRANSACTION_ELEMENT ; ptsge -> Reserved_0100_Checksum = 0 ; ptsge -> ImageOffset = 0 ; ptsge -> ImageSize = cpu_to_le32 ( fwlen ) ; sgdir = 0x04000000 ; sge_offset = sizeof ( MPIHeader_t ) + sizeof ( FWDownloadTCSGE_t ) ; if ( ( sgl = kbuf_alloc_2_sgl ( fwlen , sgdir , sge_offset , & numfrags , & buflist , & sgl_dma , iocp ) ) == NULL ) return - ENOMEM ; maxfrags = ( iocp -> req_sz - sizeof ( MPIHeader_t ) - sizeof ( FWDownloadTCSGE_t ) ) / iocp -> SGE_size ; if ( numfrags > maxfrags ) { ret = - EMLINK ; goto fwdl_out ; } dctlprintk ( iocp , printk ( MYIOC_s_DEBUG_FMT ""DbG:<S2SV_blank>sgl<S2SV_blank>buffer<S2SV_blank>=<S2SV_blank>%p,<S2SV_blank>sgfrags<S2SV_blank>=<S2SV_blank>%d\\n"" , iocp -> name , sgl , numfrags ) ) ; ret = - EFAULT ; sgIn = sgl ; bl = buflist ; for ( i = 0 ; i < numfrags ; i ++ ) { nib = ( sgIn -> FlagsLength & 0x30000000 ) >> 28 ; if ( nib == 0 || nib == 3 ) { ; } else if ( sgIn -> Address ) { iocp -> add_sge ( sgOut , sgIn -> FlagsLength , sgIn -> Address ) ; n ++ ; if ( copy_from_user ( bl -> kptr , ufwbuf + fw_bytes_copied , bl -> len ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::_ioctl_fwdl<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>copy<S2SV_blank>f/w<S2SV_blank>buffer<S2SV_blank>hunk#%d<S2SV_blank>@<S2SV_blank>%p\\n"" , iocp -> name , __FILE__ , __LINE__ , n , ufwbuf ) ; goto fwdl_out ; } fw_bytes_copied += bl -> len ; } sgIn ++ ; bl ++ ; sgOut += iocp -> SGE_size ; } DBG_DUMP_FW_DOWNLOAD ( iocp , ( u32 * ) mf , numfrags ) ; ReplyMsg = NULL ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , dlmsg -> MsgContext ) ; INITIALIZE_MGMT_STATUS ( iocp -> ioctl_cmds . status ) mpt_put_msg_frame ( mptctl_id , iocp , mf ) ; retry_wait : timeleft = wait_for_completion_timeout ( & iocp -> ioctl_cmds . done , HZ * 60 ) ; if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_COMMAND_GOOD ) ) { ret = - ETIME ; printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; if ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_DID_IOCRESET ) { mpt_free_msg_frame ( iocp , mf ) ; goto fwdl_out ; } if ( ! timeleft ) { printk ( MYIOC_s_WARN_FMT ""FW<S2SV_blank>download<S2SV_blank>timeout,<S2SV_blank>doorbell=0x%08x\\n"" , iocp -> name , mpt_GetIocState ( iocp , 0 ) ) ; mptctl_timeout_expired ( iocp , mf ) ; } else goto retry_wait ; goto fwdl_out ; } if ( ! ( iocp -> ioctl_cmds . status & MPT_MGMT_STATUS_RF_VALID ) ) { printk ( MYIOC_s_WARN_FMT ""%s:<S2SV_blank>failed\\n"" , iocp -> name , __func__ ) ; mpt_free_msg_frame ( iocp , mf ) ; ret = - ENODATA ; goto fwdl_out ; } if ( sgl ) kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; ReplyMsg = ( pFWDownloadReply_t ) iocp -> ioctl_cmds . reply ; iocstat = le16_to_cpu ( ReplyMsg -> IOCStatus ) & MPI_IOCSTATUS_MASK ; if ( iocstat == MPI_IOCSTATUS_SUCCESS ) { printk ( MYIOC_s_INFO_FMT ""F/W<S2SV_blank>update<S2SV_blank>successful!\\n"" , iocp -> name ) ; return 0 ; } else if ( iocstat == MPI_IOCSTATUS_INVALID_FUNCTION ) { printk ( MYIOC_s_WARN_FMT ""Hmmm...<S2SV_blank><S2SV_blank>F/W<S2SV_blank>download<S2SV_blank>not<S2SV_blank>supported!?!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(time<S2SV_blank>to<S2SV_blank>go<S2SV_blank>bang<S2SV_blank>on<S2SV_blank>somebodies<S2SV_blank>door)\\n"" , iocp -> name ) ; return - EBADRQC ; } else if ( iocstat == MPI_IOCSTATUS_BUSY ) { printk ( MYIOC_s_WARN_FMT ""IOC_BUSY!\\n"" , iocp -> name ) ; printk ( MYIOC_s_WARN_FMT ""(try<S2SV_blank>again<S2SV_blank>later?)\\n"" , iocp -> name ) ; return - EBUSY ; } else { printk ( MYIOC_s_WARN_FMT ""ioctl_fwdl()<S2SV_blank>returned<S2SV_blank>[bad]<S2SV_blank>status<S2SV_blank>=<S2SV_blank>%04xh\\n"" , iocp -> name , iocstat ) ; printk ( MYIOC_s_WARN_FMT ""(bad<S2SV_blank>VooDoo)\\n"" , iocp -> name ) ; return - ENOMSG ; } return 0 ; fwdl_out : CLEAR_MGMT_STATUS ( iocp -> ioctl_cmds . status ) ; SET_MGMT_MSG_CONTEXT ( iocp -> ioctl_cmds . msg_context , 0 ) ; kfree_sgl ( sgl , sgl_dma , buflist , iocp ) ; return ret ; }
","<S2SV_ModStart> int mptctl_do_fw_download ( MPT_ADAPTER * iocp <S2SV_ModEnd> , char __user <S2SV_ModStart> MPT_FRAME_HDR * mf <S2SV_ModEnd> ; FWDownloadTCSGE_t * <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( mf = <S2SV_ModStart> - EAGAIN ; <S2SV_ModEnd> dctlprintk ( iocp <S2SV_ModStart> int ) fwlen <S2SV_ModEnd> ) ) ;
",torvalds@linux/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,CVE-2020-12652,https://github.com/torvalds/linux/commit/28d76df18f0ad5bcf5fa48510b225f0ed262a99b,2020-05-05T05:15Z
CWE-20,"CWE-20 static int recv_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; int sz_to_copy , target , needed ; int sz_copied = 0 ; u32 err ; int res = 0 ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( ( sock -> state == SS_UNCONNECTED ) ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> m -> msg_namelen = 0 ; <S2SV_EndBug> target = sock_rcvlowat ( sk , flags & MSG_WAITALL , buf_len ) ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } if ( sz_copied == 0 ) { set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; } if ( ! err ) { u32 offset = ( u32 ) ( unsigned long ) ( TIPC_SKB_CB ( buf ) -> handle ) ; sz -= offset ; needed = ( buf_len - sz_copied ) ; sz_to_copy = ( sz <= needed ) ? sz : needed ; res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) + offset , m -> msg_iov , sz_to_copy ) ; if ( res ) goto exit ; sz_copied += sz_to_copy ; if ( sz_to_copy < sz ) { if ( ! ( flags & MSG_PEEK ) ) TIPC_SKB_CB ( buf ) -> handle = ( void * ) ( unsigned long ) ( offset + sz_to_copy ) ; goto exit ; } } else { if ( sz_copied != 0 ) goto exit ; if ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( unlikely ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } if ( ( sz_copied < buf_len ) && ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || ( sz_copied < target ) ) && ( ! ( flags & MSG_PEEK ) ) && ( ! err ) ) goto restart ; exit : release_sock ( sk ) ; return sz_copied ? sz_copied : res ; }
","<S2SV_ModStart> exit ; } <S2SV_ModEnd> target = sock_rcvlowat
",torvalds@linux/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,CVE-2013-7271,https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c,2014-01-06T16:55Z
CWE-674,"CWE-674 static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 : <S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1023 ""hex_grammar.c"" break ; case 17 : <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1029 ""hex_grammar.c"" break ; case 18 : <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1035 ""hex_grammar.c"" break ; case 19 : <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1041 ""hex_grammar.c"" break ; case 21 : <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1047 ""hex_grammar.c"" break ; case 22 : <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1053 ""hex_grammar.c"" break ; case 23 : <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 ""hex_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }
","<S2SV_ModStart> : # line 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> ""hex_grammar.c"" break ;
",VirusTotal@yara/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7,CVE-2017-9438,https://github.com/VirusTotal/yara/commit/10e8bd3071677dd1fa76beeef4bc2fc427cea5e7,2017-06-05T17:29Z
CWE-125,"CWE-125 u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; <S2SV_StartBug> int hdrlen ; <S2SV_EndBug> uint16_t fc ; uint8_t seq ; <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ; return caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( fc ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; if ( hdrlen == - 1 ) { ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ; return caplen ; } if ( ! ndo -> ndo_vflag ) { p += hdrlen ; caplen -= hdrlen ; } else { uint16_t panid = 0 ; <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case 0x02 : panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> p += 2 ; break ; <S2SV_StartBug> case 0x03 : <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; <S2SV_StartBug> case 0x01 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
","<S2SV_ModStart> -> caplen ; u_int <S2SV_ModEnd> hdrlen ; uint16_t <S2SV_ModStart> uint8_t seq ; <S2SV_ModEnd> uint16_t panid = <S2SV_ModStart> = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ndo , p + 2 <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> ) { case <S2SV_ModStart> ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> 0 ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null>
",the-tcpdump-group@tcpdump/9be4e0b5938b705e7e36cfcb110a740c6ff0cb97,CVE-2017-13000,https://github.com/the-tcpdump-group/tcpdump/commit/9be4e0b5938b705e7e36cfcb110a740c6ff0cb97,2017-09-14T06:29Z
CWE-17,"CWE-17 static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; <S2SV_StartBug> tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , <S2SV_EndBug> & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }
","<S2SV_ModStart> tf = ( <S2SV_ModEnd> luaY_parser ) (
",antirez@redis/fdf9d455098f54f7666c702ae464e6ea21e25411,CVE-2015-4335,https://github.com/antirez/redis/commit/fdf9d455098f54f7666c702ae464e6ea21e25411,2015-06-09T14:59Z
CWE-119,"CWE-119 static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; <S2SV_StartBug> int copylen ; <S2SV_EndBug> bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ; <S2SV_StartBug> if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) <S2SV_EndBug> zerocopy = true ; if ( zerocopy ) { <S2SV_StartBug> copylen = vnet_hdr . hdr_len ; <S2SV_EndBug> if ( ! copylen ) copylen = GOODCOPY_LEN ; } else copylen = len ; skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN , copylen , vnet_hdr . hdr_len , noblock , & err ) ; if ( ! skb ) goto err ; if ( zerocopy ) err = zerocopy_sg_from_iovec ( skb , iv , vnet_hdr_len , count ) ; else err = skb_copy_datagram_from_iovec ( skb , 0 , iv , vnet_hdr_len , len ) ; if ( err ) goto err_kfree ; skb_set_network_header ( skb , ETH_HLEN ) ; skb_reset_mac_header ( skb ) ; skb -> protocol = eth_hdr ( skb ) -> h_proto ; if ( vnet_hdr_len ) { err = macvtap_skb_from_vnet_hdr ( skb , & vnet_hdr ) ; if ( err ) goto err_kfree ; } rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( zerocopy ) { skb_shinfo ( skb ) -> destructor_arg = m -> msg_control ; skb_shinfo ( skb ) -> tx_flags |= SKBTX_DEV_ZEROCOPY ; } if ( vlan ) macvlan_start_xmit ( skb , vlan -> dev ) ; else kfree_skb ( skb ) ; rcu_read_unlock_bh ( ) ; return total_len ; err_kfree : kfree_skb ( skb ) ; err : rcu_read_lock_bh ( ) ; vlan = rcu_dereference_bh ( q -> vlan ) ; if ( vlan ) vlan -> dev -> stats . tx_dropped ++ ; rcu_read_unlock_bh ( ) ; return err ; }
","<S2SV_ModStart> ; int copylen = 0 <S2SV_ModStart> goto err ; err = - EMSGSIZE ; if ( unlikely ( count > UIO_MAXIOV ) ) goto err ; <S2SV_ModStart> zerocopy ) { if ( count > MAX_SKB_FRAGS ) { copylen = iov_length ( iv , count - MAX_SKB_FRAGS ) ; if ( copylen < vnet_hdr_len ) copylen = 0 ; else copylen -= vnet_hdr_len ; } if ( copylen < vnet_hdr . hdr_len )
",torvalds@linux/b92946e2919134ebe2a4083e4302236295ea2a73,CVE-2012-2119,https://github.com/torvalds/linux/commit/b92946e2919134ebe2a4083e4302236295ea2a73,2013-01-22T23:55Z
CWE-476,"CWE-476 BOOL rdp_decrypt ( rdpRdp * rdp , STREAM * s , int length , UINT16 securityFlags ) { BYTE cmac [ 8 ] ; BYTE wmac [ 8 ] ; if ( rdp -> settings -> EncryptionMethods == ENCRYPTION_METHOD_FIPS ) { UINT16 len ; BYTE version , pad ; BYTE * sig ; if ( stream_get_left ( s ) < 12 ) return FALSE ; stream_read_UINT16 ( s , len ) ; stream_read_BYTE ( s , version ) ; stream_read_BYTE ( s , pad ) ; sig = s -> p ; stream_seek ( s , 8 ) ; length -= 12 ; if ( ! security_fips_decrypt ( s -> p , length , rdp ) ) { printf ( ""FATAL:<S2SV_blank>cannot<S2SV_blank>decrypt\\n"" ) ; return FALSE ; } if ( ! security_fips_check_signature ( s -> p , length - pad , sig , rdp ) ) { printf ( ""FATAL:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>signature\\n"" ) ; return FALSE ; } s -> size -= pad ; return TRUE ; } if ( stream_get_left ( s ) < 8 ) return FALSE ; stream_read ( s , wmac , sizeof ( wmac ) ) ; length -= sizeof ( wmac ) ; <S2SV_StartBug> security_decrypt ( s -> p , length , rdp ) ; <S2SV_EndBug> if ( securityFlags & SEC_SECURE_CHECKSUM ) security_salted_mac_signature ( rdp , s -> p , length , FALSE , cmac ) ; else security_mac_signature ( rdp , s -> p , length , cmac ) ; if ( memcmp ( wmac , cmac , sizeof ( wmac ) ) != 0 ) { printf ( ""WARNING:<S2SV_blank>invalid<S2SV_blank>packet<S2SV_blank>signature\\n"" ) ; } return TRUE ; }
","<S2SV_ModStart> wmac ) ; if ( ! <S2SV_ModStart> , rdp ) ) return FALSE
",FreeRDP@FreeRDP/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,CVE-2013-4118,https://github.com/FreeRDP/FreeRDP/commit/7d58aac24fe20ffaad7bd9b40c9ddf457c1b06e7,2016-10-03T21:59Z
